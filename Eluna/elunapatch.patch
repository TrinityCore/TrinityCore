From ddc2b8900594d873c292821c77f9776a994b5561 Mon Sep 17 00:00:00 2001
From: Easelm <easelm@live.com>
Date: Tue, 16 Jul 2013 14:12:42 -0400
Subject: [PATCH] awdawd

---
 dep/CMakeLists.txt                                 |    1 +
 dep/lualib/CMakeLists.txt                          |   20 +
 dep/lualib/lapi.c                                  | 1281 +++++
 dep/lualib/lapi.h                                  |   24 +
 dep/lualib/lauxlib.c                               |  958 ++++
 dep/lualib/lauxlib.h                               |  214 +
 dep/lualib/lbaselib.c                              |  459 ++
 dep/lualib/lbitlib.c                               |  209 +
 dep/lualib/lcode.c                                 |  882 ++++
 dep/lualib/lcode.h                                 |   83 +
 dep/lualib/lcorolib.c                              |  155 +
 dep/lualib/lctype.c                                |   52 +
 dep/lualib/lctype.h                                |   95 +
 dep/lualib/ldblib.c                                |  398 ++
 dep/lualib/ldebug.c                                |  580 +++
 dep/lualib/ldebug.h                                |   34 +
 dep/lualib/ldo.c                                   |  668 +++
 dep/lualib/ldo.h                                   |   46 +
 dep/lualib/ldump.c                                 |  173 +
 dep/lualib/lfunc.c                                 |  161 +
 dep/lualib/lfunc.h                                 |   33 +
 dep/lualib/lgc.c                                   | 1205 +++++
 dep/lualib/lgc.h                                   |  147 +
 dep/lualib/linit.c                                 |   67 +
 dep/lualib/liolib.c                                |  657 +++
 dep/lualib/llex.c                                  |  527 ++
 dep/lualib/llex.h                                  |   78 +
 dep/lualib/llimits.h                               |  309 ++
 dep/lualib/lmathlib.c                              |  283 +
 dep/lualib/lmem.c                                  |   99 +
 dep/lualib/lmem.h                                  |   50 +
 dep/lualib/loadlib.c                               |  725 +++
 dep/lualib/lobject.c                               |  289 ++
 dep/lualib/lobject.h                               |  610 +++
 dep/lualib/lopcodes.c                              |  107 +
 dep/lualib/lopcodes.h                              |  288 ++
 dep/lualib/loslib.c                                |  323 ++
 dep/lualib/lparser.c                               | 1635 ++++++
 dep/lualib/lparser.h                               |  119 +
 dep/lualib/lstate.c                                |  322 ++
 dep/lualib/lstate.h                                |  228 +
 dep/lualib/lstring.c                               |  185 +
 dep/lualib/lstring.h                               |   46 +
 dep/lualib/lstrlib.c                               |  972 ++++
 dep/lualib/ltable.c                                |  588 +++
 dep/lualib/ltable.h                                |   41 +
 dep/lualib/ltablib.c                               |  283 +
 dep/lualib/ltm.c                                   |   77 +
 dep/lualib/ltm.h                                   |   57 +
 dep/lualib/lua.c                                   |  496 ++
 dep/lualib/lua.h                                   |  442 ++
 dep/lualib/lua.hpp                                 |    9 +
 dep/lualib/luaconf.h                               |  546 ++
 dep/lualib/lualib.h                                |   55 +
 dep/lualib/lundump.c                               |  258 +
 dep/lualib/lundump.h                               |   28 +
 dep/lualib/lvm.c                                   |  868 ++++
 dep/lualib/lvm.h                                   |   45 +
 dep/lualib/lzio.c                                  |   76 +
 dep/lualib/lzio.h                                  |   65 +
 src/server/CMakeLists.txt                          |    1 +
 src/server/LuaEngine/AuraMethods.cpp               |  134 +
 src/server/LuaEngine/AuraMethods.h                 |   21 +
 src/server/LuaEngine/CMakeLists.txt                |  135 +
 src/server/LuaEngine/GameObjectMethods.cpp         |  537 ++
 src/server/LuaEngine/GameObjectMethods.h           |   54 +
 src/server/LuaEngine/GlobalMethods.h               | 1022 ++++
 src/server/LuaEngine/GroupMethods.h                |  332 ++
 src/server/LuaEngine/GuildMethods.h                |  178 +
 src/server/LuaEngine/HookMgr.cpp                   |  300 ++
 src/server/LuaEngine/HookMgr.h                     |  132 +
 src/server/LuaEngine/ItemMethods.h                 |  715 +++
 src/server/LuaEngine/LuaEngine.cpp                 |  750 +++
 src/server/LuaEngine/LuaEngine.h                   | 1361 +++++
 src/server/LuaEngine/LuaFunctions.h                |  929 ++++
 src/server/LuaEngine/LuaHooks.cpp                  | 1379 +++++
 src/server/LuaEngine/QueryMethods.h                |  184 +
 src/server/LuaEngine/QuestMethods.h                |  149 +
 src/server/LuaEngine/SpellMethods.h                |  122 +
 src/server/LuaEngine/UnitMethods.cpp               | 5428 ++++++++++++++++++++
 src/server/LuaEngine/UnitMethods.h                 |  494 ++
 src/server/LuaEngine/WorldPacketMethods.h          |  283 +
 src/server/authserver/Main.cpp                     |   22 +-
 src/server/authserver/Server/AuthSocket.cpp        |    6 +-
 src/server/game/Accounts/AccountMgr.cpp            |    4 +-
 src/server/game/Battlefield/Zones/BattlefieldWG.h  |    4 +-
 src/server/game/CMakeLists.txt                     |   10 +
 src/server/game/Conditions/ConditionMgr.cpp        |    2 +-
 src/server/game/Entities/Player/Player.cpp         |   19 +-
 src/server/game/Entities/Unit/Unit.cpp             |    9 +-
 src/server/game/Entities/Unit/Unit.h               |    7 +-
 src/server/game/Globals/ObjectMgr.cpp              |    4 +-
 src/server/game/Globals/ObjectMgr.h                |   14 +-
 src/server/game/Guilds/Guild.cpp                   |    2 +-
 src/server/game/Handlers/CharacterHandler.cpp      |    4 +
 src/server/game/Handlers/ChatHandler.cpp           |   27 +
 src/server/game/Handlers/ItemHandler.cpp           |    1 +
 src/server/game/Handlers/LootHandler.cpp           |    2 +
 src/server/game/Handlers/MiscHandler.cpp           |    7 +
 src/server/game/Scripting/ScriptMgr.cpp            |  124 +-
 src/server/game/Scripting/ScriptMgr.h              |    8 +
 src/server/game/Server/Protocol/PacketLog.cpp      |    4 +-
 src/server/game/Server/WorldSocketMgr.cpp          |    8 +-
 src/server/game/Spells/SpellEffects.cpp            |    1 +
 src/server/game/World/World.cpp                    |  642 +--
 src/server/scripts/CMakeLists.txt                  |    2 +
 src/server/scripts/Commands/cs_arena.cpp           |   26 +-
 src/server/scripts/Commands/cs_character.cpp       |    2 +-
 src/server/scripts/Commands/cs_reload.cpp          |    9 +
 src/server/scripts/Commands/cs_server.cpp          |    2 +-
 .../Stratholme/instance_stratholme.cpp             |   12 +-
 .../SunwellPlateau/boss_kalecgos.cpp               |    4 +-
 .../EasternKingdoms/ZulAman/boss_akilzon.cpp       |    2 +-
 .../scripts/EasternKingdoms/ZulAman/zulaman.cpp    |   22 +-
 .../BlackfathomDeeps/blackfathom_deeps.cpp         |   38 +-
 .../Kalimdor/RazorfenDowns/razorfen_downs.cpp      |   70 +-
 src/server/scripts/Kalimdor/zone_the_barrens.cpp   |   37 +
 .../TrialOfTheCrusader/trial_of_the_crusader.cpp   |   18 +-
 .../scripts/Northrend/Nexus/Oculus/oculus.cpp      |   15 +-
 .../UtgardeKeep/UtgardePinnacle/boss_palehoof.cpp  |    4 +-
 .../scripts/Outland/BlackTemple/black_temple.cpp   |  164 +-
 .../Outland/BlackTemple/boss_shade_of_akama.cpp    |    4 +-
 .../ShatteredHalls/boss_nethekurse.cpp             |   11 +-
 .../ShatteredHalls/boss_warbringer_omrogg.cpp      |    1 +
 .../boss_warchief_kargath_bladefist.cpp            |    1 +
 .../ShatteredHalls/instance_shattered_halls.cpp    |    7 +-
 .../scripts/Outland/TempestKeep/Eye/boss_alar.cpp  |   21 +-
 src/server/shared/Configuration/Config.cpp         |  103 +-
 src/server/shared/Configuration/Config.h           |   49 +-
 src/server/shared/DataStores/DBCStore.h            |   35 +-
 src/server/shared/Logging/Log.cpp                  |   16 +-
 src/server/worldserver/CommandLine/CliRunnable.cpp |    2 +-
 src/server/worldserver/Main.cpp                    |    2 +-
 src/server/worldserver/Master.cpp                  |   38 +-
 src/server/worldserver/RemoteAccess/RARunnable.cpp |    6 +-
 src/server/worldserver/RemoteAccess/RASocket.cpp   |    2 +-
 136 files changed, 35239 insertions(+), 788 deletions(-)
 create mode 100644 dep/lualib/CMakeLists.txt
 create mode 100644 dep/lualib/lapi.c
 create mode 100644 dep/lualib/lapi.h
 create mode 100644 dep/lualib/lauxlib.c
 create mode 100644 dep/lualib/lauxlib.h
 create mode 100644 dep/lualib/lbaselib.c
 create mode 100644 dep/lualib/lbitlib.c
 create mode 100644 dep/lualib/lcode.c
 create mode 100644 dep/lualib/lcode.h
 create mode 100644 dep/lualib/lcorolib.c
 create mode 100644 dep/lualib/lctype.c
 create mode 100644 dep/lualib/lctype.h
 create mode 100644 dep/lualib/ldblib.c
 create mode 100644 dep/lualib/ldebug.c
 create mode 100644 dep/lualib/ldebug.h
 create mode 100644 dep/lualib/ldo.c
 create mode 100644 dep/lualib/ldo.h
 create mode 100644 dep/lualib/ldump.c
 create mode 100644 dep/lualib/lfunc.c
 create mode 100644 dep/lualib/lfunc.h
 create mode 100644 dep/lualib/lgc.c
 create mode 100644 dep/lualib/lgc.h
 create mode 100644 dep/lualib/linit.c
 create mode 100644 dep/lualib/liolib.c
 create mode 100644 dep/lualib/llex.c
 create mode 100644 dep/lualib/llex.h
 create mode 100644 dep/lualib/llimits.h
 create mode 100644 dep/lualib/lmathlib.c
 create mode 100644 dep/lualib/lmem.c
 create mode 100644 dep/lualib/lmem.h
 create mode 100644 dep/lualib/loadlib.c
 create mode 100644 dep/lualib/lobject.c
 create mode 100644 dep/lualib/lobject.h
 create mode 100644 dep/lualib/lopcodes.c
 create mode 100644 dep/lualib/lopcodes.h
 create mode 100644 dep/lualib/loslib.c
 create mode 100644 dep/lualib/lparser.c
 create mode 100644 dep/lualib/lparser.h
 create mode 100644 dep/lualib/lstate.c
 create mode 100644 dep/lualib/lstate.h
 create mode 100644 dep/lualib/lstring.c
 create mode 100644 dep/lualib/lstring.h
 create mode 100644 dep/lualib/lstrlib.c
 create mode 100644 dep/lualib/ltable.c
 create mode 100644 dep/lualib/ltable.h
 create mode 100644 dep/lualib/ltablib.c
 create mode 100644 dep/lualib/ltm.c
 create mode 100644 dep/lualib/ltm.h
 create mode 100644 dep/lualib/lua.c
 create mode 100644 dep/lualib/lua.h
 create mode 100644 dep/lualib/lua.hpp
 create mode 100644 dep/lualib/luaconf.h
 create mode 100644 dep/lualib/lualib.h
 create mode 100644 dep/lualib/lundump.c
 create mode 100644 dep/lualib/lundump.h
 create mode 100644 dep/lualib/lvm.c
 create mode 100644 dep/lualib/lvm.h
 create mode 100644 dep/lualib/lzio.c
 create mode 100644 dep/lualib/lzio.h
 create mode 100644 src/server/LuaEngine/AuraMethods.cpp
 create mode 100644 src/server/LuaEngine/AuraMethods.h
 create mode 100644 src/server/LuaEngine/CMakeLists.txt
 create mode 100644 src/server/LuaEngine/GameObjectMethods.cpp
 create mode 100644 src/server/LuaEngine/GameObjectMethods.h
 create mode 100644 src/server/LuaEngine/GlobalMethods.h
 create mode 100644 src/server/LuaEngine/GroupMethods.h
 create mode 100644 src/server/LuaEngine/GuildMethods.h
 create mode 100644 src/server/LuaEngine/HookMgr.cpp
 create mode 100644 src/server/LuaEngine/HookMgr.h
 create mode 100644 src/server/LuaEngine/ItemMethods.h
 create mode 100644 src/server/LuaEngine/LuaEngine.cpp
 create mode 100644 src/server/LuaEngine/LuaEngine.h
 create mode 100644 src/server/LuaEngine/LuaFunctions.h
 create mode 100644 src/server/LuaEngine/LuaHooks.cpp
 create mode 100644 src/server/LuaEngine/QueryMethods.h
 create mode 100644 src/server/LuaEngine/QuestMethods.h
 create mode 100644 src/server/LuaEngine/SpellMethods.h
 create mode 100644 src/server/LuaEngine/UnitMethods.cpp
 create mode 100644 src/server/LuaEngine/UnitMethods.h
 create mode 100644 src/server/LuaEngine/WorldPacketMethods.h

diff --git a/dep/CMakeLists.txt b/dep/CMakeLists.txt
index ad5e04c..6629e57 100644
--- a/dep/CMakeLists.txt
+++ b/dep/CMakeLists.txt
@@ -33,6 +33,7 @@ endif()
 
 add_subdirectory(g3dlite)
 add_subdirectory(recastnavigation)
+add_subdirectory(lualib)
 
 if(SERVERS)
   add_subdirectory(gsoap)
diff --git a/dep/lualib/CMakeLists.txt b/dep/lualib/CMakeLists.txt
new file mode 100644
index 0000000..f8ab5f2
--- /dev/null
+++ b/dep/lualib/CMakeLists.txt
@@ -0,0 +1,20 @@
+# Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+file(GLOB sources *.c)
+
+set(lua_STAT_SRCS
+  ${sources}
+)
+
+include_directories(
+  ${CMAKE_CURRENT_SOURCE_DIR}
+)
+
+add_library(lua STATIC ${lua_STAT_SRCS})
\ No newline at end of file
diff --git a/dep/lualib/lapi.c b/dep/lualib/lapi.c
new file mode 100644
index 0000000..1854fe6
--- /dev/null
+++ b/dep/lualib/lapi.c
@@ -0,0 +1,1281 @@
+/*
+** $Id: lapi.c,v 2.164 2012/06/08 15:14:04 roberto Exp $
+** Lua API
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdarg.h>
+#include <string.h>
+
+#define lapi_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lundump.h"
+#include "lvm.h"
+
+
+
+const char lua_ident[] =
+  "$LuaVersion: " LUA_COPYRIGHT " $"
+  "$LuaAuthors: " LUA_AUTHORS " $";
+
+
+/* value at a non-valid index */
+#define NONVALIDVALUE		cast(TValue *, luaO_nilobject)
+
+/* corresponding test */
+#define isvalid(o)	((o) != luaO_nilobject)
+
+#define api_checkvalidindex(L, i)  api_check(L, isvalid(i), "invalid index")
+
+
+static TValue *index2addr (lua_State *L, int idx) {
+  CallInfo *ci = L->ci;
+  if (idx > 0) {
+    TValue *o = ci->func + idx;
+    api_check(L, idx <= ci->top - (ci->func + 1), "unacceptable index");
+    if (o >= L->top) return NONVALIDVALUE;
+    else return o;
+  }
+  else if (idx > LUA_REGISTRYINDEX) {
+    api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), "invalid index");
+    return L->top + idx;
+  }
+  else if (idx == LUA_REGISTRYINDEX)
+    return &G(L)->l_registry;
+  else {  /* upvalues */
+    idx = LUA_REGISTRYINDEX - idx;
+    api_check(L, idx <= MAXUPVAL + 1, "upvalue index too large");
+    if (ttislcf(ci->func))  /* light C function? */
+      return NONVALIDVALUE;  /* it has no upvalues */
+    else {
+      CClosure *func = clCvalue(ci->func);
+      return (idx <= func->nupvalues) ? &func->upvalue[idx-1] : NONVALIDVALUE;
+    }
+  }
+}
+
+
+/*
+** to be called by 'lua_checkstack' in protected mode, to grow stack
+** capturing memory errors
+*/
+static void growstack (lua_State *L, void *ud) {
+  int size = *(int *)ud;
+  luaD_growstack(L, size);
+}
+
+
+LUA_API int lua_checkstack (lua_State *L, int size) {
+  int res;
+  CallInfo *ci = L->ci;
+  lua_lock(L);
+  if (L->stack_last - L->top > size)  /* stack large enough? */
+    res = 1;  /* yes; check is OK */
+  else {  /* no; need to grow stack */
+    int inuse = cast_int(L->top - L->stack) + EXTRA_STACK;
+    if (inuse > LUAI_MAXSTACK - size)  /* can grow without overflow? */
+      res = 0;  /* no */
+    else  /* try to grow stack */
+      res = (luaD_rawrunprotected(L, &growstack, &size) == LUA_OK);
+  }
+  if (res && ci->top < L->top + size)
+    ci->top = L->top + size;  /* adjust frame top */
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
+  int i;
+  if (from == to) return;
+  lua_lock(to);
+  api_checknelems(from, n);
+  api_check(from, G(from) == G(to), "moving among independent states");
+  api_check(from, to->ci->top - to->top >= n, "not enough elements to move");
+  from->top -= n;
+  for (i = 0; i < n; i++) {
+    setobj2s(to, to->top++, from->top + i);
+  }
+  lua_unlock(to);
+}
+
+
+LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
+  lua_CFunction old;
+  lua_lock(L);
+  old = G(L)->panic;
+  G(L)->panic = panicf;
+  lua_unlock(L);
+  return old;
+}
+
+
+LUA_API const lua_Number *lua_version (lua_State *L) {
+  static const lua_Number version = LUA_VERSION_NUM;
+  if (L == NULL) return &version;
+  else return G(L)->version;
+}
+
+
+
+/*
+** basic stack manipulation
+*/
+
+
+/*
+** convert an acceptable stack index into an absolute index
+*/
+LUA_API int lua_absindex (lua_State *L, int idx) {
+  return (idx > 0 || idx <= LUA_REGISTRYINDEX)
+         ? idx
+         : cast_int(L->top - L->ci->func + idx);
+}
+
+
+LUA_API int lua_gettop (lua_State *L) {
+  return cast_int(L->top - (L->ci->func + 1));
+}
+
+
+LUA_API void lua_settop (lua_State *L, int idx) {
+  StkId func = L->ci->func;
+  lua_lock(L);
+  if (idx >= 0) {
+    api_check(L, idx <= L->stack_last - (func + 1), "new top too large");
+    while (L->top < (func + 1) + idx)
+      setnilvalue(L->top++);
+    L->top = (func + 1) + idx;
+  }
+  else {
+    api_check(L, -(idx+1) <= (L->top - (func + 1)), "invalid new top");
+    L->top += idx+1;  /* `subtract' index (index is negative) */
+  }
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_remove (lua_State *L, int idx) {
+  StkId p;
+  lua_lock(L);
+  p = index2addr(L, idx);
+  api_checkvalidindex(L, p);
+  while (++p < L->top) setobjs2s(L, p-1, p);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_insert (lua_State *L, int idx) {
+  StkId p;
+  StkId q;
+  lua_lock(L);
+  p = index2addr(L, idx);
+  api_checkvalidindex(L, p);
+  for (q = L->top; q>p; q--) setobjs2s(L, q, q-1);
+  setobjs2s(L, p, L->top);
+  lua_unlock(L);
+}
+
+
+static void moveto (lua_State *L, TValue *fr, int idx) {
+  TValue *to = index2addr(L, idx);
+  api_checkvalidindex(L, to);
+  setobj(L, to, fr);
+  if (idx < LUA_REGISTRYINDEX)  /* function upvalue? */
+    luaC_barrier(L, clCvalue(L->ci->func), fr);
+  /* LUA_REGISTRYINDEX does not need gc barrier
+     (collector revisits it before finishing collection) */
+}
+
+
+LUA_API void lua_replace (lua_State *L, int idx) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  moveto(L, L->top - 1, idx);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {
+  TValue *fr;
+  lua_lock(L);
+  fr = index2addr(L, fromidx);
+  api_checkvalidindex(L, fr);
+  moveto(L, fr, toidx);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushvalue (lua_State *L, int idx) {
+  lua_lock(L);
+  setobj2s(L, L->top, index2addr(L, idx));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API int lua_type (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  return (isvalid(o) ? ttypenv(o) : LUA_TNONE);
+}
+
+
+LUA_API const char *lua_typename (lua_State *L, int t) {
+  UNUSED(L);
+  return ttypename(t);
+}
+
+
+LUA_API int lua_iscfunction (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  return (ttislcf(o) || (ttisCclosure(o)));
+}
+
+
+LUA_API int lua_isnumber (lua_State *L, int idx) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  return tonumber(o, &n);
+}
+
+
+LUA_API int lua_isstring (lua_State *L, int idx) {
+  int t = lua_type(L, idx);
+  return (t == LUA_TSTRING || t == LUA_TNUMBER);
+}
+
+
+LUA_API int lua_isuserdata (lua_State *L, int idx) {
+  const TValue *o = index2addr(L, idx);
+  return (ttisuserdata(o) || ttislightuserdata(o));
+}
+
+
+LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
+  StkId o1 = index2addr(L, index1);
+  StkId o2 = index2addr(L, index2);
+  return (isvalid(o1) && isvalid(o2)) ? luaV_rawequalobj(o1, o2) : 0;
+}
+
+
+LUA_API void  lua_arith (lua_State *L, int op) {
+  StkId o1;  /* 1st operand */
+  StkId o2;  /* 2nd operand */
+  lua_lock(L);
+  if (op != LUA_OPUNM) /* all other operations expect two operands */
+    api_checknelems(L, 2);
+  else {  /* for unary minus, add fake 2nd operand */
+    api_checknelems(L, 1);
+    setobjs2s(L, L->top, L->top - 1);
+    L->top++;
+  }
+  o1 = L->top - 2;
+  o2 = L->top - 1;
+  if (ttisnumber(o1) && ttisnumber(o2)) {
+    changenvalue(o1, luaO_arith(op, nvalue(o1), nvalue(o2)));
+  }
+  else
+    luaV_arith(L, o1, o1, o2, cast(TMS, op - LUA_OPADD + TM_ADD));
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_compare (lua_State *L, int index1, int index2, int op) {
+  StkId o1, o2;
+  int i = 0;
+  lua_lock(L);  /* may call tag method */
+  o1 = index2addr(L, index1);
+  o2 = index2addr(L, index2);
+  if (isvalid(o1) && isvalid(o2)) {
+    switch (op) {
+      case LUA_OPEQ: i = equalobj(L, o1, o2); break;
+      case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;
+      case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;
+      default: api_check(L, 0, "invalid option");
+    }
+  }
+  lua_unlock(L);
+  return i;
+}
+
+
+LUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *isnum) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  if (tonumber(o, &n)) {
+    if (isnum) *isnum = 1;
+    return nvalue(o);
+  }
+  else {
+    if (isnum) *isnum = 0;
+    return 0;
+  }
+}
+
+
+LUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *isnum) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  if (tonumber(o, &n)) {
+    lua_Integer res;
+    lua_Number num = nvalue(o);
+    lua_number2integer(res, num);
+    if (isnum) *isnum = 1;
+    return res;
+  }
+  else {
+    if (isnum) *isnum = 0;
+    return 0;
+  }
+}
+
+
+LUA_API lua_Unsigned lua_tounsignedx (lua_State *L, int idx, int *isnum) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  if (tonumber(o, &n)) {
+    lua_Unsigned res;
+    lua_Number num = nvalue(o);
+    lua_number2unsigned(res, num);
+    if (isnum) *isnum = 1;
+    return res;
+  }
+  else {
+    if (isnum) *isnum = 0;
+    return 0;
+  }
+}
+
+
+LUA_API int lua_toboolean (lua_State *L, int idx) {
+  const TValue *o = index2addr(L, idx);
+  return !l_isfalse(o);
+}
+
+
+LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
+  StkId o = index2addr(L, idx);
+  if (!ttisstring(o)) {
+    lua_lock(L);  /* `luaV_tostring' may create a new string */
+    if (!luaV_tostring(L, o)) {  /* conversion failed? */
+      if (len != NULL) *len = 0;
+      lua_unlock(L);
+      return NULL;
+    }
+    luaC_checkGC(L);
+    o = index2addr(L, idx);  /* previous call may reallocate the stack */
+    lua_unlock(L);
+  }
+  if (len != NULL) *len = tsvalue(o)->len;
+  return svalue(o);
+}
+
+
+LUA_API size_t lua_rawlen (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  switch (ttypenv(o)) {
+    case LUA_TSTRING: return tsvalue(o)->len;
+    case LUA_TUSERDATA: return uvalue(o)->len;
+    case LUA_TTABLE: return luaH_getn(hvalue(o));
+    default: return 0;
+  }
+}
+
+
+LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  if (ttislcf(o)) return fvalue(o);
+  else if (ttisCclosure(o))
+    return clCvalue(o)->f;
+  else return NULL;  /* not a C function */
+}
+
+
+LUA_API void *lua_touserdata (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  switch (ttypenv(o)) {
+    case LUA_TUSERDATA: return (rawuvalue(o) + 1);
+    case LUA_TLIGHTUSERDATA: return pvalue(o);
+    default: return NULL;
+  }
+}
+
+
+LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  return (!ttisthread(o)) ? NULL : thvalue(o);
+}
+
+
+LUA_API const void *lua_topointer (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  switch (ttype(o)) {
+    case LUA_TTABLE: return hvalue(o);
+    case LUA_TLCL: return clLvalue(o);
+    case LUA_TCCL: return clCvalue(o);
+    case LUA_TLCF: return cast(void *, cast(size_t, fvalue(o)));
+    case LUA_TTHREAD: return thvalue(o);
+    case LUA_TUSERDATA:
+    case LUA_TLIGHTUSERDATA:
+      return lua_touserdata(L, idx);
+    default: return NULL;
+  }
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushnil (lua_State *L) {
+  lua_lock(L);
+  setnilvalue(L->top);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
+  lua_lock(L);
+  setnvalue(L->top, n);
+  luai_checknum(L, L->top,
+    luaG_runerror(L, "C API - attempt to push a signaling NaN"));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
+  lua_lock(L);
+  setnvalue(L->top, cast_num(n));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushunsigned (lua_State *L, lua_Unsigned u) {
+  lua_Number n;
+  lua_lock(L);
+  n = lua_unsigned2number(u);
+  setnvalue(L->top, n);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {
+  TString *ts;
+  lua_lock(L);
+  luaC_checkGC(L);
+  ts = luaS_newlstr(L, s, len);
+  setsvalue2s(L, L->top, ts);
+  api_incr_top(L);
+  lua_unlock(L);
+  return getstr(ts);
+}
+
+
+LUA_API const char *lua_pushstring (lua_State *L, const char *s) {
+  if (s == NULL) {
+    lua_pushnil(L);
+    return NULL;
+  }
+  else {
+    TString *ts;
+    lua_lock(L);
+    luaC_checkGC(L);
+    ts = luaS_new(L, s);
+    setsvalue2s(L, L->top, ts);
+    api_incr_top(L);
+    lua_unlock(L);
+    return getstr(ts);
+  }
+}
+
+
+LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
+                                      va_list argp) {
+  const char *ret;
+  lua_lock(L);
+  luaC_checkGC(L);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *ret;
+  va_list argp;
+  lua_lock(L);
+  luaC_checkGC(L);
+  va_start(argp, fmt);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
+  lua_lock(L);
+  if (n == 0) {
+    setfvalue(L->top, fn);
+  }
+  else {
+    Closure *cl;
+    api_checknelems(L, n);
+    api_check(L, n <= MAXUPVAL, "upvalue index too large");
+    luaC_checkGC(L);
+    cl = luaF_newCclosure(L, n);
+    cl->c.f = fn;
+    L->top -= n;
+    while (n--)
+      setobj2n(L, &cl->c.upvalue[n], L->top + n);
+    setclCvalue(L, L->top, cl);
+  }
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushboolean (lua_State *L, int b) {
+  lua_lock(L);
+  setbvalue(L->top, (b != 0));  /* ensure that true is 1 */
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
+  lua_lock(L);
+  setpvalue(L->top, p);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_pushthread (lua_State *L) {
+  lua_lock(L);
+  setthvalue(L, L->top, L);
+  api_incr_top(L);
+  lua_unlock(L);
+  return (G(L)->mainthread == L);
+}
+
+
+
+/*
+** get functions (Lua -> stack)
+*/
+
+
+LUA_API void lua_getglobal (lua_State *L, const char *var) {
+  Table *reg = hvalue(&G(L)->l_registry);
+  const TValue *gt;  /* global table */
+  lua_lock(L);
+  gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
+  setsvalue2s(L, L->top++, luaS_new(L, var));
+  luaV_gettable(L, gt, L->top - 1, L->top - 1);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_gettable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_checkvalidindex(L, t);
+  luaV_gettable(L, t, L->top - 1, L->top - 1);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_getfield (lua_State *L, int idx, const char *k) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_checkvalidindex(L, t);
+  setsvalue2s(L, L->top, luaS_new(L, k));
+  api_incr_top(L);
+  luaV_gettable(L, t, L->top - 1, L->top - 1);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawget (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setobj2s(L, L->top - 1, luaH_get(hvalue(t), L->top - 1));
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setobj2s(L, L->top, luaH_getint(hvalue(t), n));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawgetp (lua_State *L, int idx, const void *p) {
+  StkId t;
+  TValue k;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setpvalue(&k, cast(void *, p));
+  setobj2s(L, L->top, luaH_get(hvalue(t), &k));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {
+  Table *t;
+  lua_lock(L);
+  luaC_checkGC(L);
+  t = luaH_new(L);
+  sethvalue(L, L->top, t);
+  api_incr_top(L);
+  if (narray > 0 || nrec > 0)
+    luaH_resize(L, t, narray, nrec);
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_getmetatable (lua_State *L, int objindex) {
+  const TValue *obj;
+  Table *mt = NULL;
+  int res;
+  lua_lock(L);
+  obj = index2addr(L, objindex);
+  switch (ttypenv(obj)) {
+    case LUA_TTABLE:
+      mt = hvalue(obj)->metatable;
+      break;
+    case LUA_TUSERDATA:
+      mt = uvalue(obj)->metatable;
+      break;
+    default:
+      mt = G(L)->mt[ttypenv(obj)];
+      break;
+  }
+  if (mt == NULL)
+    res = 0;
+  else {
+    sethvalue(L, L->top, mt);
+    api_incr_top(L);
+    res = 1;
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_getuservalue (lua_State *L, int idx) {
+  StkId o;
+  lua_lock(L);
+  o = index2addr(L, idx);
+  api_checkvalidindex(L, o);
+  api_check(L, ttisuserdata(o), "userdata expected");
+  if (uvalue(o)->env) {
+    sethvalue(L, L->top, uvalue(o)->env);
+  } else
+    setnilvalue(L->top);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+/*
+** set functions (stack -> Lua)
+*/
+
+
+LUA_API void lua_setglobal (lua_State *L, const char *var) {
+  Table *reg = hvalue(&G(L)->l_registry);
+  const TValue *gt;  /* global table */
+  lua_lock(L);
+  api_checknelems(L, 1);
+  gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
+  setsvalue2s(L, L->top++, luaS_new(L, var));
+  luaV_settable(L, gt, L->top - 1, L->top - 2);
+  L->top -= 2;  /* pop value and key */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_settable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = index2addr(L, idx);
+  api_checkvalidindex(L, t);
+  luaV_settable(L, t, L->top - 2, L->top - 1);
+  L->top -= 2;  /* pop index and value */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  t = index2addr(L, idx);
+  api_checkvalidindex(L, t);
+  setsvalue2s(L, L->top++, luaS_new(L, k));
+  luaV_settable(L, t, L->top - 1, L->top - 2);
+  L->top -= 2;  /* pop value and key */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawset (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setobj2t(L, luaH_set(L, hvalue(t), L->top-2), L->top-1);
+  invalidateTMcache(hvalue(t));
+  luaC_barrierback(L, gcvalue(t), L->top-1);
+  L->top -= 2;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  luaH_setint(L, hvalue(t), n, L->top - 1);
+  luaC_barrierback(L, gcvalue(t), L->top-1);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {
+  StkId t;
+  TValue k;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setpvalue(&k, cast(void *, p));
+  setobj2t(L, luaH_set(L, hvalue(t), &k), L->top - 1);
+  luaC_barrierback(L, gcvalue(t), L->top - 1);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_setmetatable (lua_State *L, int objindex) {
+  TValue *obj;
+  Table *mt;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  obj = index2addr(L, objindex);
+  api_checkvalidindex(L, obj);
+  if (ttisnil(L->top - 1))
+    mt = NULL;
+  else {
+    api_check(L, ttistable(L->top - 1), "table expected");
+    mt = hvalue(L->top - 1);
+  }
+  switch (ttypenv(obj)) {
+    case LUA_TTABLE: {
+      hvalue(obj)->metatable = mt;
+      if (mt)
+        luaC_objbarrierback(L, gcvalue(obj), mt);
+        luaC_checkfinalizer(L, gcvalue(obj), mt);
+      break;
+    }
+    case LUA_TUSERDATA: {
+      uvalue(obj)->metatable = mt;
+      if (mt) {
+        luaC_objbarrier(L, rawuvalue(obj), mt);
+        luaC_checkfinalizer(L, gcvalue(obj), mt);
+      }
+      break;
+    }
+    default: {
+      G(L)->mt[ttypenv(obj)] = mt;
+      break;
+    }
+  }
+  L->top--;
+  lua_unlock(L);
+  return 1;
+}
+
+
+LUA_API void lua_setuservalue (lua_State *L, int idx) {
+  StkId o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = index2addr(L, idx);
+  api_checkvalidindex(L, o);
+  api_check(L, ttisuserdata(o), "userdata expected");
+  if (ttisnil(L->top - 1))
+    uvalue(o)->env = NULL;
+  else {
+    api_check(L, ttistable(L->top - 1), "table expected");
+    uvalue(o)->env = hvalue(L->top - 1);
+    luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));
+  }
+  L->top--;
+  lua_unlock(L);
+}
+
+
+/*
+** `load' and `call' functions (run Lua code)
+*/
+
+
+#define checkresults(L,na,nr) \
+     api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)), \
+	"results from function overflow current stack size")
+
+
+LUA_API int lua_getctx (lua_State *L, int *ctx) {
+  if (L->ci->callstatus & CIST_YIELDED) {
+    if (ctx) *ctx = L->ci->u.c.ctx;
+    return L->ci->u.c.status;
+  }
+  else return LUA_OK;
+}
+
+
+LUA_API void lua_callk (lua_State *L, int nargs, int nresults, int ctx,
+                        lua_CFunction k) {
+  StkId func;
+  lua_lock(L);
+  api_check(L, k == NULL || !isLua(L->ci),
+    "cannot use continuations inside hooks");
+  api_checknelems(L, nargs+1);
+  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
+  checkresults(L, nargs, nresults);
+  func = L->top - (nargs+1);
+  if (k != NULL && L->nny == 0) {  /* need to prepare continuation? */
+    L->ci->u.c.k = k;  /* save continuation */
+    L->ci->u.c.ctx = ctx;  /* save context */
+    luaD_call(L, func, nresults, 1);  /* do the call */
+  }
+  else  /* no continuation or no yieldable */
+    luaD_call(L, func, nresults, 0);  /* just do the call */
+  adjustresults(L, nresults);
+  lua_unlock(L);
+}
+
+
+
+/*
+** Execute a protected call.
+*/
+struct CallS {  /* data to `f_call' */
+  StkId func;
+  int nresults;
+};
+
+
+static void f_call (lua_State *L, void *ud) {
+  struct CallS *c = cast(struct CallS *, ud);
+  luaD_call(L, c->func, c->nresults, 0);
+}
+
+
+
+LUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,
+                        int ctx, lua_CFunction k) {
+  struct CallS c;
+  int status;
+  ptrdiff_t func;
+  lua_lock(L);
+  api_check(L, k == NULL || !isLua(L->ci),
+    "cannot use continuations inside hooks");
+  api_checknelems(L, nargs+1);
+  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
+  checkresults(L, nargs, nresults);
+  if (errfunc == 0)
+    func = 0;
+  else {
+    StkId o = index2addr(L, errfunc);
+    api_checkvalidindex(L, o);
+    func = savestack(L, o);
+  }
+  c.func = L->top - (nargs+1);  /* function to be called */
+  if (k == NULL || L->nny > 0) {  /* no continuation or no yieldable? */
+    c.nresults = nresults;  /* do a 'conventional' protected call */
+    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);
+  }
+  else {  /* prepare continuation (call is already protected by 'resume') */
+    CallInfo *ci = L->ci;
+    ci->u.c.k = k;  /* save continuation */
+    ci->u.c.ctx = ctx;  /* save context */
+    /* save information for error recovery */
+    ci->extra = savestack(L, c.func);
+    ci->u.c.old_allowhook = L->allowhook;
+    ci->u.c.old_errfunc = L->errfunc;
+    L->errfunc = func;
+    /* mark that function may do error recovery */
+    ci->callstatus |= CIST_YPCALL;
+    luaD_call(L, c.func, nresults, 1);  /* do the call */
+    ci->callstatus &= ~CIST_YPCALL;
+    L->errfunc = ci->u.c.old_errfunc;
+    status = LUA_OK;  /* if it is here, there were no errors */
+  }
+  adjustresults(L, nresults);
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
+                      const char *chunkname, const char *mode) {
+  ZIO z;
+  int status;
+  lua_lock(L);
+  if (!chunkname) chunkname = "?";
+  luaZ_init(L, &z, reader, data);
+  status = luaD_protectedparser(L, &z, chunkname, mode);
+  if (status == LUA_OK) {  /* no errors? */
+    LClosure *f = clLvalue(L->top - 1);  /* get newly created function */
+    if (f->nupvalues == 1) {  /* does it have one upvalue? */
+      /* get global table from registry */
+      Table *reg = hvalue(&G(L)->l_registry);
+      const TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
+      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */
+      setobj(L, f->upvals[0]->v, gt);
+      luaC_barrier(L, f->upvals[0], gt);
+    }
+  }
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data) {
+  int status;
+  TValue *o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = L->top - 1;
+  if (isLfunction(o))
+    status = luaU_dump(L, getproto(o), writer, data, 0);
+  else
+    status = 1;
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int  lua_status (lua_State *L) {
+  return L->status;
+}
+
+
+/*
+** Garbage-collection function
+*/
+
+LUA_API int lua_gc (lua_State *L, int what, int data) {
+  int res = 0;
+  global_State *g;
+  lua_lock(L);
+  g = G(L);
+  switch (what) {
+    case LUA_GCSTOP: {
+      g->gcrunning = 0;
+      break;
+    }
+    case LUA_GCRESTART: {
+      luaE_setdebt(g, 0);
+      g->gcrunning = 1;
+      break;
+    }
+    case LUA_GCCOLLECT: {
+      luaC_fullgc(L, 0);
+      break;
+    }
+    case LUA_GCCOUNT: {
+      /* GC values are expressed in Kbytes: #bytes/2^10 */
+      res = cast_int(gettotalbytes(g) >> 10);
+      break;
+    }
+    case LUA_GCCOUNTB: {
+      res = cast_int(gettotalbytes(g) & 0x3ff);
+      break;
+    }
+    case LUA_GCSTEP: {
+      if (g->gckind == KGC_GEN) {  /* generational mode? */
+        res = (g->GCestimate == 0);  /* true if it will do major collection */
+        luaC_forcestep(L);  /* do a single step */
+      }
+      else {
+       lu_mem debt = cast(lu_mem, data) * 1024 - GCSTEPSIZE;
+       if (g->gcrunning)
+         debt += g->GCdebt;  /* include current debt */
+       luaE_setdebt(g, debt);
+       luaC_forcestep(L);
+       if (g->gcstate == GCSpause)  /* end of cycle? */
+         res = 1;  /* signal it */
+      }
+      break;
+    }
+    case LUA_GCSETPAUSE: {
+      res = g->gcpause;
+      g->gcpause = data;
+      break;
+    }
+    case LUA_GCSETMAJORINC: {
+      res = g->gcmajorinc;
+      g->gcmajorinc = data;
+      break;
+    }
+    case LUA_GCSETSTEPMUL: {
+      res = g->gcstepmul;
+      g->gcstepmul = data;
+      break;
+    }
+    case LUA_GCISRUNNING: {
+      res = g->gcrunning;
+      break;
+    }
+    case LUA_GCGEN: {  /* change collector to generational mode */
+      luaC_changemode(L, KGC_GEN);
+      break;
+    }
+    case LUA_GCINC: {  /* change collector to incremental mode */
+      luaC_changemode(L, KGC_NORMAL);
+      break;
+    }
+    default: res = -1;  /* invalid option */
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+
+/*
+** miscellaneous functions
+*/
+
+
+LUA_API int lua_error (lua_State *L) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  luaG_errormsg(L);
+  lua_unlock(L);
+  return 0;  /* to avoid warnings */
+}
+
+
+LUA_API int lua_next (lua_State *L, int idx) {
+  StkId t;
+  int more;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  more = luaH_next(L, hvalue(t), L->top - 1);
+  if (more) {
+    api_incr_top(L);
+  }
+  else  /* no more elements */
+    L->top -= 1;  /* remove key */
+  lua_unlock(L);
+  return more;
+}
+
+
+LUA_API void lua_concat (lua_State *L, int n) {
+  lua_lock(L);
+  api_checknelems(L, n);
+  if (n >= 2) {
+    luaC_checkGC(L);
+    luaV_concat(L, n);
+  }
+  else if (n == 0) {  /* push empty string */
+    setsvalue2s(L, L->top, luaS_newlstr(L, "", 0));
+    api_incr_top(L);
+  }
+  /* else n == 1; nothing to do */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_len (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  luaV_objlen(L, L->top, t);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {
+  lua_Alloc f;
+  lua_lock(L);
+  if (ud) *ud = G(L)->ud;
+  f = G(L)->frealloc;
+  lua_unlock(L);
+  return f;
+}
+
+
+LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {
+  lua_lock(L);
+  G(L)->ud = ud;
+  G(L)->frealloc = f;
+  lua_unlock(L);
+}
+
+
+LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
+  Udata *u;
+  lua_lock(L);
+  luaC_checkGC(L);
+  u = luaS_newudata(L, size, NULL);
+  setuvalue(L, L->top, u);
+  api_incr_top(L);
+  lua_unlock(L);
+  return u + 1;
+}
+
+
+
+static const char *aux_upvalue (StkId fi, int n, TValue **val,
+                                GCObject **owner) {
+  switch (ttype(fi)) {
+    case LUA_TCCL: {  /* C closure */
+      CClosure *f = clCvalue(fi);
+      if (!(1 <= n && n <= f->nupvalues)) return NULL;
+      *val = &f->upvalue[n-1];
+      if (owner) *owner = obj2gco(f);
+      return "";
+    }
+    case LUA_TLCL: {  /* Lua closure */
+      LClosure *f = clLvalue(fi);
+      TString *name;
+      Proto *p = f->p;
+      if (!(1 <= n && n <= p->sizeupvalues)) return NULL;
+      *val = f->upvals[n-1]->v;
+      if (owner) *owner = obj2gco(f->upvals[n - 1]);
+      name = p->upvalues[n-1].name;
+      return (name == NULL) ? "" : getstr(name);
+    }
+    default: return NULL;  /* not a closure */
+  }
+}
+
+
+LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TValue *val = NULL;  /* to avoid warnings */
+  lua_lock(L);
+  name = aux_upvalue(index2addr(L, funcindex), n, &val, NULL);
+  if (name) {
+    setobj2s(L, L->top, val);
+    api_incr_top(L);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TValue *val = NULL;  /* to avoid warnings */
+  GCObject *owner = NULL;  /* to avoid warnings */
+  StkId fi;
+  lua_lock(L);
+  fi = index2addr(L, funcindex);
+  api_checknelems(L, 1);
+  name = aux_upvalue(fi, n, &val, &owner);
+  if (name) {
+    L->top--;
+    setobj(L, val, L->top);
+    luaC_barrier(L, owner, L->top);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {
+  LClosure *f;
+  StkId fi = index2addr(L, fidx);
+  api_check(L, ttisLclosure(fi), "Lua function expected");
+  f = clLvalue(fi);
+  api_check(L, (1 <= n && n <= f->p->sizeupvalues), "invalid upvalue index");
+  if (pf) *pf = f;
+  return &f->upvals[n - 1];  /* get its upvalue pointer */
+}
+
+
+LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {
+  StkId fi = index2addr(L, fidx);
+  switch (ttype(fi)) {
+    case LUA_TLCL: {  /* lua closure */
+      return *getupvalref(L, fidx, n, NULL);
+    }
+    case LUA_TCCL: {  /* C closure */
+      CClosure *f = clCvalue(fi);
+      api_check(L, 1 <= n && n <= f->nupvalues, "invalid upvalue index");
+      return &f->upvalue[n - 1];
+    }
+    default: {
+      api_check(L, 0, "closure expected");
+      return NULL;
+    }
+  }
+}
+
+
+LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,
+                                            int fidx2, int n2) {
+  LClosure *f1;
+  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);
+  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);
+  *up1 = *up2;
+  luaC_objbarrier(L, f1, *up2);
+}
+
diff --git a/dep/lualib/lapi.h b/dep/lualib/lapi.h
new file mode 100644
index 0000000..0909a39
--- /dev/null
+++ b/dep/lualib/lapi.h
@@ -0,0 +1,24 @@
+/*
+** $Id: lapi.h,v 2.7 2009/11/27 15:37:59 roberto Exp $
+** Auxiliary functions from Lua API
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lapi_h
+#define lapi_h
+
+
+#include "llimits.h"
+#include "lstate.h"
+
+#define api_incr_top(L)   {L->top++; api_check(L, L->top <= L->ci->top, \
+				"stack overflow");}
+
+#define adjustresults(L,nres) \
+    { if ((nres) == LUA_MULTRET && L->ci->top < L->top) L->ci->top = L->top; }
+
+#define api_checknelems(L,n)	api_check(L, (n) < (L->top - L->ci->func), \
+				  "not enough elements in the stack")
+
+
+#endif
diff --git a/dep/lualib/lauxlib.c b/dep/lualib/lauxlib.c
new file mode 100644
index 0000000..36ae7e6
--- /dev/null
+++ b/dep/lualib/lauxlib.c
@@ -0,0 +1,958 @@
+/*
+** $Id: lauxlib.c,v 1.244 2012/05/31 20:28:45 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#include <errno.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+/* This file uses only the official API of Lua.
+** Any function declared here could be written as an application function.
+*/
+
+#define lauxlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+
+
+/*
+** {======================================================
+** Traceback
+** =======================================================
+*/
+
+
+#define LEVELS1	12	/* size of the first part of the stack */
+#define LEVELS2	10	/* size of the second part of the stack */
+
+
+
+/*
+** search for 'objidx' in table at index -1.
+** return 1 + string at top if find a good name.
+*/
+static int findfield (lua_State *L, int objidx, int level) {
+  if (level == 0 || !lua_istable(L, -1))
+    return 0;  /* not found */
+  lua_pushnil(L);  /* start 'next' loop */
+  while (lua_next(L, -2)) {  /* for each pair in table */
+    if (lua_type(L, -2) == LUA_TSTRING) {  /* ignore non-string keys */
+      if (lua_rawequal(L, objidx, -1)) {  /* found object? */
+        lua_pop(L, 1);  /* remove value (but keep name) */
+        return 1;
+      }
+      else if (findfield(L, objidx, level - 1)) {  /* try recursively */
+        lua_remove(L, -2);  /* remove table (but keep name) */
+        lua_pushliteral(L, ".");
+        lua_insert(L, -2);  /* place '.' between the two names */
+        lua_concat(L, 3);
+        return 1;
+      }
+    }
+    lua_pop(L, 1);  /* remove value */
+  }
+  return 0;  /* not found */
+}
+
+
+static int pushglobalfuncname (lua_State *L, lua_Debug *ar) {
+  int top = lua_gettop(L);
+  lua_getinfo(L, "f", ar);  /* push function */
+  lua_pushglobaltable(L);
+  if (findfield(L, top + 1, 2)) {
+    lua_copy(L, -1, top + 1);  /* move name to proper place */
+    lua_pop(L, 2);  /* remove pushed values */
+    return 1;
+  }
+  else {
+    lua_settop(L, top);  /* remove function and global table */
+    return 0;
+  }
+}
+
+
+static void pushfuncname (lua_State *L, lua_Debug *ar) {
+  if (*ar->namewhat != '\0')  /* is there a name? */
+    lua_pushfstring(L, "function " LUA_QS, ar->name);
+  else if (*ar->what == 'm')  /* main? */
+      lua_pushfstring(L, "main chunk");
+  else if (*ar->what == 'C') {
+    if (pushglobalfuncname(L, ar)) {
+      lua_pushfstring(L, "function " LUA_QS, lua_tostring(L, -1));
+      lua_remove(L, -2);  /* remove name */
+    }
+    else
+      lua_pushliteral(L, "?");
+  }
+  else
+    lua_pushfstring(L, "function <%s:%d>", ar->short_src, ar->linedefined);
+}
+
+
+static int countlevels (lua_State *L) {
+  lua_Debug ar;
+  int li = 1, le = 1;
+  /* find an upper bound */
+  while (lua_getstack(L, le, &ar)) { li = le; le *= 2; }
+  /* do a binary search */
+  while (li < le) {
+    int m = (li + le)/2;
+    if (lua_getstack(L, m, &ar)) li = m + 1;
+    else le = m;
+  }
+  return le - 1;
+}
+
+
+LUALIB_API void luaL_traceback (lua_State *L, lua_State *L1,
+                                const char *msg, int level) {
+  lua_Debug ar;
+  int top = lua_gettop(L);
+  int numlevels = countlevels(L1);
+  int mark = (numlevels > LEVELS1 + LEVELS2) ? LEVELS1 : 0;
+  if (msg) lua_pushfstring(L, "%s\n", msg);
+  lua_pushliteral(L, "stack traceback:");
+  while (lua_getstack(L1, level++, &ar)) {
+    if (level == mark) {  /* too many levels? */
+      lua_pushliteral(L, "\n\t...");  /* add a '...' */
+      level = numlevels - LEVELS2;  /* and skip to last ones */
+    }
+    else {
+      lua_getinfo(L1, "Slnt", &ar);
+      lua_pushfstring(L, "\n\t%s:", ar.short_src);
+      if (ar.currentline > 0)
+        lua_pushfstring(L, "%d:", ar.currentline);
+      lua_pushliteral(L, " in ");
+      pushfuncname(L, &ar);
+      if (ar.istailcall)
+        lua_pushliteral(L, "\n\t(...tail calls...)");
+      lua_concat(L, lua_gettop(L) - top);
+    }
+  }
+  lua_concat(L, lua_gettop(L) - top);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Error-report functions
+** =======================================================
+*/
+
+LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
+  lua_Debug ar;
+  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */
+    return luaL_error(L, "bad argument #%d (%s)", narg, extramsg);
+  lua_getinfo(L, "n", &ar);
+  if (strcmp(ar.namewhat, "method") == 0) {
+    narg--;  /* do not count `self' */
+    if (narg == 0)  /* error is in the self argument itself? */
+      return luaL_error(L, "calling " LUA_QS " on bad self", ar.name);
+  }
+  if (ar.name == NULL)
+    ar.name = (pushglobalfuncname(L, &ar)) ? lua_tostring(L, -1) : "?";
+  return luaL_error(L, "bad argument #%d to " LUA_QS " (%s)",
+                        narg, ar.name, extramsg);
+}
+
+
+static int typeerror (lua_State *L, int narg, const char *tname) {
+  const char *msg = lua_pushfstring(L, "%s expected, got %s",
+                                    tname, luaL_typename(L, narg));
+  return luaL_argerror(L, narg, msg);
+}
+
+
+static void tag_error (lua_State *L, int narg, int tag) {
+  typeerror(L, narg, lua_typename(L, tag));
+}
+
+
+LUALIB_API void luaL_where (lua_State *L, int level) {
+  lua_Debug ar;
+  if (lua_getstack(L, level, &ar)) {  /* check function at level */
+    lua_getinfo(L, "Sl", &ar);  /* get info about it */
+    if (ar.currentline > 0) {  /* is there info? */
+      lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
+      return;
+    }
+  }
+  lua_pushliteral(L, "");  /* else, no information available... */
+}
+
+
+LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  luaL_where(L, 1);
+  lua_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_concat(L, 2);
+  return lua_error(L);
+}
+
+
+LUALIB_API int luaL_fileresult (lua_State *L, int stat, const char *fname) {
+  int en = errno;  /* calls to Lua API may change this value */
+  if (stat) {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+  else {
+    lua_pushnil(L);
+    if (fname)
+      lua_pushfstring(L, "%s: %s", fname, strerror(en));
+    else
+      lua_pushfstring(L, "%s", strerror(en));
+    lua_pushinteger(L, en);
+    return 3;
+  }
+}
+
+
+#if !defined(inspectstat)	/* { */
+
+#if defined(LUA_USE_POSIX)
+
+#include <sys/wait.h>
+
+/*
+** use appropriate macros to interpret 'pclose' return status
+*/
+#define inspectstat(stat,what)  \
+   if (WIFEXITED(stat)) { stat = WEXITSTATUS(stat); } \
+   else if (WIFSIGNALED(stat)) { stat = WTERMSIG(stat); what = "signal"; }
+
+#else
+
+#define inspectstat(stat,what)  /* no op */
+
+#endif
+
+#endif				/* } */
+
+
+LUALIB_API int luaL_execresult (lua_State *L, int stat) {
+  const char *what = "exit";  /* type of termination */
+  if (stat == -1)  /* error? */
+    return luaL_fileresult(L, 0, NULL);
+  else {
+    inspectstat(stat, what);  /* interpret result */
+    if (*what == 'e' && stat == 0)  /* successful termination? */
+      lua_pushboolean(L, 1);
+    else
+      lua_pushnil(L);
+    lua_pushstring(L, what);
+    lua_pushinteger(L, stat);
+    return 3;  /* return true/nil,what,code */
+  }
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Userdata's metatable manipulation
+** =======================================================
+*/
+
+LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
+  luaL_getmetatable(L, tname);  /* try to get metatable */
+  if (!lua_isnil(L, -1))  /* name already in use? */
+    return 0;  /* leave previous value on top, but return 0 */
+  lua_pop(L, 1);
+  lua_newtable(L);  /* create metatable */
+  lua_pushvalue(L, -1);
+  lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */
+  return 1;
+}
+
+
+LUALIB_API void luaL_setmetatable (lua_State *L, const char *tname) {
+  luaL_getmetatable(L, tname);
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API void *luaL_testudata (lua_State *L, int ud, const char *tname) {
+  void *p = lua_touserdata(L, ud);
+  if (p != NULL) {  /* value is a userdata? */
+    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */
+      luaL_getmetatable(L, tname);  /* get correct metatable */
+      if (!lua_rawequal(L, -1, -2))  /* not the same? */
+        p = NULL;  /* value is a userdata with wrong metatable */
+      lua_pop(L, 2);  /* remove both metatables */
+      return p;
+    }
+  }
+  return NULL;  /* value is not a userdata with a metatable */
+}
+
+
+LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
+  void *p = luaL_testudata(L, ud, tname);
+  if (p == NULL) typeerror(L, ud, tname);
+  return p;
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Argument check functions
+** =======================================================
+*/
+
+LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,
+                                 const char *const lst[]) {
+  const char *name = (def) ? luaL_optstring(L, narg, def) :
+                             luaL_checkstring(L, narg);
+  int i;
+  for (i=0; lst[i]; i++)
+    if (strcmp(lst[i], name) == 0)
+      return i;
+  return luaL_argerror(L, narg,
+                       lua_pushfstring(L, "invalid option " LUA_QS, name));
+}
+
+
+LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *msg) {
+  /* keep some extra space to run error routines, if needed */
+  const int extra = LUA_MINSTACK;
+  if (!lua_checkstack(L, space + extra)) {
+    if (msg)
+      luaL_error(L, "stack overflow (%s)", msg);
+    else
+      luaL_error(L, "stack overflow");
+  }
+}
+
+
+LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
+  if (lua_type(L, narg) != t)
+    tag_error(L, narg, t);
+}
+
+
+LUALIB_API void luaL_checkany (lua_State *L, int narg) {
+  if (lua_type(L, narg) == LUA_TNONE)
+    luaL_argerror(L, narg, "value expected");
+}
+
+
+LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {
+  const char *s = lua_tolstring(L, narg, len);
+  if (!s) tag_error(L, narg, LUA_TSTRING);
+  return s;
+}
+
+
+LUALIB_API const char *luaL_optlstring (lua_State *L, int narg,
+                                        const char *def, size_t *len) {
+  if (lua_isnoneornil(L, narg)) {
+    if (len)
+      *len = (def ? strlen(def) : 0);
+    return def;
+  }
+  else return luaL_checklstring(L, narg, len);
+}
+
+
+LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {
+  int isnum;
+  lua_Number d = lua_tonumberx(L, narg, &isnum);
+  if (!isnum)
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {
+  return luaL_opt(L, luaL_checknumber, narg, def);
+}
+
+
+LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int narg) {
+  int isnum;
+  lua_Integer d = lua_tointegerx(L, narg, &isnum);
+  if (!isnum)
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Unsigned luaL_checkunsigned (lua_State *L, int narg) {
+  int isnum;
+  lua_Unsigned d = lua_tounsignedx(L, narg, &isnum);
+  if (!isnum)
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int narg,
+                                                      lua_Integer def) {
+  return luaL_opt(L, luaL_checkinteger, narg, def);
+}
+
+
+LUALIB_API lua_Unsigned luaL_optunsigned (lua_State *L, int narg,
+                                                        lua_Unsigned def) {
+  return luaL_opt(L, luaL_checkunsigned, narg, def);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+/*
+** check whether buffer is using a userdata on the stack as a temporary
+** buffer
+*/
+#define buffonstack(B)	((B)->b != (B)->initb)
+
+
+/*
+** returns a pointer to a free area with at least 'sz' bytes
+*/
+LUALIB_API char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz) {
+  lua_State *L = B->L;
+  if (B->size - B->n < sz) {  /* not enough space? */
+    char *newbuff;
+    size_t newsize = B->size * 2;  /* double buffer size */
+    if (newsize - B->n < sz)  /* not bit enough? */
+      newsize = B->n + sz;
+    if (newsize < B->n || newsize - B->n < sz)
+      luaL_error(L, "buffer too large");
+    /* create larger buffer */
+    newbuff = (char *)lua_newuserdata(L, newsize * sizeof(char));
+    /* move content to new buffer */
+    memcpy(newbuff, B->b, B->n * sizeof(char));
+    if (buffonstack(B))
+      lua_remove(L, -2);  /* remove old buffer */
+    B->b = newbuff;
+    B->size = newsize;
+  }
+  return &B->b[B->n];
+}
+
+
+LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
+  char *b = luaL_prepbuffsize(B, l);
+  memcpy(b, s, l * sizeof(char));
+  luaL_addsize(B, l);
+}
+
+
+LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
+  luaL_addlstring(B, s, strlen(s));
+}
+
+
+LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
+  lua_State *L = B->L;
+  lua_pushlstring(L, B->b, B->n);
+  if (buffonstack(B))
+    lua_remove(L, -2);  /* remove old buffer */
+}
+
+
+LUALIB_API void luaL_pushresultsize (luaL_Buffer *B, size_t sz) {
+  luaL_addsize(B, sz);
+  luaL_pushresult(B);
+}
+
+
+LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
+  lua_State *L = B->L;
+  size_t l;
+  const char *s = lua_tolstring(L, -1, &l);
+  if (buffonstack(B))
+    lua_insert(L, -2);  /* put value below buffer */
+  luaL_addlstring(B, s, l);
+  lua_remove(L, (buffonstack(B)) ? -2 : -1);  /* remove value */
+}
+
+
+LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
+  B->L = L;
+  B->b = B->initb;
+  B->n = 0;
+  B->size = LUAL_BUFFERSIZE;
+}
+
+
+LUALIB_API char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz) {
+  luaL_buffinit(L, B);
+  return luaL_prepbuffsize(B, sz);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Reference system
+** =======================================================
+*/
+
+/* index of free-list header */
+#define freelist	0
+
+
+LUALIB_API int luaL_ref (lua_State *L, int t) {
+  int ref;
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 1);  /* remove from stack */
+    return LUA_REFNIL;  /* `nil' has a unique fixed reference */
+  }
+  t = lua_absindex(L, t);
+  lua_rawgeti(L, t, freelist);  /* get first free element */
+  ref = (int)lua_tointeger(L, -1);  /* ref = t[freelist] */
+  lua_pop(L, 1);  /* remove it from stack */
+  if (ref != 0) {  /* any free element? */
+    lua_rawgeti(L, t, ref);  /* remove it from list */
+    lua_rawseti(L, t, freelist);  /* (t[freelist] = t[ref]) */
+  }
+  else  /* no free elements */
+    ref = (int)lua_rawlen(L, t) + 1;  /* get a new reference */
+  lua_rawseti(L, t, ref);
+  return ref;
+}
+
+
+LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
+  if (ref >= 0) {
+    t = lua_absindex(L, t);
+    lua_rawgeti(L, t, freelist);
+    lua_rawseti(L, t, ref);  /* t[ref] = t[freelist] */
+    lua_pushinteger(L, ref);
+    lua_rawseti(L, t, freelist);  /* t[freelist] = ref */
+  }
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Load functions
+** =======================================================
+*/
+
+typedef struct LoadF {
+  int n;  /* number of pre-read characters */
+  FILE *f;  /* file being read */
+  char buff[LUAL_BUFFERSIZE];  /* area for reading file */
+} LoadF;
+
+
+static const char *getF (lua_State *L, void *ud, size_t *size) {
+  LoadF *lf = (LoadF *)ud;
+  (void)L;  /* not used */
+  if (lf->n > 0) {  /* are there pre-read characters to be read? */
+    *size = lf->n;  /* return them (chars already in buffer) */
+    lf->n = 0;  /* no more pre-read characters */
+  }
+  else {  /* read a block from file */
+    /* 'fread' can return > 0 *and* set the EOF flag. If next call to
+       'getF' called 'fread', it might still wait for user input.
+       The next check avoids this problem. */
+    if (feof(lf->f)) return NULL;
+    *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);  /* read block */
+  }
+  return lf->buff;
+}
+
+
+static int errfile (lua_State *L, const char *what, int fnameindex) {
+  const char *serr = strerror(errno);
+  const char *filename = lua_tostring(L, fnameindex) + 1;
+  lua_pushfstring(L, "cannot %s %s: %s", what, filename, serr);
+  lua_remove(L, fnameindex);
+  return LUA_ERRFILE;
+}
+
+
+static int skipBOM (LoadF *lf) {
+  const char *p = "\xEF\xBB\xBF";  /* Utf8 BOM mark */
+  int c;
+  lf->n = 0;
+  do {
+    c = getc(lf->f);
+    if (c == EOF || c != *(unsigned char *)p++) return c;
+    lf->buff[lf->n++] = c;  /* to be read by the parser */
+  } while (*p != '\0');
+  lf->n = 0;  /* prefix matched; discard it */
+  return getc(lf->f);  /* return next character */
+}
+
+
+/*
+** reads the first character of file 'f' and skips an optional BOM mark
+** in its beginning plus its first line if it starts with '#'. Returns
+** true if it skipped the first line.  In any case, '*cp' has the
+** first "valid" character of the file (after the optional BOM and
+** a first-line comment).
+*/
+static int skipcomment (LoadF *lf, int *cp) {
+  int c = *cp = skipBOM(lf);
+  if (c == '#') {  /* first line is a comment (Unix exec. file)? */
+    do {  /* skip first line */
+      c = getc(lf->f);
+    } while (c != EOF && c != '\n') ;
+    *cp = getc(lf->f);  /* skip end-of-line, if present */
+    return 1;  /* there was a comment */
+  }
+  else return 0;  /* no comment */
+}
+
+
+LUALIB_API int luaL_loadfilex (lua_State *L, const char *filename,
+                                             const char *mode) {
+  LoadF lf;
+  int status, readstatus;
+  int c;
+  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
+  if (filename == NULL) {
+    lua_pushliteral(L, "=stdin");
+    lf.f = stdin;
+  }
+  else {
+    lua_pushfstring(L, "@%s", filename);
+    lf.f = fopen(filename, "r");
+    if (lf.f == NULL) return errfile(L, "open", fnameindex);
+  }
+  if (skipcomment(&lf, &c))  /* read initial portion */
+    lf.buff[lf.n++] = '\n';  /* add line to correct line numbers */
+  if (c == LUA_SIGNATURE[0] && filename) {  /* binary file? */
+    lf.f = freopen(filename, "rb", lf.f);  /* reopen in binary mode */
+    if (lf.f == NULL) return errfile(L, "reopen", fnameindex);
+    skipcomment(&lf, &c);  /* re-read initial portion */
+  }
+  if (c != EOF)
+    lf.buff[lf.n++] = c;  /* 'c' is the first character of the stream */
+  status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);
+  readstatus = ferror(lf.f);
+  if (filename) fclose(lf.f);  /* close file (even in case of errors) */
+  if (readstatus) {
+    lua_settop(L, fnameindex);  /* ignore results from `lua_load' */
+    return errfile(L, "read", fnameindex);
+  }
+  lua_remove(L, fnameindex);
+  return status;
+}
+
+
+typedef struct LoadS {
+  const char *s;
+  size_t size;
+} LoadS;
+
+
+static const char *getS (lua_State *L, void *ud, size_t *size) {
+  LoadS *ls = (LoadS *)ud;
+  (void)L;  /* not used */
+  if (ls->size == 0) return NULL;
+  *size = ls->size;
+  ls->size = 0;
+  return ls->s;
+}
+
+
+LUALIB_API int luaL_loadbufferx (lua_State *L, const char *buff, size_t size,
+                                 const char *name, const char *mode) {
+  LoadS ls;
+  ls.s = buff;
+  ls.size = size;
+  return lua_load(L, getS, &ls, name, mode);
+}
+
+
+LUALIB_API int luaL_loadstring (lua_State *L, const char *s) {
+  return luaL_loadbuffer(L, s, strlen(s), s);
+}
+
+/* }====================================================== */
+
+
+
+LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
+  if (!lua_getmetatable(L, obj))  /* no metatable? */
+    return 0;
+  lua_pushstring(L, event);
+  lua_rawget(L, -2);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 2);  /* remove metatable and metafield */
+    return 0;
+  }
+  else {
+    lua_remove(L, -2);  /* remove only metatable */
+    return 1;
+  }
+}
+
+
+LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
+  obj = lua_absindex(L, obj);
+  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */
+    return 0;
+  lua_pushvalue(L, obj);
+  lua_call(L, 1, 1);
+  return 1;
+}
+
+
+LUALIB_API int luaL_len (lua_State *L, int idx) {
+  int l;
+  int isnum;
+  lua_len(L, idx);
+  l = (int)lua_tointegerx(L, -1, &isnum);
+  if (!isnum)
+    luaL_error(L, "object length is not a number");
+  lua_pop(L, 1);  /* remove object */
+  return l;
+}
+
+
+LUALIB_API const char *luaL_tolstring (lua_State *L, int idx, size_t *len) {
+  if (!luaL_callmeta(L, idx, "__tostring")) {  /* no metafield? */
+    switch (lua_type(L, idx)) {
+      case LUA_TNUMBER:
+      case LUA_TSTRING:
+        lua_pushvalue(L, idx);
+        break;
+      case LUA_TBOOLEAN:
+        lua_pushstring(L, (lua_toboolean(L, idx) ? "true" : "false"));
+        break;
+      case LUA_TNIL:
+        lua_pushliteral(L, "nil");
+        break;
+      default:
+        lua_pushfstring(L, "%s: %p", luaL_typename(L, idx),
+                                            lua_topointer(L, idx));
+        break;
+    }
+  }
+  return lua_tolstring(L, -1, len);
+}
+
+
+/*
+** {======================================================
+** Compatibility with 5.1 module functions
+** =======================================================
+*/
+#if defined(LUA_COMPAT_MODULE)
+
+static const char *luaL_findtable (lua_State *L, int idx,
+                                   const char *fname, int szhint) {
+  const char *e;
+  if (idx) lua_pushvalue(L, idx);
+  do {
+    e = strchr(fname, '.');
+    if (e == NULL) e = fname + strlen(fname);
+    lua_pushlstring(L, fname, e - fname);
+    lua_rawget(L, -2);
+    if (lua_isnil(L, -1)) {  /* no such field? */
+      lua_pop(L, 1);  /* remove this nil */
+      lua_createtable(L, 0, (*e == '.' ? 1 : szhint)); /* new table for field */
+      lua_pushlstring(L, fname, e - fname);
+      lua_pushvalue(L, -2);
+      lua_settable(L, -4);  /* set new table into field */
+    }
+    else if (!lua_istable(L, -1)) {  /* field has a non-table value? */
+      lua_pop(L, 2);  /* remove table and value */
+      return fname;  /* return problematic part of the name */
+    }
+    lua_remove(L, -2);  /* remove previous table */
+    fname = e + 1;
+  } while (*e == '.');
+  return NULL;
+}
+
+
+/*
+** Count number of elements in a luaL_Reg list.
+*/
+static int libsize (const luaL_Reg *l) {
+  int size = 0;
+  for (; l && l->name; l++) size++;
+  return size;
+}
+
+
+/*
+** Find or create a module table with a given name. The function
+** first looks at the _LOADED table and, if that fails, try a
+** global variable with that name. In any case, leaves on the stack
+** the module table.
+*/
+LUALIB_API void luaL_pushmodule (lua_State *L, const char *modname,
+                                 int sizehint) {
+  luaL_findtable(L, LUA_REGISTRYINDEX, "_LOADED", 1);  /* get _LOADED table */
+  lua_getfield(L, -1, modname);  /* get _LOADED[modname] */
+  if (!lua_istable(L, -1)) {  /* not found? */
+    lua_pop(L, 1);  /* remove previous result */
+    /* try global variable (and create one if it does not exist) */
+    lua_pushglobaltable(L);
+    if (luaL_findtable(L, 0, modname, sizehint) != NULL)
+      luaL_error(L, "name conflict for module " LUA_QS, modname);
+    lua_pushvalue(L, -1);
+    lua_setfield(L, -3, modname);  /* _LOADED[modname] = new table */
+  }
+  lua_remove(L, -2);  /* remove _LOADED table */
+}
+
+
+LUALIB_API void luaL_openlib (lua_State *L, const char *libname,
+                               const luaL_Reg *l, int nup) {
+  luaL_checkversion(L);
+  if (libname) {
+    luaL_pushmodule(L, libname, libsize(l));  /* get/create library table */
+    lua_insert(L, -(nup + 1));  /* move library table to below upvalues */
+  }
+  if (l)
+    luaL_setfuncs(L, l, nup);
+  else
+    lua_pop(L, nup);  /* remove upvalues */
+}
+
+#endif
+/* }====================================================== */
+
+/*
+** set functions from list 'l' into table at top - 'nup'; each
+** function gets the 'nup' elements at the top as upvalues.
+** Returns with only the table at the stack.
+*/
+LUALIB_API void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup) {
+  luaL_checkversion(L);
+  luaL_checkstack(L, nup, "too many upvalues");
+  for (; l->name != NULL; l++) {  /* fill the table with given functions */
+    int i;
+    for (i = 0; i < nup; i++)  /* copy upvalues to the top */
+      lua_pushvalue(L, -nup);
+    lua_pushcclosure(L, l->func, nup);  /* closure with those upvalues */
+    lua_setfield(L, -(nup + 2), l->name);
+  }
+  lua_pop(L, nup);  /* remove upvalues */
+}
+
+
+/*
+** ensure that stack[idx][fname] has a table and push that table
+** into the stack
+*/
+LUALIB_API int luaL_getsubtable (lua_State *L, int idx, const char *fname) {
+  lua_getfield(L, idx, fname);
+  if (lua_istable(L, -1)) return 1;  /* table already there */
+  else {
+    lua_pop(L, 1);  /* remove previous result */
+    idx = lua_absindex(L, idx);
+    lua_newtable(L);
+    lua_pushvalue(L, -1);  /* copy to be left at top */
+    lua_setfield(L, idx, fname);  /* assign new table to field */
+    return 0;  /* false, because did not find table there */
+  }
+}
+
+
+/*
+** stripped-down 'require'. Calls 'openf' to open a module,
+** registers the result in 'package.loaded' table and, if 'glb'
+** is true, also registers the result in the global table.
+** Leaves resulting module on the top.
+*/
+LUALIB_API void luaL_requiref (lua_State *L, const char *modname,
+                               lua_CFunction openf, int glb) {
+  lua_pushcfunction(L, openf);
+  lua_pushstring(L, modname);  /* argument to open function */
+  lua_call(L, 1, 1);  /* open module */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_LOADED");
+  lua_pushvalue(L, -2);  /* make copy of module (call result) */
+  lua_setfield(L, -2, modname);  /* _LOADED[modname] = module */
+  lua_pop(L, 1);  /* remove _LOADED table */
+  if (glb) {
+    lua_pushvalue(L, -1);  /* copy of 'mod' */
+    lua_setglobal(L, modname);  /* _G[modname] = module */
+  }
+}
+
+
+LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,
+                                                               const char *r) {
+  const char *wild;
+  size_t l = strlen(p);
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while ((wild = strstr(s, p)) != NULL) {
+    luaL_addlstring(&b, s, wild - s);  /* push prefix */
+    luaL_addstring(&b, r);  /* push replacement in place of pattern */
+    s = wild + l;  /* continue after `p' */
+  }
+  luaL_addstring(&b, s);  /* push last suffix */
+  luaL_pushresult(&b);
+  return lua_tostring(L, -1);
+}
+
+
+static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
+  (void)ud; (void)osize;  /* not used */
+  if (nsize == 0) {
+    free(ptr);
+    return NULL;
+  }
+  else
+    return realloc(ptr, nsize);
+}
+
+
+static int panic (lua_State *L) {
+  luai_writestringerror("PANIC: unprotected error in call to Lua API (%s)\n",
+                   lua_tostring(L, -1));
+  return 0;  /* return to Lua to abort */
+}
+
+
+LUALIB_API lua_State *luaL_newstate (void) {
+  lua_State *L = lua_newstate(l_alloc, NULL);
+  if (L) lua_atpanic(L, &panic);
+  return L;
+}
+
+
+LUALIB_API void luaL_checkversion_ (lua_State *L, lua_Number ver) {
+  const lua_Number *v = lua_version(L);
+  if (v != lua_version(NULL))
+    luaL_error(L, "multiple Lua VMs detected");
+  else if (*v != ver)
+    luaL_error(L, "version mismatch: app. needs %f, Lua core provides %f",
+                  ver, *v);
+  /* check conversions number -> integer types */
+  lua_pushnumber(L, -(lua_Number)0x1234);
+  if (lua_tointeger(L, -1) != -0x1234 ||
+      lua_tounsigned(L, -1) != (lua_Unsigned)-0x1234)
+    luaL_error(L, "bad conversion number->int;"
+                  " must recompile Lua with proper settings");
+  lua_pop(L, 1);
+}
+
diff --git a/dep/lualib/lauxlib.h b/dep/lualib/lauxlib.h
new file mode 100644
index 0000000..7aba289
--- /dev/null
+++ b/dep/lualib/lauxlib.h
@@ -0,0 +1,214 @@
+/*
+** $Id: lauxlib.h,v 1.120 2011/11/29 15:55:08 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lauxlib_h
+#define lauxlib_h
+
+
+#include <stddef.h>
+#include <stdio.h>
+
+#include "lua.h"
+
+
+
+/* extra error code for `luaL_load' */
+#define LUA_ERRFILE     (LUA_ERRERR+1)
+
+
+typedef struct luaL_Reg {
+  const char *name;
+  lua_CFunction func;
+} luaL_Reg;
+
+
+LUALIB_API void (luaL_checkversion_) (lua_State *L, lua_Number ver);
+#define luaL_checkversion(L)	luaL_checkversion_(L, LUA_VERSION_NUM)
+
+LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
+LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
+LUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);
+LUALIB_API int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);
+LUALIB_API const char *(luaL_checklstring) (lua_State *L, int numArg,
+                                                          size_t *l);
+LUALIB_API const char *(luaL_optlstring) (lua_State *L, int numArg,
+                                          const char *def, size_t *l);
+LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int numArg);
+LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);
+
+LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
+LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int nArg,
+                                          lua_Integer def);
+LUALIB_API lua_Unsigned (luaL_checkunsigned) (lua_State *L, int numArg);
+LUALIB_API lua_Unsigned (luaL_optunsigned) (lua_State *L, int numArg,
+                                            lua_Unsigned def);
+
+LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
+LUALIB_API void (luaL_checktype) (lua_State *L, int narg, int t);
+LUALIB_API void (luaL_checkany) (lua_State *L, int narg);
+
+LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
+LUALIB_API void  (luaL_setmetatable) (lua_State *L, const char *tname);
+LUALIB_API void *(luaL_testudata) (lua_State *L, int ud, const char *tname);
+LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);
+
+LUALIB_API void (luaL_where) (lua_State *L, int lvl);
+LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);
+
+LUALIB_API int (luaL_checkoption) (lua_State *L, int narg, const char *def,
+                                   const char *const lst[]);
+
+LUALIB_API int (luaL_fileresult) (lua_State *L, int stat, const char *fname);
+LUALIB_API int (luaL_execresult) (lua_State *L, int stat);
+
+/* pre-defined references */
+#define LUA_NOREF       (-2)
+#define LUA_REFNIL      (-1)
+
+LUALIB_API int (luaL_ref) (lua_State *L, int t);
+LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);
+
+LUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename,
+                                               const char *mode);
+
+#define luaL_loadfile(L,f)	luaL_loadfilex(L,f,NULL)
+
+LUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,
+                                   const char *name, const char *mode);
+LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);
+
+LUALIB_API lua_State *(luaL_newstate) (void);
+
+LUALIB_API int (luaL_len) (lua_State *L, int idx);
+
+LUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
+                                                  const char *r);
+
+LUALIB_API void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);
+
+LUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname);
+
+LUALIB_API void (luaL_traceback) (lua_State *L, lua_State *L1,
+                                  const char *msg, int level);
+
+LUALIB_API void (luaL_requiref) (lua_State *L, const char *modname,
+                                 lua_CFunction openf, int glb);
+
+/*
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+
+#define luaL_newlibtable(L,l)	\
+  lua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)
+
+#define luaL_newlib(L,l)	(luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
+
+#define luaL_argcheck(L, cond,numarg,extramsg)	\
+		((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
+#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
+#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))
+#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
+#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))
+#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
+#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))
+#define luaL_optbool(L, n, d) ( lua_isboolean( L, n ) ? lua_toboolean( L, n ) : (bool)luaL_optint( L, n, d ) )
+#define luaL_checkbool(L, n) ( lua_isboolean( L, n ) ? lua_toboolean( L, n ) : (bool)luaL_optint( L, n, false) )
+
+#define luaL_typename(L,i)	lua_typename(L, lua_type(L,(i)))
+
+#define luaL_dofile(L, fn) \
+	(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
+
+#define luaL_dostring(L, s) \
+	(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
+
+#define luaL_getmetatable(L,n)	(lua_getfield(L, LUA_REGISTRYINDEX, (n)))
+
+#define luaL_opt(L,f,n,d)	(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
+
+#define luaL_loadbuffer(L,s,sz,n)	luaL_loadbufferx(L,s,sz,n,NULL)
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+typedef struct luaL_Buffer {
+  char *b;  /* buffer address */
+  size_t size;  /* buffer size */
+  size_t n;  /* number of characters in buffer */
+  lua_State *L;
+  char initb[LUAL_BUFFERSIZE];  /* initial buffer */
+} luaL_Buffer;
+
+
+#define luaL_addchar(B,c) \
+  ((void)((B)->n < (B)->size || luaL_prepbuffsize((B), 1)), \
+   ((B)->b[(B)->n++] = (c)))
+
+#define luaL_addsize(B,s)	((B)->n += (s))
+
+LUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
+LUALIB_API char *(luaL_prepbuffsize) (luaL_Buffer *B, size_t sz);
+LUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
+LUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);
+LUALIB_API void (luaL_addvalue) (luaL_Buffer *B);
+LUALIB_API void (luaL_pushresult) (luaL_Buffer *B);
+LUALIB_API void (luaL_pushresultsize) (luaL_Buffer *B, size_t sz);
+LUALIB_API char *(luaL_buffinitsize) (lua_State *L, luaL_Buffer *B, size_t sz);
+
+#define luaL_prepbuffer(B)	luaL_prepbuffsize(B, LUAL_BUFFERSIZE)
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** File handles for IO library
+** =======================================================
+*/
+
+/*
+** A file handle is a userdata with metatable 'LUA_FILEHANDLE' and
+** initial structure 'luaL_Stream' (it may contain other fields
+** after that initial structure).
+*/
+
+#define LUA_FILEHANDLE          "FILE*"
+
+
+typedef struct luaL_Stream {
+  FILE *f;  /* stream (NULL for incompletely created streams) */
+  lua_CFunction closef;  /* to close stream (NULL for closed streams) */
+} luaL_Stream;
+
+/* }====================================================== */
+
+
+
+/* compatibility with old module system */
+#if defined(LUA_COMPAT_MODULE)
+
+LUALIB_API void (luaL_pushmodule) (lua_State *L, const char *modname,
+                                   int sizehint);
+LUALIB_API void (luaL_openlib) (lua_State *L, const char *libname,
+                                const luaL_Reg *l, int nup);
+
+#define luaL_register(L,n,l)	(luaL_openlib(L,(n),(l),0))
+
+#endif
+
+
+#endif
+
+
diff --git a/dep/lualib/lbaselib.c b/dep/lualib/lbaselib.c
new file mode 100644
index 0000000..dbfcb02
--- /dev/null
+++ b/dep/lualib/lbaselib.c
@@ -0,0 +1,459 @@
+/*
+** $Id: lbaselib.c,v 1.274 2012/04/27 14:13:19 roberto Exp $
+** Basic library
+** See Copyright Notice in lua.h
+*/
+
+
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lbaselib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+static int luaB_print (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  lua_getglobal(L, "tostring");
+  for (i=1; i<=n; i++) {
+    const char *s;
+    size_t l;
+    lua_pushvalue(L, -1);  /* function to be called */
+    lua_pushvalue(L, i);   /* value to print */
+    lua_call(L, 1, 1);
+    s = lua_tolstring(L, -1, &l);  /* get result */
+    if (s == NULL)
+      return luaL_error(L,
+         LUA_QL("tostring") " must return a string to " LUA_QL("print"));
+    if (i>1) luai_writestring("\t", 1);
+    luai_writestring(s, l);
+    lua_pop(L, 1);  /* pop result */
+  }
+  luai_writeline();
+  return 0;
+}
+
+
+#define SPACECHARS	" \f\n\r\t\v"
+
+static int luaB_tonumber (lua_State *L) {
+  if (lua_isnoneornil(L, 2)) {  /* standard conversion */
+    int isnum;
+    lua_Number n = lua_tonumberx(L, 1, &isnum);
+    if (isnum) {
+      lua_pushnumber(L, n);
+      return 1;
+    }  /* else not a number; must be something */
+    luaL_checkany(L, 1);
+  }
+  else {
+    size_t l;
+    const char *s = luaL_checklstring(L, 1, &l);
+    const char *e = s + l;  /* end point for 's' */
+    int base = luaL_checkint(L, 2);
+    int neg = 0;
+    luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
+    s += strspn(s, SPACECHARS);  /* skip initial spaces */
+    if (*s == '-') { s++; neg = 1; }  /* handle signal */
+    else if (*s == '+') s++;
+    if (isalnum((unsigned char)*s)) {
+      lua_Number n = 0;
+      do {
+        int digit = (isdigit((unsigned char)*s)) ? *s - '0'
+                       : toupper((unsigned char)*s) - 'A' + 10;
+        if (digit >= base) break;  /* invalid numeral; force a fail */
+        n = n * (lua_Number)base + (lua_Number)digit;
+        s++;
+      } while (isalnum((unsigned char)*s));
+      s += strspn(s, SPACECHARS);  /* skip trailing spaces */
+      if (s == e) {  /* no invalid trailing characters? */
+        lua_pushnumber(L, (neg) ? -n : n);
+        return 1;
+      }  /* else not a number */
+    }  /* else not a number */
+  }
+  lua_pushnil(L);  /* not a number */
+  return 1;
+}
+
+
+static int luaB_error (lua_State *L) {
+  int level = luaL_optint(L, 2, 1);
+  lua_settop(L, 1);
+  if (lua_isstring(L, 1) && level > 0) {  /* add extra information? */
+    luaL_where(L, level);
+    lua_pushvalue(L, 1);
+    lua_concat(L, 2);
+  }
+  return lua_error(L);
+}
+
+
+static int luaB_getmetatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_getmetatable(L, 1)) {
+    lua_pushnil(L);
+    return 1;  /* no metatable */
+  }
+  luaL_getmetafield(L, 1, "__metatable");
+  return 1;  /* returns either __metatable field (if present) or metatable */
+}
+
+
+static int luaB_setmetatable (lua_State *L) {
+  int t = lua_type(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
+                    "nil or table expected");
+  if (luaL_getmetafield(L, 1, "__metatable"))
+    return luaL_error(L, "cannot change a protected metatable");
+  lua_settop(L, 2);
+  lua_setmetatable(L, 1);
+  return 1;
+}
+
+
+static int luaB_rawequal (lua_State *L) {
+  luaL_checkany(L, 1);
+  luaL_checkany(L, 2);
+  lua_pushboolean(L, lua_rawequal(L, 1, 2));
+  return 1;
+}
+
+
+static int luaB_rawlen (lua_State *L) {
+  int t = lua_type(L, 1);
+  luaL_argcheck(L, t == LUA_TTABLE || t == LUA_TSTRING, 1,
+                   "table or string expected");
+  lua_pushinteger(L, lua_rawlen(L, 1));
+  return 1;
+}
+
+
+static int luaB_rawget (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  lua_settop(L, 2);
+  lua_rawget(L, 1);
+  return 1;
+}
+
+static int luaB_rawset (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  luaL_checkany(L, 3);
+  lua_settop(L, 3);
+  lua_rawset(L, 1);
+  return 1;
+}
+
+
+static int luaB_collectgarbage (lua_State *L) {
+  static const char *const opts[] = {"stop", "restart", "collect",
+    "count", "step", "setpause", "setstepmul",
+    "setmajorinc", "isrunning", "generational", "incremental", NULL};
+  static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
+    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL,
+    LUA_GCSETMAJORINC, LUA_GCISRUNNING, LUA_GCGEN, LUA_GCINC};
+  int o = optsnum[luaL_checkoption(L, 1, "collect", opts)];
+  int ex = luaL_optint(L, 2, 0);
+  int res = lua_gc(L, o, ex);
+  switch (o) {
+    case LUA_GCCOUNT: {
+      int b = lua_gc(L, LUA_GCCOUNTB, 0);
+      lua_pushnumber(L, res + ((lua_Number)b/1024));
+      lua_pushinteger(L, b);
+      return 2;
+    }
+    case LUA_GCSTEP: case LUA_GCISRUNNING: {
+      lua_pushboolean(L, res);
+      return 1;
+    }
+    default: {
+      lua_pushinteger(L, res);
+      return 1;
+    }
+  }
+}
+
+
+static int luaB_type (lua_State *L) {
+  luaL_checkany(L, 1);
+  lua_pushstring(L, luaL_typename(L, 1));
+  return 1;
+}
+
+
+static int pairsmeta (lua_State *L, const char *method, int iszero,
+                      lua_CFunction iter) {
+  if (!luaL_getmetafield(L, 1, method)) {  /* no metamethod? */
+    luaL_checktype(L, 1, LUA_TTABLE);  /* argument must be a table */
+    lua_pushcfunction(L, iter);  /* will return generator, */
+    lua_pushvalue(L, 1);  /* state, */
+    if (iszero) lua_pushinteger(L, 0);  /* and initial value */
+    else lua_pushnil(L);
+  }
+  else {
+    lua_pushvalue(L, 1);  /* argument 'self' to metamethod */
+    lua_call(L, 1, 3);  /* get 3 values from metamethod */
+  }
+  return 3;
+}
+
+
+static int luaB_next (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */
+  if (lua_next(L, 1))
+    return 2;
+  else {
+    lua_pushnil(L);
+    return 1;
+  }
+}
+
+
+static int luaB_pairs (lua_State *L) {
+  return pairsmeta(L, "__pairs", 0, luaB_next);
+}
+
+
+static int ipairsaux (lua_State *L) {
+  int i = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  i++;  /* next value */
+  lua_pushinteger(L, i);
+  lua_rawgeti(L, 1, i);
+  return (lua_isnil(L, -1)) ? 1 : 2;
+}
+
+
+static int luaB_ipairs (lua_State *L) {
+  return pairsmeta(L, "__ipairs", 1, ipairsaux);
+}
+
+
+static int load_aux (lua_State *L, int status) {
+  if (status == LUA_OK)
+    return 1;
+  else {
+    lua_pushnil(L);
+    lua_insert(L, -2);  /* put before error message */
+    return 2;  /* return nil plus error message */
+  }
+}
+
+
+static int luaB_loadfile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  const char *mode = luaL_optstring(L, 2, NULL);
+  int env = !lua_isnone(L, 3);  /* 'env' parameter? */
+  int status = luaL_loadfilex(L, fname, mode);
+  if (status == LUA_OK && env) {  /* 'env' parameter? */
+    lua_pushvalue(L, 3);
+    lua_setupvalue(L, -2, 1);  /* set it as 1st upvalue of loaded chunk */
+  }
+  return load_aux(L, status);
+}
+
+
+/*
+** {======================================================
+** Generic Read function
+** =======================================================
+*/
+
+
+/*
+** reserved slot, above all arguments, to hold a copy of the returned
+** string to avoid it being collected while parsed. 'load' has four
+** optional arguments (chunk, source name, mode, and environment).
+*/
+#define RESERVEDSLOT	5
+
+
+/*
+** Reader for generic `load' function: `lua_load' uses the
+** stack for internal stuff, so the reader cannot change the
+** stack top. Instead, it keeps its resulting string in a
+** reserved slot inside the stack.
+*/
+static const char *generic_reader (lua_State *L, void *ud, size_t *size) {
+  (void)(ud);  /* not used */
+  luaL_checkstack(L, 2, "too many nested functions");
+  lua_pushvalue(L, 1);  /* get function */
+  lua_call(L, 0, 1);  /* call it */
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 1);  /* pop result */
+    *size = 0;
+    return NULL;
+  }
+  else if (!lua_isstring(L, -1))
+    luaL_error(L, "reader function must return a string");
+  lua_replace(L, RESERVEDSLOT);  /* save string in reserved slot */
+  return lua_tolstring(L, RESERVEDSLOT, size);
+}
+
+
+static int luaB_load (lua_State *L) {
+  int status;
+  size_t l;
+  int top = lua_gettop(L);
+  const char *s = lua_tolstring(L, 1, &l);
+  const char *mode = luaL_optstring(L, 3, "bt");
+  if (s != NULL) {  /* loading a string? */
+    const char *chunkname = luaL_optstring(L, 2, s);
+    status = luaL_loadbufferx(L, s, l, chunkname, mode);
+  }
+  else {  /* loading from a reader function */
+    const char *chunkname = luaL_optstring(L, 2, "=(load)");
+    luaL_checktype(L, 1, LUA_TFUNCTION);
+    lua_settop(L, RESERVEDSLOT);  /* create reserved slot */
+    status = lua_load(L, generic_reader, NULL, chunkname, mode);
+  }
+  if (status == LUA_OK && top >= 4) {  /* is there an 'env' argument */
+    lua_pushvalue(L, 4);  /* environment for loaded function */
+    lua_setupvalue(L, -2, 1);  /* set it as 1st upvalue */
+  }
+  return load_aux(L, status);
+}
+
+/* }====================================================== */
+
+
+static int dofilecont (lua_State *L) {
+  return lua_gettop(L) - 1;
+}
+
+
+static int luaB_dofile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  lua_settop(L, 1);
+  if (luaL_loadfile(L, fname) != LUA_OK) lua_error(L);
+  lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);
+  return dofilecont(L);
+}
+
+
+static int luaB_assert (lua_State *L) {
+  if (!lua_toboolean(L, 1))
+    return luaL_error(L, "%s", luaL_optstring(L, 2, "assertion failed!"));
+  return lua_gettop(L);
+}
+
+
+static int luaB_select (lua_State *L) {
+  int n = lua_gettop(L);
+  if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {
+    lua_pushinteger(L, n-1);
+    return 1;
+  }
+  else {
+    int i = luaL_checkint(L, 1);
+    if (i < 0) i = n + i;
+    else if (i > n) i = n;
+    luaL_argcheck(L, 1 <= i, 1, "index out of range");
+    return n - i;
+  }
+}
+
+
+static int finishpcall (lua_State *L, int status) {
+  if (!lua_checkstack(L, 1)) {  /* no space for extra boolean? */
+    lua_settop(L, 0);  /* create space for return values */
+    lua_pushboolean(L, 0);
+    lua_pushstring(L, "stack overflow");
+    return 2;  /* return false, msg */
+  }
+  lua_pushboolean(L, status);  /* first result (status) */
+  lua_replace(L, 1);  /* put first result in first slot */
+  return lua_gettop(L);
+}
+
+
+static int pcallcont (lua_State *L) {
+  int status = lua_getctx(L, NULL);
+  return finishpcall(L, (status == LUA_YIELD));
+}
+
+
+static int luaB_pcall (lua_State *L) {
+  int status;
+  luaL_checkany(L, 1);
+  lua_pushnil(L);
+  lua_insert(L, 1);  /* create space for status result */
+  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, pcallcont);
+  return finishpcall(L, (status == LUA_OK));
+}
+
+
+static int luaB_xpcall (lua_State *L) {
+  int status;
+  int n = lua_gettop(L);
+  luaL_argcheck(L, n >= 2, 2, "value expected");
+  lua_pushvalue(L, 1);  /* exchange function... */
+  lua_copy(L, 2, 1);  /* ...and error handler */
+  lua_replace(L, 2);
+  status = lua_pcallk(L, n - 2, LUA_MULTRET, 1, 0, pcallcont);
+  return finishpcall(L, (status == LUA_OK));
+}
+
+
+static int luaB_tostring (lua_State *L) {
+  luaL_checkany(L, 1);
+  luaL_tolstring(L, 1, NULL);
+  return 1;
+}
+
+
+static const luaL_Reg base_funcs[] = {
+  {"assert", luaB_assert},
+  {"collectgarbage", luaB_collectgarbage},
+  {"dofile", luaB_dofile},
+  {"error", luaB_error},
+  {"getmetatable", luaB_getmetatable},
+  {"ipairs", luaB_ipairs},
+  {"loadfile", luaB_loadfile},
+  {"load", luaB_load},
+#if defined(LUA_COMPAT_LOADSTRING)
+  {"loadstring", luaB_load},
+#endif
+  {"next", luaB_next},
+  {"pairs", luaB_pairs},
+  {"pcall", luaB_pcall},
+  {"print", luaB_print},
+  {"rawequal", luaB_rawequal},
+  {"rawlen", luaB_rawlen},
+  {"rawget", luaB_rawget},
+  {"rawset", luaB_rawset},
+  {"select", luaB_select},
+  {"setmetatable", luaB_setmetatable},
+  {"tonumber", luaB_tonumber},
+  {"tostring", luaB_tostring},
+  {"type", luaB_type},
+  {"xpcall", luaB_xpcall},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_base (lua_State *L) {
+  /* set global _G */
+  lua_pushglobaltable(L);
+  lua_pushglobaltable(L);
+  lua_setfield(L, -2, "_G");
+  /* open lib into global table */
+  luaL_setfuncs(L, base_funcs, 0);
+  lua_pushliteral(L, LUA_VERSION);
+  lua_setfield(L, -2, "_VERSION");  /* set global _VERSION */
+  return 1;
+}
+
diff --git a/dep/lualib/lbitlib.c b/dep/lualib/lbitlib.c
new file mode 100644
index 0000000..7533b85
--- /dev/null
+++ b/dep/lualib/lbitlib.c
@@ -0,0 +1,209 @@
+/*
+** $Id: lbitlib.c,v 1.16 2011/06/20 16:35:23 roberto Exp $
+** Standard library for bitwise operations
+** See Copyright Notice in lua.h
+*/
+
+#define lbitlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/* number of bits to consider in a number */
+#if !defined(LUA_NBITS)
+#define LUA_NBITS	32
+#endif
+
+
+#define ALLONES		(~(((~(lua_Unsigned)0) << (LUA_NBITS - 1)) << 1))
+
+/* macro to trim extra bits */
+#define trim(x)		((x) & ALLONES)
+
+
+/* builds a number with 'n' ones (1 <= n <= LUA_NBITS) */
+#define mask(n)		(~((ALLONES << 1) << ((n) - 1)))
+
+
+typedef lua_Unsigned b_uint;
+
+
+
+static b_uint andaux (lua_State *L) {
+  int i, n = lua_gettop(L);
+  b_uint r = ~(b_uint)0;
+  for (i = 1; i <= n; i++)
+    r &= luaL_checkunsigned(L, i);
+  return trim(r);
+}
+
+
+static int b_and (lua_State *L) {
+  b_uint r = andaux(L);
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static int b_test (lua_State *L) {
+  b_uint r = andaux(L);
+  lua_pushboolean(L, r != 0);
+  return 1;
+}
+
+
+static int b_or (lua_State *L) {
+  int i, n = lua_gettop(L);
+  b_uint r = 0;
+  for (i = 1; i <= n; i++)
+    r |= luaL_checkunsigned(L, i);
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_xor (lua_State *L) {
+  int i, n = lua_gettop(L);
+  b_uint r = 0;
+  for (i = 1; i <= n; i++)
+    r ^= luaL_checkunsigned(L, i);
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_not (lua_State *L) {
+  b_uint r = ~luaL_checkunsigned(L, 1);
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_shift (lua_State *L, b_uint r, int i) {
+  if (i < 0) {  /* shift right? */
+    i = -i;
+    r = trim(r);
+    if (i >= LUA_NBITS) r = 0;
+    else r >>= i;
+  }
+  else {  /* shift left */
+    if (i >= LUA_NBITS) r = 0;
+    else r <<= i;
+    r = trim(r);
+  }
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static int b_lshift (lua_State *L) {
+  return b_shift(L, luaL_checkunsigned(L, 1), luaL_checkint(L, 2));
+}
+
+
+static int b_rshift (lua_State *L) {
+  return b_shift(L, luaL_checkunsigned(L, 1), -luaL_checkint(L, 2));
+}
+
+
+static int b_arshift (lua_State *L) {
+  b_uint r = luaL_checkunsigned(L, 1);
+  int i = luaL_checkint(L, 2);
+  if (i < 0 || !(r & ((b_uint)1 << (LUA_NBITS - 1))))
+    return b_shift(L, r, -i);
+  else {  /* arithmetic shift for 'negative' number */
+    if (i >= LUA_NBITS) r = ALLONES;
+    else
+      r = trim((r >> i) | ~(~(b_uint)0 >> i));  /* add signal bit */
+    lua_pushunsigned(L, r);
+    return 1;
+  }
+}
+
+
+static int b_rot (lua_State *L, int i) {
+  b_uint r = luaL_checkunsigned(L, 1);
+  i &= (LUA_NBITS - 1);  /* i = i % NBITS */
+  r = trim(r);
+  r = (r << i) | (r >> (LUA_NBITS - i));
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_lrot (lua_State *L) {
+  return b_rot(L, luaL_checkint(L, 2));
+}
+
+
+static int b_rrot (lua_State *L) {
+  return b_rot(L, -luaL_checkint(L, 2));
+}
+
+
+/*
+** get field and width arguments for field-manipulation functions,
+** checking whether they are valid
+*/
+static int fieldargs (lua_State *L, int farg, int *width) {
+  int f = luaL_checkint(L, farg);
+  int w = luaL_optint(L, farg + 1, 1);
+  luaL_argcheck(L, 0 <= f, farg, "field cannot be negative");
+  luaL_argcheck(L, 0 < w, farg + 1, "width must be positive");
+  if (f + w > LUA_NBITS)
+    luaL_error(L, "trying to access non-existent bits");
+  *width = w;
+  return f;
+}
+
+
+static int b_extract (lua_State *L) {
+  int w;
+  b_uint r = luaL_checkunsigned(L, 1);
+  int f = fieldargs(L, 2, &w);
+  r = (r >> f) & mask(w);
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static int b_replace (lua_State *L) {
+  int w;
+  b_uint r = luaL_checkunsigned(L, 1);
+  b_uint v = luaL_checkunsigned(L, 2);
+  int f = fieldargs(L, 3, &w);
+  int m = mask(w);
+  v &= m;  /* erase bits outside given width */
+  r = (r & ~(m << f)) | (v << f);
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static const luaL_Reg bitlib[] = {
+  {"arshift", b_arshift},
+  {"band", b_and},
+  {"bnot", b_not},
+  {"bor", b_or},
+  {"bxor", b_xor},
+  {"btest", b_test},
+  {"extract", b_extract},
+  {"lrotate", b_lrot},
+  {"lshift", b_lshift},
+  {"replace", b_replace},
+  {"rrotate", b_rrot},
+  {"rshift", b_rshift},
+  {NULL, NULL}
+};
+
+
+
+LUAMOD_API int luaopen_bit32 (lua_State *L) {
+  luaL_newlib(L, bitlib);
+  return 1;
+}
+
diff --git a/dep/lualib/lcode.c b/dep/lualib/lcode.c
new file mode 100644
index 0000000..614e452
--- /dev/null
+++ b/dep/lualib/lcode.c
@@ -0,0 +1,882 @@
+/*
+** $Id: lcode.c,v 2.60 2011/08/30 16:26:41 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+#define lcode_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lvm.h"
+
+
+#define hasjumps(e)	((e)->t != (e)->f)
+
+
+static int isnumeral(expdesc *e) {
+  return (e->k == VKNUM && e->t == NO_JUMP && e->f == NO_JUMP);
+}
+
+
+void luaK_nil (FuncState *fs, int from, int n) {
+  Instruction *previous;
+  int l = from + n - 1;  /* last register to set nil */
+  if (fs->pc > fs->lasttarget) {  /* no jumps to current position? */
+    previous = &fs->f->code[fs->pc-1];
+    if (GET_OPCODE(*previous) == OP_LOADNIL) {
+      int pfrom = GETARG_A(*previous);
+      int pl = pfrom + GETARG_B(*previous);
+      if ((pfrom <= from && from <= pl + 1) ||
+          (from <= pfrom && pfrom <= l + 1)) {  /* can connect both? */
+        if (pfrom < from) from = pfrom;  /* from = min(from, pfrom) */
+        if (pl > l) l = pl;  /* l = max(l, pl) */
+        SETARG_A(*previous, from);
+        SETARG_B(*previous, l - from);
+        return;
+      }
+    }  /* else go through */
+  }
+  luaK_codeABC(fs, OP_LOADNIL, from, n - 1, 0);  /* else no optimization */
+}
+
+
+int luaK_jump (FuncState *fs) {
+  int jpc = fs->jpc;  /* save list of jumps to here */
+  int j;
+  fs->jpc = NO_JUMP;
+  j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
+  luaK_concat(fs, &j, jpc);  /* keep them on hold */
+  return j;
+}
+
+
+void luaK_ret (FuncState *fs, int first, int nret) {
+  luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);
+}
+
+
+static int condjump (FuncState *fs, OpCode op, int A, int B, int C) {
+  luaK_codeABC(fs, op, A, B, C);
+  return luaK_jump(fs);
+}
+
+
+static void fixjump (FuncState *fs, int pc, int dest) {
+  Instruction *jmp = &fs->f->code[pc];
+  int offset = dest-(pc+1);
+  lua_assert(dest != NO_JUMP);
+  if (abs(offset) > MAXARG_sBx)
+    luaX_syntaxerror(fs->ls, "control structure too long");
+  SETARG_sBx(*jmp, offset);
+}
+
+
+/*
+** returns current `pc' and marks it as a jump target (to avoid wrong
+** optimizations with consecutive instructions not in the same basic block).
+*/
+int luaK_getlabel (FuncState *fs) {
+  fs->lasttarget = fs->pc;
+  return fs->pc;
+}
+
+
+static int getjump (FuncState *fs, int pc) {
+  int offset = GETARG_sBx(fs->f->code[pc]);
+  if (offset == NO_JUMP)  /* point to itself represents end of list */
+    return NO_JUMP;  /* end of list */
+  else
+    return (pc+1)+offset;  /* turn offset into absolute position */
+}
+
+
+static Instruction *getjumpcontrol (FuncState *fs, int pc) {
+  Instruction *pi = &fs->f->code[pc];
+  if (pc >= 1 && testTMode(GET_OPCODE(*(pi-1))))
+    return pi-1;
+  else
+    return pi;
+}
+
+
+/*
+** check whether list has any jump that do not produce a value
+** (or produce an inverted value)
+*/
+static int need_value (FuncState *fs, int list) {
+  for (; list != NO_JUMP; list = getjump(fs, list)) {
+    Instruction i = *getjumpcontrol(fs, list);
+    if (GET_OPCODE(i) != OP_TESTSET) return 1;
+  }
+  return 0;  /* not found */
+}
+
+
+static int patchtestreg (FuncState *fs, int node, int reg) {
+  Instruction *i = getjumpcontrol(fs, node);
+  if (GET_OPCODE(*i) != OP_TESTSET)
+    return 0;  /* cannot patch other instructions */
+  if (reg != NO_REG && reg != GETARG_B(*i))
+    SETARG_A(*i, reg);
+  else  /* no register to put value or register already has the value */
+    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
+
+  return 1;
+}
+
+
+static void removevalues (FuncState *fs, int list) {
+  for (; list != NO_JUMP; list = getjump(fs, list))
+      patchtestreg(fs, list, NO_REG);
+}
+
+
+static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
+                          int dtarget) {
+  while (list != NO_JUMP) {
+    int next = getjump(fs, list);
+    if (patchtestreg(fs, list, reg))
+      fixjump(fs, list, vtarget);
+    else
+      fixjump(fs, list, dtarget);  /* jump to default target */
+    list = next;
+  }
+}
+
+
+static void dischargejpc (FuncState *fs) {
+  patchlistaux(fs, fs->jpc, fs->pc, NO_REG, fs->pc);
+  fs->jpc = NO_JUMP;
+}
+
+
+void luaK_patchlist (FuncState *fs, int list, int target) {
+  if (target == fs->pc)
+    luaK_patchtohere(fs, list);
+  else {
+    lua_assert(target < fs->pc);
+    patchlistaux(fs, list, target, NO_REG, target);
+  }
+}
+
+
+LUAI_FUNC void luaK_patchclose (FuncState *fs, int list, int level) {
+  level++;  /* argument is +1 to reserve 0 as non-op */
+  while (list != NO_JUMP) {
+    int next = getjump(fs, list);
+    lua_assert(GET_OPCODE(fs->f->code[list]) == OP_JMP &&
+                (GETARG_A(fs->f->code[list]) == 0 ||
+                 GETARG_A(fs->f->code[list]) >= level));
+    SETARG_A(fs->f->code[list], level);
+    list = next;
+  }
+}
+
+
+void luaK_patchtohere (FuncState *fs, int list) {
+  luaK_getlabel(fs);
+  luaK_concat(fs, &fs->jpc, list);
+}
+
+
+void luaK_concat (FuncState *fs, int *l1, int l2) {
+  if (l2 == NO_JUMP) return;
+  else if (*l1 == NO_JUMP)
+    *l1 = l2;
+  else {
+    int list = *l1;
+    int next;
+    while ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */
+      list = next;
+    fixjump(fs, list, l2);
+  }
+}
+
+
+static int luaK_code (FuncState *fs, Instruction i) {
+  Proto *f = fs->f;
+  dischargejpc(fs);  /* `pc' will change */
+  /* put new instruction in code array */
+  luaM_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,
+                  MAX_INT, "opcodes");
+  f->code[fs->pc] = i;
+  /* save corresponding line information */
+  luaM_growvector(fs->ls->L, f->lineinfo, fs->pc, f->sizelineinfo, int,
+                  MAX_INT, "opcodes");
+  f->lineinfo[fs->pc] = fs->ls->lastline;
+  return fs->pc++;
+}
+
+
+int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
+  lua_assert(getOpMode(o) == iABC);
+  lua_assert(getBMode(o) != OpArgN || b == 0);
+  lua_assert(getCMode(o) != OpArgN || c == 0);
+  lua_assert(a <= MAXARG_A && b <= MAXARG_B && c <= MAXARG_C);
+  return luaK_code(fs, CREATE_ABC(o, a, b, c));
+}
+
+
+int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
+  lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
+  lua_assert(getCMode(o) == OpArgN);
+  lua_assert(a <= MAXARG_A && bc <= MAXARG_Bx);
+  return luaK_code(fs, CREATE_ABx(o, a, bc));
+}
+
+
+static int codeextraarg (FuncState *fs, int a) {
+  lua_assert(a <= MAXARG_Ax);
+  return luaK_code(fs, CREATE_Ax(OP_EXTRAARG, a));
+}
+
+
+int luaK_codek (FuncState *fs, int reg, int k) {
+  if (k <= MAXARG_Bx)
+    return luaK_codeABx(fs, OP_LOADK, reg, k);
+  else {
+    int p = luaK_codeABx(fs, OP_LOADKX, reg, 0);
+    codeextraarg(fs, k);
+    return p;
+  }
+}
+
+
+void luaK_checkstack (FuncState *fs, int n) {
+  int newstack = fs->freereg + n;
+  if (newstack > fs->f->maxstacksize) {
+    if (newstack >= MAXSTACK)
+      luaX_syntaxerror(fs->ls, "function or expression too complex");
+    fs->f->maxstacksize = cast_byte(newstack);
+  }
+}
+
+
+void luaK_reserveregs (FuncState *fs, int n) {
+  luaK_checkstack(fs, n);
+  fs->freereg += n;
+}
+
+
+static void freereg (FuncState *fs, int reg) {
+  if (!ISK(reg) && reg >= fs->nactvar) {
+    fs->freereg--;
+    lua_assert(reg == fs->freereg);
+  }
+}
+
+
+static void freeexp (FuncState *fs, expdesc *e) {
+  if (e->k == VNONRELOC)
+    freereg(fs, e->u.info);
+}
+
+
+static int addk (FuncState *fs, TValue *key, TValue *v) {
+  lua_State *L = fs->ls->L;
+  TValue *idx = luaH_set(L, fs->h, key);
+  Proto *f = fs->f;
+  int k, oldsize;
+  if (ttisnumber(idx)) {
+    lua_Number n = nvalue(idx);
+    lua_number2int(k, n);
+    if (luaV_rawequalobj(&f->k[k], v))
+      return k;
+    /* else may be a collision (e.g., between 0.0 and "\0\0\0\0\0\0\0\0");
+       go through and create a new entry for this value */
+  }
+  /* constant not found; create a new entry */
+  oldsize = f->sizek;
+  k = fs->nk;
+  /* numerical value does not need GC barrier;
+     table has no metatable, so it does not need to invalidate cache */
+  setnvalue(idx, cast_num(k));
+  luaM_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, "constants");
+  while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);
+  setobj(L, &f->k[k], v);
+  fs->nk++;
+  luaC_barrier(L, f, v);
+  return k;
+}
+
+
+int luaK_stringK (FuncState *fs, TString *s) {
+  TValue o;
+  setsvalue(fs->ls->L, &o, s);
+  return addk(fs, &o, &o);
+}
+
+
+int luaK_numberK (FuncState *fs, lua_Number r) {
+  int n;
+  lua_State *L = fs->ls->L;
+  TValue o;
+  setnvalue(&o, r);
+  if (r == 0 || luai_numisnan(NULL, r)) {  /* handle -0 and NaN */
+    /* use raw representation as key to avoid numeric problems */
+    setsvalue(L, L->top, luaS_newlstr(L, (char *)&r, sizeof(r)));
+     incr_top(L);
+     n = addk(fs, L->top - 1, &o);
+     L->top--;
+  }
+  else
+    n = addk(fs, &o, &o);  /* regular case */
+  return n;
+}
+
+
+static int boolK (FuncState *fs, int b) {
+  TValue o;
+  setbvalue(&o, b);
+  return addk(fs, &o, &o);
+}
+
+
+static int nilK (FuncState *fs) {
+  TValue k, v;
+  setnilvalue(&v);
+  /* cannot use nil as key; instead use table itself to represent nil */
+  sethvalue(fs->ls->L, &k, fs->h);
+  return addk(fs, &k, &v);
+}
+
+
+void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {
+  if (e->k == VCALL) {  /* expression is an open function call? */
+    SETARG_C(getcode(fs, e), nresults+1);
+  }
+  else if (e->k == VVARARG) {
+    SETARG_B(getcode(fs, e), nresults+1);
+    SETARG_A(getcode(fs, e), fs->freereg);
+    luaK_reserveregs(fs, 1);
+  }
+}
+
+
+void luaK_setoneret (FuncState *fs, expdesc *e) {
+  if (e->k == VCALL) {  /* expression is an open function call? */
+    e->k = VNONRELOC;
+    e->u.info = GETARG_A(getcode(fs, e));
+  }
+  else if (e->k == VVARARG) {
+    SETARG_B(getcode(fs, e), 2);
+    e->k = VRELOCABLE;  /* can relocate its simple result */
+  }
+}
+
+
+void luaK_dischargevars (FuncState *fs, expdesc *e) {
+  switch (e->k) {
+    case VLOCAL: {
+      e->k = VNONRELOC;
+      break;
+    }
+    case VUPVAL: {
+      e->u.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->u.info, 0);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VINDEXED: {
+      OpCode op = OP_GETTABUP;  /* assume 't' is in an upvalue */
+      freereg(fs, e->u.ind.idx);
+      if (e->u.ind.vt == VLOCAL) {  /* 't' is in a register? */
+        freereg(fs, e->u.ind.t);
+        op = OP_GETTABLE;
+      }
+      e->u.info = luaK_codeABC(fs, op, 0, e->u.ind.t, e->u.ind.idx);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VVARARG:
+    case VCALL: {
+      luaK_setoneret(fs, e);
+      break;
+    }
+    default: break;  /* there is one value available (somewhere) */
+  }
+}
+
+
+static int code_label (FuncState *fs, int A, int b, int jump) {
+  luaK_getlabel(fs);  /* those instructions may be jump targets */
+  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
+}
+
+
+static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: {
+      luaK_nil(fs, reg, 1);
+      break;
+    }
+    case VFALSE:  case VTRUE: {
+      luaK_codeABC(fs, OP_LOADBOOL, reg, e->k == VTRUE, 0);
+      break;
+    }
+    case VK: {
+      luaK_codek(fs, reg, e->u.info);
+      break;
+    }
+    case VKNUM: {
+      luaK_codek(fs, reg, luaK_numberK(fs, e->u.nval));
+      break;
+    }
+    case VRELOCABLE: {
+      Instruction *pc = &getcode(fs, e);
+      SETARG_A(*pc, reg);
+      break;
+    }
+    case VNONRELOC: {
+      if (reg != e->u.info)
+        luaK_codeABC(fs, OP_MOVE, reg, e->u.info, 0);
+      break;
+    }
+    default: {
+      lua_assert(e->k == VVOID || e->k == VJMP);
+      return;  /* nothing to do... */
+    }
+  }
+  e->u.info = reg;
+  e->k = VNONRELOC;
+}
+
+
+static void discharge2anyreg (FuncState *fs, expdesc *e) {
+  if (e->k != VNONRELOC) {
+    luaK_reserveregs(fs, 1);
+    discharge2reg(fs, e, fs->freereg-1);
+  }
+}
+
+
+static void exp2reg (FuncState *fs, expdesc *e, int reg) {
+  discharge2reg(fs, e, reg);
+  if (e->k == VJMP)
+    luaK_concat(fs, &e->t, e->u.info);  /* put this jump in `t' list */
+  if (hasjumps(e)) {
+    int final;  /* position after whole expression */
+    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
+    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
+    if (need_value(fs, e->t) || need_value(fs, e->f)) {
+      int fj = (e->k == VJMP) ? NO_JUMP : luaK_jump(fs);
+      p_f = code_label(fs, reg, 0, 1);
+      p_t = code_label(fs, reg, 1, 0);
+      luaK_patchtohere(fs, fj);
+    }
+    final = luaK_getlabel(fs);
+    patchlistaux(fs, e->f, final, reg, p_f);
+    patchlistaux(fs, e->t, final, reg, p_t);
+  }
+  e->f = e->t = NO_JUMP;
+  e->u.info = reg;
+  e->k = VNONRELOC;
+}
+
+
+void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  freeexp(fs, e);
+  luaK_reserveregs(fs, 1);
+  exp2reg(fs, e, fs->freereg - 1);
+}
+
+
+int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  if (e->k == VNONRELOC) {
+    if (!hasjumps(e)) return e->u.info;  /* exp is already in a register */
+    if (e->u.info >= fs->nactvar) {  /* reg. is not a local? */
+      exp2reg(fs, e, e->u.info);  /* put value on it */
+      return e->u.info;
+    }
+  }
+  luaK_exp2nextreg(fs, e);  /* default */
+  return e->u.info;
+}
+
+
+void luaK_exp2anyregup (FuncState *fs, expdesc *e) {
+  if (e->k != VUPVAL || hasjumps(e))
+    luaK_exp2anyreg(fs, e);
+}
+
+
+void luaK_exp2val (FuncState *fs, expdesc *e) {
+  if (hasjumps(e))
+    luaK_exp2anyreg(fs, e);
+  else
+    luaK_dischargevars(fs, e);
+}
+
+
+int luaK_exp2RK (FuncState *fs, expdesc *e) {
+  luaK_exp2val(fs, e);
+  switch (e->k) {
+    case VTRUE:
+    case VFALSE:
+    case VNIL: {
+      if (fs->nk <= MAXINDEXRK) {  /* constant fits in RK operand? */
+        e->u.info = (e->k == VNIL) ? nilK(fs) : boolK(fs, (e->k == VTRUE));
+        e->k = VK;
+        return RKASK(e->u.info);
+      }
+      else break;
+    }
+    case VKNUM: {
+      e->u.info = luaK_numberK(fs, e->u.nval);
+      e->k = VK;
+      /* go through */
+    }
+    case VK: {
+      if (e->u.info <= MAXINDEXRK)  /* constant fits in argC? */
+        return RKASK(e->u.info);
+      else break;
+    }
+    default: break;
+  }
+  /* not a constant in the right range: put it in a register */
+  return luaK_exp2anyreg(fs, e);
+}
+
+
+void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
+  switch (var->k) {
+    case VLOCAL: {
+      freeexp(fs, ex);
+      exp2reg(fs, ex, var->u.info);
+      return;
+    }
+    case VUPVAL: {
+      int e = luaK_exp2anyreg(fs, ex);
+      luaK_codeABC(fs, OP_SETUPVAL, e, var->u.info, 0);
+      break;
+    }
+    case VINDEXED: {
+      OpCode op = (var->u.ind.vt == VLOCAL) ? OP_SETTABLE : OP_SETTABUP;
+      int e = luaK_exp2RK(fs, ex);
+      luaK_codeABC(fs, op, var->u.ind.t, var->u.ind.idx, e);
+      break;
+    }
+    default: {
+      lua_assert(0);  /* invalid var kind to store */
+      break;
+    }
+  }
+  freeexp(fs, ex);
+}
+
+
+void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
+  int ereg;
+  luaK_exp2anyreg(fs, e);
+  ereg = e->u.info;  /* register where 'e' was placed */
+  freeexp(fs, e);
+  e->u.info = fs->freereg;  /* base register for op_self */
+  e->k = VNONRELOC;
+  luaK_reserveregs(fs, 2);  /* function and 'self' produced by op_self */
+  luaK_codeABC(fs, OP_SELF, e->u.info, ereg, luaK_exp2RK(fs, key));
+  freeexp(fs, key);
+}
+
+
+static void invertjump (FuncState *fs, expdesc *e) {
+  Instruction *pc = getjumpcontrol(fs, e->u.info);
+  lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&
+                                           GET_OPCODE(*pc) != OP_TEST);
+  SETARG_A(*pc, !(GETARG_A(*pc)));
+}
+
+
+static int jumponcond (FuncState *fs, expdesc *e, int cond) {
+  if (e->k == VRELOCABLE) {
+    Instruction ie = getcode(fs, e);
+    if (GET_OPCODE(ie) == OP_NOT) {
+      fs->pc--;  /* remove previous OP_NOT */
+      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
+    }
+    /* else go through */
+  }
+  discharge2anyreg(fs, e);
+  freeexp(fs, e);
+  return condjump(fs, OP_TESTSET, NO_REG, e->u.info, cond);
+}
+
+
+void luaK_goiftrue (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VJMP: {
+      invertjump(fs, e);
+      pc = e->u.info;
+      break;
+    }
+    case VK: case VKNUM: case VTRUE: {
+      pc = NO_JUMP;  /* always true; do nothing */
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 0);
+      break;
+    }
+  }
+  luaK_concat(fs, &e->f, pc);  /* insert last jump in `f' list */
+  luaK_patchtohere(fs, e->t);
+  e->t = NO_JUMP;
+}
+
+
+void luaK_goiffalse (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VJMP: {
+      pc = e->u.info;
+      break;
+    }
+    case VNIL: case VFALSE: {
+      pc = NO_JUMP;  /* always false; do nothing */
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 1);
+      break;
+    }
+  }
+  luaK_concat(fs, &e->t, pc);  /* insert last jump in `t' list */
+  luaK_patchtohere(fs, e->f);
+  e->f = NO_JUMP;
+}
+
+
+static void codenot (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: case VFALSE: {
+      e->k = VTRUE;
+      break;
+    }
+    case VK: case VKNUM: case VTRUE: {
+      e->k = VFALSE;
+      break;
+    }
+    case VJMP: {
+      invertjump(fs, e);
+      break;
+    }
+    case VRELOCABLE:
+    case VNONRELOC: {
+      discharge2anyreg(fs, e);
+      freeexp(fs, e);
+      e->u.info = luaK_codeABC(fs, OP_NOT, 0, e->u.info, 0);
+      e->k = VRELOCABLE;
+      break;
+    }
+    default: {
+      lua_assert(0);  /* cannot happen */
+      break;
+    }
+  }
+  /* interchange true and false lists */
+  { int temp = e->f; e->f = e->t; e->t = temp; }
+  removevalues(fs, e->f);
+  removevalues(fs, e->t);
+}
+
+
+void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
+  lua_assert(!hasjumps(t));
+  t->u.ind.t = t->u.info;
+  t->u.ind.idx = luaK_exp2RK(fs, k);
+  t->u.ind.vt = (t->k == VUPVAL) ? VUPVAL
+                                 : check_exp(vkisinreg(t->k), VLOCAL);
+  t->k = VINDEXED;
+}
+
+
+static int constfolding (OpCode op, expdesc *e1, expdesc *e2) {
+  lua_Number r;
+  if (!isnumeral(e1) || !isnumeral(e2)) return 0;
+  if ((op == OP_DIV || op == OP_MOD) && e2->u.nval == 0)
+    return 0;  /* do not attempt to divide by 0 */
+  r = luaO_arith(op - OP_ADD + LUA_OPADD, e1->u.nval, e2->u.nval);
+  e1->u.nval = r;
+  return 1;
+}
+
+
+static void codearith (FuncState *fs, OpCode op,
+                       expdesc *e1, expdesc *e2, int line) {
+  if (constfolding(op, e1, e2))
+    return;
+  else {
+    int o2 = (op != OP_UNM && op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;
+    int o1 = luaK_exp2RK(fs, e1);
+    if (o1 > o2) {
+      freeexp(fs, e1);
+      freeexp(fs, e2);
+    }
+    else {
+      freeexp(fs, e2);
+      freeexp(fs, e1);
+    }
+    e1->u.info = luaK_codeABC(fs, op, 0, o1, o2);
+    e1->k = VRELOCABLE;
+    luaK_fixline(fs, line);
+  }
+}
+
+
+static void codecomp (FuncState *fs, OpCode op, int cond, expdesc *e1,
+                                                          expdesc *e2) {
+  int o1 = luaK_exp2RK(fs, e1);
+  int o2 = luaK_exp2RK(fs, e2);
+  freeexp(fs, e2);
+  freeexp(fs, e1);
+  if (cond == 0 && op != OP_EQ) {
+    int temp;  /* exchange args to replace by `<' or `<=' */
+    temp = o1; o1 = o2; o2 = temp;  /* o1 <==> o2 */
+    cond = 1;
+  }
+  e1->u.info = condjump(fs, op, cond, o1, o2);
+  e1->k = VJMP;
+}
+
+
+void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e, int line) {
+  expdesc e2;
+  e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;
+  switch (op) {
+    case OPR_MINUS: {
+      if (isnumeral(e))  /* minus constant? */
+        e->u.nval = luai_numunm(NULL, e->u.nval);  /* fold it */
+      else {
+        luaK_exp2anyreg(fs, e);
+        codearith(fs, OP_UNM, e, &e2, line);
+      }
+      break;
+    }
+    case OPR_NOT: codenot(fs, e); break;
+    case OPR_LEN: {
+      luaK_exp2anyreg(fs, e);  /* cannot operate on constants */
+      codearith(fs, OP_LEN, e, &e2, line);
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
+  switch (op) {
+    case OPR_AND: {
+      luaK_goiftrue(fs, v);
+      break;
+    }
+    case OPR_OR: {
+      luaK_goiffalse(fs, v);
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */
+      break;
+    }
+    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:
+    case OPR_MOD: case OPR_POW: {
+      if (!isnumeral(v)) luaK_exp2RK(fs, v);
+      break;
+    }
+    default: {
+      luaK_exp2RK(fs, v);
+      break;
+    }
+  }
+}
+
+
+void luaK_posfix (FuncState *fs, BinOpr op,
+                  expdesc *e1, expdesc *e2, int line) {
+  switch (op) {
+    case OPR_AND: {
+      lua_assert(e1->t == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &e2->f, e1->f);
+      *e1 = *e2;
+      break;
+    }
+    case OPR_OR: {
+      lua_assert(e1->f == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &e2->t, e1->t);
+      *e1 = *e2;
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2val(fs, e2);
+      if (e2->k == VRELOCABLE && GET_OPCODE(getcode(fs, e2)) == OP_CONCAT) {
+        lua_assert(e1->u.info == GETARG_B(getcode(fs, e2))-1);
+        freeexp(fs, e1);
+        SETARG_B(getcode(fs, e2), e1->u.info);
+        e1->k = VRELOCABLE; e1->u.info = e2->u.info;
+      }
+      else {
+        luaK_exp2nextreg(fs, e2);  /* operand must be on the 'stack' */
+        codearith(fs, OP_CONCAT, e1, e2, line);
+      }
+      break;
+    }
+    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:
+    case OPR_MOD: case OPR_POW: {
+      codearith(fs, cast(OpCode, op - OPR_ADD + OP_ADD), e1, e2, line);
+      break;
+    }
+    case OPR_EQ: case OPR_LT: case OPR_LE: {
+      codecomp(fs, cast(OpCode, op - OPR_EQ + OP_EQ), 1, e1, e2);
+      break;
+    }
+    case OPR_NE: case OPR_GT: case OPR_GE: {
+      codecomp(fs, cast(OpCode, op - OPR_NE + OP_EQ), 0, e1, e2);
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+void luaK_fixline (FuncState *fs, int line) {
+  fs->f->lineinfo[fs->pc - 1] = line;
+}
+
+
+void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
+  int c =  (nelems - 1)/LFIELDS_PER_FLUSH + 1;
+  int b = (tostore == LUA_MULTRET) ? 0 : tostore;
+  lua_assert(tostore != 0);
+  if (c <= MAXARG_C)
+    luaK_codeABC(fs, OP_SETLIST, base, b, c);
+  else if (c <= MAXARG_Ax) {
+    luaK_codeABC(fs, OP_SETLIST, base, b, 0);
+    codeextraarg(fs, c);
+  }
+  else
+    luaX_syntaxerror(fs->ls, "constructor too long");
+  fs->freereg = base + 1;  /* free registers with list values */
+}
+
diff --git a/dep/lualib/lcode.h b/dep/lualib/lcode.h
new file mode 100644
index 0000000..5a1fa9f
--- /dev/null
+++ b/dep/lualib/lcode.h
@@ -0,0 +1,83 @@
+/*
+** $Id: lcode.h,v 1.58 2011/08/30 16:26:41 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lcode_h
+#define lcode_h
+
+#include "llex.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+
+
+/*
+** Marks the end of a patch list. It is an invalid value both as an absolute
+** address, and as a list link (would link an element to itself).
+*/
+#define NO_JUMP (-1)
+
+
+/*
+** grep "ORDER OPR" if you change these enums  (ORDER OP)
+*/
+typedef enum BinOpr {
+  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,
+  OPR_CONCAT,
+  OPR_EQ, OPR_LT, OPR_LE,
+  OPR_NE, OPR_GT, OPR_GE,
+  OPR_AND, OPR_OR,
+  OPR_NOBINOPR
+} BinOpr;
+
+
+typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;
+
+
+#define getcode(fs,e)	((fs)->f->code[(e)->u.info])
+
+#define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)
+
+#define luaK_setmultret(fs,e)	luaK_setreturns(fs, e, LUA_MULTRET)
+
+#define luaK_jumpto(fs,t)	luaK_patchlist(fs, luaK_jump(fs), t)
+
+LUAI_FUNC int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);
+LUAI_FUNC int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);
+LUAI_FUNC int luaK_codek (FuncState *fs, int reg, int k);
+LUAI_FUNC void luaK_fixline (FuncState *fs, int line);
+LUAI_FUNC void luaK_nil (FuncState *fs, int from, int n);
+LUAI_FUNC void luaK_reserveregs (FuncState *fs, int n);
+LUAI_FUNC void luaK_checkstack (FuncState *fs, int n);
+LUAI_FUNC int luaK_stringK (FuncState *fs, TString *s);
+LUAI_FUNC int luaK_numberK (FuncState *fs, lua_Number r);
+LUAI_FUNC void luaK_dischargevars (FuncState *fs, expdesc *e);
+LUAI_FUNC int luaK_exp2anyreg (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_exp2anyregup (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_exp2nextreg (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_exp2val (FuncState *fs, expdesc *e);
+LUAI_FUNC int luaK_exp2RK (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_self (FuncState *fs, expdesc *e, expdesc *key);
+LUAI_FUNC void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);
+LUAI_FUNC void luaK_goiftrue (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_goiffalse (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);
+LUAI_FUNC void luaK_setreturns (FuncState *fs, expdesc *e, int nresults);
+LUAI_FUNC void luaK_setoneret (FuncState *fs, expdesc *e);
+LUAI_FUNC int luaK_jump (FuncState *fs);
+LUAI_FUNC void luaK_ret (FuncState *fs, int first, int nret);
+LUAI_FUNC void luaK_patchlist (FuncState *fs, int list, int target);
+LUAI_FUNC void luaK_patchtohere (FuncState *fs, int list);
+LUAI_FUNC void luaK_patchclose (FuncState *fs, int list, int level);
+LUAI_FUNC void luaK_concat (FuncState *fs, int *l1, int l2);
+LUAI_FUNC int luaK_getlabel (FuncState *fs);
+LUAI_FUNC void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v, int line);
+LUAI_FUNC void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);
+LUAI_FUNC void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1,
+                            expdesc *v2, int line);
+LUAI_FUNC void luaK_setlist (FuncState *fs, int base, int nelems, int tostore);
+
+
+#endif
diff --git a/dep/lualib/lcorolib.c b/dep/lualib/lcorolib.c
new file mode 100644
index 0000000..c7932d9
--- /dev/null
+++ b/dep/lualib/lcorolib.c
@@ -0,0 +1,155 @@
+/*
+** $Id: lcorolib.c,v 1.4 2012/04/27 18:59:04 roberto Exp $
+** Coroutine Library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+
+#define lcorolib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+static int auxresume (lua_State *L, lua_State *co, int narg) {
+  int status;
+  if (!lua_checkstack(co, narg)) {
+    lua_pushliteral(L, "too many arguments to resume");
+    return -1;  /* error flag */
+  }
+  if (lua_status(co) == LUA_OK && lua_gettop(co) == 0) {
+    lua_pushliteral(L, "cannot resume dead coroutine");
+    return -1;  /* error flag */
+  }
+  lua_xmove(L, co, narg);
+  status = lua_resume(co, L, narg);
+  if (status == LUA_OK || status == LUA_YIELD) {
+    int nres = lua_gettop(co);
+    if (!lua_checkstack(L, nres + 1)) {
+      lua_pop(co, nres);  /* remove results anyway */
+      lua_pushliteral(L, "too many results to resume");
+      return -1;  /* error flag */
+    }
+    lua_xmove(co, L, nres);  /* move yielded values */
+    return nres;
+  }
+  else {
+    lua_xmove(co, L, 1);  /* move error message */
+    return -1;  /* error flag */
+  }
+}
+
+
+static int luaB_coresume (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  int r;
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  r = auxresume(L, co, lua_gettop(L) - 1);
+  if (r < 0) {
+    lua_pushboolean(L, 0);
+    lua_insert(L, -2);
+    return 2;  /* return false + error message */
+  }
+  else {
+    lua_pushboolean(L, 1);
+    lua_insert(L, -(r + 1));
+    return r + 1;  /* return true + `resume' returns */
+  }
+}
+
+
+static int luaB_auxwrap (lua_State *L) {
+  lua_State *co = lua_tothread(L, lua_upvalueindex(1));
+  int r = auxresume(L, co, lua_gettop(L));
+  if (r < 0) {
+    if (lua_isstring(L, -1)) {  /* error object is a string? */
+      luaL_where(L, 1);  /* add extra info */
+      lua_insert(L, -2);
+      lua_concat(L, 2);
+    }
+    lua_error(L);  /* propagate error */
+  }
+  return r;
+}
+
+
+static int luaB_cocreate (lua_State *L) {
+  lua_State *NL;
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  NL = lua_newthread(L);
+  lua_pushvalue(L, 1);  /* move function to top */
+  lua_xmove(L, NL, 1);  /* move function from L to NL */
+  return 1;
+}
+
+
+static int luaB_cowrap (lua_State *L) {
+  luaB_cocreate(L);
+  lua_pushcclosure(L, luaB_auxwrap, 1);
+  return 1;
+}
+
+
+static int luaB_yield (lua_State *L) {
+  return lua_yield(L, lua_gettop(L));
+}
+
+
+static int luaB_costatus (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  if (L == co) lua_pushliteral(L, "running");
+  else {
+    switch (lua_status(co)) {
+      case LUA_YIELD:
+        lua_pushliteral(L, "suspended");
+        break;
+      case LUA_OK: {
+        lua_Debug ar;
+        if (lua_getstack(co, 0, &ar) > 0)  /* does it have frames? */
+          lua_pushliteral(L, "normal");  /* it is running */
+        else if (lua_gettop(co) == 0)
+            lua_pushliteral(L, "dead");
+        else
+          lua_pushliteral(L, "suspended");  /* initial state */
+        break;
+      }
+      default:  /* some error occurred */
+        lua_pushliteral(L, "dead");
+        break;
+    }
+  }
+  return 1;
+}
+
+
+static int luaB_corunning (lua_State *L) {
+  int ismain = lua_pushthread(L);
+  lua_pushboolean(L, ismain);
+  return 2;
+}
+
+
+static const luaL_Reg co_funcs[] = {
+  {"create", luaB_cocreate},
+  {"resume", luaB_coresume},
+  {"running", luaB_corunning},
+  {"status", luaB_costatus},
+  {"wrap", luaB_cowrap},
+  {"yield", luaB_yield},
+  {NULL, NULL}
+};
+
+
+
+LUAMOD_API int luaopen_coroutine (lua_State *L) {
+  luaL_newlib(L, co_funcs);
+  return 1;
+}
+
diff --git a/dep/lualib/lctype.c b/dep/lualib/lctype.c
new file mode 100644
index 0000000..55e433a
--- /dev/null
+++ b/dep/lualib/lctype.c
@@ -0,0 +1,52 @@
+/*
+** $Id: lctype.c,v 1.11 2011/10/03 16:19:23 roberto Exp $
+** 'ctype' functions for Lua
+** See Copyright Notice in lua.h
+*/
+
+#define lctype_c
+#define LUA_CORE
+
+#include "lctype.h"
+
+#if !LUA_USE_CTYPE	/* { */
+
+#include <limits.h>
+
+LUAI_DDEF const lu_byte luai_ctype_[UCHAR_MAX + 2] = {
+  0x00,  /* EOZ */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 0. */
+  0x00,  0x08,  0x08,  0x08,  0x08,  0x08,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 1. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x0c,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,	/* 2. */
+  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,
+  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,	/* 3. */
+  0x16,  0x16,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,
+  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,	/* 4. */
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,	/* 5. */
+  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x05,
+  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,	/* 6. */
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,	/* 7. */
+  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 8. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 9. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* a. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* b. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* c. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* d. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* e. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* f. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+};
+
+#endif			/* } */
diff --git a/dep/lualib/lctype.h b/dep/lualib/lctype.h
new file mode 100644
index 0000000..99c7d12
--- /dev/null
+++ b/dep/lualib/lctype.h
@@ -0,0 +1,95 @@
+/*
+** $Id: lctype.h,v 1.12 2011/07/15 12:50:29 roberto Exp $
+** 'ctype' functions for Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lctype_h
+#define lctype_h
+
+#include "lua.h"
+
+
+/*
+** WARNING: the functions defined here do not necessarily correspond
+** to the similar functions in the standard C ctype.h. They are
+** optimized for the specific needs of Lua
+*/
+
+#if !defined(LUA_USE_CTYPE)
+
+#if 'A' == 65 && '0' == 48
+/* ASCII case: can use its own tables; faster and fixed */
+#define LUA_USE_CTYPE	0
+#else
+/* must use standard C ctype */
+#define LUA_USE_CTYPE	1
+#endif
+
+#endif
+
+
+#if !LUA_USE_CTYPE	/* { */
+
+#include <limits.h>
+
+#include "llimits.h"
+
+
+#define ALPHABIT	0
+#define DIGITBIT	1
+#define PRINTBIT	2
+#define SPACEBIT	3
+#define XDIGITBIT	4
+
+
+#define MASK(B)		(1 << (B))
+
+
+/*
+** add 1 to char to allow index -1 (EOZ)
+*/
+#define testprop(c,p)	(luai_ctype_[(c)+1] & (p))
+
+/*
+** 'lalpha' (Lua alphabetic) and 'lalnum' (Lua alphanumeric) both include '_'
+*/
+#define lislalpha(c)	testprop(c, MASK(ALPHABIT))
+#define lislalnum(c)	testprop(c, (MASK(ALPHABIT) | MASK(DIGITBIT)))
+#define lisdigit(c)	testprop(c, MASK(DIGITBIT))
+#define lisspace(c)	testprop(c, MASK(SPACEBIT))
+#define lisprint(c)	testprop(c, MASK(PRINTBIT))
+#define lisxdigit(c)	testprop(c, MASK(XDIGITBIT))
+
+/*
+** this 'ltolower' only works for alphabetic characters
+*/
+#define ltolower(c)	((c) | ('A' ^ 'a'))
+
+
+/* two more entries for 0 and -1 (EOZ) */
+LUAI_DDEC const lu_byte luai_ctype_[UCHAR_MAX + 2];
+
+
+#else			/* }{ */
+
+/*
+** use standard C ctypes
+*/
+
+#include <ctype.h>
+
+
+#define lislalpha(c)	(isalpha(c) || (c) == '_')
+#define lislalnum(c)	(isalnum(c) || (c) == '_')
+#define lisdigit(c)	(isdigit(c))
+#define lisspace(c)	(isspace(c))
+#define lisprint(c)	(isprint(c))
+#define lisxdigit(c)	(isxdigit(c))
+
+#define ltolower(c)	(tolower(c))
+
+#endif			/* } */
+
+#endif
+
diff --git a/dep/lualib/ldblib.c b/dep/lualib/ldblib.c
new file mode 100644
index 0000000..c022694
--- /dev/null
+++ b/dep/lualib/ldblib.c
@@ -0,0 +1,398 @@
+/*
+** $Id: ldblib.c,v 1.132 2012/01/19 20:14:44 roberto Exp $
+** Interface from Lua to its debug API
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ldblib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#define HOOKKEY		"_HKEY"
+
+
+
+static int db_getregistry (lua_State *L) {
+  lua_pushvalue(L, LUA_REGISTRYINDEX);
+  return 1;
+}
+
+
+static int db_getmetatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_getmetatable(L, 1)) {
+    lua_pushnil(L);  /* no metatable */
+  }
+  return 1;
+}
+
+
+static int db_setmetatable (lua_State *L) {
+  int t = lua_type(L, 2);
+  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
+                    "nil or table expected");
+  lua_settop(L, 2);
+  lua_setmetatable(L, 1);
+  return 1;  /* return 1st argument */
+}
+
+
+static int db_getuservalue (lua_State *L) {
+  if (lua_type(L, 1) != LUA_TUSERDATA)
+    lua_pushnil(L);
+  else
+    lua_getuservalue(L, 1);
+  return 1;
+}
+
+
+static int db_setuservalue (lua_State *L) {
+  if (lua_type(L, 1) == LUA_TLIGHTUSERDATA)
+    luaL_argerror(L, 1, "full userdata expected, got light userdata");
+  luaL_checktype(L, 1, LUA_TUSERDATA);
+  if (!lua_isnoneornil(L, 2))
+    luaL_checktype(L, 2, LUA_TTABLE);
+  lua_settop(L, 2);
+  lua_setuservalue(L, 1);
+  return 1;
+}
+
+
+static void settabss (lua_State *L, const char *i, const char *v) {
+  lua_pushstring(L, v);
+  lua_setfield(L, -2, i);
+}
+
+
+static void settabsi (lua_State *L, const char *i, int v) {
+  lua_pushinteger(L, v);
+  lua_setfield(L, -2, i);
+}
+
+
+static void settabsb (lua_State *L, const char *i, int v) {
+  lua_pushboolean(L, v);
+  lua_setfield(L, -2, i);
+}
+
+
+static lua_State *getthread (lua_State *L, int *arg) {
+  if (lua_isthread(L, 1)) {
+    *arg = 1;
+    return lua_tothread(L, 1);
+  }
+  else {
+    *arg = 0;
+    return L;
+  }
+}
+
+
+static void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {
+  if (L == L1) {
+    lua_pushvalue(L, -2);
+    lua_remove(L, -3);
+  }
+  else
+    lua_xmove(L1, L, 1);
+  lua_setfield(L, -2, fname);
+}
+
+
+static int db_getinfo (lua_State *L) {
+  lua_Debug ar;
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  const char *options = luaL_optstring(L, arg+2, "flnStu");
+  if (lua_isnumber(L, arg+1)) {
+    if (!lua_getstack(L1, (int)lua_tointeger(L, arg+1), &ar)) {
+      lua_pushnil(L);  /* level out of range */
+      return 1;
+    }
+  }
+  else if (lua_isfunction(L, arg+1)) {
+    lua_pushfstring(L, ">%s", options);
+    options = lua_tostring(L, -1);
+    lua_pushvalue(L, arg+1);
+    lua_xmove(L, L1, 1);
+  }
+  else
+    return luaL_argerror(L, arg+1, "function or level expected");
+  if (!lua_getinfo(L1, options, &ar))
+    return luaL_argerror(L, arg+2, "invalid option");
+  lua_createtable(L, 0, 2);
+  if (strchr(options, 'S')) {
+    settabss(L, "source", ar.source);
+    settabss(L, "short_src", ar.short_src);
+    settabsi(L, "linedefined", ar.linedefined);
+    settabsi(L, "lastlinedefined", ar.lastlinedefined);
+    settabss(L, "what", ar.what);
+  }
+  if (strchr(options, 'l'))
+    settabsi(L, "currentline", ar.currentline);
+  if (strchr(options, 'u')) {
+    settabsi(L, "nups", ar.nups);
+    settabsi(L, "nparams", ar.nparams);
+    settabsb(L, "isvararg", ar.isvararg);
+  }
+  if (strchr(options, 'n')) {
+    settabss(L, "name", ar.name);
+    settabss(L, "namewhat", ar.namewhat);
+  }
+  if (strchr(options, 't'))
+    settabsb(L, "istailcall", ar.istailcall);
+  if (strchr(options, 'L'))
+    treatstackoption(L, L1, "activelines");
+  if (strchr(options, 'f'))
+    treatstackoption(L, L1, "func");
+  return 1;  /* return table */
+}
+
+
+static int db_getlocal (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  lua_Debug ar;
+  const char *name;
+  int nvar = luaL_checkint(L, arg+2);  /* local-variable index */
+  if (lua_isfunction(L, arg + 1)) {  /* function argument? */
+    lua_pushvalue(L, arg + 1);  /* push function */
+    lua_pushstring(L, lua_getlocal(L, NULL, nvar));  /* push local name */
+    return 1;
+  }
+  else {  /* stack-level argument */
+    if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */
+      return luaL_argerror(L, arg+1, "level out of range");
+    name = lua_getlocal(L1, &ar, nvar);
+    if (name) {
+      lua_xmove(L1, L, 1);  /* push local value */
+      lua_pushstring(L, name);  /* push name */
+      lua_pushvalue(L, -2);  /* re-order */
+      return 2;
+    }
+    else {
+      lua_pushnil(L);  /* no name (nor value) */
+      return 1;
+    }
+  }
+}
+
+
+static int db_setlocal (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  lua_Debug ar;
+  if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */
+    return luaL_argerror(L, arg+1, "level out of range");
+  luaL_checkany(L, arg+3);
+  lua_settop(L, arg+3);
+  lua_xmove(L, L1, 1);
+  lua_pushstring(L, lua_setlocal(L1, &ar, luaL_checkint(L, arg+2)));
+  return 1;
+}
+
+
+static int auxupvalue (lua_State *L, int get) {
+  const char *name;
+  int n = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
+  if (name == NULL) return 0;
+  lua_pushstring(L, name);
+  lua_insert(L, -(get+1));
+  return get + 1;
+}
+
+
+static int db_getupvalue (lua_State *L) {
+  return auxupvalue(L, 1);
+}
+
+
+static int db_setupvalue (lua_State *L) {
+  luaL_checkany(L, 3);
+  return auxupvalue(L, 0);
+}
+
+
+static int checkupval (lua_State *L, int argf, int argnup) {
+  lua_Debug ar;
+  int nup = luaL_checkint(L, argnup);
+  luaL_checktype(L, argf, LUA_TFUNCTION);
+  lua_pushvalue(L, argf);
+  lua_getinfo(L, ">u", &ar);
+  luaL_argcheck(L, 1 <= nup && nup <= ar.nups, argnup, "invalid upvalue index");
+  return nup;
+}
+
+
+static int db_upvalueid (lua_State *L) {
+  int n = checkupval(L, 1, 2);
+  lua_pushlightuserdata(L, lua_upvalueid(L, 1, n));
+  return 1;
+}
+
+
+static int db_upvaluejoin (lua_State *L) {
+  int n1 = checkupval(L, 1, 2);
+  int n2 = checkupval(L, 3, 4);
+  luaL_argcheck(L, !lua_iscfunction(L, 1), 1, "Lua function expected");
+  luaL_argcheck(L, !lua_iscfunction(L, 3), 3, "Lua function expected");
+  lua_upvaluejoin(L, 1, n1, 3, n2);
+  return 0;
+}
+
+
+#define gethooktable(L)	luaL_getsubtable(L, LUA_REGISTRYINDEX, HOOKKEY)
+
+
+static void hookf (lua_State *L, lua_Debug *ar) {
+  static const char *const hooknames[] =
+    {"call", "return", "line", "count", "tail call"};
+  gethooktable(L);
+  lua_pushthread(L);
+  lua_rawget(L, -2);
+  if (lua_isfunction(L, -1)) {
+    lua_pushstring(L, hooknames[(int)ar->event]);
+    if (ar->currentline >= 0)
+      lua_pushinteger(L, ar->currentline);
+    else lua_pushnil(L);
+    lua_assert(lua_getinfo(L, "lS", ar));
+    lua_call(L, 2, 0);
+  }
+}
+
+
+static int makemask (const char *smask, int count) {
+  int mask = 0;
+  if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
+  if (strchr(smask, 'r')) mask |= LUA_MASKRET;
+  if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+  if (count > 0) mask |= LUA_MASKCOUNT;
+  return mask;
+}
+
+
+static char *unmakemask (int mask, char *smask) {
+  int i = 0;
+  if (mask & LUA_MASKCALL) smask[i++] = 'c';
+  if (mask & LUA_MASKRET) smask[i++] = 'r';
+  if (mask & LUA_MASKLINE) smask[i++] = 'l';
+  smask[i] = '\0';
+  return smask;
+}
+
+
+static int db_sethook (lua_State *L) {
+  int arg, mask, count;
+  lua_Hook func;
+  lua_State *L1 = getthread(L, &arg);
+  if (lua_isnoneornil(L, arg+1)) {
+    lua_settop(L, arg+1);
+    func = NULL; mask = 0; count = 0;  /* turn off hooks */
+  }
+  else {
+    const char *smask = luaL_checkstring(L, arg+2);
+    luaL_checktype(L, arg+1, LUA_TFUNCTION);
+    count = luaL_optint(L, arg+3, 0);
+    func = hookf; mask = makemask(smask, count);
+  }
+  if (gethooktable(L) == 0) {  /* creating hook table? */
+    lua_pushstring(L, "k");
+    lua_setfield(L, -2, "__mode");  /** hooktable.__mode = "k" */
+    lua_pushvalue(L, -1);
+    lua_setmetatable(L, -2);  /* setmetatable(hooktable) = hooktable */
+  }
+  lua_pushthread(L1); lua_xmove(L1, L, 1);
+  lua_pushvalue(L, arg+1);
+  lua_rawset(L, -3);  /* set new hook */
+  lua_sethook(L1, func, mask, count);  /* set hooks */
+  return 0;
+}
+
+
+static int db_gethook (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  char buff[5];
+  int mask = lua_gethookmask(L1);
+  lua_Hook hook = lua_gethook(L1);
+  if (hook != NULL && hook != hookf)  /* external hook? */
+    lua_pushliteral(L, "external hook");
+  else {
+    gethooktable(L);
+    lua_pushthread(L1); lua_xmove(L1, L, 1);
+    lua_rawget(L, -2);   /* get hook */
+    lua_remove(L, -2);  /* remove hook table */
+  }
+  lua_pushstring(L, unmakemask(mask, buff));
+  lua_pushinteger(L, lua_gethookcount(L1));
+  return 3;
+}
+
+
+static int db_debug (lua_State *L) {
+  for (;;) {
+    char buffer[250];
+    luai_writestringerror("%s", "lua_debug> ");
+    if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
+        strcmp(buffer, "cont\n") == 0)
+      return 0;
+    if (luaL_loadbuffer(L, buffer, strlen(buffer), "=(debug command)") ||
+        lua_pcall(L, 0, 0, 0))
+      luai_writestringerror("%s\n", lua_tostring(L, -1));
+    lua_settop(L, 0);  /* remove eventual returns */
+  }
+}
+
+
+static int db_traceback (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  const char *msg = lua_tostring(L, arg + 1);
+  if (msg == NULL && !lua_isnoneornil(L, arg + 1))  /* non-string 'msg'? */
+    lua_pushvalue(L, arg + 1);  /* return it untouched */
+  else {
+    int level = luaL_optint(L, arg + 2, (L == L1) ? 1 : 0);
+    luaL_traceback(L, L1, msg, level);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg dblib[] = {
+  {"debug", db_debug},
+  {"getuservalue", db_getuservalue},
+  {"gethook", db_gethook},
+  {"getinfo", db_getinfo},
+  {"getlocal", db_getlocal},
+  {"getregistry", db_getregistry},
+  {"getmetatable", db_getmetatable},
+  {"getupvalue", db_getupvalue},
+  {"upvaluejoin", db_upvaluejoin},
+  {"upvalueid", db_upvalueid},
+  {"setuservalue", db_setuservalue},
+  {"sethook", db_sethook},
+  {"setlocal", db_setlocal},
+  {"setmetatable", db_setmetatable},
+  {"setupvalue", db_setupvalue},
+  {"traceback", db_traceback},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_debug (lua_State *L) {
+  luaL_newlib(L, dblib);
+  return 1;
+}
+
diff --git a/dep/lualib/ldebug.c b/dep/lualib/ldebug.c
new file mode 100644
index 0000000..43f8f04
--- /dev/null
+++ b/dep/lualib/ldebug.c
@@ -0,0 +1,580 @@
+/*
+** $Id: ldebug.c,v 2.89 2012/01/20 22:05:50 roberto Exp $
+** Debug Interface
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdarg.h>
+#include <stddef.h>
+#include <string.h>
+
+
+#define ldebug_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lvm.h"
+
+
+
+#define noLuaClosure(f)		((f) == NULL || (f)->c.tt == LUA_TCCL)
+
+
+static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name);
+
+
+static int currentpc (CallInfo *ci) {
+  lua_assert(isLua(ci));
+  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);
+}
+
+
+static int currentline (CallInfo *ci) {
+  return getfuncline(ci_func(ci)->p, currentpc(ci));
+}
+
+
+/*
+** this function can be called asynchronous (e.g. during a signal)
+*/
+LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
+  if (func == NULL || mask == 0) {  /* turn off hooks? */
+    mask = 0;
+    func = NULL;
+  }
+  if (isLua(L->ci))
+    L->oldpc = L->ci->u.l.savedpc;
+  L->hook = func;
+  L->basehookcount = count;
+  resethookcount(L);
+  L->hookmask = cast_byte(mask);
+  return 1;
+}
+
+
+LUA_API lua_Hook lua_gethook (lua_State *L) {
+  return L->hook;
+}
+
+
+LUA_API int lua_gethookmask (lua_State *L) {
+  return L->hookmask;
+}
+
+
+LUA_API int lua_gethookcount (lua_State *L) {
+  return L->basehookcount;
+}
+
+
+LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
+  int status;
+  CallInfo *ci;
+  if (level < 0) return 0;  /* invalid (negative) level */
+  lua_lock(L);
+  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)
+    level--;
+  if (level == 0 && ci != &L->base_ci) {  /* level found? */
+    status = 1;
+    ar->i_ci = ci;
+  }
+  else status = 0;  /* no such level */
+  lua_unlock(L);
+  return status;
+}
+
+
+static const char *upvalname (Proto *p, int uv) {
+  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);
+  if (s == NULL) return "?";
+  else return getstr(s);
+}
+
+
+static const char *findvararg (CallInfo *ci, int n, StkId *pos) {
+  int nparams = clLvalue(ci->func)->p->numparams;
+  if (n >= ci->u.l.base - ci->func - nparams)
+    return NULL;  /* no such vararg */
+  else {
+    *pos = ci->func + nparams + n;
+    return "(*vararg)";  /* generic name for any vararg */
+  }
+}
+
+
+static const char *findlocal (lua_State *L, CallInfo *ci, int n,
+                              StkId *pos) {
+  const char *name = NULL;
+  StkId base;
+  if (isLua(ci)) {
+    if (n < 0)  /* access to vararg values? */
+      return findvararg(ci, -n, pos);
+    else {
+      base = ci->u.l.base;
+      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));
+    }
+  }
+  else
+    base = ci->func + 1;
+  if (name == NULL) {  /* no 'standard' name? */
+    StkId limit = (ci == L->ci) ? L->top : ci->next->func;
+    if (limit - base >= n && n > 0)  /* is 'n' inside 'ci' stack? */
+      name = "(*temporary)";  /* generic name for any valid slot */
+    else
+      return NULL;  /* no name */
+  }
+  *pos = base + (n - 1);
+  return name;
+}
+
+
+LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
+  const char *name;
+  lua_lock(L);
+  if (ar == NULL) {  /* information about non-active function? */
+    if (!isLfunction(L->top - 1))  /* not a Lua function? */
+      name = NULL;
+    else  /* consider live variables at function start (parameters) */
+      name = luaF_getlocalname(clLvalue(L->top - 1)->p, n, 0);
+  }
+  else {  /* active function; get information through 'ar' */
+    StkId pos = 0;  /* to avoid warnings */
+    name = findlocal(L, ar->i_ci, n, &pos);
+    if (name) {
+      setobj2s(L, L->top, pos);
+      api_incr_top(L);
+    }
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
+  StkId pos = 0;  /* to avoid warnings */
+  const char *name = findlocal(L, ar->i_ci, n, &pos);
+  lua_lock(L);
+  if (name)
+    setobjs2s(L, pos, L->top - 1);
+  L->top--;  /* pop value */
+  lua_unlock(L);
+  return name;
+}
+
+
+static void funcinfo (lua_Debug *ar, Closure *cl) {
+  if (noLuaClosure(cl)) {
+    ar->source = "=[C]";
+    ar->linedefined = -1;
+    ar->lastlinedefined = -1;
+    ar->what = "C";
+  }
+  else {
+    Proto *p = cl->l.p;
+    ar->source = p->source ? getstr(p->source) : "=?";
+    ar->linedefined = p->linedefined;
+    ar->lastlinedefined = p->lastlinedefined;
+    ar->what = (ar->linedefined == 0) ? "main" : "Lua";
+  }
+  luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
+}
+
+
+static void collectvalidlines (lua_State *L, Closure *f) {
+  if (noLuaClosure(f)) {
+    setnilvalue(L->top);
+    incr_top(L);
+  }
+  else {
+    int i;
+    TValue v;
+    int *lineinfo = f->l.p->lineinfo;
+    Table *t = luaH_new(L);  /* new table to store active lines */
+    sethvalue(L, L->top, t);  /* push it on stack */
+    incr_top(L);
+    setbvalue(&v, 1);  /* boolean 'true' to be the value of all indices */
+    for (i = 0; i < f->l.p->sizelineinfo; i++)  /* for all lines with code */
+      luaH_setint(L, t, lineinfo[i], &v);  /* table[line] = true */
+  }
+}
+
+
+static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
+                       Closure *f, CallInfo *ci) {
+  int status = 1;
+  for (; *what; what++) {
+    switch (*what) {
+      case 'S': {
+        funcinfo(ar, f);
+        break;
+      }
+      case 'l': {
+        ar->currentline = (ci && isLua(ci)) ? currentline(ci) : -1;
+        break;
+      }
+      case 'u': {
+        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;
+        if (noLuaClosure(f)) {
+          ar->isvararg = 1;
+          ar->nparams = 0;
+        }
+        else {
+          ar->isvararg = f->l.p->is_vararg;
+          ar->nparams = f->l.p->numparams;
+        }
+        break;
+      }
+      case 't': {
+        ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;
+        break;
+      }
+      case 'n': {
+        /* calling function is a known Lua function? */
+        if (ci && !(ci->callstatus & CIST_TAIL) && isLua(ci->previous))
+          ar->namewhat = getfuncname(L, ci->previous, &ar->name);
+        else
+          ar->namewhat = NULL;
+        if (ar->namewhat == NULL) {
+          ar->namewhat = "";  /* not found */
+          ar->name = NULL;
+        }
+        break;
+      }
+      case 'L':
+      case 'f':  /* handled by lua_getinfo */
+        break;
+      default: status = 0;  /* invalid option */
+    }
+  }
+  return status;
+}
+
+
+LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
+  int status;
+  Closure *cl;
+  CallInfo *ci;
+  StkId func;
+  lua_lock(L);
+  if (*what == '>') {
+    ci = NULL;
+    func = L->top - 1;
+    api_check(L, ttisfunction(func), "function expected");
+    what++;  /* skip the '>' */
+    L->top--;  /* pop function */
+  }
+  else {
+    ci = ar->i_ci;
+    func = ci->func;
+    lua_assert(ttisfunction(ci->func));
+  }
+  cl = ttisclosure(func) ? clvalue(func) : NULL;
+  status = auxgetinfo(L, what, ar, cl, ci);
+  if (strchr(what, 'f')) {
+    setobjs2s(L, L->top, func);
+    incr_top(L);
+  }
+  if (strchr(what, 'L'))
+    collectvalidlines(L, cl);
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** {======================================================
+** Symbolic Execution
+** =======================================================
+*/
+
+static const char *getobjname (Proto *p, int lastpc, int reg,
+                               const char **name);
+
+
+/*
+** find a "name" for the RK value 'c'
+*/
+static void kname (Proto *p, int pc, int c, const char **name) {
+  if (ISK(c)) {  /* is 'c' a constant? */
+    TValue *kvalue = &p->k[INDEXK(c)];
+    if (ttisstring(kvalue)) {  /* literal constant? */
+      *name = svalue(kvalue);  /* it is its own name */
+      return;
+    }
+    /* else no reasonable name found */
+  }
+  else {  /* 'c' is a register */
+    const char *what = getobjname(p, pc, c, name); /* search for 'c' */
+    if (what && *what == 'c') {  /* found a constant name? */
+      return;  /* 'name' already filled */
+    }
+    /* else no reasonable name found */
+  }
+  *name = "?";  /* no reasonable name found */
+}
+
+
+/*
+** try to find last instruction before 'lastpc' that modified register 'reg'
+*/
+static int findsetreg (Proto *p, int lastpc, int reg) {
+  int pc;
+  int setreg = -1;  /* keep last instruction that changed 'reg' */
+  for (pc = 0; pc < lastpc; pc++) {
+    Instruction i = p->code[pc];
+    OpCode op = GET_OPCODE(i);
+    int a = GETARG_A(i);
+    switch (op) {
+      case OP_LOADNIL: {
+        int b = GETARG_B(i);
+        if (a <= reg && reg <= a + b)  /* set registers from 'a' to 'a+b' */
+          setreg = pc;
+        break;
+      }
+      case OP_TFORCALL: {
+        if (reg >= a + 2) setreg = pc;  /* affect all regs above its base */
+        break;
+      }
+      case OP_CALL:
+      case OP_TAILCALL: {
+        if (reg >= a) setreg = pc;  /* affect all registers above base */
+        break;
+      }
+      case OP_JMP: {
+        int b = GETARG_sBx(i);
+        int dest = pc + 1 + b;
+        /* jump is forward and do not skip `lastpc'? */
+        if (pc < dest && dest <= lastpc)
+          pc += b;  /* do the jump */
+        break;
+      }
+      case OP_TEST: {
+        if (reg == a) setreg = pc;  /* jumped code can change 'a' */
+        break;
+      }
+      default:
+        if (testAMode(op) && reg == a)  /* any instruction that set A */
+          setreg = pc;
+        break;
+    }
+  }
+  return setreg;
+}
+
+
+static const char *getobjname (Proto *p, int lastpc, int reg,
+                               const char **name) {
+  int pc;
+  *name = luaF_getlocalname(p, reg + 1, lastpc);
+  if (*name)  /* is a local? */
+    return "local";
+  /* else try symbolic execution */
+  pc = findsetreg(p, lastpc, reg);
+  if (pc != -1) {  /* could find instruction? */
+    Instruction i = p->code[pc];
+    OpCode op = GET_OPCODE(i);
+    switch (op) {
+      case OP_MOVE: {
+        int b = GETARG_B(i);  /* move from 'b' to 'a' */
+        if (b < GETARG_A(i))
+          return getobjname(p, pc, b, name);  /* get name for 'b' */
+        break;
+      }
+      case OP_GETTABUP:
+      case OP_GETTABLE: {
+        int k = GETARG_C(i);  /* key index */
+        int t = GETARG_B(i);  /* table index */
+        const char *vn = (op == OP_GETTABLE)  /* name of indexed variable */
+                         ? luaF_getlocalname(p, t + 1, pc)
+                         : upvalname(p, t);
+        kname(p, pc, k, name);
+        return (vn && strcmp(vn, LUA_ENV) == 0) ? "global" : "field";
+      }
+      case OP_GETUPVAL: {
+        *name = upvalname(p, GETARG_B(i));
+        return "upvalue";
+      }
+      case OP_LOADK:
+      case OP_LOADKX: {
+        int b = (op == OP_LOADK) ? GETARG_Bx(i)
+                                 : GETARG_Ax(p->code[pc + 1]);
+        if (ttisstring(&p->k[b])) {
+          *name = svalue(&p->k[b]);
+          return "constant";
+        }
+        break;
+      }
+      case OP_SELF: {
+        int k = GETARG_C(i);  /* key index */
+        kname(p, pc, k, name);
+        return "method";
+      }
+      default: break;  /* go through to return NULL */
+    }
+  }
+  return NULL;  /* could not find reasonable name */
+}
+
+
+static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {
+  TMS tm;
+  Proto *p = ci_func(ci)->p;  /* calling function */
+  int pc = currentpc(ci);  /* calling instruction index */
+  Instruction i = p->code[pc];  /* calling instruction */
+  switch (GET_OPCODE(i)) {
+    case OP_CALL:
+    case OP_TAILCALL:  /* get function name */
+      return getobjname(p, pc, GETARG_A(i), name);
+    case OP_TFORCALL: {  /* for iterator */
+      *name = "for iterator";
+       return "for iterator";
+    }
+    /* all other instructions can call only through metamethods */
+    case OP_SELF:
+    case OP_GETTABUP:
+    case OP_GETTABLE: tm = TM_INDEX; break;
+    case OP_SETTABUP:
+    case OP_SETTABLE: tm = TM_NEWINDEX; break;
+    case OP_EQ: tm = TM_EQ; break;
+    case OP_ADD: tm = TM_ADD; break;
+    case OP_SUB: tm = TM_SUB; break;
+    case OP_MUL: tm = TM_MUL; break;
+    case OP_DIV: tm = TM_DIV; break;
+    case OP_MOD: tm = TM_MOD; break;
+    case OP_POW: tm = TM_POW; break;
+    case OP_UNM: tm = TM_UNM; break;
+    case OP_LEN: tm = TM_LEN; break;
+    case OP_LT: tm = TM_LT; break;
+    case OP_LE: tm = TM_LE; break;
+    case OP_CONCAT: tm = TM_CONCAT; break;
+    default:
+      return NULL;  /* else no useful name can be found */
+  }
+  *name = getstr(G(L)->tmname[tm]);
+  return "metamethod";
+}
+
+/* }====================================================== */
+
+
+
+/*
+** only ANSI way to check whether a pointer points to an array
+** (used only for error messages, so efficiency is not a big concern)
+*/
+static int isinstack (CallInfo *ci, const TValue *o) {
+  StkId p;
+  for (p = ci->u.l.base; p < ci->top; p++)
+    if (o == p) return 1;
+  return 0;
+}
+
+
+static const char *getupvalname (CallInfo *ci, const TValue *o,
+                                 const char **name) {
+  LClosure *c = ci_func(ci);
+  int i;
+  for (i = 0; i < c->nupvalues; i++) {
+    if (c->upvals[i]->v == o) {
+      *name = upvalname(c->p, i);
+      return "upvalue";
+    }
+  }
+  return NULL;
+}
+
+
+l_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
+  CallInfo *ci = L->ci;
+  const char *name = NULL;
+  const char *t = objtypename(o);
+  const char *kind = NULL;
+  if (isLua(ci)) {
+    kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */
+    if (!kind && isinstack(ci, o))  /* no? try a register */
+      kind = getobjname(ci_func(ci)->p, currentpc(ci),
+                        cast_int(o - ci->u.l.base), &name);
+  }
+  if (kind)
+    luaG_runerror(L, "attempt to %s %s " LUA_QS " (a %s value)",
+                op, kind, name, t);
+  else
+    luaG_runerror(L, "attempt to %s a %s value", op, t);
+}
+
+
+l_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
+  if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;
+  lua_assert(!ttisstring(p1) && !ttisnumber(p2));
+  luaG_typeerror(L, p1, "concatenate");
+}
+
+
+l_noret luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {
+  TValue temp;
+  if (luaV_tonumber(p1, &temp) == NULL)
+    p2 = p1;  /* first operand is wrong */
+  luaG_typeerror(L, p2, "perform arithmetic on");
+}
+
+
+l_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
+  const char *t1 = objtypename(p1);
+  const char *t2 = objtypename(p2);
+  if (t1 == t2)
+    luaG_runerror(L, "attempt to compare two %s values", t1);
+  else
+    luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
+}
+
+
+static void addinfo (lua_State *L, const char *msg) {
+  CallInfo *ci = L->ci;
+  if (isLua(ci)) {  /* is Lua code? */
+    char buff[LUA_IDSIZE];  /* add file:line information */
+    int line = currentline(ci);
+    TString *src = ci_func(ci)->p->source;
+    if (src)
+      luaO_chunkid(buff, getstr(src), LUA_IDSIZE);
+    else {  /* no source available; use "?" instead */
+      buff[0] = '?'; buff[1] = '\0';
+    }
+    luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
+  }
+}
+
+
+l_noret luaG_errormsg (lua_State *L) {
+  if (L->errfunc != 0) {  /* is there an error handling function? */
+    StkId errfunc = restorestack(L, L->errfunc);
+    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);
+    setobjs2s(L, L->top, L->top - 1);  /* move argument */
+    setobjs2s(L, L->top - 1, errfunc);  /* push function */
+    incr_top(L);
+    luaD_call(L, L->top - 2, 1, 0);  /* call it */
+  }
+  luaD_throw(L, LUA_ERRRUN);
+}
+
+
+l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  addinfo(L, luaO_pushvfstring(L, fmt, argp));
+  va_end(argp);
+  luaG_errormsg(L);
+}
+
diff --git a/dep/lualib/ldebug.h b/dep/lualib/ldebug.h
new file mode 100644
index 0000000..fe39556
--- /dev/null
+++ b/dep/lualib/ldebug.h
@@ -0,0 +1,34 @@
+/*
+** $Id: ldebug.h,v 2.7 2011/10/07 20:45:19 roberto Exp $
+** Auxiliary functions from Debug Interface module
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldebug_h
+#define ldebug_h
+
+
+#include "lstate.h"
+
+
+#define pcRel(pc, p)	(cast(int, (pc) - (p)->code) - 1)
+
+#define getfuncline(f,pc)	(((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
+
+#define resethookcount(L)	(L->hookcount = L->basehookcount)
+
+/* Active Lua function (given call info) */
+#define ci_func(ci)		(clLvalue((ci)->func))
+
+
+LUAI_FUNC l_noret luaG_typeerror (lua_State *L, const TValue *o,
+                                                const char *opname);
+LUAI_FUNC l_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2);
+LUAI_FUNC l_noret luaG_aritherror (lua_State *L, const TValue *p1,
+                                                 const TValue *p2);
+LUAI_FUNC l_noret luaG_ordererror (lua_State *L, const TValue *p1,
+                                                 const TValue *p2);
+LUAI_FUNC l_noret luaG_runerror (lua_State *L, const char *fmt, ...);
+LUAI_FUNC l_noret luaG_errormsg (lua_State *L);
+
+#endif
diff --git a/dep/lualib/ldo.c b/dep/lualib/ldo.c
new file mode 100644
index 0000000..d18e33c
--- /dev/null
+++ b/dep/lualib/ldo.c
@@ -0,0 +1,668 @@
+/*
+** $Id: ldo.c,v 2.105 2012/06/08 15:14:04 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include <setjmp.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ldo_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lundump.h"
+#include "lvm.h"
+#include "lzio.h"
+
+
+
+
+/*
+** {======================================================
+** Error-recovery functions
+** =======================================================
+*/
+
+/*
+** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By
+** default, Lua handles errors with exceptions when compiling as
+** C++ code, with _longjmp/_setjmp when asked to use them, and with
+** longjmp/setjmp otherwise.
+*/
+#if !defined(LUAI_THROW)
+
+#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)
+/* C++ exceptions */
+#define LUAI_THROW(L,c)		throw(c)
+#define LUAI_TRY(L,c,a) \
+	try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
+#define luai_jmpbuf		int  /* dummy variable */
+
+#elif defined(LUA_USE_ULONGJMP)
+/* in Unix, try _longjmp/_setjmp (more efficient) */
+#define LUAI_THROW(L,c)		_longjmp((c)->b, 1)
+#define LUAI_TRY(L,c,a)		if (_setjmp((c)->b) == 0) { a }
+#define luai_jmpbuf		jmp_buf
+
+#else
+/* default handling with long jumps */
+#define LUAI_THROW(L,c)		longjmp((c)->b, 1)
+#define LUAI_TRY(L,c,a)		if (setjmp((c)->b) == 0) { a }
+#define luai_jmpbuf		jmp_buf
+
+#endif
+
+#endif
+
+
+
+/* chain list of long jump buffers */
+struct lua_longjmp {
+  struct lua_longjmp *previous;
+  luai_jmpbuf b;
+  volatile int status;  /* error code */
+};
+
+
+static void seterrorobj (lua_State *L, int errcode, StkId oldtop) {
+  switch (errcode) {
+    case LUA_ERRMEM: {  /* memory error? */
+      setsvalue2s(L, oldtop, G(L)->memerrmsg); /* reuse preregistered msg. */
+      break;
+    }
+    case LUA_ERRERR: {
+      setsvalue2s(L, oldtop, luaS_newliteral(L, "error in error handling"));
+      break;
+    }
+    default: {
+      setobjs2s(L, oldtop, L->top - 1);  /* error message on current top */
+      break;
+    }
+  }
+  L->top = oldtop + 1;
+}
+
+
+l_noret luaD_throw (lua_State *L, int errcode) {
+  if (L->errorJmp) {  /* thread has an error handler? */
+    L->errorJmp->status = errcode;  /* set status */
+    LUAI_THROW(L, L->errorJmp);  /* jump to it */
+  }
+  else {  /* thread has no error handler */
+    L->status = cast_byte(errcode);  /* mark it as dead */
+    if (G(L)->mainthread->errorJmp) {  /* main thread has a handler? */
+      setobjs2s(L, G(L)->mainthread->top++, L->top - 1);  /* copy error obj. */
+      luaD_throw(G(L)->mainthread, errcode);  /* re-throw in main thread */
+    }
+    else {  /* no handler at all; abort */
+      if (G(L)->panic) {  /* panic function? */
+        lua_unlock(L);
+        G(L)->panic(L);  /* call it (last chance to jump out) */
+      }
+      abort();
+    }
+  }
+}
+
+
+int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
+  unsigned short oldnCcalls = L->nCcalls;
+  struct lua_longjmp lj;
+  lj.status = LUA_OK;
+  lj.previous = L->errorJmp;  /* chain new error handler */
+  L->errorJmp = &lj;
+  LUAI_TRY(L, &lj,
+    (*f)(L, ud);
+  );
+  L->errorJmp = lj.previous;  /* restore old error handler */
+  L->nCcalls = oldnCcalls;
+  return lj.status;
+}
+
+/* }====================================================== */
+
+
+static void correctstack (lua_State *L, TValue *oldstack) {
+  CallInfo *ci;
+  GCObject *up;
+  L->top = (L->top - oldstack) + L->stack;
+  for (up = L->openupval; up != NULL; up = up->gch.next)
+    gco2uv(up)->v = (gco2uv(up)->v - oldstack) + L->stack;
+  for (ci = L->ci; ci != NULL; ci = ci->previous) {
+    ci->top = (ci->top - oldstack) + L->stack;
+    ci->func = (ci->func - oldstack) + L->stack;
+    if (isLua(ci))
+      ci->u.l.base = (ci->u.l.base - oldstack) + L->stack;
+  }
+}
+
+
+/* some space for error handling */
+#define ERRORSTACKSIZE	(LUAI_MAXSTACK + 200)
+
+
+void luaD_reallocstack (lua_State *L, int newsize) {
+  TValue *oldstack = L->stack;
+  int lim = L->stacksize;
+  lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);
+  lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK);
+  luaM_reallocvector(L, L->stack, L->stacksize, newsize, TValue);
+  for (; lim < newsize; lim++)
+    setnilvalue(L->stack + lim); /* erase new segment */
+  L->stacksize = newsize;
+  L->stack_last = L->stack + newsize - EXTRA_STACK;
+  correctstack(L, oldstack);
+}
+
+
+void luaD_growstack (lua_State *L, int n) {
+  int size = L->stacksize;
+  if (size > LUAI_MAXSTACK)  /* error after extra size? */
+    luaD_throw(L, LUA_ERRERR);
+  else {
+    int needed = cast_int(L->top - L->stack) + n + EXTRA_STACK;
+    int newsize = 2 * size;
+    if (newsize > LUAI_MAXSTACK) newsize = LUAI_MAXSTACK;
+    if (newsize < needed) newsize = needed;
+    if (newsize > LUAI_MAXSTACK) {  /* stack overflow? */
+      luaD_reallocstack(L, ERRORSTACKSIZE);
+      luaG_runerror(L, "stack overflow");
+    }
+    else
+      luaD_reallocstack(L, newsize);
+  }
+}
+
+
+static int stackinuse (lua_State *L) {
+  CallInfo *ci;
+  StkId lim = L->top;
+  for (ci = L->ci; ci != NULL; ci = ci->previous) {
+    lua_assert(ci->top <= L->stack_last);
+    if (lim < ci->top) lim = ci->top;
+  }
+  return cast_int(lim - L->stack) + 1;  /* part of stack in use */
+}
+
+
+void luaD_shrinkstack (lua_State *L) {
+  int inuse = stackinuse(L);
+  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;
+  if (goodsize > LUAI_MAXSTACK) goodsize = LUAI_MAXSTACK;
+  if (inuse > LUAI_MAXSTACK ||  /* handling stack overflow? */
+      goodsize >= L->stacksize)  /* would grow instead of shrink? */
+    condmovestack(L);  /* don't change stack (change only for debugging) */
+  else
+    luaD_reallocstack(L, goodsize);  /* shrink it */
+}
+
+
+void luaD_hook (lua_State *L, int event, int line) {
+  lua_Hook hook = L->hook;
+  if (hook && L->allowhook) {
+    CallInfo *ci = L->ci;
+    ptrdiff_t top = savestack(L, L->top);
+    ptrdiff_t ci_top = savestack(L, ci->top);
+    lua_Debug ar;
+    ar.event = event;
+    ar.currentline = line;
+    ar.i_ci = ci;
+    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+    ci->top = L->top + LUA_MINSTACK;
+    lua_assert(ci->top <= L->stack_last);
+    L->allowhook = 0;  /* cannot call hooks inside a hook */
+    ci->callstatus |= CIST_HOOKED;
+    lua_unlock(L);
+    (*hook)(L, &ar);
+    lua_lock(L);
+    lua_assert(!L->allowhook);
+    L->allowhook = 1;
+    ci->top = restorestack(L, ci_top);
+    L->top = restorestack(L, top);
+    ci->callstatus &= ~CIST_HOOKED;
+  }
+}
+
+
+static void callhook (lua_State *L, CallInfo *ci) {
+  int hook = LUA_HOOKCALL;
+  ci->u.l.savedpc++;  /* hooks assume 'pc' is already incremented */
+  if (isLua(ci->previous) &&
+      GET_OPCODE(*(ci->previous->u.l.savedpc - 1)) == OP_TAILCALL) {
+    ci->callstatus |= CIST_TAIL;
+    hook = LUA_HOOKTAILCALL;
+  }
+  luaD_hook(L, hook, -1);
+  ci->u.l.savedpc--;  /* correct 'pc' */
+}
+
+
+static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
+  int i;
+  int nfixargs = p->numparams;
+  StkId base, fixed;
+  lua_assert(actual >= nfixargs);
+  /* move fixed parameters to final position */
+  fixed = L->top - actual;  /* first fixed argument */
+  base = L->top;  /* final position of first argument */
+  for (i=0; i<nfixargs; i++) {
+    setobjs2s(L, L->top++, fixed + i);
+    setnilvalue(fixed + i);
+  }
+  return base;
+}
+
+
+static StkId tryfuncTM (lua_State *L, StkId func) {
+  const TValue *tm = luaT_gettmbyobj(L, func, TM_CALL);
+  StkId p;
+  ptrdiff_t funcr = savestack(L, func);
+  if (!ttisfunction(tm))
+    luaG_typeerror(L, func, "call");
+  /* Open a hole inside the stack at `func' */
+  for (p = L->top; p > func; p--) setobjs2s(L, p, p-1);
+  incr_top(L);
+  func = restorestack(L, funcr);  /* previous call may change stack */
+  setobj2s(L, func, tm);  /* tag method is the new function to be called */
+  return func;
+}
+
+
+
+#define next_ci(L) (L->ci = (L->ci->next ? L->ci->next : luaE_extendCI(L)))
+
+
+/*
+** returns true if function has been executed (C function)
+*/
+int luaD_precall (lua_State *L, StkId func, int nresults) {
+  lua_CFunction f;
+  CallInfo *ci;
+  int n;  /* number of arguments (Lua) or returns (C) */
+  ptrdiff_t funcr = savestack(L, func);
+  switch (ttype(func)) {
+    case LUA_TLCF:  /* light C function */
+      f = fvalue(func);
+      goto Cfunc;
+    case LUA_TCCL: {  /* C closure */
+      f = clCvalue(func)->f;
+     Cfunc:
+      luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+      ci = next_ci(L);  /* now 'enter' new function */
+      ci->nresults = nresults;
+      ci->func = restorestack(L, funcr);
+      ci->top = L->top + LUA_MINSTACK;
+      lua_assert(ci->top <= L->stack_last);
+      ci->callstatus = 0;
+      if (L->hookmask & LUA_MASKCALL)
+        luaD_hook(L, LUA_HOOKCALL, -1);
+      lua_unlock(L);
+      n = (*f)(L);  /* do the actual call */
+      lua_lock(L);
+      api_checknelems(L, n);
+      luaD_poscall(L, L->top - n);
+      return 1;
+    }
+    case LUA_TLCL: {  /* Lua function: prepare its call */
+      StkId base;
+      Proto *p = clLvalue(func)->p;
+      luaD_checkstack(L, p->maxstacksize);
+      func = restorestack(L, funcr);
+      n = cast_int(L->top - func) - 1;  /* number of real arguments */
+      for (; n < p->numparams; n++)
+        setnilvalue(L->top++);  /* complete missing arguments */
+      base = (!p->is_vararg) ? func + 1 : adjust_varargs(L, p, n);
+      ci = next_ci(L);  /* now 'enter' new function */
+      ci->nresults = nresults;
+      ci->func = func;
+      ci->u.l.base = base;
+      ci->top = base + p->maxstacksize;
+      lua_assert(ci->top <= L->stack_last);
+      ci->u.l.savedpc = p->code;  /* starting point */
+      ci->callstatus = CIST_LUA;
+      L->top = ci->top;
+      if (L->hookmask & LUA_MASKCALL)
+        callhook(L, ci);
+      return 0;
+    }
+    default: {  /* not a function */
+      func = tryfuncTM(L, func);  /* retry with 'function' tag method */
+      return luaD_precall(L, func, nresults);  /* now it must be a function */
+    }
+  }
+}
+
+
+int luaD_poscall (lua_State *L, StkId firstResult) {
+  StkId res;
+  int wanted, i;
+  CallInfo *ci = L->ci;
+  if (L->hookmask & (LUA_MASKRET | LUA_MASKLINE)) {
+    if (L->hookmask & LUA_MASKRET) {
+      ptrdiff_t fr = savestack(L, firstResult);  /* hook may change stack */
+      luaD_hook(L, LUA_HOOKRET, -1);
+      firstResult = restorestack(L, fr);
+    }
+    L->oldpc = ci->previous->u.l.savedpc;  /* 'oldpc' for caller function */
+  }
+  res = ci->func;  /* res == final position of 1st result */
+  wanted = ci->nresults;
+  L->ci = ci = ci->previous;  /* back to caller */
+  /* move results to correct place */
+  for (i = wanted; i != 0 && firstResult < L->top; i--)
+    setobjs2s(L, res++, firstResult++);
+  while (i-- > 0)
+    setnilvalue(res++);
+  L->top = res;
+  return (wanted - LUA_MULTRET);  /* 0 iff wanted == LUA_MULTRET */
+}
+
+
+/*
+** Call a function (C or Lua). The function to be called is at *func.
+** The arguments are on the stack, right after the function.
+** When returns, all the results are on the stack, starting at the original
+** function position.
+*/
+void luaD_call (lua_State *L, StkId func, int nResults, int allowyield) {
+  if (++L->nCcalls >= LUAI_MAXCCALLS) {
+    if (L->nCcalls == LUAI_MAXCCALLS)
+      luaG_runerror(L, "C stack overflow");
+    else if (L->nCcalls >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))
+      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */
+  }
+  if (!allowyield) L->nny++;
+  if (!luaD_precall(L, func, nResults))  /* is a Lua function? */
+    luaV_execute(L);  /* call it */
+  if (!allowyield) L->nny--;
+  L->nCcalls--;
+  luaC_checkGC(L);
+}
+
+
+static void finishCcall (lua_State *L) {
+  CallInfo *ci = L->ci;
+  int n;
+  lua_assert(ci->u.c.k != NULL);  /* must have a continuation */
+  lua_assert(L->nny == 0);
+  /* finish 'lua_callk' */
+  adjustresults(L, ci->nresults);
+  /* call continuation function */
+  if (!(ci->callstatus & CIST_STAT))  /* no call status? */
+    ci->u.c.status = LUA_YIELD;  /* 'default' status */
+  lua_assert(ci->u.c.status != LUA_OK);
+  ci->callstatus = (ci->callstatus & ~(CIST_YPCALL | CIST_STAT)) | CIST_YIELDED;
+  lua_unlock(L);
+  n = (*ci->u.c.k)(L);
+  lua_lock(L);
+  api_checknelems(L, n);
+  /* finish 'luaD_precall' */
+  luaD_poscall(L, L->top - n);
+}
+
+
+static void unroll (lua_State *L, void *ud) {
+  UNUSED(ud);
+  for (;;) {
+    if (L->ci == &L->base_ci)  /* stack is empty? */
+      return;  /* coroutine finished normally */
+    if (!isLua(L->ci))  /* C function? */
+      finishCcall(L);
+    else {  /* Lua function */
+      luaV_finishOp(L);  /* finish interrupted instruction */
+      luaV_execute(L);  /* execute down to higher C 'boundary' */
+    }
+  }
+}
+
+
+/*
+** check whether thread has a suspended protected call
+*/
+static CallInfo *findpcall (lua_State *L) {
+  CallInfo *ci;
+  for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */
+    if (ci->callstatus & CIST_YPCALL)
+      return ci;
+  }
+  return NULL;  /* no pending pcall */
+}
+
+
+static int recover (lua_State *L, int status) {
+  StkId oldtop;
+  CallInfo *ci = findpcall(L);
+  if (ci == NULL) return 0;  /* no recovery point */
+  /* "finish" luaD_pcall */
+  oldtop = restorestack(L, ci->extra);
+  luaF_close(L, oldtop);
+  seterrorobj(L, status, oldtop);
+  L->ci = ci;
+  L->allowhook = ci->u.c.old_allowhook;
+  L->nny = 0;  /* should be zero to be yieldable */
+  luaD_shrinkstack(L);
+  L->errfunc = ci->u.c.old_errfunc;
+  ci->callstatus |= CIST_STAT;  /* call has error status */
+  ci->u.c.status = status;  /* (here it is) */
+  return 1;  /* continue running the coroutine */
+}
+
+
+/*
+** signal an error in the call to 'resume', not in the execution of the
+** coroutine itself. (Such errors should not be handled by any coroutine
+** error handler and should not kill the coroutine.)
+*/
+static l_noret resume_error (lua_State *L, const char *msg, StkId firstArg) {
+  L->top = firstArg;  /* remove args from the stack */
+  setsvalue2s(L, L->top, luaS_new(L, msg));  /* push error message */
+  incr_top(L);
+  luaD_throw(L, -1);  /* jump back to 'lua_resume' */
+}
+
+
+/*
+** do the work for 'lua_resume' in protected mode
+*/
+static void resume (lua_State *L, void *ud) {
+  int nCcalls = L->nCcalls;
+  StkId firstArg = cast(StkId, ud);
+  CallInfo *ci = L->ci;
+  if (nCcalls >= LUAI_MAXCCALLS)
+    resume_error(L, "C stack overflow", firstArg);
+  if (L->status == LUA_OK) {  /* may be starting a coroutine */
+    if (ci != &L->base_ci)  /* not in base level? */
+      resume_error(L, "cannot resume non-suspended coroutine", firstArg);
+    /* coroutine is in base level; start running it */
+    if (!luaD_precall(L, firstArg - 1, LUA_MULTRET))  /* Lua function? */
+      luaV_execute(L);  /* call it */
+  }
+  else if (L->status != LUA_YIELD)
+    resume_error(L, "cannot resume dead coroutine", firstArg);
+  else {  /* resuming from previous yield */
+    L->status = LUA_OK;
+    ci->func = restorestack(L, ci->extra);
+    if (isLua(ci))  /* yielded inside a hook? */
+      luaV_execute(L);  /* just continue running Lua code */
+    else {  /* 'common' yield */
+      if (ci->u.c.k != NULL) {  /* does it have a continuation? */
+        int n;
+        ci->u.c.status = LUA_YIELD;  /* 'default' status */
+        ci->callstatus |= CIST_YIELDED;
+        lua_unlock(L);
+        n = (*ci->u.c.k)(L);  /* call continuation */
+        lua_lock(L);
+        api_checknelems(L, n);
+        firstArg = L->top - n;  /* yield results come from continuation */
+      }
+      luaD_poscall(L, firstArg);  /* finish 'luaD_precall' */
+    }
+    unroll(L, NULL);
+  }
+  lua_assert(nCcalls == L->nCcalls);
+}
+
+
+LUA_API int lua_resume (lua_State *L, lua_State *from, int nargs) {
+  int status;
+  lua_lock(L);
+  luai_userstateresume(L, nargs);
+  L->nCcalls = (from) ? from->nCcalls + 1 : 1;
+  L->nny = 0;  /* allow yields */
+  api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);
+  status = luaD_rawrunprotected(L, resume, L->top - nargs);
+  if (status == -1)  /* error calling 'lua_resume'? */
+    status = LUA_ERRRUN;
+  else {  /* yield or regular error */
+    while (status != LUA_OK && status != LUA_YIELD) {  /* error? */
+      if (recover(L, status))  /* recover point? */
+        status = luaD_rawrunprotected(L, unroll, NULL);  /* run continuation */
+      else {  /* unrecoverable error */
+        L->status = cast_byte(status);  /* mark thread as `dead' */
+        seterrorobj(L, status, L->top);
+        L->ci->top = L->top;
+        break;
+      }
+    }
+    lua_assert(status == L->status);
+  }
+  L->nny = 1;  /* do not allow yields */
+  L->nCcalls--;
+  lua_assert(L->nCcalls == ((from) ? from->nCcalls : 0));
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_yieldk (lua_State *L, int nresults, int ctx, lua_CFunction k) {
+  CallInfo *ci = L->ci;
+  luai_userstateyield(L, nresults);
+  lua_lock(L);
+  api_checknelems(L, nresults);
+  if (L->nny > 0) {
+    if (L != G(L)->mainthread)
+      luaG_runerror(L, "attempt to yield across metamethod/C-call boundary");
+    else
+      luaG_runerror(L, "attempt to yield from outside a coroutine");
+  }
+  L->status = LUA_YIELD;
+  ci->extra = savestack(L, ci->func);  /* save current 'func' */
+  if (isLua(ci)) {  /* inside a hook? */
+    api_check(L, k == NULL, "hooks cannot continue after yielding");
+  }
+  else {
+    if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */
+      ci->u.c.ctx = ctx;  /* save context */
+    ci->func = L->top - nresults - 1;  /* protect stack below results */
+    luaD_throw(L, LUA_YIELD);
+  }
+  lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */
+  lua_unlock(L);
+  return 0;  /* return to 'luaD_hook' */
+}
+
+
+int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                ptrdiff_t old_top, ptrdiff_t ef) {
+  int status;
+  CallInfo *old_ci = L->ci;
+  lu_byte old_allowhooks = L->allowhook;
+  unsigned short old_nny = L->nny;
+  ptrdiff_t old_errfunc = L->errfunc;
+  L->errfunc = ef;
+  status = luaD_rawrunprotected(L, func, u);
+  if (status != LUA_OK) {  /* an error occurred? */
+    StkId oldtop = restorestack(L, old_top);
+    luaF_close(L, oldtop);  /* close possible pending closures */
+    seterrorobj(L, status, oldtop);
+    L->ci = old_ci;
+    L->allowhook = old_allowhooks;
+    L->nny = old_nny;
+    luaD_shrinkstack(L);
+  }
+  L->errfunc = old_errfunc;
+  return status;
+}
+
+
+
+/*
+** Execute a protected parser.
+*/
+struct SParser {  /* data to `f_parser' */
+  ZIO *z;
+  Mbuffer buff;  /* dynamic structure used by the scanner */
+  Dyndata dyd;  /* dynamic structures used by the parser */
+  const char *mode;
+  const char *name;
+};
+
+
+static void checkmode (lua_State *L, const char *mode, const char *x) {
+  if (mode && strchr(mode, x[0]) == NULL) {
+    luaO_pushfstring(L,
+       "attempt to load a %s chunk (mode is " LUA_QS ")", x, mode);
+    luaD_throw(L, LUA_ERRSYNTAX);
+  }
+}
+
+
+static void f_parser (lua_State *L, void *ud) {
+  int i;
+  Closure *cl;
+  struct SParser *p = cast(struct SParser *, ud);
+  int c = zgetc(p->z);  /* read first character */
+  if (c == LUA_SIGNATURE[0]) {
+    checkmode(L, p->mode, "binary");
+    cl = luaU_undump(L, p->z, &p->buff, p->name);
+  }
+  else {
+    checkmode(L, p->mode, "text");
+    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);
+  }
+  lua_assert(cl->l.nupvalues == cl->l.p->sizeupvalues);
+  for (i = 0; i < cl->l.nupvalues; i++) {  /* initialize upvalues */
+    UpVal *up = luaF_newupval(L);
+    cl->l.upvals[i] = up;
+    luaC_objbarrier(L, cl, up);
+  }
+}
+
+
+int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
+                                        const char *mode) {
+  struct SParser p;
+  int status;
+  L->nny++;  /* cannot yield during parsing */
+  p.z = z; p.name = name; p.mode = mode;
+  p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;
+  p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;
+  p.dyd.label.arr = NULL; p.dyd.label.size = 0;
+  luaZ_initbuffer(L, &p.buff);
+  status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);
+  luaZ_freebuffer(L, &p.buff);
+  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);
+  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);
+  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);
+  L->nny--;
+  return status;
+}
+
+
diff --git a/dep/lualib/ldo.h b/dep/lualib/ldo.h
new file mode 100644
index 0000000..27b837d
--- /dev/null
+++ b/dep/lualib/ldo.h
@@ -0,0 +1,46 @@
+/*
+** $Id: ldo.h,v 2.20 2011/11/29 15:55:08 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldo_h
+#define ldo_h
+
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lzio.h"
+
+
+#define luaD_checkstack(L,n)	if (L->stack_last - L->top <= (n)) \
+				    luaD_growstack(L, n); else condmovestack(L);
+
+
+#define incr_top(L) {L->top++; luaD_checkstack(L,0);}
+
+#define savestack(L,p)		((char *)(p) - (char *)L->stack)
+#define restorestack(L,n)	((TValue *)((char *)L->stack + (n)))
+
+
+/* type of protected functions, to be ran by `runprotected' */
+typedef void (*Pfunc) (lua_State *L, void *ud);
+
+LUAI_FUNC int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
+                                                  const char *mode);
+LUAI_FUNC void luaD_hook (lua_State *L, int event, int line);
+LUAI_FUNC int luaD_precall (lua_State *L, StkId func, int nresults);
+LUAI_FUNC void luaD_call (lua_State *L, StkId func, int nResults,
+                                        int allowyield);
+LUAI_FUNC int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                                        ptrdiff_t oldtop, ptrdiff_t ef);
+LUAI_FUNC int luaD_poscall (lua_State *L, StkId firstResult);
+LUAI_FUNC void luaD_reallocstack (lua_State *L, int newsize);
+LUAI_FUNC void luaD_growstack (lua_State *L, int n);
+LUAI_FUNC void luaD_shrinkstack (lua_State *L);
+
+LUAI_FUNC l_noret luaD_throw (lua_State *L, int errcode);
+LUAI_FUNC int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);
+
+#endif
+
diff --git a/dep/lualib/ldump.c b/dep/lualib/ldump.c
new file mode 100644
index 0000000..d5e6a47
--- /dev/null
+++ b/dep/lualib/ldump.c
@@ -0,0 +1,173 @@
+/*
+** $Id: ldump.c,v 2.17 2012/01/23 23:02:10 roberto Exp $
+** save precompiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#include <stddef.h>
+
+#define ldump_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lundump.h"
+
+typedef struct {
+ lua_State* L;
+ lua_Writer writer;
+ void* data;
+ int strip;
+ int status;
+} DumpState;
+
+#define DumpMem(b,n,size,D)	DumpBlock(b,(n)*(size),D)
+#define DumpVar(x,D)		DumpMem(&x,1,sizeof(x),D)
+
+static void DumpBlock(const void* b, size_t size, DumpState* D)
+{
+ if (D->status==0)
+ {
+  lua_unlock(D->L);
+  D->status=(*D->writer)(D->L,b,size,D->data);
+  lua_lock(D->L);
+ }
+}
+
+static void DumpChar(int y, DumpState* D)
+{
+ char x=(char)y;
+ DumpVar(x,D);
+}
+
+static void DumpInt(int x, DumpState* D)
+{
+ DumpVar(x,D);
+}
+
+static void DumpNumber(lua_Number x, DumpState* D)
+{
+ DumpVar(x,D);
+}
+
+static void DumpVector(const void* b, int n, size_t size, DumpState* D)
+{
+ DumpInt(n,D);
+ DumpMem(b,n,size,D);
+}
+
+static void DumpString(const TString* s, DumpState* D)
+{
+ if (s==NULL)
+ {
+  size_t size=0;
+  DumpVar(size,D);
+ }
+ else
+ {
+  size_t size=s->tsv.len+1;		/* include trailing '\0' */
+  DumpVar(size,D);
+  DumpBlock(getstr(s),size*sizeof(char),D);
+ }
+}
+
+#define DumpCode(f,D)	 DumpVector(f->code,f->sizecode,sizeof(Instruction),D)
+
+static void DumpFunction(const Proto* f, DumpState* D);
+
+static void DumpConstants(const Proto* f, DumpState* D)
+{
+ int i,n=f->sizek;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  const TValue* o=&f->k[i];
+  DumpChar(ttypenv(o),D);
+  switch (ttypenv(o))
+  {
+   case LUA_TNIL:
+	break;
+   case LUA_TBOOLEAN:
+	DumpChar(bvalue(o),D);
+	break;
+   case LUA_TNUMBER:
+	DumpNumber(nvalue(o),D);
+	break;
+   case LUA_TSTRING:
+	DumpString(rawtsvalue(o),D);
+	break;
+    default: lua_assert(0);
+  }
+ }
+ n=f->sizep;
+ DumpInt(n,D);
+ for (i=0; i<n; i++) DumpFunction(f->p[i],D);
+}
+
+static void DumpUpvalues(const Proto* f, DumpState* D)
+{
+ int i,n=f->sizeupvalues;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  DumpChar(f->upvalues[i].instack,D);
+  DumpChar(f->upvalues[i].idx,D);
+ }
+}
+
+static void DumpDebug(const Proto* f, DumpState* D)
+{
+ int i,n;
+ DumpString((D->strip) ? NULL : f->source,D);
+ n= (D->strip) ? 0 : f->sizelineinfo;
+ DumpVector(f->lineinfo,n,sizeof(int),D);
+ n= (D->strip) ? 0 : f->sizelocvars;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  DumpString(f->locvars[i].varname,D);
+  DumpInt(f->locvars[i].startpc,D);
+  DumpInt(f->locvars[i].endpc,D);
+ }
+ n= (D->strip) ? 0 : f->sizeupvalues;
+ DumpInt(n,D);
+ for (i=0; i<n; i++) DumpString(f->upvalues[i].name,D);
+}
+
+static void DumpFunction(const Proto* f, DumpState* D)
+{
+ DumpInt(f->linedefined,D);
+ DumpInt(f->lastlinedefined,D);
+ DumpChar(f->numparams,D);
+ DumpChar(f->is_vararg,D);
+ DumpChar(f->maxstacksize,D);
+ DumpCode(f,D);
+ DumpConstants(f,D);
+ DumpUpvalues(f,D);
+ DumpDebug(f,D);
+}
+
+static void DumpHeader(DumpState* D)
+{
+ lu_byte h[LUAC_HEADERSIZE];
+ luaU_header(h);
+ DumpBlock(h,LUAC_HEADERSIZE,D);
+}
+
+/*
+** dump Lua function as precompiled chunk
+*/
+int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)
+{
+ DumpState D;
+ D.L=L;
+ D.writer=w;
+ D.data=data;
+ D.strip=strip;
+ D.status=0;
+ DumpHeader(&D);
+ DumpFunction(f,&D);
+ return D.status;
+}
diff --git a/dep/lualib/lfunc.c b/dep/lualib/lfunc.c
new file mode 100644
index 0000000..4fd27fe
--- /dev/null
+++ b/dep/lualib/lfunc.c
@@ -0,0 +1,161 @@
+/*
+** $Id: lfunc.c,v 2.29 2012/05/08 13:53:33 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define lfunc_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+
+Closure *luaF_newCclosure (lua_State *L, int n) {
+  Closure *c = &luaC_newobj(L, LUA_TCCL, sizeCclosure(n), NULL, 0)->cl;
+  c->c.nupvalues = cast_byte(n);
+  return c;
+}
+
+
+Closure *luaF_newLclosure (lua_State *L, int n) {
+  Closure *c = &luaC_newobj(L, LUA_TLCL, sizeLclosure(n), NULL, 0)->cl;
+  c->l.p = NULL;
+  c->l.nupvalues = cast_byte(n);
+  while (n--) c->l.upvals[n] = NULL;
+  return c;
+}
+
+
+UpVal *luaF_newupval (lua_State *L) {
+  UpVal *uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), NULL, 0)->uv;
+  uv->v = &uv->u.value;
+  setnilvalue(uv->v);
+  return uv;
+}
+
+
+UpVal *luaF_findupval (lua_State *L, StkId level) {
+  global_State *g = G(L);
+  GCObject **pp = &L->openupval;
+  UpVal *p;
+  UpVal *uv;
+  while (*pp != NULL && (p = gco2uv(*pp))->v >= level) {
+    GCObject *o = obj2gco(p);
+    lua_assert(p->v != &p->u.value);
+    if (p->v == level) {  /* found a corresponding upvalue? */
+      if (isdead(g, o))  /* is it dead? */
+        changewhite(o);  /* resurrect it */
+      return p;
+    }
+    resetoldbit(o);  /* may create a newer upval after this one */
+    pp = &p->next;
+  }
+  /* not found: create a new one */
+  uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), pp, 0)->uv;
+  uv->v = level;  /* current value lives in the stack */
+  uv->u.l.prev = &g->uvhead;  /* double link it in `uvhead' list */
+  uv->u.l.next = g->uvhead.u.l.next;
+  uv->u.l.next->u.l.prev = uv;
+  g->uvhead.u.l.next = uv;
+  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
+  return uv;
+}
+
+
+static void unlinkupval (UpVal *uv) {
+  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
+  uv->u.l.next->u.l.prev = uv->u.l.prev;  /* remove from `uvhead' list */
+  uv->u.l.prev->u.l.next = uv->u.l.next;
+}
+
+
+void luaF_freeupval (lua_State *L, UpVal *uv) {
+  if (uv->v != &uv->u.value)  /* is it open? */
+    unlinkupval(uv);  /* remove from open list */
+  luaM_free(L, uv);  /* free upvalue */
+}
+
+
+void luaF_close (lua_State *L, StkId level) {
+  UpVal *uv;
+  global_State *g = G(L);
+  while (L->openupval != NULL && (uv = gco2uv(L->openupval))->v >= level) {
+    GCObject *o = obj2gco(uv);
+    lua_assert(!isblack(o) && uv->v != &uv->u.value);
+    L->openupval = uv->next;  /* remove from `open' list */
+    if (isdead(g, o))
+      luaF_freeupval(L, uv);  /* free upvalue */
+    else {
+      unlinkupval(uv);  /* remove upvalue from 'uvhead' list */
+      setobj(L, &uv->u.value, uv->v);  /* move value to upvalue slot */
+      uv->v = &uv->u.value;  /* now current value lives here */
+      gch(o)->next = g->allgc;  /* link upvalue into 'allgc' list */
+      g->allgc = o;
+      luaC_checkupvalcolor(g, uv);
+    }
+  }
+}
+
+
+Proto *luaF_newproto (lua_State *L) {
+  Proto *f = &luaC_newobj(L, LUA_TPROTO, sizeof(Proto), NULL, 0)->p;
+  f->k = NULL;
+  f->sizek = 0;
+  f->p = NULL;
+  f->sizep = 0;
+  f->code = NULL;
+  f->cache = NULL;
+  f->sizecode = 0;
+  f->lineinfo = NULL;
+  f->sizelineinfo = 0;
+  f->upvalues = NULL;
+  f->sizeupvalues = 0;
+  f->numparams = 0;
+  f->is_vararg = 0;
+  f->maxstacksize = 0;
+  f->locvars = NULL;
+  f->sizelocvars = 0;
+  f->linedefined = 0;
+  f->lastlinedefined = 0;
+  f->source = NULL;
+  return f;
+}
+
+
+void luaF_freeproto (lua_State *L, Proto *f) {
+  luaM_freearray(L, f->code, f->sizecode);
+  luaM_freearray(L, f->p, f->sizep);
+  luaM_freearray(L, f->k, f->sizek);
+  luaM_freearray(L, f->lineinfo, f->sizelineinfo);
+  luaM_freearray(L, f->locvars, f->sizelocvars);
+  luaM_freearray(L, f->upvalues, f->sizeupvalues);
+  luaM_free(L, f);
+}
+
+
+/*
+** Look for n-th local variable at line `line' in function `func'.
+** Returns NULL if not found.
+*/
+const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
+  int i;
+  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
+    if (pc < f->locvars[i].endpc) {  /* is variable active? */
+      local_number--;
+      if (local_number == 0)
+        return getstr(f->locvars[i].varname);
+    }
+  }
+  return NULL;  /* not found */
+}
+
diff --git a/dep/lualib/lfunc.h b/dep/lualib/lfunc.h
new file mode 100644
index 0000000..e236a71
--- /dev/null
+++ b/dep/lualib/lfunc.h
@@ -0,0 +1,33 @@
+/*
+** $Id: lfunc.h,v 2.8 2012/05/08 13:53:33 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lfunc_h
+#define lfunc_h
+
+
+#include "lobject.h"
+
+
+#define sizeCclosure(n)	(cast(int, sizeof(CClosure)) + \
+                         cast(int, sizeof(TValue)*((n)-1)))
+
+#define sizeLclosure(n)	(cast(int, sizeof(LClosure)) + \
+                         cast(int, sizeof(TValue *)*((n)-1)))
+
+
+LUAI_FUNC Proto *luaF_newproto (lua_State *L);
+LUAI_FUNC Closure *luaF_newCclosure (lua_State *L, int nelems);
+LUAI_FUNC Closure *luaF_newLclosure (lua_State *L, int nelems);
+LUAI_FUNC UpVal *luaF_newupval (lua_State *L);
+LUAI_FUNC UpVal *luaF_findupval (lua_State *L, StkId level);
+LUAI_FUNC void luaF_close (lua_State *L, StkId level);
+LUAI_FUNC void luaF_freeproto (lua_State *L, Proto *f);
+LUAI_FUNC void luaF_freeupval (lua_State *L, UpVal *uv);
+LUAI_FUNC const char *luaF_getlocalname (const Proto *func, int local_number,
+                                         int pc);
+
+
+#endif
diff --git a/dep/lualib/lgc.c b/dep/lualib/lgc.c
new file mode 100644
index 0000000..06f972a
--- /dev/null
+++ b/dep/lualib/lgc.c
@@ -0,0 +1,1205 @@
+/*
+** $Id: lgc.c,v 2.133 2012/05/31 21:28:59 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#include <string.h>
+
+#define lgc_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+
+/*
+** cost of sweeping one element (the size of a small object divided
+** by some adjust for the sweep speed)
+*/
+#define GCSWEEPCOST	((sizeof(TString) + 4) / 4)
+
+/* maximum number of elements to sweep in each single step */
+#define GCSWEEPMAX	(cast_int((GCSTEPSIZE / GCSWEEPCOST) / 4))
+
+/* maximum number of finalizers to call in each GC step */
+#define GCFINALIZENUM	4
+
+
+/*
+** macro to adjust 'stepmul': 'stepmul' is actually used like
+** 'stepmul / STEPMULADJ' (value chosen by tests)
+*/
+#define STEPMULADJ		200
+
+/*
+** macro to adjust 'pause': 'pause' is actually used like
+** 'pause / PAUSEADJ' (value chosen by tests)
+*/
+#define PAUSEADJ		200
+
+
+
+
+/*
+** standard negative debt for GC; a reasonable "time" to wait before
+** starting a new cycle
+*/
+#define stddebtest(g,e)	(-cast(l_mem, (e)/PAUSEADJ) * g->gcpause)
+#define stddebt(g)	stddebtest(g, gettotalbytes(g))
+
+
+/*
+** 'makewhite' erases all color bits plus the old bit and then
+** sets only the current white bit
+*/
+#define maskcolors	(~(bit2mask(BLACKBIT, OLDBIT) | WHITEBITS))
+#define makewhite(g,x)	\
+ (gch(x)->marked = cast_byte((gch(x)->marked & maskcolors) | luaC_white(g)))
+
+#define white2gray(x)	resetbits(gch(x)->marked, WHITEBITS)
+#define black2gray(x)	resetbit(gch(x)->marked, BLACKBIT)
+
+
+#define isfinalized(x)		testbit(gch(x)->marked, FINALIZEDBIT)
+
+#define checkdeadkey(n)	lua_assert(!ttisdeadkey(gkey(n)) || ttisnil(gval(n)))
+
+
+#define checkconsistency(obj)  \
+  lua_longassert(!iscollectable(obj) || righttt(obj))
+
+
+#define markvalue(g,o) { checkconsistency(o); \
+  if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }
+
+#define markobject(g,t) { if ((t) && iswhite(obj2gco(t))) \
+		reallymarkobject(g, obj2gco(t)); }
+
+static void reallymarkobject (global_State *g, GCObject *o);
+
+
+/*
+** {======================================================
+** Generic functions
+** =======================================================
+*/
+
+
+/*
+** one after last element in a hash array
+*/
+#define gnodelast(h)	gnode(h, cast(size_t, sizenode(h)))
+
+
+/*
+** link table 'h' into list pointed by 'p'
+*/
+#define linktable(h,p)	((h)->gclist = *(p), *(p) = obj2gco(h))
+
+
+/*
+** if key is not marked, mark its entry as dead (therefore removing it
+** from the table)
+*/
+static void removeentry (Node *n) {
+  lua_assert(ttisnil(gval(n)));
+  if (valiswhite(gkey(n)))
+    setdeadvalue(gkey(n));  /* unused and unmarked key; remove it */
+}
+
+
+/*
+** tells whether a key or value can be cleared from a weak
+** table. Non-collectable objects are never removed from weak
+** tables. Strings behave as `values', so are never removed too. for
+** other objects: if really collected, cannot keep them; for objects
+** being finalized, keep them in keys, but not in values
+*/
+static int iscleared (global_State *g, const TValue *o) {
+  if (!iscollectable(o)) return 0;
+  else if (ttisstring(o)) {
+    markobject(g, rawtsvalue(o));  /* strings are `values', so are never weak */
+    return 0;
+  }
+  else return iswhite(gcvalue(o));
+}
+
+
+/*
+** barrier that moves collector forward, that is, mark the white object
+** being pointed by a black object.
+*/
+void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {
+  global_State *g = G(L);
+  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
+  lua_assert(isgenerational(g) || g->gcstate != GCSpause);
+  lua_assert(gch(o)->tt != LUA_TTABLE);
+  if (keepinvariant(g))  /* must keep invariant? */
+    reallymarkobject(g, v);  /* restore invariant */
+  else {  /* sweep phase */
+    lua_assert(issweepphase(g));
+    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */
+  }
+}
+
+
+/*
+** barrier that moves collector backward, that is, mark the black object
+** pointing to a white object as gray again. (Current implementation
+** only works for tables; access to 'gclist' is not uniform across
+** different types.)
+*/
+void luaC_barrierback_ (lua_State *L, GCObject *o) {
+  global_State *g = G(L);
+  lua_assert(isblack(o) && !isdead(g, o) && gch(o)->tt == LUA_TTABLE);
+  black2gray(o);  /* make object gray (again) */
+  gco2t(o)->gclist = g->grayagain;
+  g->grayagain = o;
+}
+
+
+/*
+** barrier for prototypes. When creating first closure (cache is
+** NULL), use a forward barrier; this may be the only closure of the
+** prototype (if it is a "regular" function, with a single instance)
+** and the prototype may be big, so it is better to avoid traversing
+** it again. Otherwise, use a backward barrier, to avoid marking all
+** possible instances.
+*/
+LUAI_FUNC void luaC_barrierproto_ (lua_State *L, Proto *p, Closure *c) {
+  global_State *g = G(L);
+  lua_assert(isblack(obj2gco(p)));
+  if (p->cache == NULL) {  /* first time? */
+    luaC_objbarrier(L, p, c);
+  }
+  else {  /* use a backward barrier */
+    black2gray(obj2gco(p));  /* make prototype gray (again) */
+    p->gclist = g->grayagain;
+    g->grayagain = obj2gco(p);
+  }
+}
+
+
+/*
+** check color (and invariants) for an upvalue that was closed,
+** i.e., moved into the 'allgc' list
+*/
+void luaC_checkupvalcolor (global_State *g, UpVal *uv) {
+  GCObject *o = obj2gco(uv);
+  lua_assert(!isblack(o));  /* open upvalues are never black */
+  if (isgray(o)) {
+    if (keepinvariant(g)) {
+      resetoldbit(o);  /* see MOVE OLD rule */
+      gray2black(o);  /* it is being visited now */
+      markvalue(g, uv->v);
+    }
+    else {
+      lua_assert(issweepphase(g));
+      makewhite(g, o);
+    }
+  }
+}
+
+
+/*
+** create a new collectable object (with given type and size) and link
+** it to '*list'. 'offset' tells how many bytes to allocate before the
+** object itself (used only by states).
+*/
+GCObject *luaC_newobj (lua_State *L, int tt, size_t sz, GCObject **list,
+                       int offset) {
+  global_State *g = G(L);
+  char *raw = cast(char *, luaM_newobject(L, novariant(tt), sz));
+  GCObject *o = obj2gco(raw + offset);
+  if (list == NULL)
+    list = &g->allgc;  /* standard list for collectable objects */
+  gch(o)->marked = luaC_white(g);
+  gch(o)->tt = tt;
+  gch(o)->next = *list;
+  *list = o;
+  return o;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Mark functions
+** =======================================================
+*/
+
+
+/*
+** mark an object. Userdata, strings, and closed upvalues are visited
+** and turned black here. Other objects are marked gray and added
+** to appropriate list to be visited (and turned black) later. (Open
+** upvalues are already linked in 'headuv' list.)
+*/
+static void reallymarkobject (global_State *g, GCObject *o) {
+  lu_mem size;
+  white2gray(o);
+  switch (gch(o)->tt) {
+    case LUA_TSHRSTR:
+    case LUA_TLNGSTR: {
+      size = sizestring(gco2ts(o));
+      break;  /* nothing else to mark; make it black */
+    }
+    case LUA_TUSERDATA: {
+      Table *mt = gco2u(o)->metatable;
+      markobject(g, mt);
+      markobject(g, gco2u(o)->env);
+      size = sizeudata(gco2u(o));
+      break;
+    }
+    case LUA_TUPVAL: {
+      UpVal *uv = gco2uv(o);
+      markvalue(g, uv->v);
+      if (uv->v != &uv->u.value)  /* open? */
+        return;  /* open upvalues remain gray */
+      size = sizeof(UpVal);
+      break;
+    }
+    case LUA_TLCL: {
+      gco2lcl(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    case LUA_TCCL: {
+      gco2ccl(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    case LUA_TTABLE: {
+      linktable(gco2t(o), &g->gray);
+      return;
+    }
+    case LUA_TTHREAD: {
+      gco2th(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    case LUA_TPROTO: {
+      gco2p(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    default: lua_assert(0); return;
+  }
+  gray2black(o);
+  g->GCmemtrav += size;
+}
+
+
+/*
+** mark metamethods for basic types
+*/
+static void markmt (global_State *g) {
+  int i;
+  for (i=0; i < LUA_NUMTAGS; i++)
+    markobject(g, g->mt[i]);
+}
+
+
+/*
+** mark all objects in list of being-finalized
+*/
+static void markbeingfnz (global_State *g) {
+  GCObject *o;
+  for (o = g->tobefnz; o != NULL; o = gch(o)->next) {
+    makewhite(g, o);
+    reallymarkobject(g, o);
+  }
+}
+
+
+/*
+** mark all values stored in marked open upvalues. (See comment in
+** 'lstate.h'.)
+*/
+static void remarkupvals (global_State *g) {
+  UpVal *uv;
+  for (uv = g->uvhead.u.l.next; uv != &g->uvhead; uv = uv->u.l.next) {
+    if (isgray(obj2gco(uv)))
+      markvalue(g, uv->v);
+  }
+}
+
+
+/*
+** mark root set and reset all gray lists, to start a new
+** incremental (or full) collection
+*/
+static void markroot (global_State *g) {
+  g->gray = g->grayagain = NULL;
+  g->weak = g->allweak = g->ephemeron = NULL;
+  markobject(g, g->mainthread);
+  markvalue(g, &g->l_registry);
+  markmt(g);
+  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Traverse functions
+** =======================================================
+*/
+
+static void traverseweakvalue (global_State *g, Table *h) {
+  Node *n, *limit = gnodelast(h);
+  /* if there is array part, assume it may have white values (do not
+     traverse it just to check) */
+  int hasclears = (h->sizearray > 0);
+  for (n = gnode(h, 0); n < limit; n++) {
+    checkdeadkey(n);
+    if (ttisnil(gval(n)))  /* entry is empty? */
+      removeentry(n);  /* remove it */
+    else {
+      lua_assert(!ttisnil(gkey(n)));
+      markvalue(g, gkey(n));  /* mark key */
+      if (!hasclears && iscleared(g, gval(n)))  /* is there a white value? */
+        hasclears = 1;  /* table will have to be cleared */
+    }
+  }
+  if (hasclears)
+    linktable(h, &g->weak);  /* has to be cleared later */
+  else  /* no white values */
+    linktable(h, &g->grayagain);  /* no need to clean */
+}
+
+
+static int traverseephemeron (global_State *g, Table *h) {
+  int marked = 0;  /* true if an object is marked in this traversal */
+  int hasclears = 0;  /* true if table has white keys */
+  int prop = 0;  /* true if table has entry "white-key -> white-value" */
+  Node *n, *limit = gnodelast(h);
+  int i;
+  /* traverse array part (numeric keys are 'strong') */
+  for (i = 0; i < h->sizearray; i++) {
+    if (valiswhite(&h->array[i])) {
+      marked = 1;
+      reallymarkobject(g, gcvalue(&h->array[i]));
+    }
+  }
+  /* traverse hash part */
+  for (n = gnode(h, 0); n < limit; n++) {
+    checkdeadkey(n);
+    if (ttisnil(gval(n)))  /* entry is empty? */
+      removeentry(n);  /* remove it */
+    else if (iscleared(g, gkey(n))) {  /* key is not marked (yet)? */
+      hasclears = 1;  /* table must be cleared */
+      if (valiswhite(gval(n)))  /* value not marked yet? */
+        prop = 1;  /* must propagate again */
+    }
+    else if (valiswhite(gval(n))) {  /* value not marked yet? */
+      marked = 1;
+      reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */
+    }
+  }
+  if (prop)
+    linktable(h, &g->ephemeron);  /* have to propagate again */
+  else if (hasclears)  /* does table have white keys? */
+    linktable(h, &g->allweak);  /* may have to clean white keys */
+  else  /* no white keys */
+    linktable(h, &g->grayagain);  /* no need to clean */
+  return marked;
+}
+
+
+static void traversestrongtable (global_State *g, Table *h) {
+  Node *n, *limit = gnodelast(h);
+  int i;
+  for (i = 0; i < h->sizearray; i++)  /* traverse array part */
+    markvalue(g, &h->array[i]);
+  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */
+    checkdeadkey(n);
+    if (ttisnil(gval(n)))  /* entry is empty? */
+      removeentry(n);  /* remove it */
+    else {
+      lua_assert(!ttisnil(gkey(n)));
+      markvalue(g, gkey(n));  /* mark key */
+      markvalue(g, gval(n));  /* mark value */
+    }
+  }
+}
+
+
+static lu_mem traversetable (global_State *g, Table *h) {
+  const char *weakkey, *weakvalue;
+  const TValue *mode = gfasttm(g, h->metatable, TM_MODE);
+  markobject(g, h->metatable);
+  if (mode && ttisstring(mode) &&  /* is there a weak mode? */
+      ((weakkey = strchr(svalue(mode), 'k')),
+       (weakvalue = strchr(svalue(mode), 'v')),
+       (weakkey || weakvalue))) {  /* is really weak? */
+    black2gray(obj2gco(h));  /* keep table gray */
+    if (!weakkey)  /* strong keys? */
+      traverseweakvalue(g, h);
+    else if (!weakvalue)  /* strong values? */
+      traverseephemeron(g, h);
+    else  /* all weak */
+      linktable(h, &g->allweak);  /* nothing to traverse now */
+  }
+  else  /* not weak */
+    traversestrongtable(g, h);
+  return sizeof(Table) + sizeof(TValue) * h->sizearray +
+                         sizeof(Node) * sizenode(h);
+}
+
+
+static int traverseproto (global_State *g, Proto *f) {
+  int i;
+  if (f->cache && iswhite(obj2gco(f->cache)))
+    f->cache = NULL;  /* allow cache to be collected */
+  markobject(g, f->source);
+  for (i = 0; i < f->sizek; i++)  /* mark literals */
+    markvalue(g, &f->k[i]);
+  for (i = 0; i < f->sizeupvalues; i++)  /* mark upvalue names */
+    markobject(g, f->upvalues[i].name);
+  for (i = 0; i < f->sizep; i++)  /* mark nested protos */
+    markobject(g, f->p[i]);
+  for (i = 0; i < f->sizelocvars; i++)  /* mark local-variable names */
+    markobject(g, f->locvars[i].varname);
+  return sizeof(Proto) + sizeof(Instruction) * f->sizecode +
+                         sizeof(Proto *) * f->sizep +
+                         sizeof(TValue) * f->sizek +
+                         sizeof(int) * f->sizelineinfo +
+                         sizeof(LocVar) * f->sizelocvars +
+                         sizeof(Upvaldesc) * f->sizeupvalues;
+}
+
+
+static lu_mem traverseCclosure (global_State *g, CClosure *cl) {
+  int i;
+  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */
+    markvalue(g, &cl->upvalue[i]);
+  return sizeCclosure(cl->nupvalues);
+}
+
+static lu_mem traverseLclosure (global_State *g, LClosure *cl) {
+  int i;
+  markobject(g, cl->p);  /* mark its prototype */
+  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */
+    markobject(g, cl->upvals[i]);
+  return sizeLclosure(cl->nupvalues);
+}
+
+
+static lu_mem traversestack (global_State *g, lua_State *th) {
+  StkId o = th->stack;
+  if (o == NULL)
+    return 1;  /* stack not completely built yet */
+  for (; o < th->top; o++)
+    markvalue(g, o);
+  if (g->gcstate == GCSatomic) {  /* final traversal? */
+    StkId lim = th->stack + th->stacksize;  /* real end of stack */
+    for (; o < lim; o++)  /* clear not-marked stack slice */
+      setnilvalue(o);
+  }
+  return sizeof(lua_State) + sizeof(TValue) * th->stacksize;
+}
+
+
+/*
+** traverse one gray object, turning it to black (except for threads,
+** which are always gray).
+*/
+static void propagatemark (global_State *g) {
+  lu_mem size;
+  GCObject *o = g->gray;
+  lua_assert(isgray(o));
+  gray2black(o);
+  switch (gch(o)->tt) {
+    case LUA_TTABLE: {
+      Table *h = gco2t(o);
+      g->gray = h->gclist;  /* remove from 'gray' list */
+      size = traversetable(g, h);
+      break;
+    }
+    case LUA_TLCL: {
+      LClosure *cl = gco2lcl(o);
+      g->gray = cl->gclist;  /* remove from 'gray' list */
+      size = traverseLclosure(g, cl);
+      break;
+    }
+    case LUA_TCCL: {
+      CClosure *cl = gco2ccl(o);
+      g->gray = cl->gclist;  /* remove from 'gray' list */
+      size = traverseCclosure(g, cl);
+      break;
+    }
+    case LUA_TTHREAD: {
+      lua_State *th = gco2th(o);
+      g->gray = th->gclist;  /* remove from 'gray' list */
+      th->gclist = g->grayagain;
+      g->grayagain = o;  /* insert into 'grayagain' list */
+      black2gray(o);
+      size = traversestack(g, th);
+      break;
+    }
+    case LUA_TPROTO: {
+      Proto *p = gco2p(o);
+      g->gray = p->gclist;  /* remove from 'gray' list */
+      size = traverseproto(g, p);
+      break;
+    }
+    default: lua_assert(0); return;
+  }
+  g->GCmemtrav += size;
+}
+
+
+static void propagateall (global_State *g) {
+  while (g->gray) propagatemark(g);
+}
+
+
+static void propagatelist (global_State *g, GCObject *l) {
+  lua_assert(g->gray == NULL);  /* no grays left */
+  g->gray = l;
+  propagateall(g);  /* traverse all elements from 'l' */
+}
+
+/*
+** retraverse all gray lists. Because tables may be reinserted in other
+** lists when traversed, traverse the original lists to avoid traversing
+** twice the same table (which is not wrong, but inefficient)
+*/
+static void retraversegrays (global_State *g) {
+  GCObject *weak = g->weak;  /* save original lists */
+  GCObject *grayagain = g->grayagain;
+  GCObject *ephemeron = g->ephemeron;
+  g->weak = g->grayagain = g->ephemeron = NULL;
+  propagateall(g);  /* traverse main gray list */
+  propagatelist(g, grayagain);
+  propagatelist(g, weak);
+  propagatelist(g, ephemeron);
+}
+
+
+static void convergeephemerons (global_State *g) {
+  int changed;
+  do {
+    GCObject *w;
+    GCObject *next = g->ephemeron;  /* get ephemeron list */
+    g->ephemeron = NULL;  /* tables will return to this list when traversed */
+    changed = 0;
+    while ((w = next) != NULL) {
+      next = gco2t(w)->gclist;
+      if (traverseephemeron(g, gco2t(w))) {  /* traverse marked some value? */
+        propagateall(g);  /* propagate changes */
+        changed = 1;  /* will have to revisit all ephemeron tables */
+      }
+    }
+  } while (changed);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Sweep Functions
+** =======================================================
+*/
+
+
+/*
+** clear entries with unmarked keys from all weaktables in list 'l' up
+** to element 'f'
+*/
+static void clearkeys (global_State *g, GCObject *l, GCObject *f) {
+  for (; l != f; l = gco2t(l)->gclist) {
+    Table *h = gco2t(l);
+    Node *n, *limit = gnodelast(h);
+    for (n = gnode(h, 0); n < limit; n++) {
+      if (!ttisnil(gval(n)) && (iscleared(g, gkey(n)))) {
+        setnilvalue(gval(n));  /* remove value ... */
+        removeentry(n);  /* and remove entry from table */
+      }
+    }
+  }
+}
+
+
+/*
+** clear entries with unmarked values from all weaktables in list 'l' up
+** to element 'f'
+*/
+static void clearvalues (global_State *g, GCObject *l, GCObject *f) {
+  for (; l != f; l = gco2t(l)->gclist) {
+    Table *h = gco2t(l);
+    Node *n, *limit = gnodelast(h);
+    int i;
+    for (i = 0; i < h->sizearray; i++) {
+      TValue *o = &h->array[i];
+      if (iscleared(g, o))  /* value was collected? */
+        setnilvalue(o);  /* remove value */
+    }
+    for (n = gnode(h, 0); n < limit; n++) {
+      if (!ttisnil(gval(n)) && iscleared(g, gval(n))) {
+        setnilvalue(gval(n));  /* remove value ... */
+        removeentry(n);  /* and remove entry from table */
+      }
+    }
+  }
+}
+
+
+static void freeobj (lua_State *L, GCObject *o) {
+  switch (gch(o)->tt) {
+    case LUA_TPROTO: luaF_freeproto(L, gco2p(o)); break;
+    case LUA_TLCL: {
+      luaM_freemem(L, o, sizeLclosure(gco2lcl(o)->nupvalues));
+      break;
+    }
+    case LUA_TCCL: {
+      luaM_freemem(L, o, sizeCclosure(gco2ccl(o)->nupvalues));
+      break;
+    }
+    case LUA_TUPVAL: luaF_freeupval(L, gco2uv(o)); break;
+    case LUA_TTABLE: luaH_free(L, gco2t(o)); break;
+    case LUA_TTHREAD: luaE_freethread(L, gco2th(o)); break;
+    case LUA_TUSERDATA: luaM_freemem(L, o, sizeudata(gco2u(o))); break;
+    case LUA_TSHRSTR:
+      G(L)->strt.nuse--;
+      /* go through */
+    case LUA_TLNGSTR: {
+      luaM_freemem(L, o, sizestring(gco2ts(o)));
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+#define sweepwholelist(L,p)	sweeplist(L,p,MAX_LUMEM)
+static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count);
+
+
+/*
+** sweep the (open) upvalues of a thread and resize its stack and
+** list of call-info structures.
+*/
+static void sweepthread (lua_State *L, lua_State *L1) {
+  if (L1->stack == NULL) return;  /* stack not completely built yet */
+  sweepwholelist(L, &L1->openupval);  /* sweep open upvalues */
+  luaE_freeCI(L1);  /* free extra CallInfo slots */
+  /* should not change the stack during an emergency gc cycle */
+  if (G(L)->gckind != KGC_EMERGENCY)
+    luaD_shrinkstack(L1);
+}
+
+
+/*
+** sweep at most 'count' elements from a list of GCObjects erasing dead
+** objects, where a dead (not alive) object is one marked with the "old"
+** (non current) white and not fixed.
+** In non-generational mode, change all non-dead objects back to white,
+** preparing for next collection cycle.
+** In generational mode, keep black objects black, and also mark them as
+** old; stop when hitting an old object, as all objects after that
+** one will be old too.
+** When object is a thread, sweep its list of open upvalues too.
+*/
+static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {
+  global_State *g = G(L);
+  int ow = otherwhite(g);
+  int toclear, toset;  /* bits to clear and to set in all live objects */
+  int tostop;  /* stop sweep when this is true */
+  if (isgenerational(g)) {  /* generational mode? */
+    toclear = ~0;  /* clear nothing */
+    toset = bitmask(OLDBIT);  /* set the old bit of all surviving objects */
+    tostop = bitmask(OLDBIT);  /* do not sweep old generation */
+  }
+  else {  /* normal mode */
+    toclear = maskcolors;  /* clear all color bits + old bit */
+    toset = luaC_white(g);  /* make object white */
+    tostop = 0;  /* do not stop */
+  }
+  while (*p != NULL && count-- > 0) {
+    GCObject *curr = *p;
+    int marked = gch(curr)->marked;
+    if (isdeadm(ow, marked)) {  /* is 'curr' dead? */
+      *p = gch(curr)->next;  /* remove 'curr' from list */
+      freeobj(L, curr);  /* erase 'curr' */
+    }
+    else {
+      if (testbits(marked, tostop))
+        return NULL;  /* stop sweeping this list */
+      if (gch(curr)->tt == LUA_TTHREAD)
+        sweepthread(L, gco2th(curr));  /* sweep thread's upvalues */
+      /* update marks */
+      gch(curr)->marked = cast_byte((marked & toclear) | toset);
+      p = &gch(curr)->next;  /* go to next element */
+    }
+  }
+  return (*p == NULL) ? NULL : p;
+}
+
+
+/*
+** sweep a list until a live object (or end of list)
+*/
+static GCObject **sweeptolive (lua_State *L, GCObject **p, int *n) {
+  GCObject ** old = p;
+  int i = 0;
+  do {
+    i++;
+    p = sweeplist(L, p, 1);
+  } while (p == old);
+  if (n) *n += i;
+  return p;
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Finalization
+** =======================================================
+*/
+
+static void checkSizes (lua_State *L) {
+  global_State *g = G(L);
+  if (g->gckind != KGC_EMERGENCY) {  /* do not change sizes in emergency */
+    int hs = g->strt.size / 2;  /* half the size of the string table */
+    if (g->strt.nuse < cast(lu_int32, hs))  /* using less than that half? */
+      luaS_resize(L, hs);  /* halve its size */
+    luaZ_freebuffer(L, &g->buff);  /* free concatenation buffer */
+  }
+}
+
+
+static GCObject *udata2finalize (global_State *g) {
+  GCObject *o = g->tobefnz;  /* get first element */
+  lua_assert(isfinalized(o));
+  g->tobefnz = gch(o)->next;  /* remove it from 'tobefnz' list */
+  gch(o)->next = g->allgc;  /* return it to 'allgc' list */
+  g->allgc = o;
+  resetbit(gch(o)->marked, SEPARATED);  /* mark that it is not in 'tobefnz' */
+  lua_assert(!isold(o));  /* see MOVE OLD rule */
+  if (!keepinvariant(g))  /* not keeping invariant? */
+    makewhite(g, o);  /* "sweep" object */
+  return o;
+}
+
+
+static void dothecall (lua_State *L, void *ud) {
+  UNUSED(ud);
+  luaD_call(L, L->top - 2, 0, 0);
+}
+
+
+static void GCTM (lua_State *L, int propagateerrors) {
+  global_State *g = G(L);
+  const TValue *tm;
+  TValue v;
+  setgcovalue(L, &v, udata2finalize(g));
+  tm = luaT_gettmbyobj(L, &v, TM_GC);
+  if (tm != NULL && ttisfunction(tm)) {  /* is there a finalizer? */
+    int status;
+    lu_byte oldah = L->allowhook;
+    int running  = g->gcrunning;
+    L->allowhook = 0;  /* stop debug hooks during GC metamethod */
+    g->gcrunning = 0;  /* avoid GC steps */
+    setobj2s(L, L->top, tm);  /* push finalizer... */
+    setobj2s(L, L->top + 1, &v);  /* ... and its argument */
+    L->top += 2;  /* and (next line) call the finalizer */
+    status = luaD_pcall(L, dothecall, NULL, savestack(L, L->top - 2), 0);
+    L->allowhook = oldah;  /* restore hooks */
+    g->gcrunning = running;  /* restore state */
+    if (status != LUA_OK && propagateerrors) {  /* error while running __gc? */
+      if (status == LUA_ERRRUN) {  /* is there an error object? */
+        const char *msg = (ttisstring(L->top - 1))
+                            ? svalue(L->top - 1)
+                            : "no message";
+        luaO_pushfstring(L, "error in __gc metamethod (%s)", msg);
+        status = LUA_ERRGCMM;  /* error in __gc metamethod */
+      }
+      luaD_throw(L, status);  /* re-throw error */
+    }
+  }
+}
+
+
+/*
+** move all unreachable objects (or 'all' objects) that need
+** finalization from list 'finobj' to list 'tobefnz' (to be finalized)
+*/
+static void separatetobefnz (lua_State *L, int all) {
+  global_State *g = G(L);
+  GCObject **p = &g->finobj;
+  GCObject *curr;
+  GCObject **lastnext = &g->tobefnz;
+  /* find last 'next' field in 'tobefnz' list (to add elements in its end) */
+  while (*lastnext != NULL)
+    lastnext = &gch(*lastnext)->next;
+  while ((curr = *p) != NULL) {  /* traverse all finalizable objects */
+    lua_assert(!isfinalized(curr));
+    lua_assert(testbit(gch(curr)->marked, SEPARATED));
+    if (!(all || iswhite(curr)))  /* not being collected? */
+      p = &gch(curr)->next;  /* don't bother with it */
+    else {
+      l_setbit(gch(curr)->marked, FINALIZEDBIT); /* won't be finalized again */
+      *p = gch(curr)->next;  /* remove 'curr' from 'finobj' list */
+      gch(curr)->next = *lastnext;  /* link at the end of 'tobefnz' list */
+      *lastnext = curr;
+      lastnext = &gch(curr)->next;
+    }
+  }
+}
+
+
+/*
+** if object 'o' has a finalizer, remove it from 'allgc' list (must
+** search the list to find it) and link it in 'finobj' list.
+*/
+void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt) {
+  global_State *g = G(L);
+  if (testbit(gch(o)->marked, SEPARATED) || /* obj. is already separated... */
+      isfinalized(o) ||                           /* ... or is finalized... */
+      gfasttm(g, mt, TM_GC) == NULL)                /* or has no finalizer? */
+    return;  /* nothing to be done */
+  else {  /* move 'o' to 'finobj' list */
+    GCObject **p;
+    GCheader *ho = gch(o);
+    if (g->sweepgc == &ho->next) {  /* avoid removing current sweep object */
+      lua_assert(issweepphase(g));
+      g->sweepgc = sweeptolive(L, g->sweepgc, NULL);
+    }
+    /* search for pointer pointing to 'o' */
+    for (p = &g->allgc; *p != o; p = &gch(*p)->next) { /* empty */ }
+    *p = ho->next;  /* remove 'o' from root list */
+    ho->next = g->finobj;  /* link it in list 'finobj' */
+    g->finobj = o;
+    l_setbit(ho->marked, SEPARATED);  /* mark it as such */
+    if (!keepinvariant(g))  /* not keeping invariant? */
+      makewhite(g, o);  /* "sweep" object */
+    else
+      resetoldbit(o);  /* see MOVE OLD rule */
+  }
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** GC control
+** =======================================================
+*/
+
+
+#define sweepphases  \
+	(bitmask(GCSsweepstring) | bitmask(GCSsweepudata) | bitmask(GCSsweep))
+
+
+/*
+** enter first sweep phase (strings) and prepare pointers for other
+** sweep phases.  The calls to 'sweeptolive' make pointers point to an
+** object inside the list (instead of to the header), so that the real
+** sweep do not need to skip objects created between "now" and the start
+** of the real sweep.
+** Returns how many objects it sweeped.
+*/
+static int entersweep (lua_State *L) {
+  global_State *g = G(L);
+  int n = 0;
+  g->gcstate = GCSsweepstring;
+  lua_assert(g->sweepgc == NULL && g->sweepfin == NULL);
+  /* prepare to sweep strings, finalizable objects, and regular objects */
+  g->sweepstrgc = 0;
+  g->sweepfin = sweeptolive(L, &g->finobj, &n);
+  g->sweepgc = sweeptolive(L, &g->allgc, &n);
+  return n;
+}
+
+
+/*
+** change GC mode
+*/
+void luaC_changemode (lua_State *L, int mode) {
+  global_State *g = G(L);
+  if (mode == g->gckind) return;  /* nothing to change */
+  if (mode == KGC_GEN) {  /* change to generational mode */
+    /* make sure gray lists are consistent */
+    luaC_runtilstate(L, bitmask(GCSpropagate));
+    g->GCestimate = gettotalbytes(g);
+    g->gckind = KGC_GEN;
+  }
+  else {  /* change to incremental mode */
+    /* sweep all objects to turn them back to white
+       (as white has not changed, nothing extra will be collected) */
+    g->gckind = KGC_NORMAL;
+    entersweep(L);
+    luaC_runtilstate(L, ~sweepphases);
+  }
+}
+
+
+/*
+** call all pending finalizers
+*/
+static void callallpendingfinalizers (lua_State *L, int propagateerrors) {
+  global_State *g = G(L);
+  while (g->tobefnz) {
+    resetoldbit(g->tobefnz);
+    GCTM(L, propagateerrors);
+  }
+}
+
+
+void luaC_freeallobjects (lua_State *L) {
+  global_State *g = G(L);
+  int i;
+  separatetobefnz(L, 1);  /* separate all objects with finalizers */
+  lua_assert(g->finobj == NULL);
+  callallpendingfinalizers(L, 0);
+  g->currentwhite = WHITEBITS; /* this "white" makes all objects look dead */
+  g->gckind = KGC_NORMAL;
+  sweepwholelist(L, &g->finobj);  /* finalizers can create objs. in 'finobj' */
+  sweepwholelist(L, &g->allgc);
+  for (i = 0; i < g->strt.size; i++)  /* free all string lists */
+    sweepwholelist(L, &g->strt.hash[i]);
+  lua_assert(g->strt.nuse == 0);
+}
+
+
+static l_mem atomic (lua_State *L) {
+  global_State *g = G(L);
+  l_mem work = -g->GCmemtrav;  /* start counting work */
+  GCObject *origweak, *origall;
+  lua_assert(!iswhite(obj2gco(g->mainthread)));
+  markobject(g, L);  /* mark running thread */
+  /* registry and global metatables may be changed by API */
+  markvalue(g, &g->l_registry);
+  markmt(g);  /* mark basic metatables */
+  /* remark occasional upvalues of (maybe) dead threads */
+  remarkupvals(g);
+  propagateall(g);  /* propagate changes */
+  work += g->GCmemtrav;  /* stop counting (do not (re)count grays) */
+  /* traverse objects caught by write barrier and by 'remarkupvals' */
+  retraversegrays(g);
+  work -= g->GCmemtrav;  /* restart counting */
+  convergeephemerons(g);
+  /* at this point, all strongly accessible objects are marked. */
+  /* clear values from weak tables, before checking finalizers */
+  clearvalues(g, g->weak, NULL);
+  clearvalues(g, g->allweak, NULL);
+  origweak = g->weak; origall = g->allweak;
+  work += g->GCmemtrav;  /* stop counting (objects being finalized) */
+  separatetobefnz(L, 0);  /* separate objects to be finalized */
+  markbeingfnz(g);  /* mark objects that will be finalized */
+  propagateall(g);  /* remark, to propagate `preserveness' */
+  work -= g->GCmemtrav;  /* restart counting */
+  convergeephemerons(g);
+  /* at this point, all resurrected objects are marked. */
+  /* remove dead objects from weak tables */
+  clearkeys(g, g->ephemeron, NULL);  /* clear keys from all ephemeron tables */
+  clearkeys(g, g->allweak, NULL);  /* clear keys from all allweak tables */
+  /* clear values from resurrected weak tables */
+  clearvalues(g, g->weak, origweak);
+  clearvalues(g, g->allweak, origall);
+  g->currentwhite = cast_byte(otherwhite(g));  /* flip current white */
+  work += g->GCmemtrav;  /* complete counting */
+  return work;  /* estimate of memory marked by 'atomic' */
+}
+
+
+static lu_mem singlestep (lua_State *L) {
+  global_State *g = G(L);
+  switch (g->gcstate) {
+    case GCSpause: {
+      g->GCmemtrav = 0;  /* start to count memory traversed */
+      if (!isgenerational(g))
+        markroot(g);  /* start a new collection */
+      /* in any case, root must be marked at this point */
+      lua_assert(!iswhite(obj2gco(g->mainthread))
+              && !iswhite(gcvalue(&g->l_registry)));
+      g->gcstate = GCSpropagate;
+      return g->GCmemtrav;
+    }
+    case GCSpropagate: {
+      if (g->gray) {
+        lu_mem oldtrav = g->GCmemtrav;
+        propagatemark(g);
+        return g->GCmemtrav - oldtrav;  /* memory traversed in this step */
+      }
+      else {  /* no more `gray' objects */
+        lu_mem work;
+        int sw;
+        g->gcstate = GCSatomic;  /* finish mark phase */
+        g->GCestimate = g->GCmemtrav;  /* save what was counted */;
+        work = atomic(L);  /* add what was traversed by 'atomic' */
+        g->GCestimate += work;  /* estimate of total memory traversed */ 
+        sw = entersweep(L);
+        return work + sw * GCSWEEPCOST;
+      }
+    }
+    case GCSsweepstring: {
+      int i;
+      for (i = 0; i < GCSWEEPMAX && g->sweepstrgc + i < g->strt.size; i++)
+        sweepwholelist(L, &g->strt.hash[g->sweepstrgc + i]);
+      g->sweepstrgc += i;
+      if (g->sweepstrgc >= g->strt.size)  /* no more strings to sweep? */
+        g->gcstate = GCSsweepudata;
+      return i * GCSWEEPCOST;
+    }
+    case GCSsweepudata: {
+      if (g->sweepfin) {
+        g->sweepfin = sweeplist(L, g->sweepfin, GCSWEEPMAX);
+        return GCSWEEPMAX*GCSWEEPCOST;
+      }
+      else {
+        g->gcstate = GCSsweep;
+        return 0;
+      }
+    }
+    case GCSsweep: {
+      if (g->sweepgc) {
+        g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX);
+        return GCSWEEPMAX*GCSWEEPCOST;
+      }
+      else {
+        /* sweep main thread */
+        GCObject *mt = obj2gco(g->mainthread);
+        sweeplist(L, &mt, 1);
+        checkSizes(L);
+        g->gcstate = GCSpause;  /* finish collection */
+        return GCSWEEPCOST;
+      }
+    }
+    default: lua_assert(0); return 0;
+  }
+}
+
+
+/*
+** advances the garbage collector until it reaches a state allowed
+** by 'statemask'
+*/
+void luaC_runtilstate (lua_State *L, int statesmask) {
+  global_State *g = G(L);
+  while (!testbit(statesmask, g->gcstate))
+    singlestep(L);
+}
+
+
+static void generationalcollection (lua_State *L) {
+  global_State *g = G(L);
+  if (g->GCestimate == 0) {  /* signal for another major collection? */
+    luaC_fullgc(L, 0);  /* perform a full regular collection */
+    g->GCestimate = gettotalbytes(g);  /* update control */
+  }
+  else {
+    lu_mem estimate = g->GCestimate;
+    luaC_runtilstate(L, ~bitmask(GCSpause));  /* run complete cycle */
+    luaC_runtilstate(L, bitmask(GCSpause));
+    if (gettotalbytes(g) > (estimate / 100) * g->gcmajorinc)
+      g->GCestimate = 0;  /* signal for a major collection */
+  }
+  luaE_setdebt(g, stddebt(g));
+}
+
+
+static void incstep (lua_State *L) {
+  global_State *g = G(L);
+  l_mem debt = g->GCdebt;
+  int stepmul = g->gcstepmul;
+  if (stepmul < 40) stepmul = 40;  /* avoid ridiculous low values */
+  /* convert debt from Kb to 'work units' (avoid zero debt and overflows) */
+  debt = (debt / STEPMULADJ) + 1;
+  debt = (debt < MAX_LMEM / stepmul) ? debt * stepmul : MAX_LMEM;
+  do {  /* always perform at least one single step */
+    lu_mem work = singlestep(L);  /* do some work */
+    debt -= work;
+  } while (debt > -GCSTEPSIZE && g->gcstate != GCSpause);
+  if (g->gcstate == GCSpause)
+    debt = stddebtest(g, g->GCestimate);  /* pause until next cycle */
+  else
+    debt = (debt / stepmul) * STEPMULADJ;  /* convert 'work units' to Kb */
+  luaE_setdebt(g, debt);
+}
+
+
+/*
+** performs a basic GC step
+*/
+void luaC_forcestep (lua_State *L) {
+  global_State *g = G(L);
+  int i;
+  if (isgenerational(g)) generationalcollection(L);
+  else incstep(L);
+  /* run a few finalizers (or all of them at the end of a collect cycle) */
+  for (i = 0; g->tobefnz && (i < GCFINALIZENUM || g->gcstate == GCSpause); i++)
+    GCTM(L, 1);  /* call one finalizer */
+}
+
+
+/*
+** performs a basic GC step only if collector is running
+*/
+void luaC_step (lua_State *L) {
+  global_State *g = G(L);
+  if (g->gcrunning) luaC_forcestep(L);
+  else luaE_setdebt(g, -GCSTEPSIZE);  /* avoid being called too often */
+}
+
+
+
+/*
+** performs a full GC cycle; if "isemergency", does not call
+** finalizers (which could change stack positions)
+*/
+void luaC_fullgc (lua_State *L, int isemergency) {
+  global_State *g = G(L);
+  int origkind = g->gckind;
+  int someblack = keepinvariant(g);
+  lua_assert(origkind != KGC_EMERGENCY);
+  if (isemergency)  /* do not run finalizers during emergency GC */
+    g->gckind = KGC_EMERGENCY;
+  else {
+    g->gckind = KGC_NORMAL;
+    callallpendingfinalizers(L, 1);
+  }
+  if (someblack) {  /* may there be some black objects? */
+    /* must sweep all objects to turn them back to white
+       (as white has not changed, nothing will be collected) */
+    entersweep(L);
+  }
+  /* finish any pending sweep phase to start a new cycle */
+  luaC_runtilstate(L, bitmask(GCSpause));
+  /* run entire collector */
+  luaC_runtilstate(L, ~bitmask(GCSpause));
+  luaC_runtilstate(L, bitmask(GCSpause));
+  if (origkind == KGC_GEN) {  /* generational mode? */
+    /* generational mode must always start in propagate phase */
+    luaC_runtilstate(L, bitmask(GCSpropagate));
+  }
+  g->gckind = origkind;
+  luaE_setdebt(g, stddebt(g));
+  if (!isemergency)   /* do not run finalizers during emergency GC */
+    callallpendingfinalizers(L, 1);
+}
+
+/* }====================================================== */
+
+
diff --git a/dep/lualib/lgc.h b/dep/lualib/lgc.h
new file mode 100644
index 0000000..bdd5cce
--- /dev/null
+++ b/dep/lualib/lgc.h
@@ -0,0 +1,147 @@
+/*
+** $Id: lgc.h,v 2.56 2012/05/23 15:43:14 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lgc_h
+#define lgc_h
+
+
+#include "lobject.h"
+#include "lstate.h"
+
+/*
+** Collectable objects may have one of three colors: white, which
+** means the object is not marked; gray, which means the
+** object is marked, but its references may be not marked; and
+** black, which means that the object and all its references are marked.
+** The main invariant of the garbage collector, while marking objects,
+** is that a black object can never point to a white one. Moreover,
+** any gray object must be in a "gray list" (gray, grayagain, weak,
+** allweak, ephemeron) so that it can be visited again before finishing
+** the collection cycle. These lists have no meaning when the invariant
+** is not being enforced (e.g., sweep phase).
+*/
+
+
+
+/* how much to allocate before next GC step */
+#if !defined(GCSTEPSIZE)
+/* ~100 small strings */
+#define GCSTEPSIZE	(cast_int(100 * sizeof(TString)))
+#endif
+
+
+/*
+** Possible states of the Garbage Collector
+*/
+#define GCSpropagate	0
+#define GCSatomic	1
+#define GCSsweepstring	2
+#define GCSsweepudata	3
+#define GCSsweep	4
+#define GCSpause	5
+
+
+#define issweepphase(g)  \
+	(GCSsweepstring <= (g)->gcstate && (g)->gcstate <= GCSsweep)
+
+#define isgenerational(g)	((g)->gckind == KGC_GEN)
+
+/*
+** macro to tell when main invariant (white objects cannot point to black
+** ones) must be kept. During a non-generational collection, the sweep
+** phase may break the invariant, as objects turned white may point to
+** still-black objects. The invariant is restored when sweep ends and
+** all objects are white again. During a generational collection, the
+** invariant must be kept all times.
+*/
+#define keepinvariant(g)  (isgenerational(g) || g->gcstate <= GCSatomic)
+
+
+/*
+** some useful bit tricks
+*/
+#define resetbits(x,m)		((x) &= cast(lu_byte, ~(m)))
+#define setbits(x,m)		((x) |= (m))
+#define testbits(x,m)		((x) & (m))
+#define bitmask(b)		(1<<(b))
+#define bit2mask(b1,b2)		(bitmask(b1) | bitmask(b2))
+#define l_setbit(x,b)		setbits(x, bitmask(b))
+#define resetbit(x,b)		resetbits(x, bitmask(b))
+#define testbit(x,b)		testbits(x, bitmask(b))
+
+
+/* Layout for bit use in `marked' field: */
+#define WHITE0BIT	0  /* object is white (type 0) */
+#define WHITE1BIT	1  /* object is white (type 1) */
+#define BLACKBIT	2  /* object is black */
+#define FINALIZEDBIT	3  /* object has been separated for finalization */
+#define SEPARATED	4  /* object is in 'finobj' list or in 'tobefnz' */
+#define FIXEDBIT	5  /* object is fixed (should not be collected) */
+#define OLDBIT		6  /* object is old (only in generational mode) */
+/* bit 7 is currently used by tests (luaL_checkmemory) */
+
+#define WHITEBITS	bit2mask(WHITE0BIT, WHITE1BIT)
+
+
+#define iswhite(x)      testbits((x)->gch.marked, WHITEBITS)
+#define isblack(x)      testbit((x)->gch.marked, BLACKBIT)
+#define isgray(x)  /* neither white nor black */  \
+	(!testbits((x)->gch.marked, WHITEBITS | bitmask(BLACKBIT)))
+
+#define isold(x)	testbit((x)->gch.marked, OLDBIT)
+
+/* MOVE OLD rule: whenever an object is moved to the beginning of
+   a GC list, its old bit must be cleared */
+#define resetoldbit(o)	resetbit((o)->gch.marked, OLDBIT)
+
+#define otherwhite(g)	(g->currentwhite ^ WHITEBITS)
+#define isdeadm(ow,m)	(!(((m) ^ WHITEBITS) & (ow)))
+#define isdead(g,v)	isdeadm(otherwhite(g), (v)->gch.marked)
+
+#define changewhite(x)	((x)->gch.marked ^= WHITEBITS)
+#define gray2black(x)	l_setbit((x)->gch.marked, BLACKBIT)
+
+#define valiswhite(x)	(iscollectable(x) && iswhite(gcvalue(x)))
+
+#define luaC_white(g)	cast(lu_byte, (g)->currentwhite & WHITEBITS)
+
+
+#define luaC_condGC(L,c) \
+	{if (G(L)->GCdebt > 0) {c;}; condchangemem(L);}
+#define luaC_checkGC(L)		luaC_condGC(L, luaC_step(L);)
+
+
+#define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
+	luaC_barrier_(L,obj2gco(p),gcvalue(v)); }
+
+#define luaC_barrierback(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
+	luaC_barrierback_(L,p); }
+
+#define luaC_objbarrier(L,p,o)  \
+	{ if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) \
+		luaC_barrier_(L,obj2gco(p),obj2gco(o)); }
+
+#define luaC_objbarrierback(L,p,o)  \
+   { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierback_(L,p); }
+
+#define luaC_barrierproto(L,p,c) \
+   { if (isblack(obj2gco(p))) luaC_barrierproto_(L,p,c); }
+
+LUAI_FUNC void luaC_freeallobjects (lua_State *L);
+LUAI_FUNC void luaC_step (lua_State *L);
+LUAI_FUNC void luaC_forcestep (lua_State *L);
+LUAI_FUNC void luaC_runtilstate (lua_State *L, int statesmask);
+LUAI_FUNC void luaC_fullgc (lua_State *L, int isemergency);
+LUAI_FUNC GCObject *luaC_newobj (lua_State *L, int tt, size_t sz,
+                                 GCObject **list, int offset);
+LUAI_FUNC void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v);
+LUAI_FUNC void luaC_barrierback_ (lua_State *L, GCObject *o);
+LUAI_FUNC void luaC_barrierproto_ (lua_State *L, Proto *p, Closure *c);
+LUAI_FUNC void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt);
+LUAI_FUNC void luaC_checkupvalcolor (global_State *g, UpVal *uv);
+LUAI_FUNC void luaC_changemode (lua_State *L, int mode);
+
+#endif
diff --git a/dep/lualib/linit.c b/dep/lualib/linit.c
new file mode 100644
index 0000000..8d3aa65
--- /dev/null
+++ b/dep/lualib/linit.c
@@ -0,0 +1,67 @@
+/*
+** $Id: linit.c,v 1.32 2011/04/08 19:17:36 roberto Exp $
+** Initialization of libraries for lua.c and other clients
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** If you embed Lua in your program and need to open the standard
+** libraries, call luaL_openlibs in your program. If you need a
+** different set of libraries, copy this file to your project and edit
+** it to suit your needs.
+*/
+
+
+#define linit_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lualib.h"
+#include "lauxlib.h"
+
+
+/*
+** these libs are loaded by lua.c and are readily available to any Lua
+** program
+*/
+static const luaL_Reg loadedlibs[] = {
+  {"_G", luaopen_base},
+  {LUA_LOADLIBNAME, luaopen_package},
+  {LUA_COLIBNAME, luaopen_coroutine},
+  {LUA_TABLIBNAME, luaopen_table},
+  {LUA_IOLIBNAME, luaopen_io},
+  {LUA_OSLIBNAME, luaopen_os},
+  {LUA_STRLIBNAME, luaopen_string},
+  {LUA_BITLIBNAME, luaopen_bit32},
+  {LUA_MATHLIBNAME, luaopen_math},
+  {LUA_DBLIBNAME, luaopen_debug},
+  {NULL, NULL}
+};
+
+
+/*
+** these libs are preloaded and must be required before used
+*/
+static const luaL_Reg preloadedlibs[] = {
+  {NULL, NULL}
+};
+
+
+LUALIB_API void luaL_openlibs (lua_State *L) {
+  const luaL_Reg *lib;
+  /* call open functions from 'loadedlibs' and set results to global table */
+  for (lib = loadedlibs; lib->func; lib++) {
+    luaL_requiref(L, lib->name, lib->func, 1);
+    lua_pop(L, 1);  /* remove lib */
+  }
+  /* add open functions from 'preloadedlibs' into 'package.preload' table */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_PRELOAD");
+  for (lib = preloadedlibs; lib->func; lib++) {
+    lua_pushcfunction(L, lib->func);
+    lua_setfield(L, -2, lib->name);
+  }
+  lua_pop(L, 1);  /* remove _PRELOAD table */
+}
+
diff --git a/dep/lualib/liolib.c b/dep/lualib/liolib.c
new file mode 100644
index 0000000..4814aa2
--- /dev/null
+++ b/dep/lualib/liolib.c
@@ -0,0 +1,657 @@
+/*
+** $Id: liolib.c,v 2.108 2011/11/25 12:50:03 roberto Exp $
+** Standard I/O (and system) library
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** POSIX idiosyncrasy!
+** This definition must come before the inclusion of 'stdio.h'; it
+** should not affect non-POSIX systems
+*/
+#if !defined(_FILE_OFFSET_BITS)
+#define _FILE_OFFSET_BITS 64
+#endif
+
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define liolib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+
+/*
+** {======================================================
+** lua_popen spawns a new process connected to the current
+** one through the file streams.
+** =======================================================
+*/
+
+#if !defined(lua_popen)	/* { */
+
+#if defined(LUA_USE_POPEN)	/* { */
+
+#define lua_popen(L,c,m)	((void)L, fflush(NULL), popen(c,m))
+#define lua_pclose(L,file)	((void)L, pclose(file))
+
+#elif defined(LUA_WIN)		/* }{ */
+
+#define lua_popen(L,c,m)		((void)L, _popen(c,m))
+#define lua_pclose(L,file)		((void)L, _pclose(file))
+
+
+#else				/* }{ */
+
+#define lua_popen(L,c,m)		((void)((void)c, m),  \
+		luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
+#define lua_pclose(L,file)		((void)((void)L, file), -1)
+
+
+#endif				/* } */
+
+#endif			/* } */
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** lua_fseek/lua_ftell: configuration for longer offsets
+** =======================================================
+*/
+
+#if !defined(lua_fseek)	/* { */
+
+#if defined(LUA_USE_POSIX)
+
+#define l_fseek(f,o,w)		fseeko(f,o,w)
+#define l_ftell(f)		ftello(f)
+#define l_seeknum		off_t
+
+#elif defined(LUA_WIN) && !defined(_CRTIMP_TYPEINFO) \
+   && defined(_MSC_VER) && (_MSC_VER >= 1400)
+/* Windows (but not DDK) and Visual C++ 2005 or higher */
+
+#define l_fseek(f,o,w)		_fseeki64(f,o,w)
+#define l_ftell(f)		_ftelli64(f)
+#define l_seeknum		__int64
+
+#else
+
+#define l_fseek(f,o,w)		fseek(f,o,w)
+#define l_ftell(f)		ftell(f)
+#define l_seeknum		long
+
+#endif
+
+#endif			/* } */
+
+/* }====================================================== */
+
+
+#define IO_PREFIX	"_IO_"
+#define IO_INPUT	(IO_PREFIX "input")
+#define IO_OUTPUT	(IO_PREFIX "output")
+
+
+typedef luaL_Stream LStream;
+
+
+#define tolstream(L)	((LStream *)luaL_checkudata(L, 1, LUA_FILEHANDLE))
+
+#define isclosed(p)	((p)->closef == NULL)
+
+
+static int io_type (lua_State *L) {
+  LStream *p;
+  luaL_checkany(L, 1);
+  p = (LStream *)luaL_testudata(L, 1, LUA_FILEHANDLE);
+  if (p == NULL)
+    lua_pushnil(L);  /* not a file */
+  else if (isclosed(p))
+    lua_pushliteral(L, "closed file");
+  else
+    lua_pushliteral(L, "file");
+  return 1;
+}
+
+
+static int f_tostring (lua_State *L) {
+  LStream *p = tolstream(L);
+  if (isclosed(p))
+    lua_pushliteral(L, "file (closed)");
+  else
+    lua_pushfstring(L, "file (%p)", p->f);
+  return 1;
+}
+
+
+static FILE *tofile (lua_State *L) {
+  LStream *p = tolstream(L);
+  if (isclosed(p))
+    luaL_error(L, "attempt to use a closed file");
+  lua_assert(p->f);
+  return p->f;
+}
+
+
+/*
+** When creating file handles, always creates a `closed' file handle
+** before opening the actual file; so, if there is a memory error, the
+** file is not left opened.
+*/
+static LStream *newprefile (lua_State *L) {
+  LStream *p = (LStream *)lua_newuserdata(L, sizeof(LStream));
+  p->closef = NULL;  /* mark file handle as 'closed' */
+  luaL_setmetatable(L, LUA_FILEHANDLE);
+  return p;
+}
+
+
+static int aux_close (lua_State *L) {
+  LStream *p = tolstream(L);
+  lua_CFunction cf = p->closef;
+  p->closef = NULL;  /* mark stream as closed */
+  return (*cf)(L);  /* close it */
+}
+
+
+static int io_close (lua_State *L) {
+  if (lua_isnone(L, 1))  /* no argument? */
+    lua_getfield(L, LUA_REGISTRYINDEX, IO_OUTPUT);  /* use standard output */
+  tofile(L);  /* make sure argument is an open stream */
+  return aux_close(L);
+}
+
+
+static int f_gc (lua_State *L) {
+  LStream *p = tolstream(L);
+  if (!isclosed(p) && p->f != NULL)
+    aux_close(L);  /* ignore closed and incompletely open files */
+  return 0;
+}
+
+
+/*
+** function to close regular files
+*/
+static int io_fclose (lua_State *L) {
+  LStream *p = tolstream(L);
+  int res = fclose(p->f);
+  return luaL_fileresult(L, (res == 0), NULL);
+}
+
+
+static LStream *newfile (lua_State *L) {
+  LStream *p = newprefile(L);
+  p->f = NULL;
+  p->closef = &io_fclose;
+  return p;
+}
+
+
+static void opencheck (lua_State *L, const char *fname, const char *mode) {
+  LStream *p = newfile(L);
+  p->f = fopen(fname, mode);
+  if (p->f == NULL)
+    luaL_error(L, "cannot open file " LUA_QS " (%s)", fname, strerror(errno));
+}
+
+
+static int io_open (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, "r");
+  LStream *p = newfile(L);
+  int i = 0;
+  /* check whether 'mode' matches '[rwa]%+?b?' */
+  if (!(mode[i] != '\0' && strchr("rwa", mode[i++]) != NULL &&
+       (mode[i] != '+' || ++i) &&  /* skip if char is '+' */
+       (mode[i] != 'b' || ++i) &&  /* skip if char is 'b' */
+       (mode[i] == '\0')))
+    return luaL_error(L, "invalid mode " LUA_QS
+                         " (should match " LUA_QL("[rwa]%%+?b?") ")", mode);
+  p->f = fopen(filename, mode);
+  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
+}
+
+
+/*
+** function to close 'popen' files
+*/
+static int io_pclose (lua_State *L) {
+  LStream *p = tolstream(L);
+  return luaL_execresult(L, lua_pclose(L, p->f));
+}
+
+
+static int io_popen (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, "r");
+  LStream *p = newprefile(L);
+  p->f = lua_popen(L, filename, mode);
+  p->closef = &io_pclose;
+  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
+}
+
+
+static int io_tmpfile (lua_State *L) {
+  LStream *p = newfile(L);
+  p->f = tmpfile();
+  return (p->f == NULL) ? luaL_fileresult(L, 0, NULL) : 1;
+}
+
+
+static FILE *getiofile (lua_State *L, const char *findex) {
+  LStream *p;
+  lua_getfield(L, LUA_REGISTRYINDEX, findex);
+  p = (LStream *)lua_touserdata(L, -1);
+  if (isclosed(p))
+    luaL_error(L, "standard %s file is closed", findex + strlen(IO_PREFIX));
+  return p->f;
+}
+
+
+static int g_iofile (lua_State *L, const char *f, const char *mode) {
+  if (!lua_isnoneornil(L, 1)) {
+    const char *filename = lua_tostring(L, 1);
+    if (filename)
+      opencheck(L, filename, mode);
+    else {
+      tofile(L);  /* check that it's a valid file handle */
+      lua_pushvalue(L, 1);
+    }
+    lua_setfield(L, LUA_REGISTRYINDEX, f);
+  }
+  /* return current value */
+  lua_getfield(L, LUA_REGISTRYINDEX, f);
+  return 1;
+}
+
+
+static int io_input (lua_State *L) {
+  return g_iofile(L, IO_INPUT, "r");
+}
+
+
+static int io_output (lua_State *L) {
+  return g_iofile(L, IO_OUTPUT, "w");
+}
+
+
+static int io_readline (lua_State *L);
+
+
+static void aux_lines (lua_State *L, int toclose) {
+  int i;
+  int n = lua_gettop(L) - 1;  /* number of arguments to read */
+  /* ensure that arguments will fit here and into 'io_readline' stack */
+  luaL_argcheck(L, n <= LUA_MINSTACK - 3, LUA_MINSTACK - 3, "too many options");
+  lua_pushvalue(L, 1);  /* file handle */
+  lua_pushinteger(L, n);  /* number of arguments to read */
+  lua_pushboolean(L, toclose);  /* close/not close file when finished */
+  for (i = 1; i <= n; i++) lua_pushvalue(L, i + 1);  /* copy arguments */
+  lua_pushcclosure(L, io_readline, 3 + n);
+}
+
+
+static int f_lines (lua_State *L) {
+  tofile(L);  /* check that it's a valid file handle */
+  aux_lines(L, 0);
+  return 1;
+}
+
+
+static int io_lines (lua_State *L) {
+  int toclose;
+  if (lua_isnone(L, 1)) lua_pushnil(L);  /* at least one argument */
+  if (lua_isnil(L, 1)) {  /* no file name? */
+    lua_getfield(L, LUA_REGISTRYINDEX, IO_INPUT);  /* get default input */
+    lua_replace(L, 1);  /* put it at index 1 */
+    tofile(L);  /* check that it's a valid file handle */
+    toclose = 0;  /* do not close it after iteration */
+  }
+  else {  /* open a new file */
+    const char *filename = luaL_checkstring(L, 1);
+    opencheck(L, filename, "r");
+    lua_replace(L, 1);  /* put file at index 1 */
+    toclose = 1;  /* close it after iteration */
+  }
+  aux_lines(L, toclose);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** READ
+** =======================================================
+*/
+
+
+static int read_number (lua_State *L, FILE *f) {
+  lua_Number d;
+  if (fscanf(f, LUA_NUMBER_SCAN, &d) == 1) {
+    lua_pushnumber(L, d);
+    return 1;
+  }
+  else {
+   lua_pushnil(L);  /* "result" to be removed */
+   return 0;  /* read fails */
+  }
+}
+
+
+static int test_eof (lua_State *L, FILE *f) {
+  int c = getc(f);
+  ungetc(c, f);
+  lua_pushlstring(L, NULL, 0);
+  return (c != EOF);
+}
+
+
+static int read_line (lua_State *L, FILE *f, int chop) {
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  for (;;) {
+    size_t l;
+    char *p = luaL_prepbuffer(&b);
+    if (fgets(p, LUAL_BUFFERSIZE, f) == NULL) {  /* eof? */
+      luaL_pushresult(&b);  /* close buffer */
+      return (lua_rawlen(L, -1) > 0);  /* check whether read something */
+    }
+    l = strlen(p);
+    if (l == 0 || p[l-1] != '\n')
+      luaL_addsize(&b, l);
+    else {
+      luaL_addsize(&b, l - chop);  /* chop 'eol' if needed */
+      luaL_pushresult(&b);  /* close buffer */
+      return 1;  /* read at least an `eol' */
+    }
+  }
+}
+
+
+#define MAX_SIZE_T	(~(size_t)0)
+
+static void read_all (lua_State *L, FILE *f) {
+  size_t rlen = LUAL_BUFFERSIZE;  /* how much to read in each cycle */
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  for (;;) {
+    char *p = luaL_prepbuffsize(&b, rlen);
+    size_t nr = fread(p, sizeof(char), rlen, f);
+    luaL_addsize(&b, nr);
+    if (nr < rlen) break;  /* eof? */
+    else if (rlen <= (MAX_SIZE_T / 4))  /* avoid buffers too large */
+      rlen *= 2;  /* double buffer size at each iteration */
+  }
+  luaL_pushresult(&b);  /* close buffer */
+}
+
+
+static int read_chars (lua_State *L, FILE *f, size_t n) {
+  size_t nr;  /* number of chars actually read */
+  char *p;
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  p = luaL_prepbuffsize(&b, n);  /* prepare buffer to read whole block */
+  nr = fread(p, sizeof(char), n, f);  /* try to read 'n' chars */
+  luaL_addsize(&b, nr);
+  luaL_pushresult(&b);  /* close buffer */
+  return (nr > 0);  /* true iff read something */
+}
+
+
+static int g_read (lua_State *L, FILE *f, int first) {
+  int nargs = lua_gettop(L) - 1;
+  int success;
+  int n;
+  clearerr(f);
+  if (nargs == 0) {  /* no arguments? */
+    success = read_line(L, f, 1);
+    n = first+1;  /* to return 1 result */
+  }
+  else {  /* ensure stack space for all results and for auxlib's buffer */
+    luaL_checkstack(L, nargs+LUA_MINSTACK, "too many arguments");
+    success = 1;
+    for (n = first; nargs-- && success; n++) {
+      if (lua_type(L, n) == LUA_TNUMBER) {
+        size_t l = (size_t)lua_tointeger(L, n);
+        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
+      }
+      else {
+        const char *p = lua_tostring(L, n);
+        luaL_argcheck(L, p && p[0] == '*', n, "invalid option");
+        switch (p[1]) {
+          case 'n':  /* number */
+            success = read_number(L, f);
+            break;
+          case 'l':  /* line */
+            success = read_line(L, f, 1);
+            break;
+          case 'L':  /* line with end-of-line */
+            success = read_line(L, f, 0);
+            break;
+          case 'a':  /* file */
+            read_all(L, f);  /* read entire file */
+            success = 1; /* always success */
+            break;
+          default:
+            return luaL_argerror(L, n, "invalid format");
+        }
+      }
+    }
+  }
+  if (ferror(f))
+    return luaL_fileresult(L, 0, NULL);
+  if (!success) {
+    lua_pop(L, 1);  /* remove last result */
+    lua_pushnil(L);  /* push nil instead */
+  }
+  return n - first;
+}
+
+
+static int io_read (lua_State *L) {
+  return g_read(L, getiofile(L, IO_INPUT), 1);
+}
+
+
+static int f_read (lua_State *L) {
+  return g_read(L, tofile(L), 2);
+}
+
+
+static int io_readline (lua_State *L) {
+  LStream *p = (LStream *)lua_touserdata(L, lua_upvalueindex(1));
+  int i;
+  int n = (int)lua_tointeger(L, lua_upvalueindex(2));
+  if (isclosed(p))  /* file is already closed? */
+    return luaL_error(L, "file is already closed");
+  lua_settop(L , 1);
+  for (i = 1; i <= n; i++)  /* push arguments to 'g_read' */
+    lua_pushvalue(L, lua_upvalueindex(3 + i));
+  n = g_read(L, p->f, 2);  /* 'n' is number of results */
+  lua_assert(n > 0);  /* should return at least a nil */
+  if (!lua_isnil(L, -n))  /* read at least one value? */
+    return n;  /* return them */
+  else {  /* first result is nil: EOF or error */
+    if (n > 1) {  /* is there error information? */
+      /* 2nd result is error message */
+      return luaL_error(L, "%s", lua_tostring(L, -n + 1));
+    }
+    if (lua_toboolean(L, lua_upvalueindex(3))) {  /* generator created file? */
+      lua_settop(L, 0);
+      lua_pushvalue(L, lua_upvalueindex(1));
+      aux_close(L);  /* close it */
+    }
+    return 0;
+  }
+}
+
+/* }====================================================== */
+
+
+static int g_write (lua_State *L, FILE *f, int arg) {
+  int nargs = lua_gettop(L) - arg;
+  int status = 1;
+  for (; nargs--; arg++) {
+    if (lua_type(L, arg) == LUA_TNUMBER) {
+      /* optimization: could be done exactly as for strings */
+      status = status &&
+          fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;
+    }
+    else {
+      size_t l;
+      const char *s = luaL_checklstring(L, arg, &l);
+      status = status && (fwrite(s, sizeof(char), l, f) == l);
+    }
+  }
+  if (status) return 1;  /* file handle already on stack top */
+  else return luaL_fileresult(L, status, NULL);
+}
+
+
+static int io_write (lua_State *L) {
+  return g_write(L, getiofile(L, IO_OUTPUT), 1);
+}
+
+
+static int f_write (lua_State *L) {
+  FILE *f = tofile(L);
+  lua_pushvalue(L, 1);  /* push file at the stack top (to be returned) */
+  return g_write(L, f, 2);
+}
+
+
+static int f_seek (lua_State *L) {
+  static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};
+  static const char *const modenames[] = {"set", "cur", "end", NULL};
+  FILE *f = tofile(L);
+  int op = luaL_checkoption(L, 2, "cur", modenames);
+  lua_Number p3 = luaL_optnumber(L, 3, 0);
+  l_seeknum offset = (l_seeknum)p3;
+  luaL_argcheck(L, (lua_Number)offset == p3, 3,
+                  "not an integer in proper range");
+  op = l_fseek(f, offset, mode[op]);
+  if (op)
+    return luaL_fileresult(L, 0, NULL);  /* error */
+  else {
+    lua_pushnumber(L, (lua_Number)l_ftell(f));
+    return 1;
+  }
+}
+
+
+static int f_setvbuf (lua_State *L) {
+  static const int mode[] = {_IONBF, _IOFBF, _IOLBF};
+  static const char *const modenames[] = {"no", "full", "line", NULL};
+  FILE *f = tofile(L);
+  int op = luaL_checkoption(L, 2, NULL, modenames);
+  lua_Integer sz = luaL_optinteger(L, 3, LUAL_BUFFERSIZE);
+  int res = setvbuf(f, NULL, mode[op], sz);
+  return luaL_fileresult(L, res == 0, NULL);
+}
+
+
+
+static int io_flush (lua_State *L) {
+  return luaL_fileresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
+}
+
+
+static int f_flush (lua_State *L) {
+  return luaL_fileresult(L, fflush(tofile(L)) == 0, NULL);
+}
+
+
+/*
+** functions for 'io' library
+*/
+static const luaL_Reg iolib[] = {
+  {"close", io_close},
+  {"flush", io_flush},
+  {"input", io_input},
+  {"lines", io_lines},
+  {"open", io_open},
+  {"output", io_output},
+  {"popen", io_popen},
+  {"read", io_read},
+  {"tmpfile", io_tmpfile},
+  {"type", io_type},
+  {"write", io_write},
+  {NULL, NULL}
+};
+
+
+/*
+** methods for file handles
+*/
+static const luaL_Reg flib[] = {
+  {"close", io_close},
+  {"flush", f_flush},
+  {"lines", f_lines},
+  {"read", f_read},
+  {"seek", f_seek},
+  {"setvbuf", f_setvbuf},
+  {"write", f_write},
+  {"__gc", f_gc},
+  {"__tostring", f_tostring},
+  {NULL, NULL}
+};
+
+
+static void createmeta (lua_State *L) {
+  luaL_newmetatable(L, LUA_FILEHANDLE);  /* create metatable for file handles */
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  luaL_setfuncs(L, flib, 0);  /* add file methods to new metatable */
+  lua_pop(L, 1);  /* pop new metatable */
+}
+
+
+/*
+** function to (not) close the standard files stdin, stdout, and stderr
+*/
+static int io_noclose (lua_State *L) {
+  LStream *p = tolstream(L);
+  p->closef = &io_noclose;  /* keep file opened */
+  lua_pushnil(L);
+  lua_pushliteral(L, "cannot close standard file");
+  return 2;
+}
+
+
+static void createstdfile (lua_State *L, FILE *f, const char *k,
+                           const char *fname) {
+  LStream *p = newprefile(L);
+  p->f = f;
+  p->closef = &io_noclose;
+  if (k != NULL) {
+    lua_pushvalue(L, -1);
+    lua_setfield(L, LUA_REGISTRYINDEX, k);  /* add file to registry */
+  }
+  lua_setfield(L, -2, fname);  /* add file to module */
+}
+
+
+LUAMOD_API int luaopen_io (lua_State *L) {
+  luaL_newlib(L, iolib);  /* new module */
+  createmeta(L);
+  /* create (and set) default files */
+  createstdfile(L, stdin, IO_INPUT, "stdin");
+  createstdfile(L, stdout, IO_OUTPUT, "stdout");
+  createstdfile(L, stderr, NULL, "stderr");
+  return 1;
+}
+
diff --git a/dep/lualib/llex.c b/dep/lualib/llex.c
new file mode 100644
index 0000000..c4d8c65
--- /dev/null
+++ b/dep/lualib/llex.c
@@ -0,0 +1,527 @@
+/*
+** $Id: llex.c,v 2.61 2012/01/23 23:05:51 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+
+#include <locale.h>
+#include <string.h>
+
+#define llex_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lctype.h"
+#include "ldo.h"
+#include "llex.h"
+#include "lobject.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lzio.h"
+
+
+
+#define next(ls) (ls->current = zgetc(ls->z))
+
+
+
+#define currIsNewline(ls)	(ls->current == '\n' || ls->current == '\r')
+
+
+/* ORDER RESERVED */
+static const char *const luaX_tokens [] = {
+    "and", "break", "do", "else", "elseif",
+    "end", "false", "for", "function", "goto", "if",
+    "in", "local", "nil", "not", "or", "repeat",
+    "return", "then", "true", "until", "while",
+    "..", "...", "==", ">=", "<=", "~=", "::", "<eof>",
+    "<number>", "<name>", "<string>"
+};
+
+
+#define save_and_next(ls) (save(ls, ls->current), next(ls))
+
+
+static l_noret lexerror (LexState *ls, const char *msg, int token);
+
+
+static void save (LexState *ls, int c) {
+  Mbuffer *b = ls->buff;
+  if (luaZ_bufflen(b) + 1 > luaZ_sizebuffer(b)) {
+    size_t newsize;
+    if (luaZ_sizebuffer(b) >= MAX_SIZET/2)
+      lexerror(ls, "lexical element too long", 0);
+    newsize = luaZ_sizebuffer(b) * 2;
+    luaZ_resizebuffer(ls->L, b, newsize);
+  }
+  b->buffer[luaZ_bufflen(b)++] = cast(char, c);
+}
+
+
+void luaX_init (lua_State *L) {
+  int i;
+  for (i=0; i<NUM_RESERVED; i++) {
+    TString *ts = luaS_new(L, luaX_tokens[i]);
+    luaS_fix(ts);  /* reserved words are never collected */
+    ts->tsv.extra = cast_byte(i+1);  /* reserved word */
+  }
+}
+
+
+const char *luaX_token2str (LexState *ls, int token) {
+  if (token < FIRST_RESERVED) {
+    lua_assert(token == cast(unsigned char, token));
+    return (lisprint(token)) ? luaO_pushfstring(ls->L, LUA_QL("%c"), token) :
+                              luaO_pushfstring(ls->L, "char(%d)", token);
+  }
+  else {
+    const char *s = luaX_tokens[token - FIRST_RESERVED];
+    if (token < TK_EOS)
+      return luaO_pushfstring(ls->L, LUA_QS, s);
+    else
+      return s;
+  }
+}
+
+
+static const char *txtToken (LexState *ls, int token) {
+  switch (token) {
+    case TK_NAME:
+    case TK_STRING:
+    case TK_NUMBER:
+      save(ls, '\0');
+      return luaO_pushfstring(ls->L, LUA_QS, luaZ_buffer(ls->buff));
+    default:
+      return luaX_token2str(ls, token);
+  }
+}
+
+
+static l_noret lexerror (LexState *ls, const char *msg, int token) {
+  char buff[LUA_IDSIZE];
+  luaO_chunkid(buff, getstr(ls->source), LUA_IDSIZE);
+  msg = luaO_pushfstring(ls->L, "%s:%d: %s", buff, ls->linenumber, msg);
+  if (token)
+    luaO_pushfstring(ls->L, "%s near %s", msg, txtToken(ls, token));
+  luaD_throw(ls->L, LUA_ERRSYNTAX);
+}
+
+
+l_noret luaX_syntaxerror (LexState *ls, const char *msg) {
+  lexerror(ls, msg, ls->t.token);
+}
+
+
+/*
+** creates a new string and anchors it in function's table so that
+** it will not be collected until the end of the function's compilation
+** (by that time it should be anchored in function's prototype)
+*/
+TString *luaX_newstring (LexState *ls, const char *str, size_t l) {
+  lua_State *L = ls->L;
+  TValue *o;  /* entry for `str' */
+  TString *ts = luaS_newlstr(L, str, l);  /* create new string */
+  setsvalue2s(L, L->top++, ts);  /* temporarily anchor it in stack */
+  o = luaH_set(L, ls->fs->h, L->top - 1);
+  if (ttisnil(o)) {  /* not in use yet? (see 'addK') */
+    /* boolean value does not need GC barrier;
+       table has no metatable, so it does not need to invalidate cache */
+    setbvalue(o, 1);  /* t[string] = true */
+    luaC_checkGC(L);
+  }
+  L->top--;  /* remove string from stack */
+  return ts;
+}
+
+
+/*
+** increment line number and skips newline sequence (any of
+** \n, \r, \n\r, or \r\n)
+*/
+static void inclinenumber (LexState *ls) {
+  int old = ls->current;
+  lua_assert(currIsNewline(ls));
+  next(ls);  /* skip `\n' or `\r' */
+  if (currIsNewline(ls) && ls->current != old)
+    next(ls);  /* skip `\n\r' or `\r\n' */
+  if (++ls->linenumber >= MAX_INT)
+    luaX_syntaxerror(ls, "chunk has too many lines");
+}
+
+
+void luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,
+                    int firstchar) {
+  ls->decpoint = '.';
+  ls->L = L;
+  ls->current = firstchar;
+  ls->lookahead.token = TK_EOS;  /* no look-ahead token */
+  ls->z = z;
+  ls->fs = NULL;
+  ls->linenumber = 1;
+  ls->lastline = 1;
+  ls->source = source;
+  ls->envn = luaS_new(L, LUA_ENV);  /* create env name */
+  luaS_fix(ls->envn);  /* never collect this name */
+  luaZ_resizebuffer(ls->L, ls->buff, LUA_MINBUFFER);  /* initialize buffer */
+}
+
+
+
+/*
+** =======================================================
+** LEXICAL ANALYZER
+** =======================================================
+*/
+
+
+
+static int check_next (LexState *ls, const char *set) {
+  if (ls->current == '\0' || !strchr(set, ls->current))
+    return 0;
+  save_and_next(ls);
+  return 1;
+}
+
+
+/*
+** change all characters 'from' in buffer to 'to'
+*/
+static void buffreplace (LexState *ls, char from, char to) {
+  size_t n = luaZ_bufflen(ls->buff);
+  char *p = luaZ_buffer(ls->buff);
+  while (n--)
+    if (p[n] == from) p[n] = to;
+}
+
+
+#if !defined(getlocaledecpoint)
+#define getlocaledecpoint()	(localeconv()->decimal_point[0])
+#endif
+
+
+#define buff2d(b,e)	luaO_str2d(luaZ_buffer(b), luaZ_bufflen(b) - 1, e)
+
+/*
+** in case of format error, try to change decimal point separator to
+** the one defined in the current locale and check again
+*/
+static void trydecpoint (LexState *ls, SemInfo *seminfo) {
+  char old = ls->decpoint;
+  ls->decpoint = getlocaledecpoint();
+  buffreplace(ls, old, ls->decpoint);  /* try new decimal separator */
+  if (!buff2d(ls->buff, &seminfo->r)) {
+    /* format error with correct decimal point: no more options */
+    buffreplace(ls, ls->decpoint, '.');  /* undo change (for error message) */
+    lexerror(ls, "malformed number", TK_NUMBER);
+  }
+}
+
+
+/* LUA_NUMBER */
+/*
+** this function is quite liberal in what it accepts, as 'luaO_str2d'
+** will reject ill-formed numerals.
+*/
+static void read_numeral (LexState *ls, SemInfo *seminfo) {
+  const char *expo = "Ee";
+  int first = ls->current;
+  lua_assert(lisdigit(ls->current));
+  save_and_next(ls);
+  if (first == '0' && check_next(ls, "Xx"))  /* hexadecimal? */
+    expo = "Pp";
+  for (;;) {
+    if (check_next(ls, expo))  /* exponent part? */
+      check_next(ls, "+-");  /* optional exponent sign */
+    if (lisxdigit(ls->current) || ls->current == '.')
+      save_and_next(ls);
+    else  break;
+  }
+  save(ls, '\0');
+  buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */
+  if (!buff2d(ls->buff, &seminfo->r))  /* format error? */
+    trydecpoint(ls, seminfo); /* try to update decimal point separator */
+}
+
+
+/*
+** skip a sequence '[=*[' or ']=*]' and return its number of '='s or
+** -1 if sequence is malformed
+*/
+static int skip_sep (LexState *ls) {
+  int count = 0;
+  int s = ls->current;
+  lua_assert(s == '[' || s == ']');
+  save_and_next(ls);
+  while (ls->current == '=') {
+    save_and_next(ls);
+    count++;
+  }
+  return (ls->current == s) ? count : (-count) - 1;
+}
+
+
+static void read_long_string (LexState *ls, SemInfo *seminfo, int sep) {
+  save_and_next(ls);  /* skip 2nd `[' */
+  if (currIsNewline(ls))  /* string starts with a newline? */
+    inclinenumber(ls);  /* skip it */
+  for (;;) {
+    switch (ls->current) {
+      case EOZ:
+        lexerror(ls, (seminfo) ? "unfinished long string" :
+                                 "unfinished long comment", TK_EOS);
+        break;  /* to avoid warnings */
+      case ']': {
+        if (skip_sep(ls) == sep) {
+          save_and_next(ls);  /* skip 2nd `]' */
+          goto endloop;
+        }
+        break;
+      }
+      case '\n': case '\r': {
+        save(ls, '\n');
+        inclinenumber(ls);
+        if (!seminfo) luaZ_resetbuffer(ls->buff);  /* avoid wasting space */
+        break;
+      }
+      default: {
+        if (seminfo) save_and_next(ls);
+        else next(ls);
+      }
+    }
+  } endloop:
+  if (seminfo)
+    seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + (2 + sep),
+                                     luaZ_bufflen(ls->buff) - 2*(2 + sep));
+}
+
+
+static void escerror (LexState *ls, int *c, int n, const char *msg) {
+  int i;
+  luaZ_resetbuffer(ls->buff);  /* prepare error message */
+  save(ls, '\\');
+  for (i = 0; i < n && c[i] != EOZ; i++)
+    save(ls, c[i]);
+  lexerror(ls, msg, TK_STRING);
+}
+
+
+static int readhexaesc (LexState *ls) {
+  int c[3], i;  /* keep input for error message */
+  int r = 0;  /* result accumulator */
+  c[0] = 'x';  /* for error message */
+  for (i = 1; i < 3; i++) {  /* read two hexa digits */
+    c[i] = next(ls);
+    if (!lisxdigit(c[i]))
+      escerror(ls, c, i + 1, "hexadecimal digit expected");
+    r = (r << 4) + luaO_hexavalue(c[i]);
+  }
+  return r;
+}
+
+
+static int readdecesc (LexState *ls) {
+  int c[3], i;
+  int r = 0;  /* result accumulator */
+  for (i = 0; i < 3 && lisdigit(ls->current); i++) {  /* read up to 3 digits */
+    c[i] = ls->current;
+    r = 10*r + c[i] - '0';
+    next(ls);
+  }
+  if (r > UCHAR_MAX)
+    escerror(ls, c, i, "decimal escape too large");
+  return r;
+}
+
+
+static void read_string (LexState *ls, int del, SemInfo *seminfo) {
+  save_and_next(ls);  /* keep delimiter (for error messages) */
+  while (ls->current != del) {
+    switch (ls->current) {
+      case EOZ:
+        lexerror(ls, "unfinished string", TK_EOS);
+        break;  /* to avoid warnings */
+      case '\n':
+      case '\r':
+        lexerror(ls, "unfinished string", TK_STRING);
+        break;  /* to avoid warnings */
+      case '\\': {  /* escape sequences */
+        int c;  /* final character to be saved */
+        next(ls);  /* do not save the `\' */
+        switch (ls->current) {
+          case 'a': c = '\a'; goto read_save;
+          case 'b': c = '\b'; goto read_save;
+          case 'f': c = '\f'; goto read_save;
+          case 'n': c = '\n'; goto read_save;
+          case 'r': c = '\r'; goto read_save;
+          case 't': c = '\t'; goto read_save;
+          case 'v': c = '\v'; goto read_save;
+          case 'x': c = readhexaesc(ls); goto read_save;
+          case '\n': case '\r':
+            inclinenumber(ls); c = '\n'; goto only_save;
+          case '\\': case '\"': case '\'':
+            c = ls->current; goto read_save;
+          case EOZ: goto no_save;  /* will raise an error next loop */
+          case 'z': {  /* zap following span of spaces */
+            next(ls);  /* skip the 'z' */
+            while (lisspace(ls->current)) {
+              if (currIsNewline(ls)) inclinenumber(ls);
+              else next(ls);
+            }
+            goto no_save;
+          }
+          default: {
+            if (!lisdigit(ls->current))
+              escerror(ls, &ls->current, 1, "invalid escape sequence");
+            /* digital escape \ddd */
+            c = readdecesc(ls);
+            goto only_save;
+          }
+        }
+       read_save: next(ls);  /* read next character */
+       only_save: save(ls, c);  /* save 'c' */
+       no_save: break;
+      }
+      default:
+        save_and_next(ls);
+    }
+  }
+  save_and_next(ls);  /* skip delimiter */
+  seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + 1,
+                                   luaZ_bufflen(ls->buff) - 2);
+}
+
+
+static int llex (LexState *ls, SemInfo *seminfo) {
+  luaZ_resetbuffer(ls->buff);
+  for (;;) {
+    switch (ls->current) {
+      case '\n': case '\r': {  /* line breaks */
+        inclinenumber(ls);
+        break;
+      }
+      case ' ': case '\f': case '\t': case '\v': {  /* spaces */
+        next(ls);
+        break;
+      }
+      case '-': {  /* '-' or '--' (comment) */
+        next(ls);
+        if (ls->current != '-') return '-';
+        /* else is a comment */
+        next(ls);
+        if (ls->current == '[') {  /* long comment? */
+          int sep = skip_sep(ls);
+          luaZ_resetbuffer(ls->buff);  /* `skip_sep' may dirty the buffer */
+          if (sep >= 0) {
+            read_long_string(ls, NULL, sep);  /* skip long comment */
+            luaZ_resetbuffer(ls->buff);  /* previous call may dirty the buff. */
+            break;
+          }
+        }
+        /* else short comment */
+        while (!currIsNewline(ls) && ls->current != EOZ)
+          next(ls);  /* skip until end of line (or end of file) */
+        break;
+      }
+      case '[': {  /* long string or simply '[' */
+        int sep = skip_sep(ls);
+        if (sep >= 0) {
+          read_long_string(ls, seminfo, sep);
+          return TK_STRING;
+        }
+        else if (sep == -1) return '[';
+        else lexerror(ls, "invalid long string delimiter", TK_STRING);
+      }
+      case '=': {
+        next(ls);
+        if (ls->current != '=') return '=';
+        else { next(ls); return TK_EQ; }
+      }
+      case '<': {
+        next(ls);
+        if (ls->current != '=') return '<';
+        else { next(ls); return TK_LE; }
+      }
+      case '>': {
+        next(ls);
+        if (ls->current != '=') return '>';
+        else { next(ls); return TK_GE; }
+      }
+      case '~': {
+        next(ls);
+        if (ls->current != '=') return '~';
+        else { next(ls); return TK_NE; }
+      }
+      case ':': {
+        next(ls);
+        if (ls->current != ':') return ':';
+        else { next(ls); return TK_DBCOLON; }
+      }
+      case '"': case '\'': {  /* short literal strings */
+        read_string(ls, ls->current, seminfo);
+        return TK_STRING;
+      }
+      case '.': {  /* '.', '..', '...', or number */
+        save_and_next(ls);
+        if (check_next(ls, ".")) {
+          if (check_next(ls, "."))
+            return TK_DOTS;   /* '...' */
+          else return TK_CONCAT;   /* '..' */
+        }
+        else if (!lisdigit(ls->current)) return '.';
+        /* else go through */
+      }
+      case '0': case '1': case '2': case '3': case '4':
+      case '5': case '6': case '7': case '8': case '9': {
+        read_numeral(ls, seminfo);
+        return TK_NUMBER;
+      }
+      case EOZ: {
+        return TK_EOS;
+      }
+      default: {
+        if (lislalpha(ls->current)) {  /* identifier or reserved word? */
+          TString *ts;
+          do {
+            save_and_next(ls);
+          } while (lislalnum(ls->current));
+          ts = luaX_newstring(ls, luaZ_buffer(ls->buff),
+                                  luaZ_bufflen(ls->buff));
+          seminfo->ts = ts;
+          if (isreserved(ts))  /* reserved word? */
+            return ts->tsv.extra - 1 + FIRST_RESERVED;
+          else {
+            return TK_NAME;
+          }
+        }
+        else {  /* single-char tokens (+ - / ...) */
+          int c = ls->current;
+          next(ls);
+          return c;
+        }
+      }
+    }
+  }
+}
+
+
+void luaX_next (LexState *ls) {
+  ls->lastline = ls->linenumber;
+  if (ls->lookahead.token != TK_EOS) {  /* is there a look-ahead token? */
+    ls->t = ls->lookahead;  /* use this one */
+    ls->lookahead.token = TK_EOS;  /* and discharge it */
+  }
+  else
+    ls->t.token = llex(ls, &ls->t.seminfo);  /* read next token */
+}
+
+
+int luaX_lookahead (LexState *ls) {
+  lua_assert(ls->lookahead.token == TK_EOS);
+  ls->lookahead.token = llex(ls, &ls->lookahead.seminfo);
+  return ls->lookahead.token;
+}
+
diff --git a/dep/lualib/llex.h b/dep/lualib/llex.h
new file mode 100644
index 0000000..9ca8a29
--- /dev/null
+++ b/dep/lualib/llex.h
@@ -0,0 +1,78 @@
+/*
+** $Id: llex.h,v 1.72 2011/11/30 12:43:51 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llex_h
+#define llex_h
+
+#include "lobject.h"
+#include "lzio.h"
+
+
+#define FIRST_RESERVED	257
+
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep "ORDER RESERVED"
+*/
+enum RESERVED {
+  /* terminal symbols denoted by reserved words */
+  TK_AND = FIRST_RESERVED, TK_BREAK,
+  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,
+  TK_GOTO, TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
+  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
+  /* other terminal symbols */
+  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_DBCOLON, TK_EOS,
+  TK_NUMBER, TK_NAME, TK_STRING
+};
+
+/* number of reserved words */
+#define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))
+
+
+typedef union {
+  lua_Number r;
+  TString *ts;
+} SemInfo;  /* semantics information */
+
+
+typedef struct Token {
+  int token;
+  SemInfo seminfo;
+} Token;
+
+
+/* state of the lexer plus state of the parser when shared by all
+   functions */
+typedef struct LexState {
+  int current;  /* current character (charint) */
+  int linenumber;  /* input line counter */
+  int lastline;  /* line of last token `consumed' */
+  Token t;  /* current token */
+  Token lookahead;  /* look ahead token */
+  struct FuncState *fs;  /* current function (parser) */
+  struct lua_State *L;
+  ZIO *z;  /* input stream */
+  Mbuffer *buff;  /* buffer for tokens */
+  struct Dyndata *dyd;  /* dynamic structures used by the parser */
+  TString *source;  /* current source name */
+  TString *envn;  /* environment variable name */
+  char decpoint;  /* locale decimal point */
+} LexState;
+
+
+LUAI_FUNC void luaX_init (lua_State *L);
+LUAI_FUNC void luaX_setinput (lua_State *L, LexState *ls, ZIO *z,
+                              TString *source, int firstchar);
+LUAI_FUNC TString *luaX_newstring (LexState *ls, const char *str, size_t l);
+LUAI_FUNC void luaX_next (LexState *ls);
+LUAI_FUNC int luaX_lookahead (LexState *ls);
+LUAI_FUNC l_noret luaX_syntaxerror (LexState *ls, const char *s);
+LUAI_FUNC const char *luaX_token2str (LexState *ls, int token);
+
+
+#endif
diff --git a/dep/lualib/llimits.h b/dep/lualib/llimits.h
new file mode 100644
index 0000000..fc9de1a
--- /dev/null
+++ b/dep/lualib/llimits.h
@@ -0,0 +1,309 @@
+/*
+** $Id: llimits.h,v 1.99 2012/05/28 20:32:28 roberto Exp $
+** Limits, basic types, and some other `installation-dependent' definitions
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llimits_h
+#define llimits_h
+
+
+#include <limits.h>
+#include <stddef.h>
+
+
+#include "lua.h"
+
+
+typedef unsigned LUA_INT32 lu_int32;
+
+typedef LUAI_UMEM lu_mem;
+
+typedef LUAI_MEM l_mem;
+
+
+
+/* chars used as small naturals (so that `char' is reserved for characters) */
+typedef unsigned char lu_byte;
+
+
+#define MAX_SIZET	((size_t)(~(size_t)0)-2)
+
+#define MAX_LUMEM	((lu_mem)(~(lu_mem)0)-2)
+
+#define MAX_LMEM	((l_mem) ((MAX_LUMEM >> 1) - 2))
+
+
+#define MAX_INT (INT_MAX-2)  /* maximum value of an int (-2 for safety) */
+
+/*
+** conversion of pointer to integer
+** this is for hashing only; there is no problem if the integer
+** cannot hold the whole pointer value
+*/
+#define IntPoint(p)  ((unsigned int)(lu_mem)(p))
+
+
+
+/* type to ensure maximum alignment */
+#if !defined(LUAI_USER_ALIGNMENT_T)
+#define LUAI_USER_ALIGNMENT_T	union { double u; void *s; long l; }
+#endif
+
+typedef LUAI_USER_ALIGNMENT_T L_Umaxalign;
+
+
+/* result of a `usual argument conversion' over lua_Number */
+typedef LUAI_UACNUMBER l_uacNumber;
+
+
+/* internal assertions for in-house debugging */
+#if defined(lua_assert)
+#define check_exp(c,e)		(lua_assert(c), (e))
+/* to avoid problems with conditions too long */
+#define lua_longassert(c)	{ if (!(c)) lua_assert(0); }
+#else
+#define lua_assert(c)		((void)0)
+#define check_exp(c,e)		(e)
+#define lua_longassert(c)	((void)0)
+#endif
+
+/*
+** assertion for checking API calls
+*/
+#if !defined(luai_apicheck)
+
+#if defined(LUA_USE_APICHECK)
+#include <assert.h>
+#define luai_apicheck(L,e)	assert(e)
+#else
+#define luai_apicheck(L,e)	lua_assert(e)
+#endif
+
+#endif
+
+#define api_check(l,e,msg)	luai_apicheck(l,(e) && msg)
+
+
+#if !defined(UNUSED)
+#define UNUSED(x)	((void)(x))	/* to avoid warnings */
+#endif
+
+
+#define cast(t, exp)	((t)(exp))
+
+#define cast_byte(i)	cast(lu_byte, (i))
+#define cast_num(i)	cast(lua_Number, (i))
+#define cast_int(i)	cast(int, (i))
+#define cast_uchar(i)	cast(unsigned char, (i))
+
+
+/*
+** non-return type
+*/
+#if defined(__GNUC__)
+#define l_noret		void __attribute__((noreturn))
+#elif defined(_MSC_VER)
+#define l_noret		void __declspec(noreturn)
+#else
+#define l_noret		void
+#endif
+
+
+
+/*
+** maximum depth for nested C calls and syntactical nested non-terminals
+** in a program. (Value must fit in an unsigned short int.)
+*/
+#if !defined(LUAI_MAXCCALLS)
+#define LUAI_MAXCCALLS		200
+#endif
+
+/*
+** maximum number of upvalues in a closure (both C and Lua). (Value
+** must fit in an unsigned char.)
+*/
+#define MAXUPVAL	UCHAR_MAX
+
+
+/*
+** type for virtual-machine instructions
+** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
+*/
+typedef lu_int32 Instruction;
+
+
+
+/* maximum stack for a Lua function */
+#define MAXSTACK	250
+
+
+
+/* minimum size for the string table (must be power of 2) */
+#if !defined(MINSTRTABSIZE)
+#define MINSTRTABSIZE	32
+#endif
+
+
+/* minimum size for string buffer */
+#if !defined(LUA_MINBUFFER)
+#define LUA_MINBUFFER	32
+#endif
+
+
+#if !defined(lua_lock)
+#define lua_lock(L)     ((void) 0)
+#define lua_unlock(L)   ((void) 0)
+#endif
+
+#if !defined(luai_threadyield)
+#define luai_threadyield(L)     {lua_unlock(L); lua_lock(L);}
+#endif
+
+
+/*
+** these macros allow user-specific actions on threads when you defined
+** LUAI_EXTRASPACE and need to do something extra when a thread is
+** created/deleted/resumed/yielded.
+*/
+#if !defined(luai_userstateopen)
+#define luai_userstateopen(L)		((void)L)
+#endif
+
+#if !defined(luai_userstateclose)
+#define luai_userstateclose(L)		((void)L)
+#endif
+
+#if !defined(luai_userstatethread)
+#define luai_userstatethread(L,L1)	((void)L)
+#endif
+
+#if !defined(luai_userstatefree)
+#define luai_userstatefree(L,L1)	((void)L)
+#endif
+
+#if !defined(luai_userstateresume)
+#define luai_userstateresume(L,n)       ((void)L)
+#endif
+
+#if !defined(luai_userstateyield)
+#define luai_userstateyield(L,n)        ((void)L)
+#endif
+
+/*
+** lua_number2int is a macro to convert lua_Number to int.
+** lua_number2integer is a macro to convert lua_Number to lua_Integer.
+** lua_number2unsigned is a macro to convert a lua_Number to a lua_Unsigned.
+** lua_unsigned2number is a macro to convert a lua_Unsigned to a lua_Number.
+** luai_hashnum is a macro to hash a lua_Number value into an integer.
+** The hash must be deterministic and give reasonable values for
+** both small and large values (outside the range of integers).
+*/
+
+#if defined(MS_ASMTRICK)	/* { */
+/* trick with Microsoft assembler for X86 */
+
+#define lua_number2int(i,n)  __asm {__asm fld n   __asm fistp i}
+#define lua_number2integer(i,n)		lua_number2int(i, n)
+#define lua_number2unsigned(i,n)  \
+  {__int64 l; __asm {__asm fld n   __asm fistp l} i = (unsigned int)l;}
+
+
+#elif defined(LUA_IEEE754TRICK)		/* }{ */
+/* the next trick should work on any machine using IEEE754 with
+   a 32-bit int type */
+
+union luai_Cast { double l_d; LUA_INT32 l_p[2]; };
+
+#if !defined(LUA_IEEEENDIAN)	/* { */
+#define LUAI_EXTRAIEEE	\
+  static const union luai_Cast ieeeendian = {-(33.0 + 6755399441055744.0)};
+#define LUA_IEEEENDIANLOC	(ieeeendian.l_p[1] == 33)
+#else
+#define LUA_IEEEENDIANLOC	LUA_IEEEENDIAN
+#define LUAI_EXTRAIEEE		/* empty */
+#endif				/* } */
+
+#define lua_number2int32(i,n,t) \
+  { LUAI_EXTRAIEEE \
+    volatile union luai_Cast u; u.l_d = (n) + 6755399441055744.0; \
+    (i) = (t)u.l_p[LUA_IEEEENDIANLOC]; }
+
+#define luai_hashnum(i,n)  \
+  { volatile union luai_Cast u; u.l_d = (n) + 1.0;  /* avoid -0 */ \
+    (i) = u.l_p[0]; (i) += u.l_p[1]; }  /* add double bits for his hash */
+
+#define lua_number2int(i,n)		lua_number2int32(i, n, int)
+#define lua_number2unsigned(i,n)	lua_number2int32(i, n, lua_Unsigned)
+
+/* the trick can be expanded to lua_Integer when it is a 32-bit value */
+#if defined(LUA_IEEELL)
+#define lua_number2integer(i,n)		lua_number2int32(i, n, lua_Integer)
+#endif
+
+#endif				/* } */
+
+
+/* the following definitions always work, but may be slow */
+
+#if !defined(lua_number2int)
+#define lua_number2int(i,n)	((i)=(int)(n))
+#endif
+
+#if !defined(lua_number2integer)
+#define lua_number2integer(i,n)	((i)=(lua_Integer)(n))
+#endif
+
+#if !defined(lua_number2unsigned)	/* { */
+/* the following definition assures proper modulo behavior */
+#if defined(LUA_NUMBER_DOUBLE)
+#include <math.h>
+#define SUPUNSIGNED	((lua_Number)(~(lua_Unsigned)0) + 1)
+#define lua_number2unsigned(i,n)  \
+	((i)=(lua_Unsigned)((n) - floor((n)/SUPUNSIGNED)*SUPUNSIGNED))
+#else
+#define lua_number2unsigned(i,n)	((i)=(lua_Unsigned)(n))
+#endif
+#endif				/* } */
+
+
+#if !defined(lua_unsigned2number)
+/* on several machines, coercion from unsigned to double is slow,
+   so it may be worth to avoid */
+#define lua_unsigned2number(u)  \
+    (((u) <= (lua_Unsigned)INT_MAX) ? (lua_Number)(int)(u) : (lua_Number)(u))
+#endif
+
+
+
+#if defined(ltable_c) && !defined(luai_hashnum)
+
+#include <float.h>
+#include <math.h>
+
+#define luai_hashnum(i,n) { int e;  \
+  n = frexp(n, &e) * (lua_Number)(INT_MAX - DBL_MAX_EXP);  \
+  lua_number2int(i, n); i += e; }
+
+#endif
+
+
+
+/*
+** macro to control inclusion of some hard tests on stack reallocation
+*/
+#if !defined(HARDSTACKTESTS)
+#define condmovestack(L)	((void)0)
+#else
+/* realloc stack keeping its size */
+#define condmovestack(L)	luaD_reallocstack((L), (L)->stacksize)
+#endif
+
+#if !defined(HARDMEMTESTS)
+#define condchangemem(L)	condmovestack(L)
+#else
+#define condchangemem(L)  \
+	((void)(!(G(L)->gcrunning) || (luaC_fullgc(L, 0), 1)))
+#endif
+
+#endif
diff --git a/dep/lualib/lmathlib.c b/dep/lualib/lmathlib.c
new file mode 100644
index 0000000..c3c605e
--- /dev/null
+++ b/dep/lualib/lmathlib.c
@@ -0,0 +1,283 @@
+/*
+** $Id: lmathlib.c,v 1.81 2012/05/18 17:47:53 roberto Exp $
+** Standard mathematical library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+#include <math.h>
+
+#define lmathlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/* macro 'l_tg' allows the addition of an 'l' or 'f' to all math operations */
+#if !defined(l_tg)
+#define l_tg(x)		(x)
+#endif
+
+
+#undef PI
+#define PI (l_tg(3.1415926535897932384626433832795))
+#define RADIANS_PER_DEGREE (PI/180.0)
+
+
+
+static int math_abs (lua_State *L) {
+  lua_pushnumber(L, l_tg(fabs)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_sin (lua_State *L) {
+  lua_pushnumber(L, l_tg(sin)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_sinh (lua_State *L) {
+  lua_pushnumber(L, l_tg(sinh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_cos (lua_State *L) {
+  lua_pushnumber(L, l_tg(cos)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_cosh (lua_State *L) {
+  lua_pushnumber(L, l_tg(cosh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_tan (lua_State *L) {
+  lua_pushnumber(L, l_tg(tan)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_tanh (lua_State *L) {
+  lua_pushnumber(L, l_tg(tanh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_asin (lua_State *L) {
+  lua_pushnumber(L, l_tg(asin)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_acos (lua_State *L) {
+  lua_pushnumber(L, l_tg(acos)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_atan (lua_State *L) {
+  lua_pushnumber(L, l_tg(atan)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_atan2 (lua_State *L) {
+  lua_pushnumber(L, l_tg(atan2)(luaL_checknumber(L, 1),
+                                luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_ceil (lua_State *L) {
+  lua_pushnumber(L, l_tg(ceil)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_floor (lua_State *L) {
+  lua_pushnumber(L, l_tg(floor)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_fmod (lua_State *L) {
+  lua_pushnumber(L, l_tg(fmod)(luaL_checknumber(L, 1),
+                               luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_modf (lua_State *L) {
+  lua_Number ip;
+  lua_Number fp = l_tg(modf)(luaL_checknumber(L, 1), &ip);
+  lua_pushnumber(L, ip);
+  lua_pushnumber(L, fp);
+  return 2;
+}
+
+static int math_sqrt (lua_State *L) {
+  lua_pushnumber(L, l_tg(sqrt)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_pow (lua_State *L) {
+  lua_pushnumber(L, l_tg(pow)(luaL_checknumber(L, 1),
+                              luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_log (lua_State *L) {
+  lua_Number x = luaL_checknumber(L, 1);
+  lua_Number res;
+  if (lua_isnoneornil(L, 2))
+    res = l_tg(log)(x);
+  else {
+    lua_Number base = luaL_checknumber(L, 2);
+    if (base == 10.0) res = l_tg(log10)(x);
+    else res = l_tg(log)(x)/l_tg(log)(base);
+  }
+  lua_pushnumber(L, res);
+  return 1;
+}
+
+#if defined(LUA_COMPAT_LOG10)
+static int math_log10 (lua_State *L) {
+  lua_pushnumber(L, l_tg(log10)(luaL_checknumber(L, 1)));
+  return 1;
+}
+#endif
+
+static int math_exp (lua_State *L) {
+  lua_pushnumber(L, l_tg(exp)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_deg (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)/RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_rad (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)*RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_frexp (lua_State *L) {
+  int e;
+  lua_pushnumber(L, l_tg(frexp)(luaL_checknumber(L, 1), &e));
+  lua_pushinteger(L, e);
+  return 2;
+}
+
+static int math_ldexp (lua_State *L) {
+  lua_pushnumber(L, l_tg(ldexp)(luaL_checknumber(L, 1),
+                                luaL_checkint(L, 2)));
+  return 1;
+}
+
+
+
+static int math_min (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmin = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i<=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d < dmin)
+      dmin = d;
+  }
+  lua_pushnumber(L, dmin);
+  return 1;
+}
+
+
+static int math_max (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmax = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i<=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d > dmax)
+      dmax = d;
+  }
+  lua_pushnumber(L, dmax);
+  return 1;
+}
+
+
+static int math_random (lua_State *L) {
+  /* the `%' avoids the (rare) case of r==1, and is needed also because on
+     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
+  lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
+  switch (lua_gettop(L)) {  /* check number of arguments */
+    case 0: {  /* no arguments */
+      lua_pushnumber(L, r);  /* Number between 0 and 1 */
+      break;
+    }
+    case 1: {  /* only upper limit */
+      lua_Number u = luaL_checknumber(L, 1);
+      luaL_argcheck(L, 1.0 <= u, 1, "interval is empty");
+      lua_pushnumber(L, l_tg(floor)(r*u) + 1.0);  /* int in [1, u] */
+      break;
+    }
+    case 2: {  /* lower and upper limits */
+      lua_Number l = luaL_checknumber(L, 1);
+      lua_Number u = luaL_checknumber(L, 2);
+      luaL_argcheck(L, l <= u, 2, "interval is empty");
+      lua_pushnumber(L, l_tg(floor)(r*(u-l+1)) + l);  /* int in [l, u] */
+      break;
+    }
+    default: return luaL_error(L, "wrong number of arguments");
+  }
+  return 1;
+}
+
+
+static int math_randomseed (lua_State *L) {
+  srand(luaL_checkunsigned(L, 1));
+  (void)rand(); /* discard first value to avoid undesirable correlations */
+  return 0;
+}
+
+
+static const luaL_Reg mathlib[] = {
+  {"abs",   math_abs},
+  {"acos",  math_acos},
+  {"asin",  math_asin},
+  {"atan2", math_atan2},
+  {"atan",  math_atan},
+  {"ceil",  math_ceil},
+  {"cosh",   math_cosh},
+  {"cos",   math_cos},
+  {"deg",   math_deg},
+  {"exp",   math_exp},
+  {"floor", math_floor},
+  {"fmod",   math_fmod},
+  {"frexp", math_frexp},
+  {"ldexp", math_ldexp},
+#if defined(LUA_COMPAT_LOG10)
+  {"log10", math_log10},
+#endif
+  {"log",   math_log},
+  {"max",   math_max},
+  {"min",   math_min},
+  {"modf",   math_modf},
+  {"pow",   math_pow},
+  {"rad",   math_rad},
+  {"random",     math_random},
+  {"randomseed", math_randomseed},
+  {"sinh",   math_sinh},
+  {"sin",   math_sin},
+  {"sqrt",  math_sqrt},
+  {"tanh",   math_tanh},
+  {"tan",   math_tan},
+  {NULL, NULL}
+};
+
+
+/*
+** Open math library
+*/
+LUAMOD_API int luaopen_math (lua_State *L) {
+  luaL_newlib(L, mathlib);
+  lua_pushnumber(L, PI);
+  lua_setfield(L, -2, "pi");
+  lua_pushnumber(L, HUGE_VAL);
+  lua_setfield(L, -2, "huge");
+  return 1;
+}
+
diff --git a/dep/lualib/lmem.c b/dep/lualib/lmem.c
new file mode 100644
index 0000000..3f88496
--- /dev/null
+++ b/dep/lualib/lmem.c
@@ -0,0 +1,99 @@
+/*
+** $Id: lmem.c,v 1.84 2012/05/23 15:41:53 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define lmem_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+
+/*
+** About the realloc function:
+** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize);
+** (`osize' is the old size, `nsize' is the new size)
+**
+** * frealloc(ud, NULL, x, s) creates a new block of size `s' (no
+** matter 'x').
+**
+** * frealloc(ud, p, x, 0) frees the block `p'
+** (in this specific case, frealloc must return NULL);
+** particularly, frealloc(ud, NULL, 0, 0) does nothing
+** (which is equivalent to free(NULL) in ANSI C)
+**
+** frealloc returns NULL if it cannot create or reallocate the area
+** (any reallocation to an equal or smaller size cannot fail!)
+*/
+
+
+
+#define MINSIZEARRAY	4
+
+
+void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,
+                     int limit, const char *what) {
+  void *newblock;
+  int newsize;
+  if (*size >= limit/2) {  /* cannot double it? */
+    if (*size >= limit)  /* cannot grow even a little? */
+      luaG_runerror(L, "too many %s (limit is %d)", what, limit);
+    newsize = limit;  /* still have at least one free place */
+  }
+  else {
+    newsize = (*size)*2;
+    if (newsize < MINSIZEARRAY)
+      newsize = MINSIZEARRAY;  /* minimum size */
+  }
+  newblock = luaM_reallocv(L, block, *size, newsize, size_elems);
+  *size = newsize;  /* update only when everything else is OK */
+  return newblock;
+}
+
+
+l_noret luaM_toobig (lua_State *L) {
+  luaG_runerror(L, "memory allocation error: block too big");
+}
+
+
+
+/*
+** generic allocation routine.
+*/
+void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
+  void *newblock;
+  global_State *g = G(L);
+  size_t realosize = (block) ? osize : 0;
+  lua_assert((realosize == 0) == (block == NULL));
+#if defined(HARDMEMTESTS)
+  if (nsize > realosize && g->gcrunning)
+    luaC_fullgc(L, 1);  /* force a GC whenever possible */
+#endif
+  newblock = (*g->frealloc)(g->ud, block, osize, nsize);
+  if (newblock == NULL && nsize > 0) {
+    api_check(L, nsize > realosize,
+                 "realloc cannot fail when shrinking a block");
+    if (g->gcrunning) {
+      luaC_fullgc(L, 1);  /* try to free some memory... */
+      newblock = (*g->frealloc)(g->ud, block, osize, nsize);  /* try again */
+    }
+    if (newblock == NULL)
+      luaD_throw(L, LUA_ERRMEM);
+  }
+  lua_assert((nsize == 0) == (newblock == NULL));
+  g->GCdebt = (g->GCdebt + nsize) - realosize;
+  return newblock;
+}
+
diff --git a/dep/lualib/lmem.h b/dep/lualib/lmem.h
new file mode 100644
index 0000000..535dfe0
--- /dev/null
+++ b/dep/lualib/lmem.h
@@ -0,0 +1,50 @@
+/*
+** $Id: lmem.h,v 1.38 2011/12/02 13:26:54 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lmem_h
+#define lmem_h
+
+
+#include <stddef.h>
+
+#include "llimits.h"
+#include "lua.h"
+
+
+#define luaM_reallocv(L,b,on,n,e) \
+	((cast(size_t, (n)+1) > MAX_SIZET/(e)) ?  /* +1 to avoid warnings */ \
+		(luaM_toobig(L), (void *)0) : \
+		luaM_realloc_(L, (b), (on)*(e), (n)*(e)))
+
+#define luaM_freemem(L, b, s)	luaM_realloc_(L, (b), (s), 0)
+#define luaM_free(L, b)		luaM_realloc_(L, (b), sizeof(*(b)), 0)
+#define luaM_freearray(L, b, n)   luaM_reallocv(L, (b), n, 0, sizeof((b)[0]))
+
+#define luaM_malloc(L,s)	luaM_realloc_(L, NULL, 0, (s))
+#define luaM_new(L,t)		cast(t *, luaM_malloc(L, sizeof(t)))
+#define luaM_newvector(L,n,t) \
+		cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
+
+#define luaM_newobject(L,tag,s)	luaM_realloc_(L, NULL, tag, (s))
+
+#define luaM_growvector(L,v,nelems,size,t,limit,e) \
+          if ((nelems)+1 > (size)) \
+            ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
+
+#define luaM_reallocvector(L, v,oldn,n,t) \
+   ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
+
+LUAI_FUNC l_noret luaM_toobig (lua_State *L);
+
+/* not to be called directly */
+LUAI_FUNC void *luaM_realloc_ (lua_State *L, void *block, size_t oldsize,
+                                                          size_t size);
+LUAI_FUNC void *luaM_growaux_ (lua_State *L, void *block, int *size,
+                               size_t size_elem, int limit,
+                               const char *what);
+
+#endif
+
diff --git a/dep/lualib/loadlib.c b/dep/lualib/loadlib.c
new file mode 100644
index 0000000..a995927
--- /dev/null
+++ b/dep/lualib/loadlib.c
@@ -0,0 +1,725 @@
+/*
+** $Id: loadlib.c,v 1.111 2012/05/30 12:33:44 roberto Exp $
+** Dynamic library loader for Lua
+** See Copyright Notice in lua.h
+**
+** This module contains an implementation of loadlib for Unix systems
+** that have dlfcn, an implementation for Windows, and a stub for other
+** systems.
+*/
+
+
+/*
+** if needed, includes windows header before everything else
+*/
+#if defined(_WIN32)
+#include <windows.h>
+#endif
+
+
+#include <stdlib.h>
+#include <string.h>
+
+
+#define loadlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/*
+** LUA_PATH and LUA_CPATH are the names of the environment
+** variables that Lua check to set its paths.
+*/
+#if !defined(LUA_PATH)
+#define LUA_PATH	"LUA_PATH"
+#endif
+
+#if !defined(LUA_CPATH)
+#define LUA_CPATH	"LUA_CPATH"
+#endif
+
+#define LUA_PATHSUFFIX		"_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR
+
+#define LUA_PATHVERSION		LUA_PATH LUA_PATHSUFFIX
+#define LUA_CPATHVERSION	LUA_CPATH LUA_PATHSUFFIX
+
+/*
+** LUA_PATH_SEP is the character that separates templates in a path.
+** LUA_PATH_MARK is the string that marks the substitution points in a
+** template.
+** LUA_EXEC_DIR in a Windows path is replaced by the executable's
+** directory.
+** LUA_IGMARK is a mark to ignore all before it when building the
+** luaopen_ function name.
+*/
+#if !defined (LUA_PATH_SEP)
+#define LUA_PATH_SEP		";"
+#endif
+#if !defined (LUA_PATH_MARK)
+#define LUA_PATH_MARK		"?"
+#endif
+#if !defined (LUA_EXEC_DIR)
+#define LUA_EXEC_DIR		"!"
+#endif
+#if !defined (LUA_IGMARK)
+#define LUA_IGMARK		"-"
+#endif
+
+
+/*
+** LUA_CSUBSEP is the character that replaces dots in submodule names
+** when searching for a C loader.
+** LUA_LSUBSEP is the character that replaces dots in submodule names
+** when searching for a Lua loader.
+*/
+#if !defined(LUA_CSUBSEP)
+#define LUA_CSUBSEP		LUA_DIRSEP
+#endif
+
+#if !defined(LUA_LSUBSEP)
+#define LUA_LSUBSEP		LUA_DIRSEP
+#endif
+
+
+/* prefix for open functions in C libraries */
+#define LUA_POF		"luaopen_"
+
+/* separator for open functions in C libraries */
+#define LUA_OFSEP	"_"
+
+
+/* table (in the registry) that keeps handles for all loaded C libraries */
+#define CLIBS		"_CLIBS"
+
+#define LIB_FAIL	"open"
+
+
+/* error codes for ll_loadfunc */
+#define ERRLIB		1
+#define ERRFUNC		2
+
+#define setprogdir(L)		((void)0)
+
+
+/*
+** system-dependent functions
+*/
+static void ll_unloadlib (void *lib);
+static void *ll_load (lua_State *L, const char *path, int seeglb);
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);
+
+
+
+#if defined(LUA_USE_DLOPEN)
+/*
+** {========================================================================
+** This is an implementation of loadlib based on the dlfcn interface.
+** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,
+** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least
+** as an emulation layer on top of native functions.
+** =========================================================================
+*/
+
+#include <dlfcn.h>
+
+static void ll_unloadlib (void *lib) {
+  dlclose(lib);
+}
+
+
+static void *ll_load (lua_State *L, const char *path, int seeglb) {
+  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));
+  if (lib == NULL) lua_pushstring(L, dlerror());
+  return lib;
+}
+
+
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);
+  if (f == NULL) lua_pushstring(L, dlerror());
+  return f;
+}
+
+/* }====================================================== */
+
+
+
+#elif defined(LUA_DL_DLL)
+/*
+** {======================================================================
+** This is an implementation of loadlib for Windows using native functions.
+** =======================================================================
+*/
+
+#undef setprogdir
+
+/*
+** optional flags for LoadLibraryEx
+*/
+#if !defined(LUA_LLE_FLAGS)
+#define LUA_LLE_FLAGS	0
+#endif
+
+
+static void setprogdir (lua_State *L) {
+  char buff[MAX_PATH + 1];
+  char *lb;
+  DWORD nsize = sizeof(buff)/sizeof(char);
+  DWORD n = GetModuleFileNameA(NULL, buff, nsize);
+  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\')) == NULL)
+    luaL_error(L, "unable to get ModuleFileName");
+  else {
+    *lb = '\0';
+    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);
+    lua_remove(L, -2);  /* remove original string */
+  }
+}
+
+
+static void pusherror (lua_State *L) {
+  int error = GetLastError();
+  char buffer[128];
+  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
+      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))
+    lua_pushstring(L, buffer);
+  else
+    lua_pushfstring(L, "system error %d\n", error);
+}
+
+static void ll_unloadlib (void *lib) {
+  FreeLibrary((HMODULE)lib);
+}
+
+
+static void *ll_load (lua_State *L, const char *path, int seeglb) {
+  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);
+  (void)(seeglb);  /* not used: symbols are 'global' by default */
+  if (lib == NULL) pusherror(L);
+  return lib;
+}
+
+
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  lua_CFunction f = (lua_CFunction)GetProcAddress((HMODULE)lib, sym);
+  if (f == NULL) pusherror(L);
+  return f;
+}
+
+/* }====================================================== */
+
+
+#else
+/*
+** {======================================================
+** Fallback for other systems
+** =======================================================
+*/
+
+#undef LIB_FAIL
+#define LIB_FAIL	"absent"
+
+
+#define DLMSG	"dynamic libraries not enabled; check your Lua installation"
+
+
+static void ll_unloadlib (void *lib) {
+  (void)(lib);  /* not used */
+}
+
+
+static void *ll_load (lua_State *L, const char *path, int seeglb) {
+  (void)(path); (void)(seeglb);  /* not used */
+  lua_pushliteral(L, DLMSG);
+  return NULL;
+}
+
+
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  (void)(lib); (void)(sym);  /* not used */
+  lua_pushliteral(L, DLMSG);
+  return NULL;
+}
+
+/* }====================================================== */
+#endif
+
+
+static void *ll_checkclib (lua_State *L, const char *path) {
+  void *plib;
+  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);
+  lua_getfield(L, -1, path);
+  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */
+  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */
+  return plib;
+}
+
+
+static void ll_addtoclib (lua_State *L, const char *path, void *plib) {
+  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);
+  lua_pushlightuserdata(L, plib);
+  lua_pushvalue(L, -1);
+  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */
+  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */
+  lua_pop(L, 1);  /* pop CLIBS table */
+}
+
+
+/*
+** __gc tag method for CLIBS table: calls 'll_unloadlib' for all lib
+** handles in list CLIBS
+*/
+static int gctm (lua_State *L) {
+  int n = luaL_len(L, 1);
+  for (; n >= 1; n--) {  /* for each handle, in reverse order */
+    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */
+    ll_unloadlib(lua_touserdata(L, -1));
+    lua_pop(L, 1);  /* pop handle */
+  }
+  return 0;
+}
+
+
+static int ll_loadfunc (lua_State *L, const char *path, const char *sym) {
+  void *reg = ll_checkclib(L, path);  /* check loaded C libraries */
+  if (reg == NULL) {  /* must load library? */
+    reg = ll_load(L, path, *sym == '*');
+    if (reg == NULL) return ERRLIB;  /* unable to load library */
+    ll_addtoclib(L, path, reg);
+  }
+  if (*sym == '*') {  /* loading only library (no function)? */
+    lua_pushboolean(L, 1);  /* return 'true' */
+    return 0;  /* no errors */
+  }
+  else {
+    lua_CFunction f = ll_sym(L, reg, sym);
+    if (f == NULL)
+      return ERRFUNC;  /* unable to find function */
+    lua_pushcfunction(L, f);  /* else create new function */
+    return 0;  /* no errors */
+  }
+}
+
+
+static int ll_loadlib (lua_State *L) {
+  const char *path = luaL_checkstring(L, 1);
+  const char *init = luaL_checkstring(L, 2);
+  int stat = ll_loadfunc(L, path, init);
+  if (stat == 0)  /* no errors? */
+    return 1;  /* return the loaded function */
+  else {  /* error; error message is on stack top */
+    lua_pushnil(L);
+    lua_insert(L, -2);
+    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : "init");
+    return 3;  /* return nil, error message, and where */
+  }
+}
+
+
+
+/*
+** {======================================================
+** 'require' function
+** =======================================================
+*/
+
+
+static int readable (const char *filename) {
+  FILE *f = fopen(filename, "r");  /* try to open file */
+  if (f == NULL) return 0;  /* open failed */
+  fclose(f);
+  return 1;
+}
+
+
+static const char *pushnexttemplate (lua_State *L, const char *path) {
+  const char *l;
+  while (*path == *LUA_PATH_SEP) path++;  /* skip separators */
+  if (*path == '\0') return NULL;  /* no more templates */
+  l = strchr(path, *LUA_PATH_SEP);  /* find next separator */
+  if (l == NULL) l = path + strlen(path);
+  lua_pushlstring(L, path, l - path);  /* template */
+  return l;
+}
+
+
+static const char *searchpath (lua_State *L, const char *name,
+                                             const char *path,
+                                             const char *sep,
+                                             const char *dirsep) {
+  luaL_Buffer msg;  /* to build error message */
+  luaL_buffinit(L, &msg);
+  if (*sep != '\0')  /* non-empty separator? */
+    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */
+  while ((path = pushnexttemplate(L, path)) != NULL) {
+    const char *filename = luaL_gsub(L, lua_tostring(L, -1),
+                                     LUA_PATH_MARK, name);
+    lua_remove(L, -2);  /* remove path template */
+    if (readable(filename))  /* does file exist and is readable? */
+      return filename;  /* return that file name */
+    lua_pushfstring(L, "\n\tno file " LUA_QS, filename);
+    lua_remove(L, -2);  /* remove file name */
+    luaL_addvalue(&msg);  /* concatenate error msg. entry */
+  }
+  luaL_pushresult(&msg);  /* create error message */
+  return NULL;  /* not found */
+}
+
+
+static int ll_searchpath (lua_State *L) {
+  const char *f = searchpath(L, luaL_checkstring(L, 1),
+                                luaL_checkstring(L, 2),
+                                luaL_optstring(L, 3, "."),
+                                luaL_optstring(L, 4, LUA_DIRSEP));
+  if (f != NULL) return 1;
+  else {  /* error message is on top of the stack */
+    lua_pushnil(L);
+    lua_insert(L, -2);
+    return 2;  /* return nil + error message */
+  }
+}
+
+
+static const char *findfile (lua_State *L, const char *name,
+                                           const char *pname,
+                                           const char *dirsep) {
+  const char *path;
+  lua_getfield(L, lua_upvalueindex(1), pname);
+  path = lua_tostring(L, -1);
+  if (path == NULL)
+    luaL_error(L, LUA_QL("package.%s") " must be a string", pname);
+  return searchpath(L, name, path, ".", dirsep);
+}
+
+
+static int checkload (lua_State *L, int stat, const char *filename) {
+  if (stat) {  /* module loaded successfully? */
+    lua_pushstring(L, filename);  /* will be 2nd argument to module */
+    return 2;  /* return open function and file name */
+  }
+  else
+    return luaL_error(L, "error loading module " LUA_QS
+                         " from file " LUA_QS ":\n\t%s",
+                          lua_tostring(L, 1), filename, lua_tostring(L, -1));
+}
+
+
+static int searcher_Lua (lua_State *L) {
+  const char *filename;
+  const char *name = luaL_checkstring(L, 1);
+  filename = findfile(L, name, "path", LUA_LSUBSEP);
+  if (filename == NULL) return 1;  /* module not found in this path */
+  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);
+}
+
+
+static int loadfunc (lua_State *L, const char *filename, const char *modname) {
+  const char *funcname;
+  const char *mark;
+  modname = luaL_gsub(L, modname, ".", LUA_OFSEP);
+  mark = strchr(modname, *LUA_IGMARK);
+  if (mark) {
+    int stat;
+    funcname = lua_pushlstring(L, modname, mark - modname);
+    funcname = lua_pushfstring(L, LUA_POF"%s", funcname);
+    stat = ll_loadfunc(L, filename, funcname);
+    if (stat != ERRFUNC) return stat;
+    modname = mark + 1;  /* else go ahead and try old-style name */
+  }
+  funcname = lua_pushfstring(L, LUA_POF"%s", modname);
+  return ll_loadfunc(L, filename, funcname);
+}
+
+
+static int searcher_C (lua_State *L) {
+  const char *name = luaL_checkstring(L, 1);
+  const char *filename = findfile(L, name, "cpath", LUA_CSUBSEP);
+  if (filename == NULL) return 1;  /* module not found in this path */
+  return checkload(L, (loadfunc(L, filename, name) == 0), filename);
+}
+
+
+static int searcher_Croot (lua_State *L) {
+  const char *filename;
+  const char *name = luaL_checkstring(L, 1);
+  const char *p = strchr(name, '.');
+  int stat;
+  if (p == NULL) return 0;  /* is root */
+  lua_pushlstring(L, name, p - name);
+  filename = findfile(L, lua_tostring(L, -1), "cpath", LUA_CSUBSEP);
+  if (filename == NULL) return 1;  /* root not found */
+  if ((stat = loadfunc(L, filename, name)) != 0) {
+    if (stat != ERRFUNC)
+      return checkload(L, 0, filename);  /* real error */
+    else {  /* open function not found */
+      lua_pushfstring(L, "\n\tno module " LUA_QS " in file " LUA_QS,
+                         name, filename);
+      return 1;
+    }
+  }
+  lua_pushstring(L, filename);  /* will be 2nd argument to module */
+  return 2;
+}
+
+
+static int searcher_preload (lua_State *L) {
+  const char *name = luaL_checkstring(L, 1);
+  lua_getfield(L, LUA_REGISTRYINDEX, "_PRELOAD");
+  lua_getfield(L, -1, name);
+  if (lua_isnil(L, -1))  /* not found? */
+    lua_pushfstring(L, "\n\tno field package.preload['%s']", name);
+  return 1;
+}
+
+
+static void findloader (lua_State *L, const char *name) {
+  int i;
+  luaL_Buffer msg;  /* to build error message */
+  luaL_buffinit(L, &msg);
+  lua_getfield(L, lua_upvalueindex(1), "searchers");  /* will be at index 3 */
+  if (!lua_istable(L, 3))
+    luaL_error(L, LUA_QL("package.searchers") " must be a table");
+  /*  iterate over available searchers to find a loader */
+  for (i = 1; ; i++) {
+    lua_rawgeti(L, 3, i);  /* get a searcher */
+    if (lua_isnil(L, -1)) {  /* no more searchers? */
+      lua_pop(L, 1);  /* remove nil */
+      luaL_pushresult(&msg);  /* create error message */
+      luaL_error(L, "module " LUA_QS " not found:%s",
+                    name, lua_tostring(L, -1));
+    }
+    lua_pushstring(L, name);
+    lua_call(L, 1, 2);  /* call it */
+    if (lua_isfunction(L, -2))  /* did it find a loader? */
+      return;  /* module loader found */
+    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */
+      lua_pop(L, 1);  /* remove extra return */
+      luaL_addvalue(&msg);  /* concatenate error message */
+    }
+    else
+      lua_pop(L, 2);  /* remove both returns */
+  }
+}
+
+
+static int ll_require (lua_State *L) {
+  const char *name = luaL_checkstring(L, 1);
+  lua_settop(L, 1);  /* _LOADED table will be at index 2 */
+  lua_getfield(L, LUA_REGISTRYINDEX, "_LOADED");
+  lua_getfield(L, 2, name);  /* _LOADED[name] */
+  if (lua_toboolean(L, -1))  /* is it there? */
+    return 1;  /* package is already loaded */
+  /* else must load package */
+  lua_pop(L, 1);  /* remove 'getfield' result */
+  findloader(L, name);
+  lua_pushstring(L, name);  /* pass name as argument to module loader */
+  lua_insert(L, -2);  /* name is 1st argument (before search data) */
+  lua_call(L, 2, 1);  /* run loader to load module */
+  if (!lua_isnil(L, -1))  /* non-nil return? */
+    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */
+  lua_getfield(L, 2, name);
+  if (lua_isnil(L, -1)) {   /* module did not set a value? */
+    lua_pushboolean(L, 1);  /* use true as result */
+    lua_pushvalue(L, -1);  /* extra copy to be returned */
+    lua_setfield(L, 2, name);  /* _LOADED[name] = true */
+  }
+  return 1;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** 'module' function
+** =======================================================
+*/
+#if defined(LUA_COMPAT_MODULE)
+
+/*
+** changes the environment variable of calling function
+*/
+static void set_env (lua_State *L) {
+  lua_Debug ar;
+  if (lua_getstack(L, 1, &ar) == 0 ||
+      lua_getinfo(L, "f", &ar) == 0 ||  /* get calling function */
+      lua_iscfunction(L, -1))
+    luaL_error(L, LUA_QL("module") " not called from a Lua function");
+  lua_pushvalue(L, -2);  /* copy new environment table to top */
+  lua_setupvalue(L, -2, 1);
+  lua_pop(L, 1);  /* remove function */
+}
+
+
+static void dooptions (lua_State *L, int n) {
+  int i;
+  for (i = 2; i <= n; i++) {
+    if (lua_isfunction(L, i)) {  /* avoid 'calling' extra info. */
+      lua_pushvalue(L, i);  /* get option (a function) */
+      lua_pushvalue(L, -2);  /* module */
+      lua_call(L, 1, 0);
+    }
+  }
+}
+
+
+static void modinit (lua_State *L, const char *modname) {
+  const char *dot;
+  lua_pushvalue(L, -1);
+  lua_setfield(L, -2, "_M");  /* module._M = module */
+  lua_pushstring(L, modname);
+  lua_setfield(L, -2, "_NAME");
+  dot = strrchr(modname, '.');  /* look for last dot in module name */
+  if (dot == NULL) dot = modname;
+  else dot++;
+  /* set _PACKAGE as package name (full module name minus last part) */
+  lua_pushlstring(L, modname, dot - modname);
+  lua_setfield(L, -2, "_PACKAGE");
+}
+
+
+static int ll_module (lua_State *L) {
+  const char *modname = luaL_checkstring(L, 1);
+  int lastarg = lua_gettop(L);  /* last parameter */
+  luaL_pushmodule(L, modname, 1);  /* get/create module table */
+  /* check whether table already has a _NAME field */
+  lua_getfield(L, -1, "_NAME");
+  if (!lua_isnil(L, -1))  /* is table an initialized module? */
+    lua_pop(L, 1);
+  else {  /* no; initialize it */
+    lua_pop(L, 1);
+    modinit(L, modname);
+  }
+  lua_pushvalue(L, -1);
+  set_env(L);
+  dooptions(L, lastarg);
+  return 1;
+}
+
+
+static int ll_seeall (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  if (!lua_getmetatable(L, 1)) {
+    lua_createtable(L, 0, 1); /* create new metatable */
+    lua_pushvalue(L, -1);
+    lua_setmetatable(L, 1);
+  }
+  lua_pushglobaltable(L);
+  lua_setfield(L, -2, "__index");  /* mt.__index = _G */
+  return 0;
+}
+
+#endif
+/* }====================================================== */
+
+
+
+/* auxiliary mark (for internal use) */
+#define AUXMARK		"\1"
+
+
+/*
+** return registry.LUA_NOENV as a boolean
+*/
+static int noenv (lua_State *L) {
+  int b;
+  lua_getfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
+  b = lua_toboolean(L, -1);
+  lua_pop(L, 1);  /* remove value */
+  return b;
+}
+
+
+static void setpath (lua_State *L, const char *fieldname, const char *envname1,
+                                   const char *envname2, const char *def) {
+  const char *path = getenv(envname1);
+  if (path == NULL)  /* no environment variable? */
+    path = getenv(envname2);  /* try alternative name */
+  if (path == NULL || noenv(L))  /* no environment variable? */
+    lua_pushstring(L, def);  /* use default */
+  else {
+    /* replace ";;" by ";AUXMARK;" and then AUXMARK by default path */
+    path = luaL_gsub(L, path, LUA_PATH_SEP LUA_PATH_SEP,
+                              LUA_PATH_SEP AUXMARK LUA_PATH_SEP);
+    luaL_gsub(L, path, AUXMARK, def);
+    lua_remove(L, -2);
+  }
+  setprogdir(L);
+  lua_setfield(L, -2, fieldname);
+}
+
+
+static const luaL_Reg pk_funcs[] = {
+  {"loadlib", ll_loadlib},
+  {"searchpath", ll_searchpath},
+#if defined(LUA_COMPAT_MODULE)
+  {"seeall", ll_seeall},
+#endif
+  {NULL, NULL}
+};
+
+
+static const luaL_Reg ll_funcs[] = {
+#if defined(LUA_COMPAT_MODULE)
+  {"module", ll_module},
+#endif
+  {"require", ll_require},
+  {NULL, NULL}
+};
+
+
+static void createsearcherstable (lua_State *L) {
+  static const lua_CFunction searchers[] =
+    {searcher_preload, searcher_Lua, searcher_C, searcher_Croot, NULL};
+  int i;
+  /* create 'searchers' table */
+  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);
+  /* fill it with pre-defined searchers */
+  for (i=0; searchers[i] != NULL; i++) {
+    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */
+    lua_pushcclosure(L, searchers[i], 1);
+    lua_rawseti(L, -2, i+1);
+  }
+}
+
+
+LUAMOD_API int luaopen_package (lua_State *L) {
+  /* create table CLIBS to keep track of loaded C libraries */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, CLIBS);
+  lua_createtable(L, 0, 1);  /* metatable for CLIBS */
+  lua_pushcfunction(L, gctm);
+  lua_setfield(L, -2, "__gc");  /* set finalizer for CLIBS table */
+  lua_setmetatable(L, -2);
+  /* create `package' table */
+  luaL_newlib(L, pk_funcs);
+  createsearcherstable(L);
+#if defined(LUA_COMPAT_LOADERS)
+  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */
+  lua_setfield(L, -3, "loaders");  /* put it in field `loaders' */
+#endif
+  lua_setfield(L, -2, "searchers");  /* put it in field 'searchers' */
+  /* set field 'path' */
+  setpath(L, "path", LUA_PATHVERSION, LUA_PATH, LUA_PATH_DEFAULT);
+  /* set field 'cpath' */
+  setpath(L, "cpath", LUA_CPATHVERSION, LUA_CPATH, LUA_CPATH_DEFAULT);
+  /* store config information */
+  lua_pushliteral(L, LUA_DIRSEP "\n" LUA_PATH_SEP "\n" LUA_PATH_MARK "\n"
+                     LUA_EXEC_DIR "\n" LUA_IGMARK "\n");
+  lua_setfield(L, -2, "config");
+  /* set field `loaded' */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_LOADED");
+  lua_setfield(L, -2, "loaded");
+  /* set field `preload' */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_PRELOAD");
+  lua_setfield(L, -2, "preload");
+  lua_pushglobaltable(L);
+  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */
+  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */
+  lua_pop(L, 1);  /* pop global table */
+  return 1;  /* return 'package' table */
+}
+
diff --git a/dep/lualib/lobject.c b/dep/lualib/lobject.c
new file mode 100644
index 0000000..cf0f754
--- /dev/null
+++ b/dep/lualib/lobject.c
@@ -0,0 +1,289 @@
+/*
+** $Id: lobject.c,v 2.55 2011/11/30 19:30:16 roberto Exp $
+** Some generic functions over Lua objects
+** See Copyright Notice in lua.h
+*/
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lobject_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lctype.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "lvm.h"
+
+
+
+LUAI_DDEF const TValue luaO_nilobject_ = {NILCONSTANT};
+
+
+/*
+** converts an integer to a "floating point byte", represented as
+** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
+** eeeee != 0 and (xxx) otherwise.
+*/
+int luaO_int2fb (unsigned int x) {
+  int e = 0;  /* exponent */
+  if (x < 8) return x;
+  while (x >= 0x10) {
+    x = (x+1) >> 1;
+    e++;
+  }
+  return ((e+1) << 3) | (cast_int(x) - 8);
+}
+
+
+/* converts back */
+int luaO_fb2int (int x) {
+  int e = (x >> 3) & 0x1f;
+  if (e == 0) return x;
+  else return ((x & 7) + 8) << (e - 1);
+}
+
+
+int luaO_ceillog2 (unsigned int x) {
+  static const lu_byte log_2[256] = {
+    0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
+  };
+  int l = 0;
+  x--;
+  while (x >= 256) { l += 8; x >>= 8; }
+  return l + log_2[x];
+}
+
+
+lua_Number luaO_arith (int op, lua_Number v1, lua_Number v2) {
+  switch (op) {
+    case LUA_OPADD: return luai_numadd(NULL, v1, v2);
+    case LUA_OPSUB: return luai_numsub(NULL, v1, v2);
+    case LUA_OPMUL: return luai_nummul(NULL, v1, v2);
+    case LUA_OPDIV: return luai_numdiv(NULL, v1, v2);
+    case LUA_OPMOD: return luai_nummod(NULL, v1, v2);
+    case LUA_OPPOW: return luai_numpow(NULL, v1, v2);
+    case LUA_OPUNM: return luai_numunm(NULL, v1);
+    default: lua_assert(0); return 0;
+  }
+}
+
+
+int luaO_hexavalue (int c) {
+  if (lisdigit(c)) return c - '0';
+  else return ltolower(c) - 'a' + 10;
+}
+
+
+#if !defined(lua_strx2number)
+
+#include <math.h>
+
+
+static int isneg (const char **s) {
+  if (**s == '-') { (*s)++; return 1; }
+  else if (**s == '+') (*s)++;
+  return 0;
+}
+
+
+static lua_Number readhexa (const char **s, lua_Number r, int *count) {
+  for (; lisxdigit(cast_uchar(**s)); (*s)++) {  /* read integer part */
+    r = (r * 16.0) + cast_num(luaO_hexavalue(cast_uchar(**s)));
+    (*count)++;
+  }
+  return r;
+}
+
+
+/*
+** convert an hexadecimal numeric string to a number, following
+** C99 specification for 'strtod'
+*/
+static lua_Number lua_strx2number (const char *s, char **endptr) {
+  lua_Number r = 0.0;
+  int e = 0, i = 0;
+  int neg = 0;  /* 1 if number is negative */
+  *endptr = cast(char *, s);  /* nothing is valid yet */
+  while (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */
+  neg = isneg(&s);  /* check signal */
+  if (!(*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X')))  /* check '0x' */
+    return 0.0;  /* invalid format (no '0x') */
+  s += 2;  /* skip '0x' */
+  r = readhexa(&s, r, &i);  /* read integer part */
+  if (*s == '.') {
+    s++;  /* skip dot */
+    r = readhexa(&s, r, &e);  /* read fractional part */
+  }
+  if (i == 0 && e == 0)
+    return 0.0;  /* invalid format (no digit) */
+  e *= -4;  /* each fractional digit divides value by 2^-4 */
+  *endptr = cast(char *, s);  /* valid up to here */
+  if (*s == 'p' || *s == 'P') {  /* exponent part? */
+    int exp1 = 0;
+    int neg1;
+    s++;  /* skip 'p' */
+    neg1 = isneg(&s);  /* signal */
+    if (!lisdigit(cast_uchar(*s)))
+      goto ret;  /* must have at least one digit */
+    while (lisdigit(cast_uchar(*s)))  /* read exponent */
+      exp1 = exp1 * 10 + *(s++) - '0';
+    if (neg1) exp1 = -exp1;
+    e += exp1;
+  }
+  *endptr = cast(char *, s);  /* valid up to here */
+ ret:
+  if (neg) r = -r;
+  return ldexp(r, e);
+}
+
+#endif
+
+
+int luaO_str2d (const char *s, size_t len, lua_Number *result) {
+  char *endptr;
+  if (strpbrk(s, "nN"))  /* reject 'inf' and 'nan' */
+    return 0;
+  else if (strpbrk(s, "xX"))  /* hexa? */
+    *result = lua_strx2number(s, &endptr);
+  else
+    *result = lua_str2number(s, &endptr);
+  if (endptr == s) return 0;  /* nothing recognized */
+  while (lisspace(cast_uchar(*endptr))) endptr++;
+  return (endptr == s + len);  /* OK if no trailing characters */
+}
+
+
+
+static void pushstr (lua_State *L, const char *str, size_t l) {
+  setsvalue2s(L, L->top, luaS_newlstr(L, str, l));
+  incr_top(L);
+}
+
+
+/* this function handles only `%d', `%c', %f, %p, and `%s' formats */
+const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
+  int n = 0;
+  for (;;) {
+    const char *e = strchr(fmt, '%');
+    if (e == NULL) break;
+    setsvalue2s(L, L->top, luaS_newlstr(L, fmt, e-fmt));
+    incr_top(L);
+    switch (*(e+1)) {
+      case 's': {
+        const char *s = va_arg(argp, char *);
+        if (s == NULL) s = "(null)";
+        pushstr(L, s, strlen(s));
+        break;
+      }
+      case 'c': {
+        char buff;
+        buff = cast(char, va_arg(argp, int));
+        pushstr(L, &buff, 1);
+        break;
+      }
+      case 'd': {
+        setnvalue(L->top, cast_num(va_arg(argp, int)));
+        incr_top(L);
+        break;
+      }
+      case 'f': {
+        setnvalue(L->top, cast_num(va_arg(argp, l_uacNumber)));
+        incr_top(L);
+        break;
+      }
+      case 'p': {
+        char buff[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */
+        int l = sprintf(buff, "%p", va_arg(argp, void *));
+        pushstr(L, buff, l);
+        break;
+      }
+      case '%': {
+        pushstr(L, "%", 1);
+        break;
+      }
+      default: {
+        luaG_runerror(L,
+            "invalid option " LUA_QL("%%%c") " to " LUA_QL("lua_pushfstring"),
+            *(e + 1));
+      }
+    }
+    n += 2;
+    fmt = e+2;
+  }
+  pushstr(L, fmt, strlen(fmt));
+  if (n > 0) luaV_concat(L, n + 1);
+  return svalue(L->top - 1);
+}
+
+
+const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *msg;
+  va_list argp;
+  va_start(argp, fmt);
+  msg = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  return msg;
+}
+
+
+/* number of chars of a literal string without the ending \0 */
+#define LL(x)	(sizeof(x)/sizeof(char) - 1)
+
+#define RETS	"..."
+#define PRE	"[string \""
+#define POS	"\"]"
+
+#define addstr(a,b,l)	( memcpy(a,b,(l) * sizeof(char)), a += (l) )
+
+void luaO_chunkid (char *out, const char *source, size_t bufflen) {
+  size_t l = strlen(source);
+  if (*source == '=') {  /* 'literal' source */
+    if (l <= bufflen)  /* small enough? */
+      memcpy(out, source + 1, l * sizeof(char));
+    else {  /* truncate it */
+      addstr(out, source + 1, bufflen - 1);
+      *out = '\0';
+    }
+  }
+  else if (*source == '@') {  /* file name */
+    if (l <= bufflen)  /* small enough? */
+      memcpy(out, source + 1, l * sizeof(char));
+    else {  /* add '...' before rest of name */
+      addstr(out, RETS, LL(RETS));
+      bufflen -= LL(RETS);
+      memcpy(out, source + 1 + l - bufflen, bufflen * sizeof(char));
+    }
+  }
+  else {  /* string; format as [string "source"] */
+    const char *nl = strchr(source, '\n');  /* find first new line (if any) */
+    addstr(out, PRE, LL(PRE));  /* add prefix */
+    bufflen -= LL(PRE RETS POS) + 1;  /* save space for prefix+suffix+'\0' */
+    if (l < bufflen && nl == NULL) {  /* small one-line source? */
+      addstr(out, source, l);  /* keep it */
+    }
+    else {
+      if (nl != NULL) l = nl - source;  /* stop at first newline */
+      if (l > bufflen) l = bufflen;
+      addstr(out, source, l);
+      addstr(out, RETS, LL(RETS));
+    }
+    memcpy(out, POS, (LL(POS) + 1) * sizeof(char));
+  }
+}
+
diff --git a/dep/lualib/lobject.h b/dep/lualib/lobject.h
new file mode 100644
index 0000000..ca75a02
--- /dev/null
+++ b/dep/lualib/lobject.h
@@ -0,0 +1,610 @@
+/*
+** $Id: lobject.h,v 2.70 2012/05/11 14:10:50 roberto Exp $
+** Type definitions for Lua objects
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lobject_h
+#define lobject_h
+
+
+#include <stdarg.h>
+
+
+#include "llimits.h"
+#include "lua.h"
+
+
+/*
+** Extra tags for non-values
+*/
+#define LUA_TPROTO	LUA_NUMTAGS
+#define LUA_TUPVAL	(LUA_NUMTAGS+1)
+#define LUA_TDEADKEY	(LUA_NUMTAGS+2)
+
+/*
+** number of all possible tags (including LUA_TNONE but excluding DEADKEY)
+*/
+#define LUA_TOTALTAGS	(LUA_TUPVAL+2)
+
+
+/*
+** tags for Tagged Values have the following use of bits:
+** bits 0-3: actual tag (a LUA_T* value)
+** bits 4-5: variant bits
+** bit 6: whether value is collectable
+*/
+
+#define VARBITS		(3 << 4)
+
+
+/*
+** LUA_TFUNCTION variants:
+** 0 - Lua function
+** 1 - light C function
+** 2 - regular C function (closure)
+*/
+
+/* Variant tags for functions */
+#define LUA_TLCL	(LUA_TFUNCTION | (0 << 4))  /* Lua closure */
+#define LUA_TLCF	(LUA_TFUNCTION | (1 << 4))  /* light C function */
+#define LUA_TCCL	(LUA_TFUNCTION | (2 << 4))  /* C closure */
+
+
+/*
+** LUA_TSTRING variants */
+#define LUA_TSHRSTR	(LUA_TSTRING | (0 << 4))  /* short strings */
+#define LUA_TLNGSTR	(LUA_TSTRING | (1 << 4))  /* long strings */
+
+
+/* Bit mark for collectable types */
+#define BIT_ISCOLLECTABLE	(1 << 6)
+
+/* mark a tag as collectable */
+#define ctb(t)			((t) | BIT_ISCOLLECTABLE)
+
+
+/*
+** Union of all collectable objects
+*/
+typedef union GCObject GCObject;
+
+
+/*
+** Common Header for all collectable objects (in macro form, to be
+** included in other objects)
+*/
+#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked
+
+
+/*
+** Common header in struct form
+*/
+typedef struct GCheader {
+  CommonHeader;
+} GCheader;
+
+
+
+/*
+** Union of all Lua values
+*/
+typedef union Value Value;
+
+
+#define numfield	lua_Number n;    /* numbers */
+
+
+
+/*
+** Tagged Values. This is the basic representation of values in Lua,
+** an actual value plus a tag with its type.
+*/
+
+#define TValuefields	Value value_; int tt_
+
+typedef struct lua_TValue TValue;
+
+
+/* macro defining a nil value */
+#define NILCONSTANT	{NULL}, LUA_TNIL
+
+
+#define val_(o)		((o)->value_)
+#define num_(o)		(val_(o).n)
+
+
+/* raw type tag of a TValue */
+#define rttype(o)	((o)->tt_)
+
+/* tag with no variants (bits 0-3) */
+#define novariant(x)	((x) & 0x0F)
+
+/* type tag of a TValue (bits 0-3 for tags + variant bits 4-5) */
+#define ttype(o)	(rttype(o) & 0x3F)
+
+/* type tag of a TValue with no variants (bits 0-3) */
+#define ttypenv(o)	(novariant(rttype(o)))
+
+
+/* Macros to test type */
+#define checktag(o,t)		(rttype(o) == (t))
+#define checktype(o,t)		(ttypenv(o) == (t))
+#define ttisnumber(o)		checktag((o), LUA_TNUMBER)
+#define ttisnil(o)		checktag((o), LUA_TNIL)
+#define ttisboolean(o)		checktag((o), LUA_TBOOLEAN)
+#define ttislightuserdata(o)	checktag((o), LUA_TLIGHTUSERDATA)
+#define ttisstring(o)		checktype((o), LUA_TSTRING)
+#define ttisshrstring(o)	checktag((o), ctb(LUA_TSHRSTR))
+#define ttislngstring(o)	checktag((o), ctb(LUA_TLNGSTR))
+#define ttistable(o)		checktag((o), ctb(LUA_TTABLE))
+#define ttisfunction(o)		checktype(o, LUA_TFUNCTION)
+#define ttisclosure(o)		((rttype(o) & 0x1F) == LUA_TFUNCTION)
+#define ttisCclosure(o)		checktag((o), ctb(LUA_TCCL))
+#define ttisLclosure(o)		checktag((o), ctb(LUA_TLCL))
+#define ttislcf(o)		checktag((o), LUA_TLCF)
+#define ttisuserdata(o)		checktag((o), ctb(LUA_TUSERDATA))
+#define ttisthread(o)		checktag((o), ctb(LUA_TTHREAD))
+#define ttisdeadkey(o)		checktag((o), LUA_TDEADKEY)
+
+#define ttisequal(o1,o2)	(rttype(o1) == rttype(o2))
+
+/* Macros to access values */
+#define nvalue(o)	check_exp(ttisnumber(o), num_(o))
+#define gcvalue(o)	check_exp(iscollectable(o), val_(o).gc)
+#define pvalue(o)	check_exp(ttislightuserdata(o), val_(o).p)
+#define rawtsvalue(o)	check_exp(ttisstring(o), &val_(o).gc->ts)
+#define tsvalue(o)	(&rawtsvalue(o)->tsv)
+#define rawuvalue(o)	check_exp(ttisuserdata(o), &val_(o).gc->u)
+#define uvalue(o)	(&rawuvalue(o)->uv)
+#define clvalue(o)	check_exp(ttisclosure(o), &val_(o).gc->cl)
+#define clLvalue(o)	check_exp(ttisLclosure(o), &val_(o).gc->cl.l)
+#define clCvalue(o)	check_exp(ttisCclosure(o), &val_(o).gc->cl.c)
+#define fvalue(o)	check_exp(ttislcf(o), val_(o).f)
+#define hvalue(o)	check_exp(ttistable(o), &val_(o).gc->h)
+#define bvalue(o)	check_exp(ttisboolean(o), val_(o).b)
+#define thvalue(o)	check_exp(ttisthread(o), &val_(o).gc->th)
+/* a dead value may get the 'gc' field, but cannot access its contents */
+#define deadvalue(o)	check_exp(ttisdeadkey(o), cast(void *, val_(o).gc))
+
+#define l_isfalse(o)	(ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
+
+
+#define iscollectable(o)	(rttype(o) & BIT_ISCOLLECTABLE)
+
+
+/* Macros for internal tests */
+#define righttt(obj)		(ttype(obj) == gcvalue(obj)->gch.tt)
+
+#define checkliveness(g,obj) \
+	lua_longassert(!iscollectable(obj) || \
+			(righttt(obj) && !isdead(g,gcvalue(obj))))
+
+
+/* Macros to set values */
+#define settt_(o,t)	((o)->tt_=(t))
+
+#define setnvalue(obj,x) \
+  { TValue *io=(obj); num_(io)=(x); settt_(io, LUA_TNUMBER); }
+
+#define changenvalue(o,x)	check_exp(ttisnumber(o), num_(o)=(x))
+
+#define setnilvalue(obj) settt_(obj, LUA_TNIL)
+
+#define setfvalue(obj,x) \
+  { TValue *io=(obj); val_(io).f=(x); settt_(io, LUA_TLCF); }
+
+#define setpvalue(obj,x) \
+  { TValue *io=(obj); val_(io).p=(x); settt_(io, LUA_TLIGHTUSERDATA); }
+
+#define setbvalue(obj,x) \
+  { TValue *io=(obj); val_(io).b=(x); settt_(io, LUA_TBOOLEAN); }
+
+#define setgcovalue(L,obj,x) \
+  { TValue *io=(obj); GCObject *i_g=(x); \
+    val_(io).gc=i_g; settt_(io, ctb(gch(i_g)->tt)); }
+
+#define setsvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    TString *x_ = (x); \
+    val_(io).gc=cast(GCObject *, x_); settt_(io, ctb(x_->tsv.tt)); \
+    checkliveness(G(L),io); }
+
+#define setuvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TUSERDATA)); \
+    checkliveness(G(L),io); }
+
+#define setthvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TTHREAD)); \
+    checkliveness(G(L),io); }
+
+#define setclLvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TLCL)); \
+    checkliveness(G(L),io); }
+
+#define setclCvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TCCL)); \
+    checkliveness(G(L),io); }
+
+#define sethvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TTABLE)); \
+    checkliveness(G(L),io); }
+
+#define setdeadvalue(obj)	settt_(obj, LUA_TDEADKEY)
+
+
+
+#define setobj(L,obj1,obj2) \
+	{ const TValue *io2=(obj2); TValue *io1=(obj1); \
+	  io1->value_ = io2->value_; io1->tt_ = io2->tt_; \
+	  checkliveness(G(L),io1); }
+
+
+/*
+** different types of assignments, according to destination
+*/
+
+/* from stack to (same) stack */
+#define setobjs2s	setobj
+/* to stack (not from same stack) */
+#define setobj2s	setobj
+#define setsvalue2s	setsvalue
+#define sethvalue2s	sethvalue
+#define setptvalue2s	setptvalue
+/* from table to same table */
+#define setobjt2t	setobj
+/* to table */
+#define setobj2t	setobj
+/* to new object */
+#define setobj2n	setobj
+#define setsvalue2n	setsvalue
+
+
+/* check whether a number is valid (useful only for NaN trick) */
+#define luai_checknum(L,o,c)	{ /* empty */ }
+
+
+/*
+** {======================================================
+** NaN Trick
+** =======================================================
+*/
+#if defined(LUA_NANTRICK)
+
+/*
+** numbers are represented in the 'd_' field. All other values have the
+** value (NNMARK | tag) in 'tt__'. A number with such pattern would be
+** a "signaled NaN", which is never generated by regular operations by
+** the CPU (nor by 'strtod')
+*/
+
+/* allows for external implementation for part of the trick */
+#if !defined(NNMARK)	/* { */
+
+
+#if !defined(LUA_IEEEENDIAN)
+#error option 'LUA_NANTRICK' needs 'LUA_IEEEENDIAN'
+#endif
+
+
+#define NNMARK		0x7FF7A500
+#define NNMASK		0x7FFFFF00
+
+#undef TValuefields
+#undef NILCONSTANT
+
+#if (LUA_IEEEENDIAN == 0)	/* { */
+
+/* little endian */
+#define TValuefields  \
+	union { struct { Value v__; int tt__; } i; double d__; } u
+#define NILCONSTANT	{{{NULL}, tag2tt(LUA_TNIL)}}
+/* field-access macros */
+#define v_(o)		((o)->u.i.v__)
+#define d_(o)		((o)->u.d__)
+#define tt_(o)		((o)->u.i.tt__)
+
+#else				/* }{ */
+
+/* big endian */
+#define TValuefields  \
+	union { struct { int tt__; Value v__; } i; double d__; } u
+#define NILCONSTANT	{{tag2tt(LUA_TNIL), {NULL}}}
+/* field-access macros */
+#define v_(o)		((o)->u.i.v__)
+#define d_(o)		((o)->u.d__)
+#define tt_(o)		((o)->u.i.tt__)
+
+#endif				/* } */
+
+#endif			/* } */
+
+
+/* correspondence with standard representation */
+#undef val_
+#define val_(o)		v_(o)
+#undef num_
+#define num_(o)		d_(o)
+
+
+#undef numfield
+#define numfield	/* no such field; numbers are the entire struct */
+
+/* basic check to distinguish numbers from non-numbers */
+#undef ttisnumber
+#define ttisnumber(o)	((tt_(o) & NNMASK) != NNMARK)
+
+#define tag2tt(t)	(NNMARK | (t))
+
+#undef rttype
+#define rttype(o)	(ttisnumber(o) ? LUA_TNUMBER : tt_(o) & 0xff)
+
+#undef settt_
+#define settt_(o,t)	(tt_(o) = tag2tt(t))
+
+#undef setnvalue
+#define setnvalue(obj,x) \
+	{ TValue *io_=(obj); num_(io_)=(x); lua_assert(ttisnumber(io_)); }
+
+#undef setobj
+#define setobj(L,obj1,obj2) \
+	{ const TValue *o2_=(obj2); TValue *o1_=(obj1); \
+	  o1_->u = o2_->u; \
+	  checkliveness(G(L),o1_); }
+
+
+/*
+** these redefinitions are not mandatory, but these forms are more efficient
+*/
+
+#undef checktag
+#undef checktype
+#define checktag(o,t)	(tt_(o) == tag2tt(t))
+#define checktype(o,t)	(ctb(tt_(o) | VARBITS) == ctb(tag2tt(t) | VARBITS))
+
+#undef ttisequal
+#define ttisequal(o1,o2)  \
+	(ttisnumber(o1) ? ttisnumber(o2) : (tt_(o1) == tt_(o2)))
+
+
+#undef luai_checknum
+#define luai_checknum(L,o,c)	{ if (!ttisnumber(o)) c; }
+
+#endif
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** types and prototypes
+** =======================================================
+*/
+
+
+union Value {
+  GCObject *gc;    /* collectable objects */
+  void *p;         /* light userdata */
+  int b;           /* booleans */
+  lua_CFunction f; /* light C functions */
+  numfield         /* numbers */
+};
+
+
+struct lua_TValue {
+  TValuefields;
+};
+
+
+typedef TValue *StkId;  /* index to stack elements */
+
+
+
+
+/*
+** Header for string value; string bytes follow the end of this structure
+*/
+typedef union TString {
+  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
+  struct {
+    CommonHeader;
+    lu_byte extra;  /* reserved words for short strings; "has hash" for longs */
+    unsigned int hash;
+    size_t len;  /* number of characters in string */
+  } tsv;
+} TString;
+
+
+/* get the actual string (array of bytes) from a TString */
+#define getstr(ts)	cast(const char *, (ts) + 1)
+
+/* get the actual string (array of bytes) from a Lua value */
+#define svalue(o)       getstr(rawtsvalue(o))
+
+
+/*
+** Header for userdata; memory area follows the end of this structure
+*/
+typedef union Udata {
+  L_Umaxalign dummy;  /* ensures maximum alignment for `local' udata */
+  struct {
+    CommonHeader;
+    struct Table *metatable;
+    struct Table *env;
+    size_t len;  /* number of bytes */
+  } uv;
+} Udata;
+
+
+
+/*
+** Description of an upvalue for function prototypes
+*/
+typedef struct Upvaldesc {
+  TString *name;  /* upvalue name (for debug information) */
+  lu_byte instack;  /* whether it is in stack */
+  lu_byte idx;  /* index of upvalue (in stack or in outer function's list) */
+} Upvaldesc;
+
+
+/*
+** Description of a local variable for function prototypes
+** (used for debug information)
+*/
+typedef struct LocVar {
+  TString *varname;
+  int startpc;  /* first point where variable is active */
+  int endpc;    /* first point where variable is dead */
+} LocVar;
+
+
+/*
+** Function Prototypes
+*/
+typedef struct Proto {
+  CommonHeader;
+  TValue *k;  /* constants used by the function */
+  Instruction *code;
+  struct Proto **p;  /* functions defined inside the function */
+  int *lineinfo;  /* map from opcodes to source lines (debug information) */
+  LocVar *locvars;  /* information about local variables (debug information) */
+  Upvaldesc *upvalues;  /* upvalue information */
+  union Closure *cache;  /* last created closure with this prototype */
+  TString  *source;  /* used for debug information */
+  int sizeupvalues;  /* size of 'upvalues' */
+  int sizek;  /* size of `k' */
+  int sizecode;
+  int sizelineinfo;
+  int sizep;  /* size of `p' */
+  int sizelocvars;
+  int linedefined;
+  int lastlinedefined;
+  GCObject *gclist;
+  lu_byte numparams;  /* number of fixed parameters */
+  lu_byte is_vararg;
+  lu_byte maxstacksize;  /* maximum stack used by this function */
+} Proto;
+
+
+
+/*
+** Lua Upvalues
+*/
+typedef struct UpVal {
+  CommonHeader;
+  TValue *v;  /* points to stack or to its own value */
+  union {
+    TValue value;  /* the value (when closed) */
+    struct {  /* double linked list (when open) */
+      struct UpVal *prev;
+      struct UpVal *next;
+    } l;
+  } u;
+} UpVal;
+
+
+/*
+** Closures
+*/
+
+#define ClosureHeader \
+	CommonHeader; lu_byte nupvalues; GCObject *gclist
+
+typedef struct CClosure {
+  ClosureHeader;
+  lua_CFunction f;
+  TValue upvalue[1];  /* list of upvalues */
+} CClosure;
+
+
+typedef struct LClosure {
+  ClosureHeader;
+  struct Proto *p;
+  UpVal *upvals[1];  /* list of upvalues */
+} LClosure;
+
+
+typedef union Closure {
+  CClosure c;
+  LClosure l;
+} Closure;
+
+
+#define isLfunction(o)	ttisLclosure(o)
+
+#define getproto(o)	(clLvalue(o)->p)
+
+
+/*
+** Tables
+*/
+
+typedef union TKey {
+  struct {
+    TValuefields;
+    struct Node *next;  /* for chaining */
+  } nk;
+  TValue tvk;
+} TKey;
+
+
+typedef struct Node {
+  TValue i_val;
+  TKey i_key;
+} Node;
+
+
+typedef struct Table {
+  CommonHeader;
+  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */
+  lu_byte lsizenode;  /* log2 of size of `node' array */
+  struct Table *metatable;
+  TValue *array;  /* array part */
+  Node *node;
+  Node *lastfree;  /* any free position is before this position */
+  GCObject *gclist;
+  int sizearray;  /* size of `array' array */
+} Table;
+
+
+
+/*
+** `module' operation for hashing (size is always a power of 2)
+*/
+#define lmod(s,size) \
+	(check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
+
+
+#define twoto(x)	(1<<(x))
+#define sizenode(t)	(twoto((t)->lsizenode))
+
+
+/*
+** (address of) a fixed nil value
+*/
+#define luaO_nilobject		(&luaO_nilobject_)
+
+
+LUAI_DDEC const TValue luaO_nilobject_;
+
+
+LUAI_FUNC int luaO_int2fb (unsigned int x);
+LUAI_FUNC int luaO_fb2int (int x);
+LUAI_FUNC int luaO_ceillog2 (unsigned int x);
+LUAI_FUNC lua_Number luaO_arith (int op, lua_Number v1, lua_Number v2);
+LUAI_FUNC int luaO_str2d (const char *s, size_t len, lua_Number *result);
+LUAI_FUNC int luaO_hexavalue (int c);
+LUAI_FUNC const char *luaO_pushvfstring (lua_State *L, const char *fmt,
+                                                       va_list argp);
+LUAI_FUNC const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);
+LUAI_FUNC void luaO_chunkid (char *out, const char *source, size_t len);
+
+
+#endif
+
diff --git a/dep/lualib/lopcodes.c b/dep/lualib/lopcodes.c
new file mode 100644
index 0000000..ef73692
--- /dev/null
+++ b/dep/lualib/lopcodes.c
@@ -0,0 +1,107 @@
+/*
+** $Id: lopcodes.c,v 1.49 2012/05/14 13:34:18 roberto Exp $
+** Opcodes for Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+
+#define lopcodes_c
+#define LUA_CORE
+
+
+#include "lopcodes.h"
+
+
+/* ORDER OP */
+
+LUAI_DDEF const char *const luaP_opnames[NUM_OPCODES+1] = {
+  "MOVE",
+  "LOADK",
+  "LOADKX",
+  "LOADBOOL",
+  "LOADNIL",
+  "GETUPVAL",
+  "GETTABUP",
+  "GETTABLE",
+  "SETTABUP",
+  "SETUPVAL",
+  "SETTABLE",
+  "NEWTABLE",
+  "SELF",
+  "ADD",
+  "SUB",
+  "MUL",
+  "DIV",
+  "MOD",
+  "POW",
+  "UNM",
+  "NOT",
+  "LEN",
+  "CONCAT",
+  "JMP",
+  "EQ",
+  "LT",
+  "LE",
+  "TEST",
+  "TESTSET",
+  "CALL",
+  "TAILCALL",
+  "RETURN",
+  "FORLOOP",
+  "FORPREP",
+  "TFORCALL",
+  "TFORLOOP",
+  "SETLIST",
+  "CLOSURE",
+  "VARARG",
+  "EXTRAARG",
+  NULL
+};
+
+
+#define opmode(t,a,b,c,m) (((t)<<7) | ((a)<<6) | ((b)<<4) | ((c)<<2) | (m))
+
+LUAI_DDEF const lu_byte luaP_opmodes[NUM_OPCODES] = {
+/*       T  A    B       C     mode		   opcode	*/
+  opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_MOVE */
+ ,opmode(0, 1, OpArgK, OpArgN, iABx)		/* OP_LOADK */
+ ,opmode(0, 1, OpArgN, OpArgN, iABx)		/* OP_LOADKX */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_LOADBOOL */
+ ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_LOADNIL */
+ ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_GETUPVAL */
+ ,opmode(0, 1, OpArgU, OpArgK, iABC)		/* OP_GETTABUP */
+ ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_GETTABLE */
+ ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABUP */
+ ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_SETUPVAL */
+ ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABLE */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_NEWTABLE */
+ ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_SELF */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_ADD */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SUB */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MUL */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_DIV */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MOD */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_POW */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_UNM */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_NOT */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_LEN */
+ ,opmode(0, 1, OpArgR, OpArgR, iABC)		/* OP_CONCAT */
+ ,opmode(0, 0, OpArgR, OpArgN, iAsBx)		/* OP_JMP */
+ ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_EQ */
+ ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LT */
+ ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LE */
+ ,opmode(1, 0, OpArgN, OpArgU, iABC)		/* OP_TEST */
+ ,opmode(1, 1, OpArgR, OpArgU, iABC)		/* OP_TESTSET */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_CALL */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_TAILCALL */
+ ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_RETURN */
+ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORLOOP */
+ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORPREP */
+ ,opmode(0, 0, OpArgN, OpArgU, iABC)		/* OP_TFORCALL */
+ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_TFORLOOP */
+ ,opmode(0, 0, OpArgU, OpArgU, iABC)		/* OP_SETLIST */
+ ,opmode(0, 1, OpArgU, OpArgN, iABx)		/* OP_CLOSURE */
+ ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_VARARG */
+ ,opmode(0, 0, OpArgU, OpArgU, iAx)		/* OP_EXTRAARG */
+};
+
diff --git a/dep/lualib/lopcodes.h b/dep/lualib/lopcodes.h
new file mode 100644
index 0000000..07d2b3f
--- /dev/null
+++ b/dep/lualib/lopcodes.h
@@ -0,0 +1,288 @@
+/*
+** $Id: lopcodes.h,v 1.142 2011/07/15 12:50:29 roberto Exp $
+** Opcodes for Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lopcodes_h
+#define lopcodes_h
+
+#include "llimits.h"
+
+
+/*===========================================================================
+  We assume that instructions are unsigned numbers.
+  All instructions have an opcode in the first 6 bits.
+  Instructions can have the following fields:
+	`A' : 8 bits
+	`B' : 9 bits
+	`C' : 9 bits
+	'Ax' : 26 bits ('A', 'B', and 'C' together)
+	`Bx' : 18 bits (`B' and `C' together)
+	`sBx' : signed Bx
+
+  A signed argument is represented in excess K; that is, the number
+  value is the unsigned value minus K. K is exactly the maximum value
+  for that argument (so that -max is represented by 0, and +max is
+  represented by 2*max), which is half the maximum for the corresponding
+  unsigned argument.
+===========================================================================*/
+
+
+enum OpMode {iABC, iABx, iAsBx, iAx};  /* basic instruction format */
+
+
+/*
+** size and position of opcode arguments.
+*/
+#define SIZE_C		9
+#define SIZE_B		9
+#define SIZE_Bx		(SIZE_C + SIZE_B)
+#define SIZE_A		8
+#define SIZE_Ax		(SIZE_C + SIZE_B + SIZE_A)
+
+#define SIZE_OP		6
+
+#define POS_OP		0
+#define POS_A		(POS_OP + SIZE_OP)
+#define POS_C		(POS_A + SIZE_A)
+#define POS_B		(POS_C + SIZE_C)
+#define POS_Bx		POS_C
+#define POS_Ax		POS_A
+
+
+/*
+** limits for opcode arguments.
+** we use (signed) int to manipulate most arguments,
+** so they must fit in LUAI_BITSINT-1 bits (-1 for sign)
+*/
+#if SIZE_Bx < LUAI_BITSINT-1
+#define MAXARG_Bx        ((1<<SIZE_Bx)-1)
+#define MAXARG_sBx        (MAXARG_Bx>>1)         /* `sBx' is signed */
+#else
+#define MAXARG_Bx        MAX_INT
+#define MAXARG_sBx        MAX_INT
+#endif
+
+#if SIZE_Ax < LUAI_BITSINT-1
+#define MAXARG_Ax	((1<<SIZE_Ax)-1)
+#else
+#define MAXARG_Ax	MAX_INT
+#endif
+
+
+#define MAXARG_A        ((1<<SIZE_A)-1)
+#define MAXARG_B        ((1<<SIZE_B)-1)
+#define MAXARG_C        ((1<<SIZE_C)-1)
+
+
+/* creates a mask with `n' 1 bits at position `p' */
+#define MASK1(n,p)	((~((~(Instruction)0)<<(n)))<<(p))
+
+/* creates a mask with `n' 0 bits at position `p' */
+#define MASK0(n,p)	(~MASK1(n,p))
+
+/*
+** the following macros help to manipulate instructions
+*/
+
+#define GET_OPCODE(i)	(cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))
+#define SET_OPCODE(i,o)	((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | \
+		((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))
+
+#define getarg(i,pos,size)	(cast(int, ((i)>>pos) & MASK1(size,0)))
+#define setarg(i,v,pos,size)	((i) = (((i)&MASK0(size,pos)) | \
+                ((cast(Instruction, v)<<pos)&MASK1(size,pos))))
+
+#define GETARG_A(i)	getarg(i, POS_A, SIZE_A)
+#define SETARG_A(i,v)	setarg(i, v, POS_A, SIZE_A)
+
+#define GETARG_B(i)	getarg(i, POS_B, SIZE_B)
+#define SETARG_B(i,v)	setarg(i, v, POS_B, SIZE_B)
+
+#define GETARG_C(i)	getarg(i, POS_C, SIZE_C)
+#define SETARG_C(i,v)	setarg(i, v, POS_C, SIZE_C)
+
+#define GETARG_Bx(i)	getarg(i, POS_Bx, SIZE_Bx)
+#define SETARG_Bx(i,v)	setarg(i, v, POS_Bx, SIZE_Bx)
+
+#define GETARG_Ax(i)	getarg(i, POS_Ax, SIZE_Ax)
+#define SETARG_Ax(i,v)	setarg(i, v, POS_Ax, SIZE_Ax)
+
+#define GETARG_sBx(i)	(GETARG_Bx(i)-MAXARG_sBx)
+#define SETARG_sBx(i,b)	SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
+
+
+#define CREATE_ABC(o,a,b,c)	((cast(Instruction, o)<<POS_OP) \
+			| (cast(Instruction, a)<<POS_A) \
+			| (cast(Instruction, b)<<POS_B) \
+			| (cast(Instruction, c)<<POS_C))
+
+#define CREATE_ABx(o,a,bc)	((cast(Instruction, o)<<POS_OP) \
+			| (cast(Instruction, a)<<POS_A) \
+			| (cast(Instruction, bc)<<POS_Bx))
+
+#define CREATE_Ax(o,a)		((cast(Instruction, o)<<POS_OP) \
+			| (cast(Instruction, a)<<POS_Ax))
+
+
+/*
+** Macros to operate RK indices
+*/
+
+/* this bit 1 means constant (0 means register) */
+#define BITRK		(1 << (SIZE_B - 1))
+
+/* test whether value is a constant */
+#define ISK(x)		((x) & BITRK)
+
+/* gets the index of the constant */
+#define INDEXK(r)	((int)(r) & ~BITRK)
+
+#define MAXINDEXRK	(BITRK - 1)
+
+/* code a constant index as a RK value */
+#define RKASK(x)	((x) | BITRK)
+
+
+/*
+** invalid register that fits in 8 bits
+*/
+#define NO_REG		MAXARG_A
+
+
+/*
+** R(x) - register
+** Kst(x) - constant (in constant table)
+** RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)
+*/
+
+
+/*
+** grep "ORDER OP" if you change these enums
+*/
+
+typedef enum {
+/*----------------------------------------------------------------------
+name		args	description
+------------------------------------------------------------------------*/
+OP_MOVE,/*	A B	R(A) := R(B)					*/
+OP_LOADK,/*	A Bx	R(A) := Kst(Bx)					*/
+OP_LOADKX,/*	A 	R(A) := Kst(extra arg)				*/
+OP_LOADBOOL,/*	A B C	R(A) := (Bool)B; if (C) pc++			*/
+OP_LOADNIL,/*	A B	R(A), R(A+1), ..., R(A+B) := nil		*/
+OP_GETUPVAL,/*	A B	R(A) := UpValue[B]				*/
+
+OP_GETTABUP,/*	A B C	R(A) := UpValue[B][RK(C)]			*/
+OP_GETTABLE,/*	A B C	R(A) := R(B)[RK(C)]				*/
+
+OP_SETTABUP,/*	A B C	UpValue[A][RK(B)] := RK(C)			*/
+OP_SETUPVAL,/*	A B	UpValue[B] := R(A)				*/
+OP_SETTABLE,/*	A B C	R(A)[RK(B)] := RK(C)				*/
+
+OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/
+
+OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/
+
+OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
+OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
+OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
+OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
+OP_MOD,/*	A B C	R(A) := RK(B) % RK(C)				*/
+OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
+OP_UNM,/*	A B	R(A) := -R(B)					*/
+OP_NOT,/*	A B	R(A) := not R(B)				*/
+OP_LEN,/*	A B	R(A) := length of R(B)				*/
+
+OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/
+
+OP_JMP,/*	A sBx	pc+=sBx; if (A) close all upvalues >= R(A) + 1	*/
+OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
+OP_LT,/*	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++		*/
+OP_LE,/*	A B C	if ((RK(B) <= RK(C)) ~= A) then pc++		*/
+
+OP_TEST,/*	A C	if not (R(A) <=> C) then pc++			*/
+OP_TESTSET,/*	A B C	if (R(B) <=> C) then R(A) := R(B) else pc++	*/
+
+OP_CALL,/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
+OP_TAILCALL,/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*/
+OP_RETURN,/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*/
+
+OP_FORLOOP,/*	A sBx	R(A)+=R(A+2);
+			if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }*/
+OP_FORPREP,/*	A sBx	R(A)-=R(A+2); pc+=sBx				*/
+
+OP_TFORCALL,/*	A C	R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));	*/
+OP_TFORLOOP,/*	A sBx	if R(A+1) ~= nil then { R(A)=R(A+1); pc += sBx }*/
+
+OP_SETLIST,/*	A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B	*/
+
+OP_CLOSURE,/*	A Bx	R(A) := closure(KPROTO[Bx])			*/
+
+OP_VARARG,/*	A B	R(A), R(A+1), ..., R(A+B-2) = vararg		*/
+
+OP_EXTRAARG/*	Ax	extra (larger) argument for previous opcode	*/
+} OpCode;
+
+
+#define NUM_OPCODES	(cast(int, OP_EXTRAARG) + 1)
+
+
+
+/*===========================================================================
+  Notes:
+  (*) In OP_CALL, if (B == 0) then B = top. If (C == 0), then `top' is
+  set to last_result+1, so next open instruction (OP_CALL, OP_RETURN,
+  OP_SETLIST) may use `top'.
+
+  (*) In OP_VARARG, if (B == 0) then use actual number of varargs and
+  set top (like in OP_CALL with C == 0).
+
+  (*) In OP_RETURN, if (B == 0) then return up to `top'.
+
+  (*) In OP_SETLIST, if (B == 0) then B = `top'; if (C == 0) then next
+  'instruction' is EXTRAARG(real C).
+
+  (*) In OP_LOADKX, the next 'instruction' is always EXTRAARG.
+
+  (*) For comparisons, A specifies what condition the test should accept
+  (true or false).
+
+  (*) All `skips' (pc++) assume that next instruction is a jump.
+
+===========================================================================*/
+
+
+/*
+** masks for instruction properties. The format is:
+** bits 0-1: op mode
+** bits 2-3: C arg mode
+** bits 4-5: B arg mode
+** bit 6: instruction set register A
+** bit 7: operator is a test (next instruction must be a jump)
+*/
+
+enum OpArgMask {
+  OpArgN,  /* argument is not used */
+  OpArgU,  /* argument is used */
+  OpArgR,  /* argument is a register or a jump offset */
+  OpArgK   /* argument is a constant or register/constant */
+};
+
+LUAI_DDEC const lu_byte luaP_opmodes[NUM_OPCODES];
+
+#define getOpMode(m)	(cast(enum OpMode, luaP_opmodes[m] & 3))
+#define getBMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))
+#define getCMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))
+#define testAMode(m)	(luaP_opmodes[m] & (1 << 6))
+#define testTMode(m)	(luaP_opmodes[m] & (1 << 7))
+
+
+LUAI_DDEC const char *const luaP_opnames[NUM_OPCODES+1];  /* opcode names */
+
+
+/* number of list items to accumulate before a SETLIST instruction */
+#define LFIELDS_PER_FLUSH	50
+
+
+#endif
diff --git a/dep/lualib/loslib.c b/dep/lualib/loslib.c
new file mode 100644
index 0000000..489755b
--- /dev/null
+++ b/dep/lualib/loslib.c
@@ -0,0 +1,323 @@
+/*
+** $Id: loslib.c,v 1.39 2012/05/23 15:37:09 roberto Exp $
+** Standard Operating System library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <errno.h>
+#include <locale.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#define loslib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/*
+** list of valid conversion specifiers for the 'strftime' function
+*/
+#if !defined(LUA_STRFTIMEOPTIONS)
+
+#if !defined(LUA_USE_POSIX)
+#define LUA_STRFTIMEOPTIONS	{ "aAbBcdHIjmMpSUwWxXyYz%", "" }
+#else
+#define LUA_STRFTIMEOPTIONS \
+	{ "aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%", "" \
+	  "", "E", "cCxXyY",  \
+	  "O", "deHImMSuUVwWy" }
+#endif
+
+#endif
+
+
+
+/*
+** By default, Lua uses tmpnam except when POSIX is available, where it
+** uses mkstemp.
+*/
+#if defined(LUA_USE_MKSTEMP)
+#include <unistd.h>
+#define LUA_TMPNAMBUFSIZE	32
+#define lua_tmpnam(b,e) { \
+        strcpy(b, "/tmp/lua_XXXXXX"); \
+        e = mkstemp(b); \
+        if (e != -1) close(e); \
+        e = (e == -1); }
+
+#elif !defined(lua_tmpnam)
+
+#define LUA_TMPNAMBUFSIZE	L_tmpnam
+#define lua_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }
+
+#endif
+
+
+/*
+** By default, Lua uses gmtime/localtime, except when POSIX is available,
+** where it uses gmtime_r/localtime_r
+*/
+#if defined(LUA_USE_GMTIME_R)
+
+#define l_gmtime(t,r)		gmtime_r(t,r)
+#define l_localtime(t,r)	localtime_r(t,r)
+
+#elif !defined(l_gmtime)
+
+#define l_gmtime(t,r)		((void)r, gmtime(t))
+#define l_localtime(t,r)  	((void)r, localtime(t))
+
+#endif
+
+
+
+static int os_execute (lua_State *L) {
+  const char *cmd = luaL_optstring(L, 1, NULL);
+  int stat = system(cmd);
+  if (cmd != NULL)
+    return luaL_execresult(L, stat);
+  else {
+    lua_pushboolean(L, stat);  /* true if there is a shell */
+    return 1;
+  }
+}
+
+
+static int os_remove (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  return luaL_fileresult(L, remove(filename) == 0, filename);
+}
+
+
+static int os_rename (lua_State *L) {
+  const char *fromname = luaL_checkstring(L, 1);
+  const char *toname = luaL_checkstring(L, 2);
+  return luaL_fileresult(L, rename(fromname, toname) == 0, fromname);
+}
+
+
+static int os_tmpname (lua_State *L) {
+  char buff[LUA_TMPNAMBUFSIZE];
+  int err;
+  lua_tmpnam(buff, err);
+  if (err)
+    return luaL_error(L, "unable to generate a unique filename");
+  lua_pushstring(L, buff);
+  return 1;
+}
+
+
+static int os_getenv (lua_State *L) {
+  lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */
+  return 1;
+}
+
+
+static int os_clock (lua_State *L) {
+  lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** Time/Date operations
+** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
+**   wday=%w+1, yday=%j, isdst=? }
+** =======================================================
+*/
+
+static void setfield (lua_State *L, const char *key, int value) {
+  lua_pushinteger(L, value);
+  lua_setfield(L, -2, key);
+}
+
+static void setboolfield (lua_State *L, const char *key, int value) {
+  if (value < 0)  /* undefined? */
+    return;  /* does not set field */
+  lua_pushboolean(L, value);
+  lua_setfield(L, -2, key);
+}
+
+static int getboolfield (lua_State *L, const char *key) {
+  int res;
+  lua_getfield(L, -1, key);
+  res = lua_isnil(L, -1) ? -1 : lua_toboolean(L, -1);
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static int getfield (lua_State *L, const char *key, int d) {
+  int res, isnum;
+  lua_getfield(L, -1, key);
+  res = (int)lua_tointegerx(L, -1, &isnum);
+  if (!isnum) {
+    if (d < 0)
+      return luaL_error(L, "field " LUA_QS " missing in date table", key);
+    res = d;
+  }
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static const char *checkoption (lua_State *L, const char *conv, char *buff) {
+  static const char *const options[] = LUA_STRFTIMEOPTIONS;
+  unsigned int i;
+  for (i = 0; i < sizeof(options)/sizeof(options[0]); i += 2) {
+    if (*conv != '\0' && strchr(options[i], *conv) != NULL) {
+      buff[1] = *conv;
+      if (*options[i + 1] == '\0') {  /* one-char conversion specifier? */
+        buff[2] = '\0';  /* end buffer */
+        return conv + 1;
+      }
+      else if (*(conv + 1) != '\0' &&
+               strchr(options[i + 1], *(conv + 1)) != NULL) {
+        buff[2] = *(conv + 1);  /* valid two-char conversion specifier */
+        buff[3] = '\0';  /* end buffer */
+        return conv + 2;
+      }
+    }
+  }
+  luaL_argerror(L, 1,
+    lua_pushfstring(L, "invalid conversion specifier '%%%s'", conv));
+  return conv;  /* to avoid warnings */
+}
+
+
+static int os_date (lua_State *L) {
+  const char *s = luaL_optstring(L, 1, "%c");
+  time_t t = luaL_opt(L, (time_t)luaL_checknumber, 2, time(NULL));
+  struct tm tmr, *stm;
+  if (*s == '!') {  /* UTC? */
+    stm = l_gmtime(&t, &tmr);
+    s++;  /* skip `!' */
+  }
+  else
+    stm = l_localtime(&t, &tmr);
+  if (stm == NULL)  /* invalid date? */
+    lua_pushnil(L);
+  else if (strcmp(s, "*t") == 0) {
+    lua_createtable(L, 0, 9);  /* 9 = number of fields */
+    setfield(L, "sec", stm->tm_sec);
+    setfield(L, "min", stm->tm_min);
+    setfield(L, "hour", stm->tm_hour);
+    setfield(L, "day", stm->tm_mday);
+    setfield(L, "month", stm->tm_mon+1);
+    setfield(L, "year", stm->tm_year+1900);
+    setfield(L, "wday", stm->tm_wday+1);
+    setfield(L, "yday", stm->tm_yday+1);
+    setboolfield(L, "isdst", stm->tm_isdst);
+  }
+  else {
+    char cc[4];
+    luaL_Buffer b;
+    cc[0] = '%';
+    luaL_buffinit(L, &b);
+    while (*s) {
+      if (*s != '%')  /* no conversion specifier? */
+        luaL_addchar(&b, *s++);
+      else {
+        size_t reslen;
+        char buff[200];  /* should be big enough for any conversion result */
+        s = checkoption(L, s + 1, cc);
+        reslen = strftime(buff, sizeof(buff), cc, stm);
+        luaL_addlstring(&b, buff, reslen);
+      }
+    }
+    luaL_pushresult(&b);
+  }
+  return 1;
+}
+
+
+static int os_time (lua_State *L) {
+  time_t t;
+  if (lua_isnoneornil(L, 1))  /* called without args? */
+    t = time(NULL);  /* get current time */
+  else {
+    struct tm ts;
+    luaL_checktype(L, 1, LUA_TTABLE);
+    lua_settop(L, 1);  /* make sure table is at the top */
+    ts.tm_sec = getfield(L, "sec", 0);
+    ts.tm_min = getfield(L, "min", 0);
+    ts.tm_hour = getfield(L, "hour", 12);
+    ts.tm_mday = getfield(L, "day", -1);
+    ts.tm_mon = getfield(L, "month", -1) - 1;
+    ts.tm_year = getfield(L, "year", -1) - 1900;
+    ts.tm_isdst = getboolfield(L, "isdst");
+    t = mktime(&ts);
+  }
+  if (t == (time_t)(-1))
+    lua_pushnil(L);
+  else
+    lua_pushnumber(L, (lua_Number)t);
+  return 1;
+}
+
+
+static int os_difftime (lua_State *L) {
+  lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
+                             (time_t)(luaL_optnumber(L, 2, 0))));
+  return 1;
+}
+
+/* }====================================================== */
+
+
+static int os_setlocale (lua_State *L) {
+  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,
+                      LC_NUMERIC, LC_TIME};
+  static const char *const catnames[] = {"all", "collate", "ctype", "monetary",
+     "numeric", "time", NULL};
+  const char *l = luaL_optstring(L, 1, NULL);
+  int op = luaL_checkoption(L, 2, "all", catnames);
+  lua_pushstring(L, setlocale(cat[op], l));
+  return 1;
+}
+
+
+static int os_exit (lua_State *L) {
+  int status;
+  if (lua_isboolean(L, 1))
+    status = (lua_toboolean(L, 1) ? EXIT_SUCCESS : EXIT_FAILURE);
+  else
+    status = luaL_optint(L, 1, EXIT_SUCCESS);
+  if (lua_toboolean(L, 2))
+    lua_close(L);
+  if (L) exit(status);  /* 'if' to avoid warnings for unreachable 'return' */
+  return 0;
+}
+
+
+static const luaL_Reg syslib[] = {
+  {"clock",     os_clock},
+  {"date",      os_date},
+  {"difftime",  os_difftime},
+  {"execute",   os_execute},
+  {"exit",      os_exit},
+  {"getenv",    os_getenv},
+  {"remove",    os_remove},
+  {"rename",    os_rename},
+  {"setlocale", os_setlocale},
+  {"time",      os_time},
+  {"tmpname",   os_tmpname},
+  {NULL, NULL}
+};
+
+/* }====================================================== */
+
+
+
+LUAMOD_API int luaopen_os (lua_State *L) {
+  luaL_newlib(L, syslib);
+  return 1;
+}
+
diff --git a/dep/lualib/lparser.c b/dep/lualib/lparser.c
new file mode 100644
index 0000000..b3eb3ca
--- /dev/null
+++ b/dep/lualib/lparser.c
@@ -0,0 +1,1635 @@
+/*
+** $Id: lparser.c,v 2.128 2012/05/20 14:51:23 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lparser_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+
+
+
+/* maximum number of local variables per function (must be smaller
+   than 250, due to the bytecode format) */
+#define MAXVARS		200
+
+
+#define hasmultret(k)		((k) == VCALL || (k) == VVARARG)
+
+
+
+/*
+** nodes for block list (list of active blocks)
+*/
+typedef struct BlockCnt {
+  struct BlockCnt *previous;  /* chain */
+  short firstlabel;  /* index of first label in this block */
+  short firstgoto;  /* index of first pending goto in this block */
+  lu_byte nactvar;  /* # active locals outside the block */
+  lu_byte upval;  /* true if some variable in the block is an upvalue */
+  lu_byte isloop;  /* true if `block' is a loop */
+} BlockCnt;
+
+
+
+/*
+** prototypes for recursive non-terminal functions
+*/
+static void statement (LexState *ls);
+static void expr (LexState *ls, expdesc *v);
+
+
+static void anchor_token (LexState *ls) {
+  /* last token from outer function must be EOS */
+  lua_assert(ls->fs != NULL || ls->t.token == TK_EOS);
+  if (ls->t.token == TK_NAME || ls->t.token == TK_STRING) {
+    TString *ts = ls->t.seminfo.ts;
+    luaX_newstring(ls, getstr(ts), ts->tsv.len);
+  }
+}
+
+
+/* semantic error */
+static l_noret semerror (LexState *ls, const char *msg) {
+  ls->t.token = 0;  /* remove 'near to' from final message */
+  luaX_syntaxerror(ls, msg);
+}
+
+
+static l_noret error_expected (LexState *ls, int token) {
+  luaX_syntaxerror(ls,
+      luaO_pushfstring(ls->L, "%s expected", luaX_token2str(ls, token)));
+}
+
+
+static l_noret errorlimit (FuncState *fs, int limit, const char *what) {
+  lua_State *L = fs->ls->L;
+  const char *msg;
+  int line = fs->f->linedefined;
+  const char *where = (line == 0)
+                      ? "main function"
+                      : luaO_pushfstring(L, "function at line %d", line);
+  msg = luaO_pushfstring(L, "too many %s (limit is %d) in %s",
+                             what, limit, where);
+  luaX_syntaxerror(fs->ls, msg);
+}
+
+
+static void checklimit (FuncState *fs, int v, int l, const char *what) {
+  if (v > l) errorlimit(fs, l, what);
+}
+
+
+static int testnext (LexState *ls, int c) {
+  if (ls->t.token == c) {
+    luaX_next(ls);
+    return 1;
+  }
+  else return 0;
+}
+
+
+static void check (LexState *ls, int c) {
+  if (ls->t.token != c)
+    error_expected(ls, c);
+}
+
+
+static void checknext (LexState *ls, int c) {
+  check(ls, c);
+  luaX_next(ls);
+}
+
+
+#define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }
+
+
+
+static void check_match (LexState *ls, int what, int who, int where) {
+  if (!testnext(ls, what)) {
+    if (where == ls->linenumber)
+      error_expected(ls, what);
+    else {
+      luaX_syntaxerror(ls, luaO_pushfstring(ls->L,
+             "%s expected (to close %s at line %d)",
+              luaX_token2str(ls, what), luaX_token2str(ls, who), where));
+    }
+  }
+}
+
+
+static TString *str_checkname (LexState *ls) {
+  TString *ts;
+  check(ls, TK_NAME);
+  ts = ls->t.seminfo.ts;
+  luaX_next(ls);
+  return ts;
+}
+
+
+static void init_exp (expdesc *e, expkind k, int i) {
+  e->f = e->t = NO_JUMP;
+  e->k = k;
+  e->u.info = i;
+}
+
+
+static void codestring (LexState *ls, expdesc *e, TString *s) {
+  init_exp(e, VK, luaK_stringK(ls->fs, s));
+}
+
+
+static void checkname (LexState *ls, expdesc *e) {
+  codestring(ls, e, str_checkname(ls));
+}
+
+
+static int registerlocalvar (LexState *ls, TString *varname) {
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  int oldsize = f->sizelocvars;
+  luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,
+                  LocVar, SHRT_MAX, "local variables");
+  while (oldsize < f->sizelocvars) f->locvars[oldsize++].varname = NULL;
+  f->locvars[fs->nlocvars].varname = varname;
+  luaC_objbarrier(ls->L, f, varname);
+  return fs->nlocvars++;
+}
+
+
+static void new_localvar (LexState *ls, TString *name) {
+  FuncState *fs = ls->fs;
+  Dyndata *dyd = ls->dyd;
+  int reg = registerlocalvar(ls, name);
+  checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal,
+                  MAXVARS, "local variables");
+  luaM_growvector(ls->L, dyd->actvar.arr, dyd->actvar.n + 1,
+                  dyd->actvar.size, Vardesc, MAX_INT, "local variables");
+  dyd->actvar.arr[dyd->actvar.n++].idx = cast(short, reg);
+}
+
+
+static void new_localvarliteral_ (LexState *ls, const char *name, size_t sz) {
+  new_localvar(ls, luaX_newstring(ls, name, sz));
+}
+
+#define new_localvarliteral(ls,v) \
+	new_localvarliteral_(ls, "" v, (sizeof(v)/sizeof(char))-1)
+
+
+static LocVar *getlocvar (FuncState *fs, int i) {
+  int idx = fs->ls->dyd->actvar.arr[fs->firstlocal + i].idx;
+  lua_assert(idx < fs->nlocvars);
+  return &fs->f->locvars[idx];
+}
+
+
+static void adjustlocalvars (LexState *ls, int nvars) {
+  FuncState *fs = ls->fs;
+  fs->nactvar = cast_byte(fs->nactvar + nvars);
+  for (; nvars; nvars--) {
+    getlocvar(fs, fs->nactvar - nvars)->startpc = fs->pc;
+  }
+}
+
+
+static void removevars (FuncState *fs, int tolevel) {
+  fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);
+  while (fs->nactvar > tolevel)
+    getlocvar(fs, --fs->nactvar)->endpc = fs->pc;
+}
+
+
+static int searchupvalue (FuncState *fs, TString *name) {
+  int i;
+  Upvaldesc *up = fs->f->upvalues;
+  for (i = 0; i < fs->nups; i++) {
+    if (luaS_eqstr(up[i].name, name)) return i;
+  }
+  return -1;  /* not found */
+}
+
+
+static int newupvalue (FuncState *fs, TString *name, expdesc *v) {
+  Proto *f = fs->f;
+  int oldsize = f->sizeupvalues;
+  checklimit(fs, fs->nups + 1, MAXUPVAL, "upvalues");
+  luaM_growvector(fs->ls->L, f->upvalues, fs->nups, f->sizeupvalues,
+                  Upvaldesc, MAXUPVAL, "upvalues");
+  while (oldsize < f->sizeupvalues) f->upvalues[oldsize++].name = NULL;
+  f->upvalues[fs->nups].instack = (v->k == VLOCAL);
+  f->upvalues[fs->nups].idx = cast_byte(v->u.info);
+  f->upvalues[fs->nups].name = name;
+  luaC_objbarrier(fs->ls->L, f, name);
+  return fs->nups++;
+}
+
+
+static int searchvar (FuncState *fs, TString *n) {
+  int i;
+  for (i=fs->nactvar-1; i >= 0; i--) {
+    if (luaS_eqstr(n, getlocvar(fs, i)->varname))
+      return i;
+  }
+  return -1;  /* not found */
+}
+
+
+/*
+  Mark block where variable at given level was defined
+  (to emit close instructions later).
+*/
+static void markupval (FuncState *fs, int level) {
+  BlockCnt *bl = fs->bl;
+  while (bl->nactvar > level) bl = bl->previous;
+  bl->upval = 1;
+}
+
+
+/*
+  Find variable with given name 'n'. If it is an upvalue, add this
+  upvalue into all intermediate functions.
+*/
+static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
+  if (fs == NULL)  /* no more levels? */
+    return VVOID;  /* default is global */
+  else {
+    int v = searchvar(fs, n);  /* look up locals at current level */
+    if (v >= 0) {  /* found? */
+      init_exp(var, VLOCAL, v);  /* variable is local */
+      if (!base)
+        markupval(fs, v);  /* local will be used as an upval */
+      return VLOCAL;
+    }
+    else {  /* not found as local at current level; try upvalues */
+      int idx = searchupvalue(fs, n);  /* try existing upvalues */
+      if (idx < 0) {  /* not found? */
+        if (singlevaraux(fs->prev, n, var, 0) == VVOID) /* try upper levels */
+          return VVOID;  /* not found; is a global */
+        /* else was LOCAL or UPVAL */
+        idx  = newupvalue(fs, n, var);  /* will be a new upvalue */
+      }
+      init_exp(var, VUPVAL, idx);
+      return VUPVAL;
+    }
+  }
+}
+
+
+static void singlevar (LexState *ls, expdesc *var) {
+  TString *varname = str_checkname(ls);
+  FuncState *fs = ls->fs;
+  if (singlevaraux(fs, varname, var, 1) == VVOID) {  /* global name? */
+    expdesc key;
+    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */
+    lua_assert(var->k == VLOCAL || var->k == VUPVAL);
+    codestring(ls, &key, varname);  /* key is variable name */
+    luaK_indexed(fs, var, &key);  /* env[varname] */
+  }
+}
+
+
+static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
+  FuncState *fs = ls->fs;
+  int extra = nvars - nexps;
+  if (hasmultret(e->k)) {
+    extra++;  /* includes call itself */
+    if (extra < 0) extra = 0;
+    luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */
+    if (extra > 1) luaK_reserveregs(fs, extra-1);
+  }
+  else {
+    if (e->k != VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */
+    if (extra > 0) {
+      int reg = fs->freereg;
+      luaK_reserveregs(fs, extra);
+      luaK_nil(fs, reg, extra);
+    }
+  }
+}
+
+
+static void enterlevel (LexState *ls) {
+  lua_State *L = ls->L;
+  ++L->nCcalls;
+  checklimit(ls->fs, L->nCcalls, LUAI_MAXCCALLS, "C levels");
+}
+
+
+#define leavelevel(ls)	((ls)->L->nCcalls--)
+
+
+static void closegoto (LexState *ls, int g, Labeldesc *label) {
+  int i;
+  FuncState *fs = ls->fs;
+  Labellist *gl = &ls->dyd->gt;
+  Labeldesc *gt = &gl->arr[g];
+  lua_assert(luaS_eqstr(gt->name, label->name));
+  if (gt->nactvar < label->nactvar) {
+    TString *vname = getlocvar(fs, gt->nactvar)->varname;
+    const char *msg = luaO_pushfstring(ls->L,
+      "<goto %s> at line %d jumps into the scope of local " LUA_QS,
+      getstr(gt->name), gt->line, getstr(vname));
+    semerror(ls, msg);
+  }
+  luaK_patchlist(fs, gt->pc, label->pc);
+  /* remove goto from pending list */
+  for (i = g; i < gl->n - 1; i++)
+    gl->arr[i] = gl->arr[i + 1];
+  gl->n--;
+}
+
+
+/*
+** try to close a goto with existing labels; this solves backward jumps
+*/
+static int findlabel (LexState *ls, int g) {
+  int i;
+  BlockCnt *bl = ls->fs->bl;
+  Dyndata *dyd = ls->dyd;
+  Labeldesc *gt = &dyd->gt.arr[g];
+  /* check labels in current block for a match */
+  for (i = bl->firstlabel; i < dyd->label.n; i++) {
+    Labeldesc *lb = &dyd->label.arr[i];
+    if (luaS_eqstr(lb->name, gt->name)) {  /* correct label? */
+      if (gt->nactvar > lb->nactvar &&
+          (bl->upval || dyd->label.n > bl->firstlabel))
+        luaK_patchclose(ls->fs, gt->pc, lb->nactvar);
+      closegoto(ls, g, lb);  /* close it */
+      return 1;
+    }
+  }
+  return 0;  /* label not found; cannot close goto */
+}
+
+
+static int newlabelentry (LexState *ls, Labellist *l, TString *name,
+                          int line, int pc) {
+  int n = l->n;
+  luaM_growvector(ls->L, l->arr, n, l->size,
+                  Labeldesc, SHRT_MAX, "labels/gotos");
+  l->arr[n].name = name;
+  l->arr[n].line = line;
+  l->arr[n].nactvar = ls->fs->nactvar;
+  l->arr[n].pc = pc;
+  l->n++;
+  return n;
+}
+
+
+/*
+** check whether new label 'lb' matches any pending gotos in current
+** block; solves forward jumps
+*/
+static void findgotos (LexState *ls, Labeldesc *lb) {
+  Labellist *gl = &ls->dyd->gt;
+  int i = ls->fs->bl->firstgoto;
+  while (i < gl->n) {
+    if (luaS_eqstr(gl->arr[i].name, lb->name))
+      closegoto(ls, i, lb);
+    else
+      i++;
+  }
+}
+
+
+/*
+** "export" pending gotos to outer level, to check them against
+** outer labels; if the block being exited has upvalues, and
+** the goto exits the scope of any variable (which can be the
+** upvalue), close those variables being exited.
+*/
+static void movegotosout (FuncState *fs, BlockCnt *bl) {
+  int i = bl->firstgoto;
+  Labellist *gl = &fs->ls->dyd->gt;
+  /* correct pending gotos to current block and try to close it
+     with visible labels */
+  while (i < gl->n) {
+    Labeldesc *gt = &gl->arr[i];
+    if (gt->nactvar > bl->nactvar) {
+      if (bl->upval)
+        luaK_patchclose(fs, gt->pc, bl->nactvar);
+      gt->nactvar = bl->nactvar;
+    }
+    if (!findlabel(fs->ls, i))
+      i++;  /* move to next one */
+  }
+}
+
+
+static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isloop) {
+  bl->isloop = isloop;
+  bl->nactvar = fs->nactvar;
+  bl->firstlabel = fs->ls->dyd->label.n;
+  bl->firstgoto = fs->ls->dyd->gt.n;
+  bl->upval = 0;
+  bl->previous = fs->bl;
+  fs->bl = bl;
+  lua_assert(fs->freereg == fs->nactvar);
+}
+
+
+/*
+** create a label named "break" to resolve break statements
+*/
+static void breaklabel (LexState *ls) {
+  TString *n = luaS_new(ls->L, "break");
+  int l = newlabelentry(ls, &ls->dyd->label, n, 0, ls->fs->pc);
+  findgotos(ls, &ls->dyd->label.arr[l]);
+}
+
+/*
+** generates an error for an undefined 'goto'; choose appropriate
+** message when label name is a reserved word (which can only be 'break')
+*/
+static l_noret undefgoto (LexState *ls, Labeldesc *gt) {
+  const char *msg = isreserved(gt->name)
+                    ? "<%s> at line %d not inside a loop"
+                    : "no visible label " LUA_QS " for <goto> at line %d";
+  msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);
+  semerror(ls, msg);
+}
+
+
+static void leaveblock (FuncState *fs) {
+  BlockCnt *bl = fs->bl;
+  LexState *ls = fs->ls;
+  if (bl->previous && bl->upval) {
+    /* create a 'jump to here' to close upvalues */
+    int j = luaK_jump(fs);
+    luaK_patchclose(fs, j, bl->nactvar);
+    luaK_patchtohere(fs, j);
+  }
+  if (bl->isloop)
+    breaklabel(ls);  /* close pending breaks */
+  fs->bl = bl->previous;
+  removevars(fs, bl->nactvar);
+  lua_assert(bl->nactvar == fs->nactvar);
+  fs->freereg = fs->nactvar;  /* free registers */
+  ls->dyd->label.n = bl->firstlabel;  /* remove local labels */
+  if (bl->previous)  /* inner block? */
+    movegotosout(fs, bl);  /* update pending gotos to outer block */
+  else if (bl->firstgoto < ls->dyd->gt.n)  /* pending gotos in outer block? */
+    undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]);  /* error */
+}
+
+
+/*
+** adds a new prototype into list of prototypes
+*/
+static Proto *addprototype (LexState *ls) {
+  Proto *clp;
+  lua_State *L = ls->L;
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;  /* prototype of current function */
+  if (fs->np >= f->sizep) {
+    int oldsize = f->sizep;
+    luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, "functions");
+    while (oldsize < f->sizep) f->p[oldsize++] = NULL;
+  }
+  f->p[fs->np++] = clp = luaF_newproto(L);
+  luaC_objbarrier(L, f, clp);
+  return clp;
+}
+
+
+/*
+** codes instruction to create new closure in parent function
+*/
+static void codeclosure (LexState *ls, expdesc *v) {
+  FuncState *fs = ls->fs->prev;
+  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));
+  luaK_exp2nextreg(fs, v);  /* fix it at stack top (for GC) */
+}
+
+
+static void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {
+  lua_State *L = ls->L;
+  Proto *f;
+  fs->prev = ls->fs;  /* linked list of funcstates */
+  fs->ls = ls;
+  ls->fs = fs;
+  fs->pc = 0;
+  fs->lasttarget = 0;
+  fs->jpc = NO_JUMP;
+  fs->freereg = 0;
+  fs->nk = 0;
+  fs->np = 0;
+  fs->nups = 0;
+  fs->nlocvars = 0;
+  fs->nactvar = 0;
+  fs->firstlocal = ls->dyd->actvar.n;
+  fs->bl = NULL;
+  f = fs->f;
+  f->source = ls->source;
+  f->maxstacksize = 2;  /* registers 0/1 are always valid */
+  fs->h = luaH_new(L);
+  /* anchor table of constants (to avoid being collected) */
+  sethvalue2s(L, L->top, fs->h);
+  incr_top(L);
+  enterblock(fs, bl, 0);
+}
+
+
+static void close_func (LexState *ls) {
+  lua_State *L = ls->L;
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  luaK_ret(fs, 0, 0);  /* final return */
+  leaveblock(fs);
+  luaM_reallocvector(L, f->code, f->sizecode, fs->pc, Instruction);
+  f->sizecode = fs->pc;
+  luaM_reallocvector(L, f->lineinfo, f->sizelineinfo, fs->pc, int);
+  f->sizelineinfo = fs->pc;
+  luaM_reallocvector(L, f->k, f->sizek, fs->nk, TValue);
+  f->sizek = fs->nk;
+  luaM_reallocvector(L, f->p, f->sizep, fs->np, Proto *);
+  f->sizep = fs->np;
+  luaM_reallocvector(L, f->locvars, f->sizelocvars, fs->nlocvars, LocVar);
+  f->sizelocvars = fs->nlocvars;
+  luaM_reallocvector(L, f->upvalues, f->sizeupvalues, fs->nups, Upvaldesc);
+  f->sizeupvalues = fs->nups;
+  lua_assert(fs->bl == NULL);
+  ls->fs = fs->prev;
+  /* last token read was anchored in defunct function; must re-anchor it */
+  anchor_token(ls);
+  L->top--;  /* pop table of constants */
+  luaC_checkGC(L);
+}
+
+
+
+/*============================================================*/
+/* GRAMMAR RULES */
+/*============================================================*/
+
+
+/*
+** check whether current token is in the follow set of a block.
+** 'until' closes syntactical blocks, but do not close scope,
+** so it handled in separate.
+*/
+static int block_follow (LexState *ls, int withuntil) {
+  switch (ls->t.token) {
+    case TK_ELSE: case TK_ELSEIF:
+    case TK_END: case TK_EOS:
+      return 1;
+    case TK_UNTIL: return withuntil;
+    default: return 0;
+  }
+}
+
+
+static void statlist (LexState *ls) {
+  /* statlist -> { stat [`;'] } */
+  while (!block_follow(ls, 1)) {
+    if (ls->t.token == TK_RETURN) {
+      statement(ls);
+      return;  /* 'return' must be last statement */
+    }
+    statement(ls);
+  }
+}
+
+
+static void fieldsel (LexState *ls, expdesc *v) {
+  /* fieldsel -> ['.' | ':'] NAME */
+  FuncState *fs = ls->fs;
+  expdesc key;
+  luaK_exp2anyregup(fs, v);
+  luaX_next(ls);  /* skip the dot or colon */
+  checkname(ls, &key);
+  luaK_indexed(fs, v, &key);
+}
+
+
+static void yindex (LexState *ls, expdesc *v) {
+  /* index -> '[' expr ']' */
+  luaX_next(ls);  /* skip the '[' */
+  expr(ls, v);
+  luaK_exp2val(ls->fs, v);
+  checknext(ls, ']');
+}
+
+
+/*
+** {======================================================================
+** Rules for Constructors
+** =======================================================================
+*/
+
+
+struct ConsControl {
+  expdesc v;  /* last list item read */
+  expdesc *t;  /* table descriptor */
+  int nh;  /* total number of `record' elements */
+  int na;  /* total number of array elements */
+  int tostore;  /* number of array elements pending to be stored */
+};
+
+
+static void recfield (LexState *ls, struct ConsControl *cc) {
+  /* recfield -> (NAME | `['exp1`]') = exp1 */
+  FuncState *fs = ls->fs;
+  int reg = ls->fs->freereg;
+  expdesc key, val;
+  int rkkey;
+  if (ls->t.token == TK_NAME) {
+    checklimit(fs, cc->nh, MAX_INT, "items in a constructor");
+    checkname(ls, &key);
+  }
+  else  /* ls->t.token == '[' */
+    yindex(ls, &key);
+  cc->nh++;
+  checknext(ls, '=');
+  rkkey = luaK_exp2RK(fs, &key);
+  expr(ls, &val);
+  luaK_codeABC(fs, OP_SETTABLE, cc->t->u.info, rkkey, luaK_exp2RK(fs, &val));
+  fs->freereg = reg;  /* free registers */
+}
+
+
+static void closelistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc->v.k == VVOID) return;  /* there is no list item */
+  luaK_exp2nextreg(fs, &cc->v);
+  cc->v.k = VVOID;
+  if (cc->tostore == LFIELDS_PER_FLUSH) {
+    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */
+    cc->tostore = 0;  /* no more items pending */
+  }
+}
+
+
+static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc->tostore == 0) return;
+  if (hasmultret(cc->v.k)) {
+    luaK_setmultret(fs, &cc->v);
+    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);
+    cc->na--;  /* do not count last expression (unknown number of elements) */
+  }
+  else {
+    if (cc->v.k != VVOID)
+      luaK_exp2nextreg(fs, &cc->v);
+    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);
+  }
+}
+
+
+static void listfield (LexState *ls, struct ConsControl *cc) {
+  /* listfield -> exp */
+  expr(ls, &cc->v);
+  checklimit(ls->fs, cc->na, MAX_INT, "items in a constructor");
+  cc->na++;
+  cc->tostore++;
+}
+
+
+static void field (LexState *ls, struct ConsControl *cc) {
+  /* field -> listfield | recfield */
+  switch(ls->t.token) {
+    case TK_NAME: {  /* may be 'listfield' or 'recfield' */
+      if (luaX_lookahead(ls) != '=')  /* expression? */
+        listfield(ls, cc);
+      else
+        recfield(ls, cc);
+      break;
+    }
+    case '[': {
+      recfield(ls, cc);
+      break;
+    }
+    default: {
+      listfield(ls, cc);
+      break;
+    }
+  }
+}
+
+
+static void constructor (LexState *ls, expdesc *t) {
+  /* constructor -> '{' [ field { sep field } [sep] ] '}'
+     sep -> ',' | ';' */
+  FuncState *fs = ls->fs;
+  int line = ls->linenumber;
+  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
+  struct ConsControl cc;
+  cc.na = cc.nh = cc.tostore = 0;
+  cc.t = t;
+  init_exp(t, VRELOCABLE, pc);
+  init_exp(&cc.v, VVOID, 0);  /* no value (yet) */
+  luaK_exp2nextreg(ls->fs, t);  /* fix it at stack top */
+  checknext(ls, '{');
+  do {
+    lua_assert(cc.v.k == VVOID || cc.tostore > 0);
+    if (ls->t.token == '}') break;
+    closelistfield(fs, &cc);
+    field(ls, &cc);
+  } while (testnext(ls, ',') || testnext(ls, ';'));
+  check_match(ls, '}', '{', line);
+  lastlistfield(fs, &cc);
+  SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na)); /* set initial array size */
+  SETARG_C(fs->f->code[pc], luaO_int2fb(cc.nh));  /* set initial table size */
+}
+
+/* }====================================================================== */
+
+
+
+static void parlist (LexState *ls) {
+  /* parlist -> [ param { `,' param } ] */
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  int nparams = 0;
+  f->is_vararg = 0;
+  if (ls->t.token != ')') {  /* is `parlist' not empty? */
+    do {
+      switch (ls->t.token) {
+        case TK_NAME: {  /* param -> NAME */
+          new_localvar(ls, str_checkname(ls));
+          nparams++;
+          break;
+        }
+        case TK_DOTS: {  /* param -> `...' */
+          luaX_next(ls);
+          f->is_vararg = 1;
+          break;
+        }
+        default: luaX_syntaxerror(ls, "<name> or " LUA_QL("...") " expected");
+      }
+    } while (!f->is_vararg && testnext(ls, ','));
+  }
+  adjustlocalvars(ls, nparams);
+  f->numparams = cast_byte(fs->nactvar);
+  luaK_reserveregs(fs, fs->nactvar);  /* reserve register for parameters */
+}
+
+
+static void body (LexState *ls, expdesc *e, int ismethod, int line) {
+  /* body ->  `(' parlist `)' block END */
+  FuncState new_fs;
+  BlockCnt bl;
+  new_fs.f = addprototype(ls);
+  new_fs.f->linedefined = line;
+  open_func(ls, &new_fs, &bl);
+  checknext(ls, '(');
+  if (ismethod) {
+    new_localvarliteral(ls, "self");  /* create 'self' parameter */
+    adjustlocalvars(ls, 1);
+  }
+  parlist(ls);
+  checknext(ls, ')');
+  statlist(ls);
+  new_fs.f->lastlinedefined = ls->linenumber;
+  check_match(ls, TK_END, TK_FUNCTION, line);
+  codeclosure(ls, e);
+  close_func(ls);
+}
+
+
+static int explist (LexState *ls, expdesc *v) {
+  /* explist -> expr { `,' expr } */
+  int n = 1;  /* at least one expression */
+  expr(ls, v);
+  while (testnext(ls, ',')) {
+    luaK_exp2nextreg(ls->fs, v);
+    expr(ls, v);
+    n++;
+  }
+  return n;
+}
+
+
+static void funcargs (LexState *ls, expdesc *f, int line) {
+  FuncState *fs = ls->fs;
+  expdesc args;
+  int base, nparams;
+  switch (ls->t.token) {
+    case '(': {  /* funcargs -> `(' [ explist ] `)' */
+      luaX_next(ls);
+      if (ls->t.token == ')')  /* arg list is empty? */
+        args.k = VVOID;
+      else {
+        explist(ls, &args);
+        luaK_setmultret(fs, &args);
+      }
+      check_match(ls, ')', '(', line);
+      break;
+    }
+    case '{': {  /* funcargs -> constructor */
+      constructor(ls, &args);
+      break;
+    }
+    case TK_STRING: {  /* funcargs -> STRING */
+      codestring(ls, &args, ls->t.seminfo.ts);
+      luaX_next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    default: {
+      luaX_syntaxerror(ls, "function arguments expected");
+    }
+  }
+  lua_assert(f->k == VNONRELOC);
+  base = f->u.info;  /* base register for call */
+  if (hasmultret(args.k))
+    nparams = LUA_MULTRET;  /* open call */
+  else {
+    if (args.k != VVOID)
+      luaK_exp2nextreg(fs, &args);  /* close last argument */
+    nparams = fs->freereg - (base+1);
+  }
+  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
+  luaK_fixline(fs, line);
+  fs->freereg = base+1;  /* call remove function and arguments and leaves
+                            (unless changed) one result */
+}
+
+
+
+
+/*
+** {======================================================================
+** Expression parsing
+** =======================================================================
+*/
+
+
+static void primaryexp (LexState *ls, expdesc *v) {
+  /* primaryexp -> NAME | '(' expr ')' */
+  switch (ls->t.token) {
+    case '(': {
+      int line = ls->linenumber;
+      luaX_next(ls);
+      expr(ls, v);
+      check_match(ls, ')', '(', line);
+      luaK_dischargevars(ls->fs, v);
+      return;
+    }
+    case TK_NAME: {
+      singlevar(ls, v);
+      return;
+    }
+    default: {
+      luaX_syntaxerror(ls, "unexpected symbol");
+    }
+  }
+}
+
+
+static void suffixedexp (LexState *ls, expdesc *v) {
+  /* suffixedexp ->
+       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */
+  FuncState *fs = ls->fs;
+  int line = ls->linenumber;
+  primaryexp(ls, v);
+  for (;;) {
+    switch (ls->t.token) {
+      case '.': {  /* fieldsel */
+        fieldsel(ls, v);
+        break;
+      }
+      case '[': {  /* `[' exp1 `]' */
+        expdesc key;
+        luaK_exp2anyregup(fs, v);
+        yindex(ls, &key);
+        luaK_indexed(fs, v, &key);
+        break;
+      }
+      case ':': {  /* `:' NAME funcargs */
+        expdesc key;
+        luaX_next(ls);
+        checkname(ls, &key);
+        luaK_self(fs, v, &key);
+        funcargs(ls, v, line);
+        break;
+      }
+      case '(': case TK_STRING: case '{': {  /* funcargs */
+        luaK_exp2nextreg(fs, v);
+        funcargs(ls, v, line);
+        break;
+      }
+      default: return;
+    }
+  }
+}
+
+
+static void simpleexp (LexState *ls, expdesc *v) {
+  /* simpleexp -> NUMBER | STRING | NIL | TRUE | FALSE | ... |
+                  constructor | FUNCTION body | suffixedexp */
+  switch (ls->t.token) {
+    case TK_NUMBER: {
+      init_exp(v, VKNUM, 0);
+      v->u.nval = ls->t.seminfo.r;
+      break;
+    }
+    case TK_STRING: {
+      codestring(ls, v, ls->t.seminfo.ts);
+      break;
+    }
+    case TK_NIL: {
+      init_exp(v, VNIL, 0);
+      break;
+    }
+    case TK_TRUE: {
+      init_exp(v, VTRUE, 0);
+      break;
+    }
+    case TK_FALSE: {
+      init_exp(v, VFALSE, 0);
+      break;
+    }
+    case TK_DOTS: {  /* vararg */
+      FuncState *fs = ls->fs;
+      check_condition(ls, fs->f->is_vararg,
+                      "cannot use " LUA_QL("...") " outside a vararg function");
+      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
+      break;
+    }
+    case '{': {  /* constructor */
+      constructor(ls, v);
+      return;
+    }
+    case TK_FUNCTION: {
+      luaX_next(ls);
+      body(ls, v, 0, ls->linenumber);
+      return;
+    }
+    default: {
+      suffixedexp(ls, v);
+      return;
+    }
+  }
+  luaX_next(ls);
+}
+
+
+static UnOpr getunopr (int op) {
+  switch (op) {
+    case TK_NOT: return OPR_NOT;
+    case '-': return OPR_MINUS;
+    case '#': return OPR_LEN;
+    default: return OPR_NOUNOPR;
+  }
+}
+
+
+static BinOpr getbinopr (int op) {
+  switch (op) {
+    case '+': return OPR_ADD;
+    case '-': return OPR_SUB;
+    case '*': return OPR_MUL;
+    case '/': return OPR_DIV;
+    case '%': return OPR_MOD;
+    case '^': return OPR_POW;
+    case TK_CONCAT: return OPR_CONCAT;
+    case TK_NE: return OPR_NE;
+    case TK_EQ: return OPR_EQ;
+    case '<': return OPR_LT;
+    case TK_LE: return OPR_LE;
+    case '>': return OPR_GT;
+    case TK_GE: return OPR_GE;
+    case TK_AND: return OPR_AND;
+    case TK_OR: return OPR_OR;
+    default: return OPR_NOBINOPR;
+  }
+}
+
+
+static const struct {
+  lu_byte left;  /* left priority for each binary operator */
+  lu_byte right; /* right priority */
+} priority[] = {  /* ORDER OPR */
+   {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},  /* `+' `-' `*' `/' `%' */
+   {10, 9}, {5, 4},                 /* ^, .. (right associative) */
+   {3, 3}, {3, 3}, {3, 3},          /* ==, <, <= */
+   {3, 3}, {3, 3}, {3, 3},          /* ~=, >, >= */
+   {2, 2}, {1, 1}                   /* and, or */
+};
+
+#define UNARY_PRIORITY	8  /* priority for unary operators */
+
+
+/*
+** subexpr -> (simpleexp | unop subexpr) { binop subexpr }
+** where `binop' is any binary operator with a priority higher than `limit'
+*/
+static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {
+  BinOpr op;
+  UnOpr uop;
+  enterlevel(ls);
+  uop = getunopr(ls->t.token);
+  if (uop != OPR_NOUNOPR) {
+    int line = ls->linenumber;
+    luaX_next(ls);
+    subexpr(ls, v, UNARY_PRIORITY);
+    luaK_prefix(ls->fs, uop, v, line);
+  }
+  else simpleexp(ls, v);
+  /* expand while operators have priorities higher than `limit' */
+  op = getbinopr(ls->t.token);
+  while (op != OPR_NOBINOPR && priority[op].left > limit) {
+    expdesc v2;
+    BinOpr nextop;
+    int line = ls->linenumber;
+    luaX_next(ls);
+    luaK_infix(ls->fs, op, v);
+    /* read sub-expression with higher priority */
+    nextop = subexpr(ls, &v2, priority[op].right);
+    luaK_posfix(ls->fs, op, v, &v2, line);
+    op = nextop;
+  }
+  leavelevel(ls);
+  return op;  /* return first untreated operator */
+}
+
+
+static void expr (LexState *ls, expdesc *v) {
+  subexpr(ls, v, 0);
+}
+
+/* }==================================================================== */
+
+
+
+/*
+** {======================================================================
+** Rules for Statements
+** =======================================================================
+*/
+
+
+static void block (LexState *ls) {
+  /* block -> statlist */
+  FuncState *fs = ls->fs;
+  BlockCnt bl;
+  enterblock(fs, &bl, 0);
+  statlist(ls);
+  leaveblock(fs);
+}
+
+
+/*
+** structure to chain all variables in the left-hand side of an
+** assignment
+*/
+struct LHS_assign {
+  struct LHS_assign *prev;
+  expdesc v;  /* variable (global, local, upvalue, or indexed) */
+};
+
+
+/*
+** check whether, in an assignment to an upvalue/local variable, the
+** upvalue/local variable is begin used in a previous assignment to a
+** table. If so, save original upvalue/local value in a safe place and
+** use this safe copy in the previous assignment.
+*/
+static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
+  FuncState *fs = ls->fs;
+  int extra = fs->freereg;  /* eventual position to save local variable */
+  int conflict = 0;
+  for (; lh; lh = lh->prev) {  /* check all previous assignments */
+    if (lh->v.k == VINDEXED) {  /* assigning to a table? */
+      /* table is the upvalue/local being assigned now? */
+      if (lh->v.u.ind.vt == v->k && lh->v.u.ind.t == v->u.info) {
+        conflict = 1;
+        lh->v.u.ind.vt = VLOCAL;
+        lh->v.u.ind.t = extra;  /* previous assignment will use safe copy */
+      }
+      /* index is the local being assigned? (index cannot be upvalue) */
+      if (v->k == VLOCAL && lh->v.u.ind.idx == v->u.info) {
+        conflict = 1;
+        lh->v.u.ind.idx = extra;  /* previous assignment will use safe copy */
+      }
+    }
+  }
+  if (conflict) {
+    /* copy upvalue/local value to a temporary (in position 'extra') */
+    OpCode op = (v->k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
+    luaK_codeABC(fs, op, extra, v->u.info, 0);
+    luaK_reserveregs(fs, 1);
+  }
+}
+
+
+static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {
+  expdesc e;
+  check_condition(ls, vkisvar(lh->v.k), "syntax error");
+  if (testnext(ls, ',')) {  /* assignment -> ',' suffixedexp assignment */
+    struct LHS_assign nv;
+    nv.prev = lh;
+    suffixedexp(ls, &nv.v);
+    if (nv.v.k != VINDEXED)
+      check_conflict(ls, lh, &nv.v);
+    checklimit(ls->fs, nvars + ls->L->nCcalls, LUAI_MAXCCALLS,
+                    "C levels");
+    assignment(ls, &nv, nvars+1);
+  }
+  else {  /* assignment -> `=' explist */
+    int nexps;
+    checknext(ls, '=');
+    nexps = explist(ls, &e);
+    if (nexps != nvars) {
+      adjust_assign(ls, nvars, nexps, &e);
+      if (nexps > nvars)
+        ls->fs->freereg -= nexps - nvars;  /* remove extra values */
+    }
+    else {
+      luaK_setoneret(ls->fs, &e);  /* close last expression */
+      luaK_storevar(ls->fs, &lh->v, &e);
+      return;  /* avoid default */
+    }
+  }
+  init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */
+  luaK_storevar(ls->fs, &lh->v, &e);
+}
+
+
+static int cond (LexState *ls) {
+  /* cond -> exp */
+  expdesc v;
+  expr(ls, &v);  /* read condition */
+  if (v.k == VNIL) v.k = VFALSE;  /* `falses' are all equal here */
+  luaK_goiftrue(ls->fs, &v);
+  return v.f;
+}
+
+
+static void gotostat (LexState *ls, int pc) {
+  int line = ls->linenumber;
+  TString *label;
+  int g;
+  if (testnext(ls, TK_GOTO))
+    label = str_checkname(ls);
+  else {
+    luaX_next(ls);  /* skip break */
+    label = luaS_new(ls->L, "break");
+  }
+  g = newlabelentry(ls, &ls->dyd->gt, label, line, pc);
+  findlabel(ls, g);  /* close it if label already defined */
+}
+
+
+/* check for repeated labels on the same block */
+static void checkrepeated (FuncState *fs, Labellist *ll, TString *label) {
+  int i;
+  for (i = fs->bl->firstlabel; i < ll->n; i++) {
+    if (luaS_eqstr(label, ll->arr[i].name)) {
+      const char *msg = luaO_pushfstring(fs->ls->L,
+                          "label " LUA_QS " already defined on line %d",
+                          getstr(label), ll->arr[i].line);
+      semerror(fs->ls, msg);
+    }
+  }
+}
+
+
+/* skip no-op statements */
+static void skipnoopstat (LexState *ls) {
+  while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)
+    statement(ls);
+}
+
+
+static void labelstat (LexState *ls, TString *label, int line) {
+  /* label -> '::' NAME '::' */
+  FuncState *fs = ls->fs;
+  Labellist *ll = &ls->dyd->label;
+  int l;  /* index of new label being created */
+  checkrepeated(fs, ll, label);  /* check for repeated labels */
+  checknext(ls, TK_DBCOLON);  /* skip double colon */
+  /* create new entry for this label */
+  l = newlabelentry(ls, ll, label, line, fs->pc);
+  skipnoopstat(ls);  /* skip other no-op statements */
+  if (block_follow(ls, 0)) {  /* label is last no-op statement in the block? */
+    /* assume that locals are already out of scope */
+    ll->arr[l].nactvar = fs->bl->nactvar;
+  }
+  findgotos(ls, &ll->arr[l]);
+}
+
+
+static void whilestat (LexState *ls, int line) {
+  /* whilestat -> WHILE cond DO block END */
+  FuncState *fs = ls->fs;
+  int whileinit;
+  int condexit;
+  BlockCnt bl;
+  luaX_next(ls);  /* skip WHILE */
+  whileinit = luaK_getlabel(fs);
+  condexit = cond(ls);
+  enterblock(fs, &bl, 1);
+  checknext(ls, TK_DO);
+  block(ls);
+  luaK_jumpto(fs, whileinit);
+  check_match(ls, TK_END, TK_WHILE, line);
+  leaveblock(fs);
+  luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */
+}
+
+
+static void repeatstat (LexState *ls, int line) {
+  /* repeatstat -> REPEAT block UNTIL cond */
+  int condexit;
+  FuncState *fs = ls->fs;
+  int repeat_init = luaK_getlabel(fs);
+  BlockCnt bl1, bl2;
+  enterblock(fs, &bl1, 1);  /* loop block */
+  enterblock(fs, &bl2, 0);  /* scope block */
+  luaX_next(ls);  /* skip REPEAT */
+  statlist(ls);
+  check_match(ls, TK_UNTIL, TK_REPEAT, line);
+  condexit = cond(ls);  /* read condition (inside scope block) */
+  if (bl2.upval)  /* upvalues? */
+    luaK_patchclose(fs, condexit, bl2.nactvar);
+  leaveblock(fs);  /* finish scope */
+  luaK_patchlist(fs, condexit, repeat_init);  /* close the loop */
+  leaveblock(fs);  /* finish loop */
+}
+
+
+static int exp1 (LexState *ls) {
+  expdesc e;
+  int reg;
+  expr(ls, &e);
+  luaK_exp2nextreg(ls->fs, &e);
+  lua_assert(e.k == VNONRELOC);
+  reg = e.u.info;
+  return reg;
+}
+
+
+static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
+  /* forbody -> DO block */
+  BlockCnt bl;
+  FuncState *fs = ls->fs;
+  int prep, endfor;
+  adjustlocalvars(ls, 3);  /* control variables */
+  checknext(ls, TK_DO);
+  prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);
+  enterblock(fs, &bl, 0);  /* scope for declared variables */
+  adjustlocalvars(ls, nvars);
+  luaK_reserveregs(fs, nvars);
+  block(ls);
+  leaveblock(fs);  /* end of scope for declared variables */
+  luaK_patchtohere(fs, prep);
+  if (isnum)  /* numeric for? */
+    endfor = luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP);
+  else {  /* generic for */
+    luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);
+    luaK_fixline(fs, line);
+    endfor = luaK_codeAsBx(fs, OP_TFORLOOP, base + 2, NO_JUMP);
+  }
+  luaK_patchlist(fs, endfor, prep + 1);
+  luaK_fixline(fs, line);
+}
+
+
+static void fornum (LexState *ls, TString *varname, int line) {
+  /* fornum -> NAME = exp1,exp1[,exp1] forbody */
+  FuncState *fs = ls->fs;
+  int base = fs->freereg;
+  new_localvarliteral(ls, "(for index)");
+  new_localvarliteral(ls, "(for limit)");
+  new_localvarliteral(ls, "(for step)");
+  new_localvar(ls, varname);
+  checknext(ls, '=');
+  exp1(ls);  /* initial value */
+  checknext(ls, ',');
+  exp1(ls);  /* limit */
+  if (testnext(ls, ','))
+    exp1(ls);  /* optional step */
+  else {  /* default step = 1 */
+    luaK_codek(fs, fs->freereg, luaK_numberK(fs, 1));
+    luaK_reserveregs(fs, 1);
+  }
+  forbody(ls, base, line, 1, 1);
+}
+
+
+static void forlist (LexState *ls, TString *indexname) {
+  /* forlist -> NAME {,NAME} IN explist forbody */
+  FuncState *fs = ls->fs;
+  expdesc e;
+  int nvars = 4;  /* gen, state, control, plus at least one declared var */
+  int line;
+  int base = fs->freereg;
+  /* create control variables */
+  new_localvarliteral(ls, "(for generator)");
+  new_localvarliteral(ls, "(for state)");
+  new_localvarliteral(ls, "(for control)");
+  /* create declared variables */
+  new_localvar(ls, indexname);
+  while (testnext(ls, ',')) {
+    new_localvar(ls, str_checkname(ls));
+    nvars++;
+  }
+  checknext(ls, TK_IN);
+  line = ls->linenumber;
+  adjust_assign(ls, 3, explist(ls, &e), &e);
+  luaK_checkstack(fs, 3);  /* extra space to call generator */
+  forbody(ls, base, line, nvars - 3, 0);
+}
+
+
+static void forstat (LexState *ls, int line) {
+  /* forstat -> FOR (fornum | forlist) END */
+  FuncState *fs = ls->fs;
+  TString *varname;
+  BlockCnt bl;
+  enterblock(fs, &bl, 1);  /* scope for loop and control variables */
+  luaX_next(ls);  /* skip `for' */
+  varname = str_checkname(ls);  /* first variable name */
+  switch (ls->t.token) {
+    case '=': fornum(ls, varname, line); break;
+    case ',': case TK_IN: forlist(ls, varname); break;
+    default: luaX_syntaxerror(ls, LUA_QL("=") " or " LUA_QL("in") " expected");
+  }
+  check_match(ls, TK_END, TK_FOR, line);
+  leaveblock(fs);  /* loop scope (`break' jumps to this point) */
+}
+
+
+static void test_then_block (LexState *ls, int *escapelist) {
+  /* test_then_block -> [IF | ELSEIF] cond THEN block */
+  BlockCnt bl;
+  FuncState *fs = ls->fs;
+  expdesc v;
+  int jf;  /* instruction to skip 'then' code (if condition is false) */
+  luaX_next(ls);  /* skip IF or ELSEIF */
+  expr(ls, &v);  /* read condition */
+  checknext(ls, TK_THEN);
+  if (ls->t.token == TK_GOTO || ls->t.token == TK_BREAK) {
+    luaK_goiffalse(ls->fs, &v);  /* will jump to label if condition is true */
+    enterblock(fs, &bl, 0);  /* must enter block before 'goto' */
+    gotostat(ls, v.t);  /* handle goto/break */
+    skipnoopstat(ls);  /* skip other no-op statements */
+    if (block_follow(ls, 0)) {  /* 'goto' is the entire block? */
+      leaveblock(fs);
+      return;  /* and that is it */
+    }
+    else  /* must skip over 'then' part if condition is false */
+      jf = luaK_jump(fs);
+  }
+  else {  /* regular case (not goto/break) */
+    luaK_goiftrue(ls->fs, &v);  /* skip over block if condition is false */
+    enterblock(fs, &bl, 0);
+    jf = v.f;
+  }
+  statlist(ls);  /* `then' part */
+  leaveblock(fs);
+  if (ls->t.token == TK_ELSE ||
+      ls->t.token == TK_ELSEIF)  /* followed by 'else'/'elseif'? */
+    luaK_concat(fs, escapelist, luaK_jump(fs));  /* must jump over it */
+  luaK_patchtohere(fs, jf);
+}
+
+
+static void ifstat (LexState *ls, int line) {
+  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
+  FuncState *fs = ls->fs;
+  int escapelist = NO_JUMP;  /* exit list for finished parts */
+  test_then_block(ls, &escapelist);  /* IF cond THEN block */
+  while (ls->t.token == TK_ELSEIF)
+    test_then_block(ls, &escapelist);  /* ELSEIF cond THEN block */
+  if (testnext(ls, TK_ELSE))
+    block(ls);  /* `else' part */
+  check_match(ls, TK_END, TK_IF, line);
+  luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */
+}
+
+
+static void localfunc (LexState *ls) {
+  expdesc b;
+  FuncState *fs = ls->fs;
+  new_localvar(ls, str_checkname(ls));  /* new local variable */
+  adjustlocalvars(ls, 1);  /* enter its scope */
+  body(ls, &b, 0, ls->linenumber);  /* function created in next register */
+  /* debug information will only see the variable after this point! */
+  getlocvar(fs, b.u.info)->startpc = fs->pc;
+}
+
+
+static void localstat (LexState *ls) {
+  /* stat -> LOCAL NAME {`,' NAME} [`=' explist] */
+  int nvars = 0;
+  int nexps;
+  expdesc e;
+  do {
+    new_localvar(ls, str_checkname(ls));
+    nvars++;
+  } while (testnext(ls, ','));
+  if (testnext(ls, '='))
+    nexps = explist(ls, &e);
+  else {
+    e.k = VVOID;
+    nexps = 0;
+  }
+  adjust_assign(ls, nvars, nexps, &e);
+  adjustlocalvars(ls, nvars);
+}
+
+
+static int funcname (LexState *ls, expdesc *v) {
+  /* funcname -> NAME {fieldsel} [`:' NAME] */
+  int ismethod = 0;
+  singlevar(ls, v);
+  while (ls->t.token == '.')
+    fieldsel(ls, v);
+  if (ls->t.token == ':') {
+    ismethod = 1;
+    fieldsel(ls, v);
+  }
+  return ismethod;
+}
+
+
+static void funcstat (LexState *ls, int line) {
+  /* funcstat -> FUNCTION funcname body */
+  int ismethod;
+  expdesc v, b;
+  luaX_next(ls);  /* skip FUNCTION */
+  ismethod = funcname(ls, &v);
+  body(ls, &b, ismethod, line);
+  luaK_storevar(ls->fs, &v, &b);
+  luaK_fixline(ls->fs, line);  /* definition `happens' in the first line */
+}
+
+
+static void exprstat (LexState *ls) {
+  /* stat -> func | assignment */
+  FuncState *fs = ls->fs;
+  struct LHS_assign v;
+  suffixedexp(ls, &v.v);
+  if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */
+    v.prev = NULL;
+    assignment(ls, &v, 1);
+  }
+  else {  /* stat -> func */
+    check_condition(ls, v.v.k == VCALL, "syntax error");
+    SETARG_C(getcode(fs, &v.v), 1);  /* call statement uses no results */
+  }
+}
+
+
+static void retstat (LexState *ls) {
+  /* stat -> RETURN [explist] [';'] */
+  FuncState *fs = ls->fs;
+  expdesc e;
+  int first, nret;  /* registers with returned values */
+  if (block_follow(ls, 1) || ls->t.token == ';')
+    first = nret = 0;  /* return no values */
+  else {
+    nret = explist(ls, &e);  /* optional return values */
+    if (hasmultret(e.k)) {
+      luaK_setmultret(fs, &e);
+      if (e.k == VCALL && nret == 1) {  /* tail call? */
+        SET_OPCODE(getcode(fs,&e), OP_TAILCALL);
+        lua_assert(GETARG_A(getcode(fs,&e)) == fs->nactvar);
+      }
+      first = fs->nactvar;
+      nret = LUA_MULTRET;  /* return all values */
+    }
+    else {
+      if (nret == 1)  /* only one single value? */
+        first = luaK_exp2anyreg(fs, &e);
+      else {
+        luaK_exp2nextreg(fs, &e);  /* values must go to the `stack' */
+        first = fs->nactvar;  /* return all `active' values */
+        lua_assert(nret == fs->freereg - first);
+      }
+    }
+  }
+  luaK_ret(fs, first, nret);
+  testnext(ls, ';');  /* skip optional semicolon */
+}
+
+
+static void statement (LexState *ls) {
+  int line = ls->linenumber;  /* may be needed for error messages */
+  enterlevel(ls);
+  switch (ls->t.token) {
+    case ';': {  /* stat -> ';' (empty statement) */
+      luaX_next(ls);  /* skip ';' */
+      break;
+    }
+    case TK_IF: {  /* stat -> ifstat */
+      ifstat(ls, line);
+      break;
+    }
+    case TK_WHILE: {  /* stat -> whilestat */
+      whilestat(ls, line);
+      break;
+    }
+    case TK_DO: {  /* stat -> DO block END */
+      luaX_next(ls);  /* skip DO */
+      block(ls);
+      check_match(ls, TK_END, TK_DO, line);
+      break;
+    }
+    case TK_FOR: {  /* stat -> forstat */
+      forstat(ls, line);
+      break;
+    }
+    case TK_REPEAT: {  /* stat -> repeatstat */
+      repeatstat(ls, line);
+      break;
+    }
+    case TK_FUNCTION: {  /* stat -> funcstat */
+      funcstat(ls, line);
+      break;
+    }
+    case TK_LOCAL: {  /* stat -> localstat */
+      luaX_next(ls);  /* skip LOCAL */
+      if (testnext(ls, TK_FUNCTION))  /* local function? */
+        localfunc(ls);
+      else
+        localstat(ls);
+      break;
+    }
+    case TK_DBCOLON: {  /* stat -> label */
+      luaX_next(ls);  /* skip double colon */
+      labelstat(ls, str_checkname(ls), line);
+      break;
+    }
+    case TK_RETURN: {  /* stat -> retstat */
+      luaX_next(ls);  /* skip RETURN */
+      retstat(ls);
+      break;
+    }
+    case TK_BREAK:   /* stat -> breakstat */
+    case TK_GOTO: {  /* stat -> 'goto' NAME */
+      gotostat(ls, luaK_jump(ls->fs));
+      break;
+    }
+    default: {  /* stat -> func | assignment */
+      exprstat(ls);
+      break;
+    }
+  }
+  lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&
+             ls->fs->freereg >= ls->fs->nactvar);
+  ls->fs->freereg = ls->fs->nactvar;  /* free registers */
+  leavelevel(ls);
+}
+
+/* }====================================================================== */
+
+
+/*
+** compiles the main function, which is a regular vararg function with an
+** upvalue named LUA_ENV
+*/
+static void mainfunc (LexState *ls, FuncState *fs) {
+  BlockCnt bl;
+  expdesc v;
+  open_func(ls, fs, &bl);
+  fs->f->is_vararg = 1;  /* main function is always vararg */
+  init_exp(&v, VLOCAL, 0);  /* create and... */
+  newupvalue(fs, ls->envn, &v);  /* ...set environment upvalue */
+  luaX_next(ls);  /* read first token */
+  statlist(ls);  /* parse main body */
+  check(ls, TK_EOS);
+  close_func(ls);
+}
+
+
+Closure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
+                      Dyndata *dyd, const char *name, int firstchar) {
+  LexState lexstate;
+  FuncState funcstate;
+  Closure *cl = luaF_newLclosure(L, 1);  /* create main closure */
+  /* anchor closure (to avoid being collected) */
+  setclLvalue(L, L->top, cl);
+  incr_top(L);
+  funcstate.f = cl->l.p = luaF_newproto(L);
+  funcstate.f->source = luaS_new(L, name);  /* create and anchor TString */
+  lexstate.buff = buff;
+  lexstate.dyd = dyd;
+  dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;
+  luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);
+  mainfunc(&lexstate, &funcstate);
+  lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);
+  /* all scopes should be correctly finished */
+  lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);
+  return cl;  /* it's on the stack too */
+}
+
diff --git a/dep/lualib/lparser.h b/dep/lualib/lparser.h
new file mode 100644
index 0000000..301167d
--- /dev/null
+++ b/dep/lualib/lparser.h
@@ -0,0 +1,119 @@
+/*
+** $Id: lparser.h,v 1.70 2012/05/08 13:53:33 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lparser_h
+#define lparser_h
+
+#include "llimits.h"
+#include "lobject.h"
+#include "lzio.h"
+
+
+/*
+** Expression descriptor
+*/
+
+typedef enum {
+  VVOID,	/* no value */
+  VNIL,
+  VTRUE,
+  VFALSE,
+  VK,		/* info = index of constant in `k' */
+  VKNUM,	/* nval = numerical value */
+  VNONRELOC,	/* info = result register */
+  VLOCAL,	/* info = local register */
+  VUPVAL,       /* info = index of upvalue in 'upvalues' */
+  VINDEXED,	/* t = table register/upvalue; idx = index R/K */
+  VJMP,		/* info = instruction pc */
+  VRELOCABLE,	/* info = instruction pc */
+  VCALL,	/* info = instruction pc */
+  VVARARG	/* info = instruction pc */
+} expkind;
+
+
+#define vkisvar(k)	(VLOCAL <= (k) && (k) <= VINDEXED)
+#define vkisinreg(k)	((k) == VNONRELOC || (k) == VLOCAL)
+
+typedef struct expdesc {
+  expkind k;
+  union {
+    struct {  /* for indexed variables (VINDEXED) */
+      short idx;  /* index (R/K) */
+      lu_byte t;  /* table (register or upvalue) */
+      lu_byte vt;  /* whether 't' is register (VLOCAL) or upvalue (VUPVAL) */
+    } ind;
+    int info;  /* for generic use */
+    lua_Number nval;  /* for VKNUM */
+  } u;
+  int t;  /* patch list of `exit when true' */
+  int f;  /* patch list of `exit when false' */
+} expdesc;
+
+
+/* description of active local variable */
+typedef struct Vardesc {
+  short idx;  /* variable index in stack */
+} Vardesc;
+
+
+/* description of pending goto statements and label statements */
+typedef struct Labeldesc {
+  TString *name;  /* label identifier */
+  int pc;  /* position in code */
+  int line;  /* line where it appeared */
+  lu_byte nactvar;  /* local level where it appears in current block */
+} Labeldesc;
+
+
+/* list of labels or gotos */
+typedef struct Labellist {
+  Labeldesc *arr;  /* array */
+  int n;  /* number of entries in use */
+  int size;  /* array size */
+} Labellist;
+
+
+/* dynamic structures used by the parser */
+typedef struct Dyndata {
+  struct {  /* list of active local variables */
+    Vardesc *arr;
+    int n;
+    int size;
+  } actvar;
+  Labellist gt;  /* list of pending gotos */
+  Labellist label;   /* list of active labels */
+} Dyndata;
+
+
+/* control of blocks */
+struct BlockCnt;  /* defined in lparser.c */
+
+
+/* state needed to generate code for a given function */
+typedef struct FuncState {
+  Proto *f;  /* current function header */
+  Table *h;  /* table to find (and reuse) elements in `k' */
+  struct FuncState *prev;  /* enclosing function */
+  struct LexState *ls;  /* lexical state */
+  struct BlockCnt *bl;  /* chain of current blocks */
+  int pc;  /* next position to code (equivalent to `ncode') */
+  int lasttarget;   /* 'label' of last 'jump label' */
+  int jpc;  /* list of pending jumps to `pc' */
+  int nk;  /* number of elements in `k' */
+  int np;  /* number of elements in `p' */
+  int firstlocal;  /* index of first local var (in Dyndata array) */
+  short nlocvars;  /* number of elements in 'f->locvars' */
+  lu_byte nactvar;  /* number of active local variables */
+  lu_byte nups;  /* number of upvalues */
+  lu_byte freereg;  /* first free register */
+} FuncState;
+
+
+LUAI_FUNC Closure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
+                                Dyndata *dyd, const char *name, int firstchar);
+
+
+#endif
diff --git a/dep/lualib/lstate.c b/dep/lualib/lstate.c
new file mode 100644
index 0000000..3c00c28
--- /dev/null
+++ b/dep/lualib/lstate.c
@@ -0,0 +1,322 @@
+/*
+** $Id: lstate.c,v 2.98 2012/05/30 12:33:44 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+#include <string.h>
+
+#define lstate_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+#if !defined(LUAI_GCPAUSE)
+#define LUAI_GCPAUSE	200  /* 200% */
+#endif
+
+#if !defined(LUAI_GCMAJOR)
+#define LUAI_GCMAJOR	200  /* 200% */
+#endif
+
+#if !defined(LUAI_GCMUL)
+#define LUAI_GCMUL	200 /* GC runs 'twice the speed' of memory allocation */
+#endif
+
+
+#define MEMERRMSG	"not enough memory"
+
+
+/*
+** a macro to help the creation of a unique random seed when a state is
+** created; the seed is used to randomize hashes.
+*/
+#if !defined(luai_makeseed)
+#include <time.h>
+#define luai_makeseed()		cast(size_t, time(NULL))
+#endif
+
+
+
+/*
+** thread state + extra space
+*/
+typedef struct LX {
+#if defined(LUAI_EXTRASPACE)
+  char buff[LUAI_EXTRASPACE];
+#endif
+  lua_State l;
+} LX;
+
+
+/*
+** Main thread combines a thread state and the global state
+*/
+typedef struct LG {
+  LX l;
+  global_State g;
+} LG;
+
+
+
+#define fromstate(L)	(cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l)))
+
+
+/*
+** Compute an initial seed as random as possible. In ANSI, rely on
+** Address Space Layout Randomization (if present) to increase
+** randomness..
+*/
+#define addbuff(b,p,e) \
+  { size_t t = cast(size_t, e); \
+    memcpy(buff + p, &t, sizeof(t)); p += sizeof(t); }
+
+static unsigned int makeseed (lua_State *L) {
+  char buff[4 * sizeof(size_t)];
+  unsigned int h = luai_makeseed();
+  int p = 0;
+  addbuff(buff, p, L);  /* heap variable */
+  addbuff(buff, p, &h);  /* local variable */
+  addbuff(buff, p, luaO_nilobject);  /* global variable */
+  addbuff(buff, p, &lua_newstate);  /* public function */
+  lua_assert(p == sizeof(buff));
+  return luaS_hash(buff, p, h);
+}
+
+
+/*
+** set GCdebt to a new value keeping the value (totalbytes + GCdebt)
+** invariant
+*/
+void luaE_setdebt (global_State *g, l_mem debt) {
+  g->totalbytes -= (debt - g->GCdebt);
+  g->GCdebt = debt;
+}
+
+
+CallInfo *luaE_extendCI (lua_State *L) {
+  CallInfo *ci = luaM_new(L, CallInfo);
+  lua_assert(L->ci->next == NULL);
+  L->ci->next = ci;
+  ci->previous = L->ci;
+  ci->next = NULL;
+  return ci;
+}
+
+
+void luaE_freeCI (lua_State *L) {
+  CallInfo *ci = L->ci;
+  CallInfo *next = ci->next;
+  ci->next = NULL;
+  while ((ci = next) != NULL) {
+    next = ci->next;
+    luaM_free(L, ci);
+  }
+}
+
+
+static void stack_init (lua_State *L1, lua_State *L) {
+  int i; CallInfo *ci;
+  /* initialize stack array */
+  L1->stack = luaM_newvector(L, BASIC_STACK_SIZE, TValue);
+  L1->stacksize = BASIC_STACK_SIZE;
+  for (i = 0; i < BASIC_STACK_SIZE; i++)
+    setnilvalue(L1->stack + i);  /* erase new stack */
+  L1->top = L1->stack;
+  L1->stack_last = L1->stack + L1->stacksize - EXTRA_STACK;
+  /* initialize first ci */
+  ci = &L1->base_ci;
+  ci->next = ci->previous = NULL;
+  ci->callstatus = 0;
+  ci->func = L1->top;
+  setnilvalue(L1->top++);  /* 'function' entry for this 'ci' */
+  ci->top = L1->top + LUA_MINSTACK;
+  L1->ci = ci;
+}
+
+
+static void freestack (lua_State *L) {
+  if (L->stack == NULL)
+    return;  /* stack not completely built yet */
+  L->ci = &L->base_ci;  /* free the entire 'ci' list */
+  luaE_freeCI(L);
+  luaM_freearray(L, L->stack, L->stacksize);  /* free stack array */
+}
+
+
+/*
+** Create registry table and its predefined values
+*/
+static void init_registry (lua_State *L, global_State *g) {
+  TValue mt;
+  /* create registry */
+  Table *registry = luaH_new(L);
+  sethvalue(L, &g->l_registry, registry);
+  luaH_resize(L, registry, LUA_RIDX_LAST, 0);
+  /* registry[LUA_RIDX_MAINTHREAD] = L */
+  setthvalue(L, &mt, L);
+  luaH_setint(L, registry, LUA_RIDX_MAINTHREAD, &mt);
+  /* registry[LUA_RIDX_GLOBALS] = table of globals */
+  sethvalue(L, &mt, luaH_new(L));
+  luaH_setint(L, registry, LUA_RIDX_GLOBALS, &mt);
+}
+
+
+/*
+** open parts of the state that may cause memory-allocation errors
+*/
+static void f_luaopen (lua_State *L, void *ud) {
+  global_State *g = G(L);
+  UNUSED(ud);
+  stack_init(L, L);  /* init stack */
+  init_registry(L, g);
+  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */
+  luaT_init(L);
+  luaX_init(L);
+  /* pre-create memory-error message */
+  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);
+  luaS_fix(g->memerrmsg);  /* it should never be collected */
+  g->gcrunning = 1;  /* allow gc */
+}
+
+
+/*
+** preinitialize a state with consistent values without allocating
+** any memory (to avoid errors)
+*/
+static void preinit_state (lua_State *L, global_State *g) {
+  G(L) = g;
+  L->stack = NULL;
+  L->ci = NULL;
+  L->stacksize = 0;
+  L->errorJmp = NULL;
+  L->nCcalls = 0;
+  L->hook = NULL;
+  L->hookmask = 0;
+  L->basehookcount = 0;
+  L->allowhook = 1;
+  resethookcount(L);
+  L->openupval = NULL;
+  L->nny = 1;
+  L->status = LUA_OK;
+  L->errfunc = 0;
+}
+
+
+static void close_state (lua_State *L) {
+  global_State *g = G(L);
+  luaF_close(L, L->stack);  /* close all upvalues for this thread */
+  luaC_freeallobjects(L);  /* collect all objects */
+  luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size);
+  luaZ_freebuffer(L, &g->buff);
+  freestack(L);
+  lua_assert(gettotalbytes(g) == sizeof(LG));
+  (*g->frealloc)(g->ud, fromstate(L), sizeof(LG), 0);  /* free main block */
+}
+
+
+LUA_API lua_State *lua_newthread (lua_State *L) {
+  lua_State *L1;
+  lua_lock(L);
+  luaC_checkGC(L);
+  L1 = &luaC_newobj(L, LUA_TTHREAD, sizeof(LX), NULL, offsetof(LX, l))->th;
+  setthvalue(L, L->top, L1);
+  api_incr_top(L);
+  preinit_state(L1, G(L));
+  L1->hookmask = L->hookmask;
+  L1->basehookcount = L->basehookcount;
+  L1->hook = L->hook;
+  resethookcount(L1);
+  luai_userstatethread(L, L1);
+  stack_init(L1, L);  /* init stack */
+  lua_unlock(L);
+  return L1;
+}
+
+
+void luaE_freethread (lua_State *L, lua_State *L1) {
+  LX *l = fromstate(L1);
+  luaF_close(L1, L1->stack);  /* close all upvalues for this thread */
+  lua_assert(L1->openupval == NULL);
+  luai_userstatefree(L, L1);
+  freestack(L1);
+  luaM_free(L, l);
+}
+
+
+LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
+  int i;
+  lua_State *L;
+  global_State *g;
+  LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));
+  if (l == NULL) return NULL;
+  L = &l->l.l;
+  g = &l->g;
+  L->next = NULL;
+  L->tt = LUA_TTHREAD;
+  g->currentwhite = bit2mask(WHITE0BIT, FIXEDBIT);
+  L->marked = luaC_white(g);
+  g->gckind = KGC_NORMAL;
+  preinit_state(L, g);
+  g->frealloc = f;
+  g->ud = ud;
+  g->mainthread = L;
+  g->seed = makeseed(L);
+  g->uvhead.u.l.prev = &g->uvhead;
+  g->uvhead.u.l.next = &g->uvhead;
+  g->gcrunning = 0;  /* no GC while building state */
+  g->GCestimate = 0;
+  g->strt.size = 0;
+  g->strt.nuse = 0;
+  g->strt.hash = NULL;
+  setnilvalue(&g->l_registry);
+  luaZ_initbuffer(L, &g->buff);
+  g->panic = NULL;
+  g->version = lua_version(NULL);
+  g->gcstate = GCSpause;
+  g->allgc = NULL;
+  g->finobj = NULL;
+  g->tobefnz = NULL;
+  g->sweepgc = g->sweepfin = NULL;
+  g->gray = g->grayagain = NULL;
+  g->weak = g->ephemeron = g->allweak = NULL;
+  g->totalbytes = sizeof(LG);
+  g->GCdebt = 0;
+  g->gcpause = LUAI_GCPAUSE;
+  g->gcmajorinc = LUAI_GCMAJOR;
+  g->gcstepmul = LUAI_GCMUL;
+  for (i=0; i < LUA_NUMTAGS; i++) g->mt[i] = NULL;
+  if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {
+    /* memory allocation error: free partial state */
+    close_state(L);
+    L = NULL;
+  }
+  else
+    luai_userstateopen(L);
+  return L;
+}
+
+
+LUA_API void lua_close (lua_State *L) {
+  L = G(L)->mainthread;  /* only the main thread can be closed */
+  lua_lock(L);
+  luai_userstateclose(L);
+  close_state(L);
+}
+
+
diff --git a/dep/lualib/lstate.h b/dep/lualib/lstate.h
new file mode 100644
index 0000000..29f810b
--- /dev/null
+++ b/dep/lualib/lstate.h
@@ -0,0 +1,228 @@
+/*
+** $Id: lstate.h,v 2.81 2012/06/08 15:14:04 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstate_h
+#define lstate_h
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "ltm.h"
+#include "lzio.h"
+
+
+/*
+
+** Some notes about garbage-collected objects:  All objects in Lua must
+** be kept somehow accessible until being freed.
+**
+** Lua keeps most objects linked in list g->allgc. The link uses field
+** 'next' of the CommonHeader.
+**
+** Strings are kept in several lists headed by the array g->strt.hash.
+**
+** Open upvalues are not subject to independent garbage collection. They
+** are collected together with their respective threads. Lua keeps a
+** double-linked list with all open upvalues (g->uvhead) so that it can
+** mark objects referred by them. (They are always gray, so they must
+** be remarked in the atomic step. Usually their contents would be marked
+** when traversing the respective threads, but the thread may already be
+** dead, while the upvalue is still accessible through closures.)
+**
+** Objects with finalizers are kept in the list g->finobj.
+**
+** The list g->tobefnz links all objects being finalized.
+
+*/
+
+
+struct lua_longjmp;  /* defined in ldo.c */
+
+
+
+/* extra stack space to handle TM calls and some other extras */
+#define EXTRA_STACK   5
+
+
+#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)
+
+
+/* kinds of Garbage Collection */
+#define KGC_NORMAL	0
+#define KGC_EMERGENCY	1	/* gc was forced by an allocation failure */
+#define KGC_GEN		2	/* generational collection */
+
+
+typedef struct stringtable {
+  GCObject **hash;
+  lu_int32 nuse;  /* number of elements */
+  int size;
+} stringtable;
+
+
+/*
+** information about a call
+*/
+typedef struct CallInfo {
+  StkId func;  /* function index in the stack */
+  StkId	top;  /* top for this function */
+  struct CallInfo *previous, *next;  /* dynamic call link */
+  short nresults;  /* expected number of results from this function */
+  lu_byte callstatus;
+  ptrdiff_t extra;
+  union {
+    struct {  /* only for Lua functions */
+      StkId base;  /* base for this function */
+      const Instruction *savedpc;
+    } l;
+    struct {  /* only for C functions */
+      int ctx;  /* context info. in case of yields */
+      lua_CFunction k;  /* continuation in case of yields */
+      ptrdiff_t old_errfunc;
+      lu_byte old_allowhook;
+      lu_byte status;
+    } c;
+  } u;
+} CallInfo;
+
+
+/*
+** Bits in CallInfo status
+*/
+#define CIST_LUA	(1<<0)	/* call is running a Lua function */
+#define CIST_HOOKED	(1<<1)	/* call is running a debug hook */
+#define CIST_REENTRY	(1<<2)	/* call is running on same invocation of
+                                   luaV_execute of previous call */
+#define CIST_YIELDED	(1<<3)	/* call reentered after suspension */
+#define CIST_YPCALL	(1<<4)	/* call is a yieldable protected call */
+#define CIST_STAT	(1<<5)	/* call has an error status (pcall) */
+#define CIST_TAIL	(1<<6)	/* call was tail called */
+#define CIST_HOOKYIELD	(1<<7)	/* last hook called yielded */
+
+
+#define isLua(ci)	((ci)->callstatus & CIST_LUA)
+
+
+/*
+** `global state', shared by all threads of this state
+*/
+typedef struct global_State {
+  lua_Alloc frealloc;  /* function to reallocate memory */
+  void *ud;         /* auxiliary data to `frealloc' */
+  lu_mem totalbytes;  /* number of bytes currently allocated - GCdebt */
+  l_mem GCdebt;  /* bytes allocated not yet compensated by the collector */
+  lu_mem GCmemtrav;  /* memory traversed by the GC */
+  lu_mem GCestimate;  /* an estimate of the non-garbage memory in use */
+  stringtable strt;  /* hash table for strings */
+  TValue l_registry;
+  unsigned int seed;  /* randomized seed for hashes */
+  lu_byte currentwhite;
+  lu_byte gcstate;  /* state of garbage collector */
+  lu_byte gckind;  /* kind of GC running */
+  lu_byte gcrunning;  /* true if GC is running */
+  int sweepstrgc;  /* position of sweep in `strt' */
+  GCObject *allgc;  /* list of all collectable objects */
+  GCObject *finobj;  /* list of collectable objects with finalizers */
+  GCObject **sweepgc;  /* current position of sweep in list 'allgc' */
+  GCObject **sweepfin;  /* current position of sweep in list 'finobj' */
+  GCObject *gray;  /* list of gray objects */
+  GCObject *grayagain;  /* list of objects to be traversed atomically */
+  GCObject *weak;  /* list of tables with weak values */
+  GCObject *ephemeron;  /* list of ephemeron tables (weak keys) */
+  GCObject *allweak;  /* list of all-weak tables */
+  GCObject *tobefnz;  /* list of userdata to be GC */
+  UpVal uvhead;  /* head of double-linked list of all open upvalues */
+  Mbuffer buff;  /* temporary buffer for string concatenation */
+  int gcpause;  /* size of pause between successive GCs */
+  int gcmajorinc;  /* how much to wait for a major GC (only in gen. mode) */
+  int gcstepmul;  /* GC `granularity' */
+  lua_CFunction panic;  /* to be called in unprotected errors */
+  struct lua_State *mainthread;
+  const lua_Number *version;  /* pointer to version number */
+  TString *memerrmsg;  /* memory-error message */
+  TString *tmname[TM_N];  /* array with tag-method names */
+  struct Table *mt[LUA_NUMTAGS];  /* metatables for basic types */
+} global_State;
+
+
+/*
+** `per thread' state
+*/
+struct lua_State {
+  CommonHeader;
+  lu_byte status;
+  StkId top;  /* first free slot in the stack */
+  global_State *l_G;
+  CallInfo *ci;  /* call info for current function */
+  const Instruction *oldpc;  /* last pc traced */
+  StkId stack_last;  /* last free slot in the stack */
+  StkId stack;  /* stack base */
+  int stacksize;
+  unsigned short nny;  /* number of non-yieldable calls in stack */
+  unsigned short nCcalls;  /* number of nested C calls */
+  lu_byte hookmask;
+  lu_byte allowhook;
+  int basehookcount;
+  int hookcount;
+  lua_Hook hook;
+  GCObject *openupval;  /* list of open upvalues in this stack */
+  GCObject *gclist;
+  struct lua_longjmp *errorJmp;  /* current error recover point */
+  ptrdiff_t errfunc;  /* current error handling function (stack index) */
+  CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */
+};
+
+
+#define G(L)	(L->l_G)
+
+
+/*
+** Union of all collectable objects
+*/
+union GCObject {
+  GCheader gch;  /* common header */
+  union TString ts;
+  union Udata u;
+  union Closure cl;
+  struct Table h;
+  struct Proto p;
+  struct UpVal uv;
+  struct lua_State th;  /* thread */
+};
+
+
+#define gch(o)		(&(o)->gch)
+
+/* macros to convert a GCObject into a specific value */
+#define rawgco2ts(o)  \
+	check_exp(novariant((o)->gch.tt) == LUA_TSTRING, &((o)->ts))
+#define gco2ts(o)	(&rawgco2ts(o)->tsv)
+#define rawgco2u(o)	check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
+#define gco2u(o)	(&rawgco2u(o)->uv)
+#define gco2lcl(o)	check_exp((o)->gch.tt == LUA_TLCL, &((o)->cl.l))
+#define gco2ccl(o)	check_exp((o)->gch.tt == LUA_TCCL, &((o)->cl.c))
+#define gco2cl(o)  \
+	check_exp(novariant((o)->gch.tt) == LUA_TFUNCTION, &((o)->cl))
+#define gco2t(o)	check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
+#define gco2p(o)	check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
+#define gco2uv(o)	check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
+#define gco2th(o)	check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
+
+/* macro to convert any Lua object into a GCObject */
+#define obj2gco(v)	(cast(GCObject *, (v)))
+
+
+/* actual number of total bytes allocated */
+#define gettotalbytes(g)	((g)->totalbytes + (g)->GCdebt)
+
+LUAI_FUNC void luaE_setdebt (global_State *g, l_mem debt);
+LUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);
+LUAI_FUNC CallInfo *luaE_extendCI (lua_State *L);
+LUAI_FUNC void luaE_freeCI (lua_State *L);
+
+
+#endif
+
diff --git a/dep/lualib/lstring.c b/dep/lualib/lstring.c
new file mode 100644
index 0000000..8b959f1
--- /dev/null
+++ b/dep/lualib/lstring.c
@@ -0,0 +1,185 @@
+/*
+** $Id: lstring.c,v 2.24 2012/05/11 14:14:42 roberto Exp $
+** String table (keeps all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lstring_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+
+
+/*
+** Lua will use at most ~(2^LUAI_HASHLIMIT) bytes from a string to
+** compute its hash
+*/
+#if !defined(LUAI_HASHLIMIT)
+#define LUAI_HASHLIMIT		5
+#endif
+
+
+/*
+** equality for long strings
+*/
+int luaS_eqlngstr (TString *a, TString *b) {
+  size_t len = a->tsv.len;
+  lua_assert(a->tsv.tt == LUA_TLNGSTR && b->tsv.tt == LUA_TLNGSTR);
+  return (a == b) ||  /* same instance or... */
+    ((len == b->tsv.len) &&  /* equal length and ... */
+     (memcmp(getstr(a), getstr(b), len) == 0));  /* equal contents */
+}
+
+
+/*
+** equality for strings
+*/
+int luaS_eqstr (TString *a, TString *b) {
+  return (a->tsv.tt == b->tsv.tt) &&
+         (a->tsv.tt == LUA_TSHRSTR ? eqshrstr(a, b) : luaS_eqlngstr(a, b));
+}
+
+
+unsigned int luaS_hash (const char *str, size_t l, unsigned int seed) {
+  unsigned int h = seed ^ l;
+  size_t l1;
+  size_t step = (l >> LUAI_HASHLIMIT) + 1;
+  for (l1 = l; l1 >= step; l1 -= step)
+    h = h ^ ((h<<5) + (h>>2) + cast_byte(str[l1 - 1]));
+  return h;
+}
+
+
+/*
+** resizes the string table
+*/
+void luaS_resize (lua_State *L, int newsize) {
+  int i;
+  stringtable *tb = &G(L)->strt;
+  /* cannot resize while GC is traversing strings */
+  luaC_runtilstate(L, ~bitmask(GCSsweepstring));
+  if (newsize > tb->size) {
+    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
+    for (i = tb->size; i < newsize; i++) tb->hash[i] = NULL;
+  }
+  /* rehash */
+  for (i=0; i<tb->size; i++) {
+    GCObject *p = tb->hash[i];
+    tb->hash[i] = NULL;
+    while (p) {  /* for each node in the list */
+      GCObject *next = gch(p)->next;  /* save next */
+      unsigned int h = lmod(gco2ts(p)->hash, newsize);  /* new position */
+      gch(p)->next = tb->hash[h];  /* chain it */
+      tb->hash[h] = p;
+      resetoldbit(p);  /* see MOVE OLD rule */
+      p = next;
+    }
+  }
+  if (newsize < tb->size) {
+    /* shrinking slice must be empty */
+    lua_assert(tb->hash[newsize] == NULL && tb->hash[tb->size - 1] == NULL);
+    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
+  }
+  tb->size = newsize;
+}
+
+
+/*
+** creates a new string object
+*/
+static TString *createstrobj (lua_State *L, const char *str, size_t l,
+                              int tag, unsigned int h, GCObject **list) {
+  TString *ts;
+  size_t totalsize;  /* total size of TString object */
+  totalsize = sizeof(TString) + ((l + 1) * sizeof(char));
+  ts = &luaC_newobj(L, tag, totalsize, list, 0)->ts;
+  ts->tsv.len = l;
+  ts->tsv.hash = h;
+  ts->tsv.extra = 0;
+  memcpy(ts+1, str, l*sizeof(char));
+  ((char *)(ts+1))[l] = '\0';  /* ending 0 */
+  return ts;
+}
+
+
+/*
+** creates a new short string, inserting it into string table
+*/
+static TString *newshrstr (lua_State *L, const char *str, size_t l,
+                                       unsigned int h) {
+  GCObject **list;  /* (pointer to) list where it will be inserted */
+  stringtable *tb = &G(L)->strt;
+  TString *s;
+  if (tb->nuse >= cast(lu_int32, tb->size) && tb->size <= MAX_INT/2)
+    luaS_resize(L, tb->size*2);  /* too crowded */
+  list = &tb->hash[lmod(h, tb->size)];
+  s = createstrobj(L, str, l, LUA_TSHRSTR, h, list);
+  tb->nuse++;
+  return s;
+}
+
+
+/*
+** checks whether short string exists and reuses it or creates a new one
+*/
+static TString *internshrstr (lua_State *L, const char *str, size_t l) {
+  GCObject *o;
+  global_State *g = G(L);
+  unsigned int h = luaS_hash(str, l, g->seed);
+  for (o = g->strt.hash[lmod(h, g->strt.size)];
+       o != NULL;
+       o = gch(o)->next) {
+    TString *ts = rawgco2ts(o);
+    if (h == ts->tsv.hash &&
+        ts->tsv.len == l &&
+        (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {
+      if (isdead(G(L), o))  /* string is dead (but was not collected yet)? */
+        changewhite(o);  /* resurrect it */
+      return ts;
+    }
+  }
+  return newshrstr(L, str, l, h);  /* not found; create a new string */
+}
+
+
+/*
+** new string (with explicit length)
+*/
+TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
+  if (l <= LUAI_MAXSHORTLEN)  /* short string? */
+    return internshrstr(L, str, l);
+  else {
+    if (l + 1 > (MAX_SIZET - sizeof(TString))/sizeof(char))
+      luaM_toobig(L);
+    return createstrobj(L, str, l, LUA_TLNGSTR, G(L)->seed, NULL);
+  }
+}
+
+
+/*
+** new zero-terminated string
+*/
+TString *luaS_new (lua_State *L, const char *str) {
+  return luaS_newlstr(L, str, strlen(str));
+}
+
+
+Udata *luaS_newudata (lua_State *L, size_t s, Table *e) {
+  Udata *u;
+  if (s > MAX_SIZET - sizeof(Udata))
+    luaM_toobig(L);
+  u = &luaC_newobj(L, LUA_TUSERDATA, sizeof(Udata) + s, NULL, 0)->u;
+  u->uv.len = s;
+  u->uv.metatable = NULL;
+  u->uv.env = e;
+  return u;
+}
+
diff --git a/dep/lualib/lstring.h b/dep/lualib/lstring.h
new file mode 100644
index 0000000..d312ff3
--- /dev/null
+++ b/dep/lualib/lstring.h
@@ -0,0 +1,46 @@
+/*
+** $Id: lstring.h,v 1.49 2012/02/01 21:57:15 roberto Exp $
+** String table (keep all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstring_h
+#define lstring_h
+
+#include "lgc.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+#define sizestring(s)	(sizeof(union TString)+((s)->len+1)*sizeof(char))
+
+#define sizeudata(u)	(sizeof(union Udata)+(u)->len)
+
+#define luaS_newliteral(L, s)	(luaS_newlstr(L, "" s, \
+                                 (sizeof(s)/sizeof(char))-1))
+
+#define luaS_fix(s)	l_setbit((s)->tsv.marked, FIXEDBIT)
+
+
+/*
+** test whether a string is a reserved word
+*/
+#define isreserved(s)	((s)->tsv.tt == LUA_TSHRSTR && (s)->tsv.extra > 0)
+
+
+/*
+** equality for short strings, which are always internalized
+*/
+#define eqshrstr(a,b)	check_exp((a)->tsv.tt == LUA_TSHRSTR, (a) == (b))
+
+
+LUAI_FUNC unsigned int luaS_hash (const char *str, size_t l, unsigned int seed);
+LUAI_FUNC int luaS_eqlngstr (TString *a, TString *b);
+LUAI_FUNC int luaS_eqstr (TString *a, TString *b);
+LUAI_FUNC void luaS_resize (lua_State *L, int newsize);
+LUAI_FUNC Udata *luaS_newudata (lua_State *L, size_t s, Table *e);
+LUAI_FUNC TString *luaS_newlstr (lua_State *L, const char *str, size_t l);
+LUAI_FUNC TString *luaS_new (lua_State *L, const char *str);
+
+
+#endif
diff --git a/dep/lualib/lstrlib.c b/dep/lualib/lstrlib.c
new file mode 100644
index 0000000..e13098b
--- /dev/null
+++ b/dep/lualib/lstrlib.c
@@ -0,0 +1,972 @@
+/*
+** $Id: lstrlib.c,v 1.176 2012/05/23 15:37:09 roberto Exp $
+** Standard library for string operations and pattern-matching
+** See Copyright Notice in lua.h
+*/
+
+
+#include <ctype.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lstrlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/*
+** maximum number of captures that a pattern can do during
+** pattern-matching. This limit is arbitrary.
+*/
+#if !defined(LUA_MAXCAPTURES)
+#define LUA_MAXCAPTURES		32
+#endif
+
+
+/* macro to `unsign' a character */
+#define uchar(c)	((unsigned char)(c))
+
+
+
+static int str_len (lua_State *L) {
+  size_t l;
+  luaL_checklstring(L, 1, &l);
+  lua_pushinteger(L, (lua_Integer)l);
+  return 1;
+}
+
+
+/* translate a relative string position: negative means back from end */
+static size_t posrelat (ptrdiff_t pos, size_t len) {
+  if (pos >= 0) return (size_t)pos;
+  else if (0u - (size_t)pos > len) return 0;
+  else return len - ((size_t)-pos) + 1;
+}
+
+
+static int str_sub (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  size_t start = posrelat(luaL_checkinteger(L, 2), l);
+  size_t end = posrelat(luaL_optinteger(L, 3, -1), l);
+  if (start < 1) start = 1;
+  if (end > l) end = l;
+  if (start <= end)
+    lua_pushlstring(L, s + start - 1, end - start + 1);
+  else lua_pushliteral(L, "");
+  return 1;
+}
+
+
+static int str_reverse (lua_State *L) {
+  size_t l, i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  char *p = luaL_buffinitsize(L, &b, l);
+  for (i = 0; i < l; i++)
+    p[i] = s[l - i - 1];
+  luaL_pushresultsize(&b, l);
+  return 1;
+}
+
+
+static int str_lower (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  char *p = luaL_buffinitsize(L, &b, l);
+  for (i=0; i<l; i++)
+    p[i] = tolower(uchar(s[i]));
+  luaL_pushresultsize(&b, l);
+  return 1;
+}
+
+
+static int str_upper (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  char *p = luaL_buffinitsize(L, &b, l);
+  for (i=0; i<l; i++)
+    p[i] = toupper(uchar(s[i]));
+  luaL_pushresultsize(&b, l);
+  return 1;
+}
+
+
+/* reasonable limit to avoid arithmetic overflow */
+#define MAXSIZE		((~(size_t)0) >> 1)
+
+static int str_rep (lua_State *L) {
+  size_t l, lsep;
+  const char *s = luaL_checklstring(L, 1, &l);
+  int n = luaL_checkint(L, 2);
+  const char *sep = luaL_optlstring(L, 3, "", &lsep);
+  if (n <= 0) lua_pushliteral(L, "");
+  else if (l + lsep < l || l + lsep >= MAXSIZE / n)  /* may overflow? */
+    return luaL_error(L, "resulting string too large");
+  else {
+    size_t totallen = n * l + (n - 1) * lsep;
+    luaL_Buffer b;
+    char *p = luaL_buffinitsize(L, &b, totallen);
+    while (n-- > 1) {  /* first n-1 copies (followed by separator) */
+      memcpy(p, s, l * sizeof(char)); p += l;
+      if (lsep > 0) {  /* avoid empty 'memcpy' (may be expensive) */
+        memcpy(p, sep, lsep * sizeof(char)); p += lsep;
+      }
+    }
+    memcpy(p, s, l * sizeof(char));  /* last copy (not followed by separator) */
+    luaL_pushresultsize(&b, totallen);
+  }
+  return 1;
+}
+
+
+static int str_byte (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  size_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
+  size_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
+  int n, i;
+  if (posi < 1) posi = 1;
+  if (pose > l) pose = l;
+  if (posi > pose) return 0;  /* empty interval; return no values */
+  n = (int)(pose -  posi + 1);
+  if (posi + n <= pose)  /* (size_t -> int) overflow? */
+    return luaL_error(L, "string slice too long");
+  luaL_checkstack(L, n, "string slice too long");
+  for (i=0; i<n; i++)
+    lua_pushinteger(L, uchar(s[posi+i-1]));
+  return n;
+}
+
+
+static int str_char (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  luaL_Buffer b;
+  char *p = luaL_buffinitsize(L, &b, n);
+  for (i=1; i<=n; i++) {
+    int c = luaL_checkint(L, i);
+    luaL_argcheck(L, uchar(c) == c, i, "value out of range");
+    p[i - 1] = uchar(c);
+  }
+  luaL_pushresultsize(&b, n);
+  return 1;
+}
+
+
+static int writer (lua_State *L, const void* b, size_t size, void* B) {
+  (void)L;
+  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
+  return 0;
+}
+
+
+static int str_dump (lua_State *L) {
+  luaL_Buffer b;
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  lua_settop(L, 1);
+  luaL_buffinit(L,&b);
+  if (lua_dump(L, writer, &b) != 0)
+    return luaL_error(L, "unable to dump given function");
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+
+/*
+** {======================================================
+** PATTERN MATCHING
+** =======================================================
+*/
+
+
+#define CAP_UNFINISHED	(-1)
+#define CAP_POSITION	(-2)
+
+typedef struct MatchState {
+  const char *src_init;  /* init of source string */
+  const char *src_end;  /* end ('\0') of source string */
+  const char *p_end;  /* end ('\0') of pattern */
+  lua_State *L;
+  int level;  /* total number of captures (finished or unfinished) */
+  struct {
+    const char *init;
+    ptrdiff_t len;
+  } capture[LUA_MAXCAPTURES];
+} MatchState;
+
+
+#define L_ESC		'%'
+#define SPECIALS	"^$*+?.([%-"
+
+
+static int check_capture (MatchState *ms, int l) {
+  l -= '1';
+  if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)
+    return luaL_error(ms->L, "invalid capture index %%%d", l + 1);
+  return l;
+}
+
+
+static int capture_to_close (MatchState *ms) {
+  int level = ms->level;
+  for (level--; level>=0; level--)
+    if (ms->capture[level].len == CAP_UNFINISHED) return level;
+  return luaL_error(ms->L, "invalid pattern capture");
+}
+
+
+static const char *classend (MatchState *ms, const char *p) {
+  switch (*p++) {
+    case L_ESC: {
+      if (p == ms->p_end)
+        luaL_error(ms->L, "malformed pattern (ends with " LUA_QL("%%") ")");
+      return p+1;
+    }
+    case '[': {
+      if (*p == '^') p++;
+      do {  /* look for a `]' */
+        if (p == ms->p_end)
+          luaL_error(ms->L, "malformed pattern (missing " LUA_QL("]") ")");
+        if (*(p++) == L_ESC && p < ms->p_end)
+          p++;  /* skip escapes (e.g. `%]') */
+      } while (*p != ']');
+      return p+1;
+    }
+    default: {
+      return p;
+    }
+  }
+}
+
+
+static int match_class (int c, int cl) {
+  int res;
+  switch (tolower(cl)) {
+    case 'a' : res = isalpha(c); break;
+    case 'c' : res = iscntrl(c); break;
+    case 'd' : res = isdigit(c); break;
+    case 'g' : res = isgraph(c); break;
+    case 'l' : res = islower(c); break;
+    case 'p' : res = ispunct(c); break;
+    case 's' : res = isspace(c); break;
+    case 'u' : res = isupper(c); break;
+    case 'w' : res = isalnum(c); break;
+    case 'x' : res = isxdigit(c); break;
+    case 'z' : res = (c == 0); break;  /* deprecated option */
+    default: return (cl == c);
+  }
+  return (islower(cl) ? res : !res);
+}
+
+
+static int matchbracketclass (int c, const char *p, const char *ec) {
+  int sig = 1;
+  if (*(p+1) == '^') {
+    sig = 0;
+    p++;  /* skip the `^' */
+  }
+  while (++p < ec) {
+    if (*p == L_ESC) {
+      p++;
+      if (match_class(c, uchar(*p)))
+        return sig;
+    }
+    else if ((*(p+1) == '-') && (p+2 < ec)) {
+      p+=2;
+      if (uchar(*(p-2)) <= c && c <= uchar(*p))
+        return sig;
+    }
+    else if (uchar(*p) == c) return sig;
+  }
+  return !sig;
+}
+
+
+static int singlematch (int c, const char *p, const char *ep) {
+  switch (*p) {
+    case '.': return 1;  /* matches any char */
+    case L_ESC: return match_class(c, uchar(*(p+1)));
+    case '[': return matchbracketclass(c, p, ep-1);
+    default:  return (uchar(*p) == c);
+  }
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p);
+
+
+static const char *matchbalance (MatchState *ms, const char *s,
+                                   const char *p) {
+  if (p >= ms->p_end - 1)
+    luaL_error(ms->L, "malformed pattern "
+                      "(missing arguments to " LUA_QL("%%b") ")");
+  if (*s != *p) return NULL;
+  else {
+    int b = *p;
+    int e = *(p+1);
+    int cont = 1;
+    while (++s < ms->src_end) {
+      if (*s == e) {
+        if (--cont == 0) return s+1;
+      }
+      else if (*s == b) cont++;
+    }
+  }
+  return NULL;  /* string ends out of balance */
+}
+
+
+static const char *max_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  ptrdiff_t i = 0;  /* counts maximum expand for item */
+  while ((s+i)<ms->src_end && singlematch(uchar(*(s+i)), p, ep))
+    i++;
+  /* keeps trying to match with the maximum repetitions */
+  while (i>=0) {
+    const char *res = match(ms, (s+i), ep+1);
+    if (res) return res;
+    i--;  /* else didn't match; reduce 1 repetition to try again */
+  }
+  return NULL;
+}
+
+
+static const char *min_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  for (;;) {
+    const char *res = match(ms, s, ep+1);
+    if (res != NULL)
+      return res;
+    else if (s<ms->src_end && singlematch(uchar(*s), p, ep))
+      s++;  /* try with one more repetition */
+    else return NULL;
+  }
+}
+
+
+static const char *start_capture (MatchState *ms, const char *s,
+                                    const char *p, int what) {
+  const char *res;
+  int level = ms->level;
+  if (level >= LUA_MAXCAPTURES) luaL_error(ms->L, "too many captures");
+  ms->capture[level].init = s;
+  ms->capture[level].len = what;
+  ms->level = level+1;
+  if ((res=match(ms, s, p)) == NULL)  /* match failed? */
+    ms->level--;  /* undo capture */
+  return res;
+}
+
+
+static const char *end_capture (MatchState *ms, const char *s,
+                                  const char *p) {
+  int l = capture_to_close(ms);
+  const char *res;
+  ms->capture[l].len = s - ms->capture[l].init;  /* close capture */
+  if ((res = match(ms, s, p)) == NULL)  /* match failed? */
+    ms->capture[l].len = CAP_UNFINISHED;  /* undo capture */
+  return res;
+}
+
+
+static const char *match_capture (MatchState *ms, const char *s, int l) {
+  size_t len;
+  l = check_capture(ms, l);
+  len = ms->capture[l].len;
+  if ((size_t)(ms->src_end-s) >= len &&
+      memcmp(ms->capture[l].init, s, len) == 0)
+    return s+len;
+  else return NULL;
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p) {
+  init: /* using goto's to optimize tail recursion */
+  if (p == ms->p_end)  /* end of pattern? */
+    return s;  /* match succeeded */
+  switch (*p) {
+    case '(': {  /* start capture */
+      if (*(p+1) == ')')  /* position capture? */
+        return start_capture(ms, s, p+2, CAP_POSITION);
+      else
+        return start_capture(ms, s, p+1, CAP_UNFINISHED);
+    }
+    case ')': {  /* end capture */
+      return end_capture(ms, s, p+1);
+    }
+    case '$': {
+      if ((p+1) == ms->p_end)  /* is the `$' the last char in pattern? */
+        return (s == ms->src_end) ? s : NULL;  /* check end of string */
+      else goto dflt;
+    }
+    case L_ESC: {  /* escaped sequences not in the format class[*+?-]? */
+      switch (*(p+1)) {
+        case 'b': {  /* balanced string? */
+          s = matchbalance(ms, s, p+2);
+          if (s == NULL) return NULL;
+          p+=4; goto init;  /* else return match(ms, s, p+4); */
+        }
+        case 'f': {  /* frontier? */
+          const char *ep; char previous;
+          p += 2;
+          if (*p != '[')
+            luaL_error(ms->L, "missing " LUA_QL("[") " after "
+                               LUA_QL("%%f") " in pattern");
+          ep = classend(ms, p);  /* points to what is next */
+          previous = (s == ms->src_init) ? '\0' : *(s-1);
+          if (matchbracketclass(uchar(previous), p, ep-1) ||
+             !matchbracketclass(uchar(*s), p, ep-1)) return NULL;
+          p=ep; goto init;  /* else return match(ms, s, ep); */
+        }
+        case '0': case '1': case '2': case '3':
+        case '4': case '5': case '6': case '7':
+        case '8': case '9': {  /* capture results (%0-%9)? */
+          s = match_capture(ms, s, uchar(*(p+1)));
+          if (s == NULL) return NULL;
+          p+=2; goto init;  /* else return match(ms, s, p+2) */
+        }
+        default: goto dflt;
+      }
+    }
+    default: dflt: {  /* pattern class plus optional suffix */
+      const char *ep = classend(ms, p);  /* points to what is next */
+      int m = s < ms->src_end && singlematch(uchar(*s), p, ep);
+      switch (*ep) {
+        case '?': {  /* optional */
+          const char *res;
+          if (m && ((res=match(ms, s+1, ep+1)) != NULL))
+            return res;
+          p=ep+1; goto init;  /* else return match(ms, s, ep+1); */
+        }
+        case '*': {  /* 0 or more repetitions */
+          return max_expand(ms, s, p, ep);
+        }
+        case '+': {  /* 1 or more repetitions */
+          return (m ? max_expand(ms, s+1, p, ep) : NULL);
+        }
+        case '-': {  /* 0 or more repetitions (minimum) */
+          return min_expand(ms, s, p, ep);
+        }
+        default: {
+          if (!m) return NULL;
+          s++; p=ep; goto init;  /* else return match(ms, s+1, ep); */
+        }
+      }
+    }
+  }
+}
+
+
+
+static const char *lmemfind (const char *s1, size_t l1,
+                               const char *s2, size_t l2) {
+  if (l2 == 0) return s1;  /* empty strings are everywhere */
+  else if (l2 > l1) return NULL;  /* avoids a negative `l1' */
+  else {
+    const char *init;  /* to search for a `*s2' inside `s1' */
+    l2--;  /* 1st char will be checked by `memchr' */
+    l1 = l1-l2;  /* `s2' cannot be found after that */
+    while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
+      init++;   /* 1st char is already checked */
+      if (memcmp(init, s2+1, l2) == 0)
+        return init-1;
+      else {  /* correct `l1' and `s1' to try again */
+        l1 -= init-s1;
+        s1 = init;
+      }
+    }
+    return NULL;  /* not found */
+  }
+}
+
+
+static void push_onecapture (MatchState *ms, int i, const char *s,
+                                                    const char *e) {
+  if (i >= ms->level) {
+    if (i == 0)  /* ms->level == 0, too */
+      lua_pushlstring(ms->L, s, e - s);  /* add whole match */
+    else
+      luaL_error(ms->L, "invalid capture index");
+  }
+  else {
+    ptrdiff_t l = ms->capture[i].len;
+    if (l == CAP_UNFINISHED) luaL_error(ms->L, "unfinished capture");
+    if (l == CAP_POSITION)
+      lua_pushinteger(ms->L, ms->capture[i].init - ms->src_init + 1);
+    else
+      lua_pushlstring(ms->L, ms->capture[i].init, l);
+  }
+}
+
+
+static int push_captures (MatchState *ms, const char *s, const char *e) {
+  int i;
+  int nlevels = (ms->level == 0 && s) ? 1 : ms->level;
+  luaL_checkstack(ms->L, nlevels, "too many captures");
+  for (i = 0; i < nlevels; i++)
+    push_onecapture(ms, i, s, e);
+  return nlevels;  /* number of strings pushed */
+}
+
+
+/* check whether pattern has no special characters */
+static int nospecials (const char *p, size_t l) {
+  size_t upto = 0;
+  do {
+    if (strpbrk(p + upto, SPECIALS))
+      return 0;  /* pattern has a special character */
+    upto += strlen(p + upto) + 1;  /* may have more after \0 */
+  } while (upto <= l);
+  return 1;  /* no special chars found */
+}
+
+
+static int str_find_aux (lua_State *L, int find) {
+  size_t ls, lp;
+  const char *s = luaL_checklstring(L, 1, &ls);
+  const char *p = luaL_checklstring(L, 2, &lp);
+  size_t init = posrelat(luaL_optinteger(L, 3, 1), ls);
+  if (init < 1) init = 1;
+  else if (init > ls + 1) {  /* start after string's end? */
+    lua_pushnil(L);  /* cannot find anything */
+    return 1;
+  }
+  /* explicit request or no special characters? */
+  if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {
+    /* do a plain search */
+    const char *s2 = lmemfind(s + init - 1, ls - init + 1, p, lp);
+    if (s2) {
+      lua_pushinteger(L, s2 - s + 1);
+      lua_pushinteger(L, s2 - s + lp);
+      return 2;
+    }
+  }
+  else {
+    MatchState ms;
+    const char *s1 = s + init - 1;
+    int anchor = (*p == '^');
+    if (anchor) {
+      p++; lp--;  /* skip anchor character */
+    }
+    ms.L = L;
+    ms.src_init = s;
+    ms.src_end = s + ls;
+    ms.p_end = p + lp;
+    do {
+      const char *res;
+      ms.level = 0;
+      if ((res=match(&ms, s1, p)) != NULL) {
+        if (find) {
+          lua_pushinteger(L, s1 - s + 1);  /* start */
+          lua_pushinteger(L, res - s);   /* end */
+          return push_captures(&ms, NULL, 0) + 2;
+        }
+        else
+          return push_captures(&ms, s1, res);
+      }
+    } while (s1++ < ms.src_end && !anchor);
+  }
+  lua_pushnil(L);  /* not found */
+  return 1;
+}
+
+
+static int str_find (lua_State *L) {
+  return str_find_aux(L, 1);
+}
+
+
+static int str_match (lua_State *L) {
+  return str_find_aux(L, 0);
+}
+
+
+static int gmatch_aux (lua_State *L) {
+  MatchState ms;
+  size_t ls, lp;
+  const char *s = lua_tolstring(L, lua_upvalueindex(1), &ls);
+  const char *p = lua_tolstring(L, lua_upvalueindex(2), &lp);
+  const char *src;
+  ms.L = L;
+  ms.src_init = s;
+  ms.src_end = s+ls;
+  ms.p_end = p + lp;
+  for (src = s + (size_t)lua_tointeger(L, lua_upvalueindex(3));
+       src <= ms.src_end;
+       src++) {
+    const char *e;
+    ms.level = 0;
+    if ((e = match(&ms, src, p)) != NULL) {
+      lua_Integer newstart = e-s;
+      if (e == src) newstart++;  /* empty match? go at least one position */
+      lua_pushinteger(L, newstart);
+      lua_replace(L, lua_upvalueindex(3));
+      return push_captures(&ms, src, e);
+    }
+  }
+  return 0;  /* not found */
+}
+
+
+static int gmatch (lua_State *L) {
+  luaL_checkstring(L, 1);
+  luaL_checkstring(L, 2);
+  lua_settop(L, 2);
+  lua_pushinteger(L, 0);
+  lua_pushcclosure(L, gmatch_aux, 3);
+  return 1;
+}
+
+
+static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
+                                                   const char *e) {
+  size_t l, i;
+  const char *news = lua_tolstring(ms->L, 3, &l);
+  for (i = 0; i < l; i++) {
+    if (news[i] != L_ESC)
+      luaL_addchar(b, news[i]);
+    else {
+      i++;  /* skip ESC */
+      if (!isdigit(uchar(news[i]))) {
+        if (news[i] != L_ESC)
+          luaL_error(ms->L, "invalid use of " LUA_QL("%c")
+                           " in replacement string", L_ESC);
+        luaL_addchar(b, news[i]);
+      }
+      else if (news[i] == '0')
+          luaL_addlstring(b, s, e - s);
+      else {
+        push_onecapture(ms, news[i] - '1', s, e);
+        luaL_addvalue(b);  /* add capture to accumulated result */
+      }
+    }
+  }
+}
+
+
+static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
+                                       const char *e, int tr) {
+  lua_State *L = ms->L;
+  switch (tr) {
+    case LUA_TFUNCTION: {
+      int n;
+      lua_pushvalue(L, 3);
+      n = push_captures(ms, s, e);
+      lua_call(L, n, 1);
+      break;
+    }
+    case LUA_TTABLE: {
+      push_onecapture(ms, 0, s, e);
+      lua_gettable(L, 3);
+      break;
+    }
+    default: {  /* LUA_TNUMBER or LUA_TSTRING */
+      add_s(ms, b, s, e);
+      return;
+    }
+  }
+  if (!lua_toboolean(L, -1)) {  /* nil or false? */
+    lua_pop(L, 1);
+    lua_pushlstring(L, s, e - s);  /* keep original text */
+  }
+  else if (!lua_isstring(L, -1))
+    luaL_error(L, "invalid replacement value (a %s)", luaL_typename(L, -1));
+  luaL_addvalue(b);  /* add result to accumulator */
+}
+
+
+static int str_gsub (lua_State *L) {
+  size_t srcl, lp;
+  const char *src = luaL_checklstring(L, 1, &srcl);
+  const char *p = luaL_checklstring(L, 2, &lp);
+  int tr = lua_type(L, 3);
+  size_t max_s = luaL_optinteger(L, 4, srcl+1);
+  int anchor = (*p == '^');
+  size_t n = 0;
+  MatchState ms;
+  luaL_Buffer b;
+  luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
+                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,
+                      "string/function/table expected");
+  luaL_buffinit(L, &b);
+  if (anchor) {
+    p++; lp--;  /* skip anchor character */
+  }
+  ms.L = L;
+  ms.src_init = src;
+  ms.src_end = src+srcl;
+  ms.p_end = p + lp;
+  while (n < max_s) {
+    const char *e;
+    ms.level = 0;
+    e = match(&ms, src, p);
+    if (e) {
+      n++;
+      add_value(&ms, &b, src, e, tr);
+    }
+    if (e && e>src) /* non empty match? */
+      src = e;  /* skip it */
+    else if (src < ms.src_end)
+      luaL_addchar(&b, *src++);
+    else break;
+    if (anchor) break;
+  }
+  luaL_addlstring(&b, src, ms.src_end-src);
+  luaL_pushresult(&b);
+  lua_pushinteger(L, n);  /* number of substitutions */
+  return 2;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** STRING FORMAT
+** =======================================================
+*/
+
+/*
+** LUA_INTFRMLEN is the length modifier for integer conversions in
+** 'string.format'; LUA_INTFRM_T is the integer type corresponding to
+** the previous length
+*/
+#if !defined(LUA_INTFRMLEN)	/* { */
+#if defined(LUA_USE_LONGLONG)
+
+#define LUA_INTFRMLEN		"ll"
+#define LUA_INTFRM_T		long long
+
+#else
+
+#define LUA_INTFRMLEN		"l"
+#define LUA_INTFRM_T		long
+
+#endif
+#endif				/* } */
+
+
+/*
+** LUA_FLTFRMLEN is the length modifier for float conversions in
+** 'string.format'; LUA_FLTFRM_T is the float type corresponding to
+** the previous length
+*/
+#if !defined(LUA_FLTFRMLEN)
+
+#define LUA_FLTFRMLEN		""
+#define LUA_FLTFRM_T		double
+
+#endif
+
+
+/* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */
+#define MAX_ITEM	512
+/* valid flags in a format specification */
+#define FLAGS	"-+ #0"
+/*
+** maximum size of each format specification (such as '%-099.99d')
+** (+10 accounts for %99.99x plus margin of error)
+*/
+#define MAX_FORMAT	(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)
+
+
+static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
+  size_t l;
+  const char *s = luaL_checklstring(L, arg, &l);
+  luaL_addchar(b, '"');
+  while (l--) {
+    if (*s == '"' || *s == '\\' || *s == '\n') {
+      luaL_addchar(b, '\\');
+      luaL_addchar(b, *s);
+    }
+    else if (*s == '\0' || iscntrl(uchar(*s))) {
+      char buff[10];
+      if (!isdigit(uchar(*(s+1))))
+        sprintf(buff, "\\%d", (int)uchar(*s));
+      else
+        sprintf(buff, "\\%03d", (int)uchar(*s));
+      luaL_addstring(b, buff);
+    }
+    else
+      luaL_addchar(b, *s);
+    s++;
+  }
+  luaL_addchar(b, '"');
+}
+
+static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
+  const char *p = strfrmt;
+  while (*p != '\0' && strchr(FLAGS, *p) != NULL) p++;  /* skip flags */
+  if ((size_t)(p - strfrmt) >= sizeof(FLAGS)/sizeof(char))
+    luaL_error(L, "invalid format (repeated flags)");
+  if (isdigit(uchar(*p))) p++;  /* skip width */
+  if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  if (*p == '.') {
+    p++;
+    if (isdigit(uchar(*p))) p++;  /* skip precision */
+    if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  }
+  if (isdigit(uchar(*p)))
+    luaL_error(L, "invalid format (width or precision too long)");
+  *(form++) = '%';
+  memcpy(form, strfrmt, (p - strfrmt + 1) * sizeof(char));
+  form += p - strfrmt + 1;
+  *form = '\0';
+  return p;
+}
+
+
+/*
+** add length modifier into formats
+*/
+static void addlenmod (char *form, const char *lenmod) {
+  size_t l = strlen(form);
+  size_t lm = strlen(lenmod);
+  char spec = form[l - 1];
+  strcpy(form + l - 1, lenmod);
+  form[l + lm - 1] = spec;
+  form[l + lm] = '\0';
+}
+
+
+static int str_format (lua_State *L) {
+  int top = lua_gettop(L);
+  int arg = 1;
+  size_t sfl;
+  const char *strfrmt = luaL_checklstring(L, arg, &sfl);
+  const char *strfrmt_end = strfrmt+sfl;
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while (strfrmt < strfrmt_end) {
+    if (*strfrmt != L_ESC)
+      luaL_addchar(&b, *strfrmt++);
+    else if (*++strfrmt == L_ESC)
+      luaL_addchar(&b, *strfrmt++);  /* %% */
+    else { /* format item */
+      char form[MAX_FORMAT];  /* to store the format (`%...') */
+      char *buff = luaL_prepbuffsize(&b, MAX_ITEM);  /* to put formatted item */
+      int nb = 0;  /* number of bytes in added item */
+      if (++arg > top)
+        luaL_argerror(L, arg, "no value");
+      strfrmt = scanformat(L, strfrmt, form);
+      switch (*strfrmt++) {
+        case 'c': {
+          nb = sprintf(buff, form, luaL_checkint(L, arg));
+          break;
+        }
+        case 'd':  case 'i': {
+          lua_Number n = luaL_checknumber(L, arg);
+          LUA_INTFRM_T ni = (LUA_INTFRM_T)n;
+          lua_Number diff = n - (lua_Number)ni;
+          luaL_argcheck(L, -1 < diff && diff < 1, arg,
+                        "not a number in proper range");
+          addlenmod(form, LUA_INTFRMLEN);
+          nb = sprintf(buff, form, ni);
+          break;
+        }
+        case 'o':  case 'u':  case 'x':  case 'X': {
+          lua_Number n = luaL_checknumber(L, arg);
+          unsigned LUA_INTFRM_T ni = (unsigned LUA_INTFRM_T)n;
+          lua_Number diff = n - (lua_Number)ni;
+          luaL_argcheck(L, -1 < diff && diff < 1, arg,
+                        "not a non-negative number in proper range");
+          addlenmod(form, LUA_INTFRMLEN);
+          nb = sprintf(buff, form, ni);
+          break;
+        }
+        case 'e':  case 'E': case 'f':
+#if defined(LUA_USE_AFORMAT)
+        case 'a': case 'A':
+#endif
+        case 'g': case 'G': {
+          addlenmod(form, LUA_FLTFRMLEN);
+          nb = sprintf(buff, form, (LUA_FLTFRM_T)luaL_checknumber(L, arg));
+          break;
+        }
+        case 'q': {
+          addquoted(L, &b, arg);
+          break;
+        }
+        case 's': {
+          size_t l;
+          const char *s = luaL_tolstring(L, arg, &l);
+          if (!strchr(form, '.') && l >= 100) {
+            /* no precision and string is too long to be formatted;
+               keep original string */
+            luaL_addvalue(&b);
+            break;
+          }
+          else {
+            nb = sprintf(buff, form, s);
+            lua_pop(L, 1);  /* remove result from 'luaL_tolstring' */
+            break;
+          }
+        }
+        default: {  /* also treat cases `pnLlh' */
+          return luaL_error(L, "invalid option " LUA_QL("%%%c") " to "
+                               LUA_QL("format"), *(strfrmt - 1));
+        }
+      }
+      luaL_addsize(&b, nb);
+    }
+  }
+  luaL_pushresult(&b);
+  return 1;
+}
+
+/* }====================================================== */
+
+
+static const luaL_Reg strlib[] = {
+  {"byte", str_byte},
+  {"char", str_char},
+  {"dump", str_dump},
+  {"find", str_find},
+  {"format", str_format},
+  {"gmatch", gmatch},
+  {"gsub", str_gsub},
+  {"len", str_len},
+  {"lower", str_lower},
+  {"match", str_match},
+  {"rep", str_rep},
+  {"reverse", str_reverse},
+  {"sub", str_sub},
+  {"upper", str_upper},
+  {NULL, NULL}
+};
+
+
+static void createmetatable (lua_State *L) {
+  lua_createtable(L, 0, 1);  /* table to be metatable for strings */
+  lua_pushliteral(L, "");  /* dummy string */
+  lua_pushvalue(L, -2);  /* copy table */
+  lua_setmetatable(L, -2);  /* set table as metatable for strings */
+  lua_pop(L, 1);  /* pop dummy string */
+  lua_pushvalue(L, -2);  /* get string library */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = string */
+  lua_pop(L, 1);  /* pop metatable */
+}
+
+
+/*
+** Open string library
+*/
+LUAMOD_API int luaopen_string (lua_State *L) {
+  luaL_newlib(L, strlib);
+  createmetatable(L);
+  return 1;
+}
+
diff --git a/dep/lualib/ltable.c b/dep/lualib/ltable.c
new file mode 100644
index 0000000..ffa5ecb
--- /dev/null
+++ b/dep/lualib/ltable.c
@@ -0,0 +1,588 @@
+/*
+** $Id: ltable.c,v 2.71 2012/05/23 15:37:09 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** Implementation of tables (aka arrays, objects, or hash tables).
+** Tables keep its elements in two parts: an array part and a hash part.
+** Non-negative integer keys are all candidates to be kept in the array
+** part. The actual size of the array is the largest `n' such that at
+** least half the slots between 0 and n are in use.
+** Hash uses a mix of chained scatter table with Brent's variation.
+** A main invariant of these tables is that, if an element is not
+** in its main position (i.e. the `original' position that its hash gives
+** to it), then the colliding element is in its own main position.
+** Hence even when the load factor reaches 100%, performance remains good.
+*/
+
+#include <string.h>
+
+#define ltable_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lvm.h"
+
+
+/*
+** max size of array part is 2^MAXBITS
+*/
+#if LUAI_BITSINT >= 32
+#define MAXBITS		30
+#else
+#define MAXBITS		(LUAI_BITSINT-2)
+#endif
+
+#define MAXASIZE	(1 << MAXBITS)
+
+
+#define hashpow2(t,n)		(gnode(t, lmod((n), sizenode(t))))
+
+#define hashstr(t,str)		hashpow2(t, (str)->tsv.hash)
+#define hashboolean(t,p)	hashpow2(t, p)
+
+
+/*
+** for some types, it is better to avoid modulus by power of 2, as
+** they tend to have many 2 factors.
+*/
+#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))
+
+
+#define hashpointer(t,p)	hashmod(t, IntPoint(p))
+
+
+#define dummynode		(&dummynode_)
+
+#define isdummy(n)		((n) == dummynode)
+
+static const Node dummynode_ = {
+  {NILCONSTANT},  /* value */
+  {{NILCONSTANT, NULL}}  /* key */
+};
+
+
+/*
+** hash for lua_Numbers
+*/
+static Node *hashnum (const Table *t, lua_Number n) {
+  int i;
+  luai_hashnum(i, n);
+  if (i < 0) {
+    if (cast(unsigned int, i) == 0u - i)  /* use unsigned to avoid overflows */
+      i = 0;  /* handle INT_MIN */
+    i = -i;  /* must be a positive value */
+  }
+  return hashmod(t, i);
+}
+
+
+
+/*
+** returns the `main' position of an element in a table (that is, the index
+** of its hash value)
+*/
+static Node *mainposition (const Table *t, const TValue *key) {
+  switch (ttype(key)) {
+    case LUA_TNUMBER:
+      return hashnum(t, nvalue(key));
+    case LUA_TLNGSTR: {
+      TString *s = rawtsvalue(key);
+      if (s->tsv.extra == 0) {  /* no hash? */
+        s->tsv.hash = luaS_hash(getstr(s), s->tsv.len, s->tsv.hash);
+        s->tsv.extra = 1;  /* now it has its hash */
+      }
+      return hashstr(t, rawtsvalue(key));
+    }
+    case LUA_TSHRSTR:
+      return hashstr(t, rawtsvalue(key));
+    case LUA_TBOOLEAN:
+      return hashboolean(t, bvalue(key));
+    case LUA_TLIGHTUSERDATA:
+      return hashpointer(t, pvalue(key));
+    case LUA_TLCF:
+      return hashpointer(t, fvalue(key));
+    default:
+      return hashpointer(t, gcvalue(key));
+  }
+}
+
+
+/*
+** returns the index for `key' if `key' is an appropriate key to live in
+** the array part of the table, -1 otherwise.
+*/
+static int arrayindex (const TValue *key) {
+  if (ttisnumber(key)) {
+    lua_Number n = nvalue(key);
+    int k;
+    lua_number2int(k, n);
+    if (luai_numeq(cast_num(k), n))
+      return k;
+  }
+  return -1;  /* `key' did not match some condition */
+}
+
+
+/*
+** returns the index of a `key' for table traversals. First goes all
+** elements in the array part, then elements in the hash part. The
+** beginning of a traversal is signaled by -1.
+*/
+static int findindex (lua_State *L, Table *t, StkId key) {
+  int i;
+  if (ttisnil(key)) return -1;  /* first iteration */
+  i = arrayindex(key);
+  if (0 < i && i <= t->sizearray)  /* is `key' inside array part? */
+    return i-1;  /* yes; that's the index (corrected to C) */
+  else {
+    Node *n = mainposition(t, key);
+    for (;;) {  /* check whether `key' is somewhere in the chain */
+      /* key may be dead already, but it is ok to use it in `next' */
+      if (luaV_rawequalobj(gkey(n), key) ||
+            (ttisdeadkey(gkey(n)) && iscollectable(key) &&
+             deadvalue(gkey(n)) == gcvalue(key))) {
+        i = cast_int(n - gnode(t, 0));  /* key index in hash table */
+        /* hash elements are numbered after array ones */
+        return i + t->sizearray;
+      }
+      else n = gnext(n);
+      if (n == NULL)
+        luaG_runerror(L, "invalid key to " LUA_QL("next"));  /* key not found */
+    }
+  }
+}
+
+
+int luaH_next (lua_State *L, Table *t, StkId key) {
+  int i = findindex(L, t, key);  /* find original element */
+  for (i++; i < t->sizearray; i++) {  /* try first array part */
+    if (!ttisnil(&t->array[i])) {  /* a non-nil value? */
+      setnvalue(key, cast_num(i+1));
+      setobj2s(L, key+1, &t->array[i]);
+      return 1;
+    }
+  }
+  for (i -= t->sizearray; i < sizenode(t); i++) {  /* then hash part */
+    if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
+      setobj2s(L, key, gkey(gnode(t, i)));
+      setobj2s(L, key+1, gval(gnode(t, i)));
+      return 1;
+    }
+  }
+  return 0;  /* no more elements */
+}
+
+
+/*
+** {=============================================================
+** Rehash
+** ==============================================================
+*/
+
+
+static int computesizes (int nums[], int *narray) {
+  int i;
+  int twotoi;  /* 2^i */
+  int a = 0;  /* number of elements smaller than 2^i */
+  int na = 0;  /* number of elements to go to array part */
+  int n = 0;  /* optimal size for array part */
+  for (i = 0, twotoi = 1; twotoi/2 < *narray; i++, twotoi *= 2) {
+    if (nums[i] > 0) {
+      a += nums[i];
+      if (a > twotoi/2) {  /* more than half elements present? */
+        n = twotoi;  /* optimal size (till now) */
+        na = a;  /* all elements smaller than n will go to array part */
+      }
+    }
+    if (a == *narray) break;  /* all elements already counted */
+  }
+  *narray = n;
+  lua_assert(*narray/2 <= na && na <= *narray);
+  return na;
+}
+
+
+static int countint (const TValue *key, int *nums) {
+  int k = arrayindex(key);
+  if (0 < k && k <= MAXASIZE) {  /* is `key' an appropriate array index? */
+    nums[luaO_ceillog2(k)]++;  /* count as such */
+    return 1;
+  }
+  else
+    return 0;
+}
+
+
+static int numusearray (const Table *t, int *nums) {
+  int lg;
+  int ttlg;  /* 2^lg */
+  int ause = 0;  /* summation of `nums' */
+  int i = 1;  /* count to traverse all array keys */
+  for (lg=0, ttlg=1; lg<=MAXBITS; lg++, ttlg*=2) {  /* for each slice */
+    int lc = 0;  /* counter */
+    int lim = ttlg;
+    if (lim > t->sizearray) {
+      lim = t->sizearray;  /* adjust upper limit */
+      if (i > lim)
+        break;  /* no more elements to count */
+    }
+    /* count elements in range (2^(lg-1), 2^lg] */
+    for (; i <= lim; i++) {
+      if (!ttisnil(&t->array[i-1]))
+        lc++;
+    }
+    nums[lg] += lc;
+    ause += lc;
+  }
+  return ause;
+}
+
+
+static int numusehash (const Table *t, int *nums, int *pnasize) {
+  int totaluse = 0;  /* total number of elements */
+  int ause = 0;  /* summation of `nums' */
+  int i = sizenode(t);
+  while (i--) {
+    Node *n = &t->node[i];
+    if (!ttisnil(gval(n))) {
+      ause += countint(gkey(n), nums);
+      totaluse++;
+    }
+  }
+  *pnasize += ause;
+  return totaluse;
+}
+
+
+static void setarrayvector (lua_State *L, Table *t, int size) {
+  int i;
+  luaM_reallocvector(L, t->array, t->sizearray, size, TValue);
+  for (i=t->sizearray; i<size; i++)
+     setnilvalue(&t->array[i]);
+  t->sizearray = size;
+}
+
+
+static void setnodevector (lua_State *L, Table *t, int size) {
+  int lsize;
+  if (size == 0) {  /* no elements to hash part? */
+    t->node = cast(Node *, dummynode);  /* use common `dummynode' */
+    lsize = 0;
+  }
+  else {
+    int i;
+    lsize = luaO_ceillog2(size);
+    if (lsize > MAXBITS)
+      luaG_runerror(L, "table overflow");
+    size = twoto(lsize);
+    t->node = luaM_newvector(L, size, Node);
+    for (i=0; i<size; i++) {
+      Node *n = gnode(t, i);
+      gnext(n) = NULL;
+      setnilvalue(gkey(n));
+      setnilvalue(gval(n));
+    }
+  }
+  t->lsizenode = cast_byte(lsize);
+  t->lastfree = gnode(t, size);  /* all positions are free */
+}
+
+
+void luaH_resize (lua_State *L, Table *t, int nasize, int nhsize) {
+  int i;
+  int oldasize = t->sizearray;
+  int oldhsize = t->lsizenode;
+  Node *nold = t->node;  /* save old hash ... */
+  if (nasize > oldasize)  /* array part must grow? */
+    setarrayvector(L, t, nasize);
+  /* create new hash part with appropriate size */
+  setnodevector(L, t, nhsize);
+  if (nasize < oldasize) {  /* array part must shrink? */
+    t->sizearray = nasize;
+    /* re-insert elements from vanishing slice */
+    for (i=nasize; i<oldasize; i++) {
+      if (!ttisnil(&t->array[i]))
+        luaH_setint(L, t, i + 1, &t->array[i]);
+    }
+    /* shrink array */
+    luaM_reallocvector(L, t->array, oldasize, nasize, TValue);
+  }
+  /* re-insert elements from hash part */
+  for (i = twoto(oldhsize) - 1; i >= 0; i--) {
+    Node *old = nold+i;
+    if (!ttisnil(gval(old))) {
+      /* doesn't need barrier/invalidate cache, as entry was
+         already present in the table */
+      setobjt2t(L, luaH_set(L, t, gkey(old)), gval(old));
+    }
+  }
+  if (!isdummy(nold))
+    luaM_freearray(L, nold, cast(size_t, twoto(oldhsize))); /* free old array */
+}
+
+
+void luaH_resizearray (lua_State *L, Table *t, int nasize) {
+  int nsize = isdummy(t->node) ? 0 : sizenode(t);
+  luaH_resize(L, t, nasize, nsize);
+}
+
+
+static void rehash (lua_State *L, Table *t, const TValue *ek) {
+  int nasize, na;
+  int nums[MAXBITS+1];  /* nums[i] = number of keys with 2^(i-1) < k <= 2^i */
+  int i;
+  int totaluse;
+  for (i=0; i<=MAXBITS; i++) nums[i] = 0;  /* reset counts */
+  nasize = numusearray(t, nums);  /* count keys in array part */
+  totaluse = nasize;  /* all those keys are integer keys */
+  totaluse += numusehash(t, nums, &nasize);  /* count keys in hash part */
+  /* count extra key */
+  nasize += countint(ek, nums);
+  totaluse++;
+  /* compute new size for array part */
+  na = computesizes(nums, &nasize);
+  /* resize the table to new computed sizes */
+  luaH_resize(L, t, nasize, totaluse - na);
+}
+
+
+
+/*
+** }=============================================================
+*/
+
+
+Table *luaH_new (lua_State *L) {
+  Table *t = &luaC_newobj(L, LUA_TTABLE, sizeof(Table), NULL, 0)->h;
+  t->metatable = NULL;
+  t->flags = cast_byte(~0);
+  t->array = NULL;
+  t->sizearray = 0;
+  setnodevector(L, t, 0);
+  return t;
+}
+
+
+void luaH_free (lua_State *L, Table *t) {
+  if (!isdummy(t->node))
+    luaM_freearray(L, t->node, cast(size_t, sizenode(t)));
+  luaM_freearray(L, t->array, t->sizearray);
+  luaM_free(L, t);
+}
+
+
+static Node *getfreepos (Table *t) {
+  while (t->lastfree > t->node) {
+    t->lastfree--;
+    if (ttisnil(gkey(t->lastfree)))
+      return t->lastfree;
+  }
+  return NULL;  /* could not find a free place */
+}
+
+
+
+/*
+** inserts a new key into a hash table; first, check whether key's main
+** position is free. If not, check whether colliding node is in its main
+** position or not: if it is not, move colliding node to an empty place and
+** put new key in its main position; otherwise (colliding node is in its main
+** position), new key goes to an empty position.
+*/
+TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {
+  Node *mp;
+  if (ttisnil(key)) luaG_runerror(L, "table index is nil");
+  else if (ttisnumber(key) && luai_numisnan(L, nvalue(key)))
+    luaG_runerror(L, "table index is NaN");
+  mp = mainposition(t, key);
+  if (!ttisnil(gval(mp)) || isdummy(mp)) {  /* main position is taken? */
+    Node *othern;
+    Node *n = getfreepos(t);  /* get a free place */
+    if (n == NULL) {  /* cannot find a free place? */
+      rehash(L, t, key);  /* grow table */
+      /* whatever called 'newkey' take care of TM cache and GC barrier */
+      return luaH_set(L, t, key);  /* insert key into grown table */
+    }
+    lua_assert(!isdummy(n));
+    othern = mainposition(t, gkey(mp));
+    if (othern != mp) {  /* is colliding node out of its main position? */
+      /* yes; move colliding node into free position */
+      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */
+      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */
+      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
+      gnext(mp) = NULL;  /* now `mp' is free */
+      setnilvalue(gval(mp));
+    }
+    else {  /* colliding node is in its own main position */
+      /* new node will go into free position */
+      gnext(n) = gnext(mp);  /* chain new position */
+      gnext(mp) = n;
+      mp = n;
+    }
+  }
+  setobj2t(L, gkey(mp), key);
+  luaC_barrierback(L, obj2gco(t), key);
+  lua_assert(ttisnil(gval(mp)));
+  return gval(mp);
+}
+
+
+/*
+** search function for integers
+*/
+const TValue *luaH_getint (Table *t, int key) {
+  /* (1 <= key && key <= t->sizearray) */
+  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))
+    return &t->array[key-1];
+  else {
+    lua_Number nk = cast_num(key);
+    Node *n = hashnum(t, nk);
+    do {  /* check whether `key' is somewhere in the chain */
+      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))
+        return gval(n);  /* that's it */
+      else n = gnext(n);
+    } while (n);
+    return luaO_nilobject;
+  }
+}
+
+
+/*
+** search function for short strings
+*/
+const TValue *luaH_getstr (Table *t, TString *key) {
+  Node *n = hashstr(t, key);
+  lua_assert(key->tsv.tt == LUA_TSHRSTR);
+  do {  /* check whether `key' is somewhere in the chain */
+    if (ttisshrstring(gkey(n)) && eqshrstr(rawtsvalue(gkey(n)), key))
+      return gval(n);  /* that's it */
+    else n = gnext(n);
+  } while (n);
+  return luaO_nilobject;
+}
+
+
+/*
+** main search function
+*/
+const TValue *luaH_get (Table *t, const TValue *key) {
+  switch (ttype(key)) {
+    case LUA_TNIL: return luaO_nilobject;
+    case LUA_TSHRSTR: return luaH_getstr(t, rawtsvalue(key));
+    case LUA_TNUMBER: {
+      int k;
+      lua_Number n = nvalue(key);
+      lua_number2int(k, n);
+      if (luai_numeq(cast_num(k), nvalue(key))) /* index is int? */
+        return luaH_getint(t, k);  /* use specialized version */
+      /* else go through */
+    }
+    default: {
+      Node *n = mainposition(t, key);
+      do {  /* check whether `key' is somewhere in the chain */
+        if (luaV_rawequalobj(gkey(n), key))
+          return gval(n);  /* that's it */
+        else n = gnext(n);
+      } while (n);
+      return luaO_nilobject;
+    }
+  }
+}
+
+
+/*
+** beware: when using this function you probably need to check a GC
+** barrier and invalidate the TM cache.
+*/
+TValue *luaH_set (lua_State *L, Table *t, const TValue *key) {
+  const TValue *p = luaH_get(t, key);
+  if (p != luaO_nilobject)
+    return cast(TValue *, p);
+  else return luaH_newkey(L, t, key);
+}
+
+
+void luaH_setint (lua_State *L, Table *t, int key, TValue *value) {
+  const TValue *p = luaH_getint(t, key);
+  TValue *cell;
+  if (p != luaO_nilobject)
+    cell = cast(TValue *, p);
+  else {
+    TValue k;
+    setnvalue(&k, cast_num(key));
+    cell = luaH_newkey(L, t, &k);
+  }
+  setobj2t(L, cell, value);
+}
+
+
+static int unbound_search (Table *t, unsigned int j) {
+  unsigned int i = j;  /* i is zero or a present index */
+  j++;
+  /* find `i' and `j' such that i is present and j is not */
+  while (!ttisnil(luaH_getint(t, j))) {
+    i = j;
+    j *= 2;
+    if (j > cast(unsigned int, MAX_INT)) {  /* overflow? */
+      /* table was built with bad purposes: resort to linear search */
+      i = 1;
+      while (!ttisnil(luaH_getint(t, i))) i++;
+      return i - 1;
+    }
+  }
+  /* now do a binary search between them */
+  while (j - i > 1) {
+    unsigned int m = (i+j)/2;
+    if (ttisnil(luaH_getint(t, m))) j = m;
+    else i = m;
+  }
+  return i;
+}
+
+
+/*
+** Try to find a boundary in table `t'. A `boundary' is an integer index
+** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
+*/
+int luaH_getn (Table *t) {
+  unsigned int j = t->sizearray;
+  if (j > 0 && ttisnil(&t->array[j - 1])) {
+    /* there is a boundary in the array part: (binary) search for it */
+    unsigned int i = 0;
+    while (j - i > 1) {
+      unsigned int m = (i+j)/2;
+      if (ttisnil(&t->array[m - 1])) j = m;
+      else i = m;
+    }
+    return i;
+  }
+  /* else must find a boundary in hash part */
+  else if (isdummy(t->node))  /* hash part is empty? */
+    return j;  /* that is easy... */
+  else return unbound_search(t, j);
+}
+
+
+
+#if defined(LUA_DEBUG)
+
+Node *luaH_mainposition (const Table *t, const TValue *key) {
+  return mainposition(t, key);
+}
+
+int luaH_isdummy (Node *n) { return isdummy(n); }
+
+#endif
diff --git a/dep/lualib/ltable.h b/dep/lualib/ltable.h
new file mode 100644
index 0000000..2f6f5c2
--- /dev/null
+++ b/dep/lualib/ltable.h
@@ -0,0 +1,41 @@
+/*
+** $Id: ltable.h,v 2.16 2011/08/17 20:26:47 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltable_h
+#define ltable_h
+
+#include "lobject.h"
+
+
+#define gnode(t,i)	(&(t)->node[i])
+#define gkey(n)		(&(n)->i_key.tvk)
+#define gval(n)		(&(n)->i_val)
+#define gnext(n)	((n)->i_key.nk.next)
+
+#define invalidateTMcache(t)	((t)->flags = 0)
+
+
+LUAI_FUNC const TValue *luaH_getint (Table *t, int key);
+LUAI_FUNC void luaH_setint (lua_State *L, Table *t, int key, TValue *value);
+LUAI_FUNC const TValue *luaH_getstr (Table *t, TString *key);
+LUAI_FUNC const TValue *luaH_get (Table *t, const TValue *key);
+LUAI_FUNC TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key);
+LUAI_FUNC TValue *luaH_set (lua_State *L, Table *t, const TValue *key);
+LUAI_FUNC Table *luaH_new (lua_State *L);
+LUAI_FUNC void luaH_resize (lua_State *L, Table *t, int nasize, int nhsize);
+LUAI_FUNC void luaH_resizearray (lua_State *L, Table *t, int nasize);
+LUAI_FUNC void luaH_free (lua_State *L, Table *t);
+LUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);
+LUAI_FUNC int luaH_getn (Table *t);
+
+
+#if defined(LUA_DEBUG)
+LUAI_FUNC Node *luaH_mainposition (const Table *t, const TValue *key);
+LUAI_FUNC int luaH_isdummy (Node *n);
+#endif
+
+
+#endif
diff --git a/dep/lualib/ltablib.c b/dep/lualib/ltablib.c
new file mode 100644
index 0000000..a52add0
--- /dev/null
+++ b/dep/lualib/ltablib.c
@@ -0,0 +1,283 @@
+/*
+** $Id: ltablib.c,v 1.63 2011/11/28 17:26:30 roberto Exp $
+** Library for Table Manipulation
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define ltablib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#define aux_getn(L,n)  \
+	(luaL_checktype(L, n, LUA_TTABLE), luaL_len(L, n))
+
+
+#if defined(LUA_COMPAT_MAXN)
+static int maxn (lua_State *L) {
+  lua_Number max = 0;
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_pushnil(L);  /* first key */
+  while (lua_next(L, 1)) {
+    lua_pop(L, 1);  /* remove value */
+    if (lua_type(L, -1) == LUA_TNUMBER) {
+      lua_Number v = lua_tonumber(L, -1);
+      if (v > max) max = v;
+    }
+  }
+  lua_pushnumber(L, max);
+  return 1;
+}
+#endif
+
+
+static int tinsert (lua_State *L) {
+  int e = aux_getn(L, 1) + 1;  /* first empty element */
+  int pos;  /* where to insert new element */
+  switch (lua_gettop(L)) {
+    case 2: {  /* called with only 2 arguments */
+      pos = e;  /* insert new element at the end */
+      break;
+    }
+    case 3: {
+      int i;
+      pos = luaL_checkint(L, 2);  /* 2nd argument is the position */
+      if (pos > e) e = pos;  /* `grow' array if necessary */
+      for (i = e; i > pos; i--) {  /* move up elements */
+        lua_rawgeti(L, 1, i-1);
+        lua_rawseti(L, 1, i);  /* t[i] = t[i-1] */
+      }
+      break;
+    }
+    default: {
+      return luaL_error(L, "wrong number of arguments to " LUA_QL("insert"));
+    }
+  }
+  lua_rawseti(L, 1, pos);  /* t[pos] = v */
+  return 0;
+}
+
+
+static int tremove (lua_State *L) {
+  int e = aux_getn(L, 1);
+  int pos = luaL_optint(L, 2, e);
+  if (!(1 <= pos && pos <= e))  /* position is outside bounds? */
+    return 0;  /* nothing to remove */
+  lua_rawgeti(L, 1, pos);  /* result = t[pos] */
+  for ( ;pos<e; pos++) {
+    lua_rawgeti(L, 1, pos+1);
+    lua_rawseti(L, 1, pos);  /* t[pos] = t[pos+1] */
+  }
+  lua_pushnil(L);
+  lua_rawseti(L, 1, e);  /* t[e] = nil */
+  return 1;
+}
+
+
+static void addfield (lua_State *L, luaL_Buffer *b, int i) {
+  lua_rawgeti(L, 1, i);
+  if (!lua_isstring(L, -1))
+    luaL_error(L, "invalid value (%s) at index %d in table for "
+                  LUA_QL("concat"), luaL_typename(L, -1), i);
+  luaL_addvalue(b);
+}
+
+
+static int tconcat (lua_State *L) {
+  luaL_Buffer b;
+  size_t lsep;
+  int i, last;
+  const char *sep = luaL_optlstring(L, 2, "", &lsep);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  i = luaL_optint(L, 3, 1);
+  last = luaL_opt(L, luaL_checkint, 4, luaL_len(L, 1));
+  luaL_buffinit(L, &b);
+  for (; i < last; i++) {
+    addfield(L, &b, i);
+    luaL_addlstring(&b, sep, lsep);
+  }
+  if (i == last)  /* add last value (if interval was not empty) */
+    addfield(L, &b, i);
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** Pack/unpack
+** =======================================================
+*/
+
+static int pack (lua_State *L) {
+  int n = lua_gettop(L);  /* number of elements to pack */
+  lua_createtable(L, n, 1);  /* create result table */
+  lua_pushinteger(L, n);
+  lua_setfield(L, -2, "n");  /* t.n = number of elements */
+  if (n > 0) {  /* at least one element? */
+    int i;
+    lua_pushvalue(L, 1);
+    lua_rawseti(L, -2, 1);  /* insert first element */
+    lua_replace(L, 1);  /* move table into index 1 */
+    for (i = n; i >= 2; i--)  /* assign other elements */
+      lua_rawseti(L, 1, i);
+  }
+  return 1;  /* return table */
+}
+
+
+static int unpack (lua_State *L) {
+  int i, e, n;
+  luaL_checktype(L, 1, LUA_TTABLE);
+  i = luaL_optint(L, 2, 1);
+  e = luaL_opt(L, luaL_checkint, 3, luaL_len(L, 1));
+  if (i > e) return 0;  /* empty range */
+  n = e - i + 1;  /* number of elements */
+  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */
+    return luaL_error(L, "too many results to unpack");
+  lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */
+  while (i++ < e)  /* push arg[i + 1...e] */
+    lua_rawgeti(L, 1, i);
+  return n;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Quicksort
+** (based on `Algorithms in MODULA-3', Robert Sedgewick;
+**  Addison-Wesley, 1993.)
+** =======================================================
+*/
+
+
+static void set2 (lua_State *L, int i, int j) {
+  lua_rawseti(L, 1, i);
+  lua_rawseti(L, 1, j);
+}
+
+static int sort_comp (lua_State *L, int a, int b) {
+  if (!lua_isnil(L, 2)) {  /* function? */
+    int res;
+    lua_pushvalue(L, 2);
+    lua_pushvalue(L, a-1);  /* -1 to compensate function */
+    lua_pushvalue(L, b-2);  /* -2 to compensate function and `a' */
+    lua_call(L, 2, 1);
+    res = lua_toboolean(L, -1);
+    lua_pop(L, 1);
+    return res;
+  }
+  else  /* a < b? */
+    return lua_compare(L, a, b, LUA_OPLT);
+}
+
+static void auxsort (lua_State *L, int l, int u) {
+  while (l < u) {  /* for tail recursion */
+    int i, j;
+    /* sort elements a[l], a[(l+u)/2] and a[u] */
+    lua_rawgeti(L, 1, l);
+    lua_rawgeti(L, 1, u);
+    if (sort_comp(L, -1, -2))  /* a[u] < a[l]? */
+      set2(L, l, u);  /* swap a[l] - a[u] */
+    else
+      lua_pop(L, 2);
+    if (u-l == 1) break;  /* only 2 elements */
+    i = (l+u)/2;
+    lua_rawgeti(L, 1, i);
+    lua_rawgeti(L, 1, l);
+    if (sort_comp(L, -2, -1))  /* a[i]<a[l]? */
+      set2(L, i, l);
+    else {
+      lua_pop(L, 1);  /* remove a[l] */
+      lua_rawgeti(L, 1, u);
+      if (sort_comp(L, -1, -2))  /* a[u]<a[i]? */
+        set2(L, i, u);
+      else
+        lua_pop(L, 2);
+    }
+    if (u-l == 2) break;  /* only 3 elements */
+    lua_rawgeti(L, 1, i);  /* Pivot */
+    lua_pushvalue(L, -1);
+    lua_rawgeti(L, 1, u-1);
+    set2(L, i, u-1);
+    /* a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2 */
+    i = l; j = u-1;
+    for (;;) {  /* invariant: a[l..i] <= P <= a[j..u] */
+      /* repeat ++i until a[i] >= P */
+      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
+        if (i>=u) luaL_error(L, "invalid order function for sorting");
+        lua_pop(L, 1);  /* remove a[i] */
+      }
+      /* repeat --j until a[j] <= P */
+      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
+        if (j<=l) luaL_error(L, "invalid order function for sorting");
+        lua_pop(L, 1);  /* remove a[j] */
+      }
+      if (j<i) {
+        lua_pop(L, 3);  /* pop pivot, a[i], a[j] */
+        break;
+      }
+      set2(L, i, j);
+    }
+    lua_rawgeti(L, 1, u-1);
+    lua_rawgeti(L, 1, i);
+    set2(L, u-1, i);  /* swap pivot (a[u-1]) with a[i] */
+    /* a[l..i-1] <= a[i] == P <= a[i+1..u] */
+    /* adjust so that smaller half is in [j..i] and larger one in [l..u] */
+    if (i-l < u-i) {
+      j=l; i=i-1; l=i+2;
+    }
+    else {
+      j=i+1; i=u; u=j-2;
+    }
+    auxsort(L, j, i);  /* call recursively the smaller one */
+  }  /* repeat the routine for the larger one */
+}
+
+static int sort (lua_State *L) {
+  int n = aux_getn(L, 1);
+  luaL_checkstack(L, 40, "");  /* assume array is smaller than 2^40 */
+  if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
+    luaL_checktype(L, 2, LUA_TFUNCTION);
+  lua_settop(L, 2);  /* make sure there is two arguments */
+  auxsort(L, 1, n);
+  return 0;
+}
+
+/* }====================================================== */
+
+
+static const luaL_Reg tab_funcs[] = {
+  {"concat", tconcat},
+#if defined(LUA_COMPAT_MAXN)
+  {"maxn", maxn},
+#endif
+  {"insert", tinsert},
+  {"pack", pack},
+  {"unpack", unpack},
+  {"remove", tremove},
+  {"sort", sort},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_table (lua_State *L) {
+  luaL_newlib(L, tab_funcs);
+#if defined(LUA_COMPAT_UNPACK)
+  /* _G.unpack = table.unpack */
+  lua_getfield(L, -1, "unpack");
+  lua_setglobal(L, "unpack");
+#endif
+  return 1;
+}
+
diff --git a/dep/lualib/ltm.c b/dep/lualib/ltm.c
new file mode 100644
index 0000000..e70006d
--- /dev/null
+++ b/dep/lualib/ltm.c
@@ -0,0 +1,77 @@
+/*
+** $Id: ltm.c,v 2.14 2011/06/02 19:31:40 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define ltm_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+static const char udatatypename[] = "userdata";
+
+LUAI_DDEF const char *const luaT_typenames_[LUA_TOTALTAGS] = {
+  "no value",
+  "nil", "boolean", udatatypename, "number",
+  "string", "table", "function", udatatypename, "thread",
+  "proto", "upval"  /* these last two cases are used for tests only */
+};
+
+
+void luaT_init (lua_State *L) {
+  static const char *const luaT_eventname[] = {  /* ORDER TM */
+    "__index", "__newindex",
+    "__gc", "__mode", "__len", "__eq",
+    "__add", "__sub", "__mul", "__div", "__mod",
+    "__pow", "__unm", "__lt", "__le",
+    "__concat", "__call"
+  };
+  int i;
+  for (i=0; i<TM_N; i++) {
+    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
+    luaS_fix(G(L)->tmname[i]);  /* never collect these names */
+  }
+}
+
+
+/*
+** function to be used with macro "fasttm": optimized for absence of
+** tag methods
+*/
+const TValue *luaT_gettm (Table *events, TMS event, TString *ename) {
+  const TValue *tm = luaH_getstr(events, ename);
+  lua_assert(event <= TM_EQ);
+  if (ttisnil(tm)) {  /* no tag method? */
+    events->flags |= cast_byte(1u<<event);  /* cache this fact */
+    return NULL;
+  }
+  else return tm;
+}
+
+
+const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {
+  Table *mt;
+  switch (ttypenv(o)) {
+    case LUA_TTABLE:
+      mt = hvalue(o)->metatable;
+      break;
+    case LUA_TUSERDATA:
+      mt = uvalue(o)->metatable;
+      break;
+    default:
+      mt = G(L)->mt[ttypenv(o)];
+  }
+  return (mt ? luaH_getstr(mt, G(L)->tmname[event]) : luaO_nilobject);
+}
+
diff --git a/dep/lualib/ltm.h b/dep/lualib/ltm.h
new file mode 100644
index 0000000..89bdc19
--- /dev/null
+++ b/dep/lualib/ltm.h
@@ -0,0 +1,57 @@
+/*
+** $Id: ltm.h,v 2.11 2011/02/28 17:32:10 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltm_h
+#define ltm_h
+
+
+#include "lobject.h"
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep "ORDER TM"
+*/
+typedef enum {
+  TM_INDEX,
+  TM_NEWINDEX,
+  TM_GC,
+  TM_MODE,
+  TM_LEN,
+  TM_EQ,  /* last tag method with `fast' access */
+  TM_ADD,
+  TM_SUB,
+  TM_MUL,
+  TM_DIV,
+  TM_MOD,
+  TM_POW,
+  TM_UNM,
+  TM_LT,
+  TM_LE,
+  TM_CONCAT,
+  TM_CALL,
+  TM_N		/* number of elements in the enum */
+} TMS;
+
+
+
+#define gfasttm(g,et,e) ((et) == NULL ? NULL : \
+  ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
+
+#define fasttm(l,et,e)	gfasttm(G(l), et, e)
+
+#define ttypename(x)	luaT_typenames_[(x) + 1]
+#define objtypename(x)	ttypename(ttypenv(x))
+
+LUAI_DDEC const char *const luaT_typenames_[LUA_TOTALTAGS];
+
+
+LUAI_FUNC const TValue *luaT_gettm (Table *events, TMS event, TString *ename);
+LUAI_FUNC const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o,
+                                                       TMS event);
+LUAI_FUNC void luaT_init (lua_State *L);
+
+#endif
diff --git a/dep/lualib/lua.c b/dep/lualib/lua.c
new file mode 100644
index 0000000..7614c70
--- /dev/null
+++ b/dep/lualib/lua.c
@@ -0,0 +1,496 @@
+/*
+** $Id: lua.c,v 1.205 2012/05/23 15:37:09 roberto Exp $
+** Lua stand-alone interpreter
+** See Copyright Notice in lua.h
+*/
+
+
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lua_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#if !defined(LUA_PROMPT)
+#define LUA_PROMPT		"> "
+#define LUA_PROMPT2		">> "
+#endif
+
+#if !defined(LUA_PROGNAME)
+#define LUA_PROGNAME		"lua"
+#endif
+
+#if !defined(LUA_MAXINPUT)
+#define LUA_MAXINPUT		512
+#endif
+
+#if !defined(LUA_INIT)
+#define LUA_INIT		"LUA_INIT"
+#endif
+
+#define LUA_INITVERSION  \
+	LUA_INIT "_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR
+
+
+/*
+** lua_stdin_is_tty detects whether the standard input is a 'tty' (that
+** is, whether we're running lua interactively).
+*/
+#if defined(LUA_USE_ISATTY)
+#include <unistd.h>
+#define lua_stdin_is_tty()	isatty(0)
+#elif defined(LUA_WIN)
+#include <io.h>
+#include <stdio.h>
+#define lua_stdin_is_tty()	_isatty(_fileno(stdin))
+#else
+#define lua_stdin_is_tty()	1  /* assume stdin is a tty */
+#endif
+
+
+/*
+** lua_readline defines how to show a prompt and then read a line from
+** the standard input.
+** lua_saveline defines how to "save" a read line in a "history".
+** lua_freeline defines how to free a line read by lua_readline.
+*/
+#if defined(LUA_USE_READLINE)
+
+#include <stdio.h>
+#include <readline/readline.h>
+#include <readline/history.h>
+#define lua_readline(L,b,p)	((void)L, ((b)=readline(p)) != NULL)
+#define lua_saveline(L,idx) \
+        if (lua_rawlen(L,idx) > 0)  /* non-empty line? */ \
+          add_history(lua_tostring(L, idx));  /* add it to history */
+#define lua_freeline(L,b)	((void)L, free(b))
+
+#elif !defined(lua_readline)
+
+#define lua_readline(L,b,p) \
+        ((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
+        fgets(b, LUA_MAXINPUT, stdin) != NULL)  /* get line */
+#define lua_saveline(L,idx)	{ (void)L; (void)idx; }
+#define lua_freeline(L,b)	{ (void)L; (void)b; }
+
+#endif
+
+
+
+
+static lua_State *globalL = NULL;
+
+static const char *progname = LUA_PROGNAME;
+
+
+
+static void lstop (lua_State *L, lua_Debug *ar) {
+  (void)ar;  /* unused arg. */
+  lua_sethook(L, NULL, 0, 0);
+  luaL_error(L, "interrupted!");
+}
+
+
+static void laction (int i) {
+  signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
+                              terminate process (default action) */
+  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
+}
+
+
+static void print_usage (const char *badoption) {
+  luai_writestringerror("%s: ", progname);
+  if (badoption[1] == 'e' || badoption[1] == 'l')
+    luai_writestringerror("'%s' needs argument\n", badoption);
+  else
+    luai_writestringerror("unrecognized option '%s'\n", badoption);
+  luai_writestringerror(
+  "usage: %s [options] [script [args]]\n"
+  "Available options are:\n"
+  "  -e stat  execute string " LUA_QL("stat") "\n"
+  "  -i       enter interactive mode after executing " LUA_QL("script") "\n"
+  "  -l name  require library " LUA_QL("name") "\n"
+  "  -v       show version information\n"
+  "  -E       ignore environment variables\n"
+  "  --       stop handling options\n"
+  "  -        stop handling options and execute stdin\n"
+  ,
+  progname);
+}
+
+
+static void l_message (const char *pname, const char *msg) {
+  if (pname) luai_writestringerror("%s: ", pname);
+  luai_writestringerror("%s\n", msg);
+}
+
+
+static int report (lua_State *L, int status) {
+  if (status != LUA_OK && !lua_isnil(L, -1)) {
+    const char *msg = lua_tostring(L, -1);
+    if (msg == NULL) msg = "(error object is not a string)";
+    l_message(progname, msg);
+    lua_pop(L, 1);
+    /* force a complete garbage collection in case of errors */
+    lua_gc(L, LUA_GCCOLLECT, 0);
+  }
+  return status;
+}
+
+
+/* the next function is called unprotected, so it must avoid errors */
+static void finalreport (lua_State *L, int status) {
+  if (status != LUA_OK) {
+    const char *msg = (lua_type(L, -1) == LUA_TSTRING) ? lua_tostring(L, -1)
+                                                       : NULL;
+    if (msg == NULL) msg = "(error object is not a string)";
+    l_message(progname, msg);
+    lua_pop(L, 1);
+  }
+}
+
+
+static int traceback (lua_State *L) {
+  const char *msg = lua_tostring(L, 1);
+  if (msg)
+    luaL_traceback(L, L, msg, 1);
+  else if (!lua_isnoneornil(L, 1)) {  /* is there an error object? */
+    if (!luaL_callmeta(L, 1, "__tostring"))  /* try its 'tostring' metamethod */
+      lua_pushliteral(L, "(no error message)");
+  }
+  return 1;
+}
+
+
+static int docall (lua_State *L, int narg, int nres) {
+  int status;
+  int base = lua_gettop(L) - narg;  /* function index */
+  lua_pushcfunction(L, traceback);  /* push traceback function */
+  lua_insert(L, base);  /* put it under chunk and args */
+  globalL = L;  /* to be available to 'laction' */
+  signal(SIGINT, laction);
+  status = lua_pcall(L, narg, nres, base);
+  signal(SIGINT, SIG_DFL);
+  lua_remove(L, base);  /* remove traceback function */
+  return status;
+}
+
+
+static void print_version (void) {
+  luai_writestring(LUA_COPYRIGHT, strlen(LUA_COPYRIGHT));
+  luai_writeline();
+}
+
+
+static int getargs (lua_State *L, char **argv, int n) {
+  int narg;
+  int i;
+  int argc = 0;
+  while (argv[argc]) argc++;  /* count total number of arguments */
+  narg = argc - (n + 1);  /* number of arguments to the script */
+  luaL_checkstack(L, narg + 3, "too many arguments to script");
+  for (i=n+1; i < argc; i++)
+    lua_pushstring(L, argv[i]);
+  lua_createtable(L, narg, n + 1);
+  for (i=0; i < argc; i++) {
+    lua_pushstring(L, argv[i]);
+    lua_rawseti(L, -2, i - n);
+  }
+  return narg;
+}
+
+
+static int dofile (lua_State *L, const char *name) {
+  int status = luaL_loadfile(L, name);
+  if (status == LUA_OK) status = docall(L, 0, 0);
+  return report(L, status);
+}
+
+
+static int dostring (lua_State *L, const char *s, const char *name) {
+  int status = luaL_loadbuffer(L, s, strlen(s), name);
+  if (status == LUA_OK) status = docall(L, 0, 0);
+  return report(L, status);
+}
+
+
+static int dolibrary (lua_State *L, const char *name) {
+  int status;
+  lua_getglobal(L, "require");
+  lua_pushstring(L, name);
+  status = docall(L, 1, 1);  /* call 'require(name)' */
+  if (status == LUA_OK)
+    lua_setglobal(L, name);  /* global[name] = require return */
+  return report(L, status);
+}
+
+
+static const char *get_prompt (lua_State *L, int firstline) {
+  const char *p;
+  lua_getglobal(L, firstline ? "_PROMPT" : "_PROMPT2");
+  p = lua_tostring(L, -1);
+  if (p == NULL) p = (firstline ? LUA_PROMPT : LUA_PROMPT2);
+  lua_pop(L, 1);  /* remove global */
+  return p;
+}
+
+/* mark in error messages for incomplete statements */
+#define EOFMARK		"<eof>"
+#define marklen		(sizeof(EOFMARK)/sizeof(char) - 1)
+
+static int incomplete (lua_State *L, int status) {
+  if (status == LUA_ERRSYNTAX) {
+    size_t lmsg;
+    const char *msg = lua_tolstring(L, -1, &lmsg);
+    if (lmsg >= marklen && strcmp(msg + lmsg - marklen, EOFMARK) == 0) {
+      lua_pop(L, 1);
+      return 1;
+    }
+  }
+  return 0;  /* else... */
+}
+
+
+static int pushline (lua_State *L, int firstline) {
+  char buffer[LUA_MAXINPUT];
+  char *b = buffer;
+  size_t l;
+  const char *prmt = get_prompt(L, firstline);
+  if (lua_readline(L, b, prmt) == 0)
+    return 0;  /* no input */
+  l = strlen(b);
+  if (l > 0 && b[l-1] == '\n')  /* line ends with newline? */
+    b[l-1] = '\0';  /* remove it */
+  if (firstline && b[0] == '=')  /* first line starts with `=' ? */
+    lua_pushfstring(L, "return %s", b+1);  /* change it to `return' */
+  else
+    lua_pushstring(L, b);
+  lua_freeline(L, b);
+  return 1;
+}
+
+
+static int loadline (lua_State *L) {
+  int status;
+  lua_settop(L, 0);
+  if (!pushline(L, 1))
+    return -1;  /* no input */
+  for (;;) {  /* repeat until gets a complete line */
+    size_t l;
+    const char *line = lua_tolstring(L, 1, &l);
+    status = luaL_loadbuffer(L, line, l, "=stdin");
+    if (!incomplete(L, status)) break;  /* cannot try to add lines? */
+    if (!pushline(L, 0))  /* no more input? */
+      return -1;
+    lua_pushliteral(L, "\n");  /* add a new line... */
+    lua_insert(L, -2);  /* ...between the two lines */
+    lua_concat(L, 3);  /* join them */
+  }
+  lua_saveline(L, 1);
+  lua_remove(L, 1);  /* remove line */
+  return status;
+}
+
+
+static void dotty (lua_State *L) {
+  int status;
+  const char *oldprogname = progname;
+  progname = NULL;
+  while ((status = loadline(L)) != -1) {
+    if (status == LUA_OK) status = docall(L, 0, LUA_MULTRET);
+    report(L, status);
+    if (status == LUA_OK && lua_gettop(L) > 0) {  /* any result to print? */
+      luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
+      lua_getglobal(L, "print");
+      lua_insert(L, 1);
+      if (lua_pcall(L, lua_gettop(L)-1, 0, 0) != LUA_OK)
+        l_message(progname, lua_pushfstring(L,
+                               "error calling " LUA_QL("print") " (%s)",
+                               lua_tostring(L, -1)));
+    }
+  }
+  lua_settop(L, 0);  /* clear stack */
+  luai_writeline();
+  progname = oldprogname;
+}
+
+
+static int handle_script (lua_State *L, char **argv, int n) {
+  int status;
+  const char *fname;
+  int narg = getargs(L, argv, n);  /* collect arguments */
+  lua_setglobal(L, "arg");
+  fname = argv[n];
+  if (strcmp(fname, "-") == 0 && strcmp(argv[n-1], "--") != 0)
+    fname = NULL;  /* stdin */
+  status = luaL_loadfile(L, fname);
+  lua_insert(L, -(narg+1));
+  if (status == LUA_OK)
+    status = docall(L, narg, LUA_MULTRET);
+  else
+    lua_pop(L, narg);
+  return report(L, status);
+}
+
+
+/* check that argument has no extra characters at the end */
+#define noextrachars(x)		{if ((x)[2] != '\0') return -1;}
+
+
+/* indices of various argument indicators in array args */
+#define has_i		0	/* -i */
+#define has_v		1	/* -v */
+#define has_e		2	/* -e */
+#define has_E		3	/* -E */
+
+#define num_has		4	/* number of 'has_*' */
+
+
+static int collectargs (char **argv, int *args) {
+  int i;
+  for (i = 1; argv[i] != NULL; i++) {
+    if (argv[i][0] != '-')  /* not an option? */
+        return i;
+    switch (argv[i][1]) {  /* option */
+      case '-':
+        noextrachars(argv[i]);
+        return (argv[i+1] != NULL ? i+1 : 0);
+      case '\0':
+        return i;
+      case 'E':
+        args[has_E] = 1;
+        break;
+      case 'i':
+        noextrachars(argv[i]);
+        args[has_i] = 1;  /* go through */
+      case 'v':
+        noextrachars(argv[i]);
+        args[has_v] = 1;
+        break;
+      case 'e':
+        args[has_e] = 1;  /* go through */
+      case 'l':  /* both options need an argument */
+        if (argv[i][2] == '\0') {  /* no concatenated argument? */
+          i++;  /* try next 'argv' */
+          if (argv[i] == NULL || argv[i][0] == '-')
+            return -(i - 1);  /* no next argument or it is another option */
+        }
+        break;
+      default:  /* invalid option; return its index... */
+        return -i;  /* ...as a negative value */
+    }
+  }
+  return 0;
+}
+
+
+static int runargs (lua_State *L, char **argv, int n) {
+  int i;
+  for (i = 1; i < n; i++) {
+    lua_assert(argv[i][0] == '-');
+    switch (argv[i][1]) {  /* option */
+      case 'e': {
+        const char *chunk = argv[i] + 2;
+        if (*chunk == '\0') chunk = argv[++i];
+        lua_assert(chunk != NULL);
+        if (dostring(L, chunk, "=(command line)") != LUA_OK)
+          return 0;
+        break;
+      }
+      case 'l': {
+        const char *filename = argv[i] + 2;
+        if (*filename == '\0') filename = argv[++i];
+        lua_assert(filename != NULL);
+        if (dolibrary(L, filename) != LUA_OK)
+          return 0;  /* stop if file fails */
+        break;
+      }
+      default: break;
+    }
+  }
+  return 1;
+}
+
+
+static int handle_luainit (lua_State *L) {
+  const char *name = "=" LUA_INITVERSION;
+  const char *init = getenv(name + 1);
+  if (init == NULL) {
+    name = "=" LUA_INIT;
+    init = getenv(name + 1);  /* try alternative name */
+  }
+  if (init == NULL) return LUA_OK;
+  else if (init[0] == '@')
+    return dofile(L, init+1);
+  else
+    return dostring(L, init, name);
+}
+
+
+static int pmain (lua_State *L) {
+  int argc = (int)lua_tointeger(L, 1);
+  char **argv = (char **)lua_touserdata(L, 2);
+  int script;
+  int args[num_has];
+  args[has_i] = args[has_v] = args[has_e] = args[has_E] = 0;
+  if (argv[0] && argv[0][0]) progname = argv[0];
+  script = collectargs(argv, args);
+  if (script < 0) {  /* invalid arg? */
+    print_usage(argv[-script]);
+    return 0;
+  }
+  if (args[has_v]) print_version();
+  if (args[has_E]) {  /* option '-E'? */
+    lua_pushboolean(L, 1);  /* signal for libraries to ignore env. vars. */
+    lua_setfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
+  }
+  /* open standard libraries */
+  luaL_checkversion(L);
+  lua_gc(L, LUA_GCSTOP, 0);  /* stop collector during initialization */
+  luaL_openlibs(L);  /* open libraries */
+  lua_gc(L, LUA_GCRESTART, 0);
+  if (!args[has_E] && handle_luainit(L) != LUA_OK)
+    return 0;  /* error running LUA_INIT */
+  /* execute arguments -e and -l */
+  if (!runargs(L, argv, (script > 0) ? script : argc)) return 0;
+  /* execute main script (if there is one) */
+  if (script && handle_script(L, argv, script) != LUA_OK) return 0;
+  if (args[has_i])  /* -i option? */
+    dotty(L);
+  else if (script == 0 && !args[has_e] && !args[has_v]) {  /* no arguments? */
+    if (lua_stdin_is_tty()) {
+      print_version();
+      dotty(L);
+    }
+    else dofile(L, NULL);  /* executes stdin as a file */
+  }
+  lua_pushboolean(L, 1);  /* signal no errors */
+  return 1;
+}
+
+
+int main (int argc, char **argv) {
+  int status, result;
+  lua_State *L = luaL_newstate();  /* create state */
+  if (L == NULL) {
+    l_message(argv[0], "cannot create state: not enough memory");
+    return EXIT_FAILURE;
+  }
+  /* call 'pmain' in protected mode */
+  lua_pushcfunction(L, &pmain);
+  lua_pushinteger(L, argc);  /* 1st argument */
+  lua_pushlightuserdata(L, argv); /* 2nd argument */
+  status = lua_pcall(L, 2, 1, 0);
+  result = lua_toboolean(L, -1);  /* get result */
+  finalreport(L, status);
+  lua_close(L);
+  return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
diff --git a/dep/lualib/lua.h b/dep/lualib/lua.h
new file mode 100644
index 0000000..5c88fd2
--- /dev/null
+++ b/dep/lualib/lua.h
@@ -0,0 +1,442 @@
+/*
+** $Id: lua.h,v 1.283 2012/04/20 13:18:26 roberto Exp $
+** Lua - A Scripting Language
+** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
+** See Copyright Notice at the end of this file
+*/
+
+
+#ifndef lua_h
+#define lua_h
+
+#include <stdarg.h>
+#include <stddef.h>
+
+
+#include "luaconf.h"
+
+
+#define LUA_VERSION_MAJOR	"5"
+#define LUA_VERSION_MINOR	"2"
+#define LUA_VERSION_NUM		502
+#define LUA_VERSION_RELEASE	"1"
+
+#define LUA_VERSION	"Lua " LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
+#define LUA_RELEASE	LUA_VERSION "." LUA_VERSION_RELEASE
+#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2012 Lua.org, PUC-Rio"
+#define LUA_AUTHORS	"R. Ierusalimschy, L. H. de Figueiredo, W. Celes"
+
+
+/* mark for precompiled code ('<esc>Lua') */
+#define LUA_SIGNATURE	"\033Lua"
+
+/* option for multiple returns in 'lua_pcall' and 'lua_call' */
+#define LUA_MULTRET	(-1)
+
+
+/*
+** pseudo-indices
+*/
+#define LUA_REGISTRYINDEX	LUAI_FIRSTPSEUDOIDX
+#define lua_upvalueindex(i)	(LUA_REGISTRYINDEX - (i))
+
+
+/* thread status */
+#define LUA_OK		0
+#define LUA_YIELD	1
+#define LUA_ERRRUN	2
+#define LUA_ERRSYNTAX	3
+#define LUA_ERRMEM	4
+#define LUA_ERRGCMM	5
+#define LUA_ERRERR	6
+
+
+typedef struct lua_State lua_State;
+
+typedef int (*lua_CFunction) (lua_State *L);
+
+
+/*
+** functions that read/write blocks when loading/dumping Lua chunks
+*/
+typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);
+
+typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);
+
+
+/*
+** prototype for memory-allocation functions
+*/
+typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
+
+
+/*
+** basic types
+*/
+#define LUA_TNONE		(-1)
+
+#define LUA_TNIL		0
+#define LUA_TBOOLEAN		1
+#define LUA_TLIGHTUSERDATA	2
+#define LUA_TNUMBER		3
+#define LUA_TSTRING		4
+#define LUA_TTABLE		5
+#define LUA_TFUNCTION		6
+#define LUA_TUSERDATA		7
+#define LUA_TTHREAD		8
+
+#define LUA_NUMTAGS		9
+
+
+
+/* minimum Lua stack available to a C function */
+#define LUA_MINSTACK	20
+
+
+/* predefined values in the registry */
+#define LUA_RIDX_MAINTHREAD	1
+#define LUA_RIDX_GLOBALS	2
+#define LUA_RIDX_LAST		LUA_RIDX_GLOBALS
+
+
+/* type of numbers in Lua */
+typedef LUA_NUMBER lua_Number;
+
+
+/* type for integer functions */
+typedef LUA_INTEGER lua_Integer;
+
+/* unsigned integer type */
+typedef LUA_UNSIGNED lua_Unsigned;
+
+
+
+/*
+** generic extra include file
+*/
+#if defined(LUA_USER_H)
+#include LUA_USER_H
+#endif
+
+
+
+/*
+** state manipulation
+*/
+LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
+LUA_API void       (lua_close) (lua_State *L);
+LUA_API lua_State *(lua_newthread) (lua_State *L);
+
+LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);
+
+
+LUA_API const lua_Number *(lua_version) (lua_State *L);
+
+
+/*
+** basic stack manipulation
+*/
+LUA_API int   (lua_absindex) (lua_State *L, int idx);
+LUA_API int   (lua_gettop) (lua_State *L);
+LUA_API void  (lua_settop) (lua_State *L, int idx);
+LUA_API void  (lua_pushvalue) (lua_State *L, int idx);
+LUA_API void  (lua_remove) (lua_State *L, int idx);
+LUA_API void  (lua_insert) (lua_State *L, int idx);
+LUA_API void  (lua_replace) (lua_State *L, int idx);
+LUA_API void  (lua_copy) (lua_State *L, int fromidx, int toidx);
+LUA_API int   (lua_checkstack) (lua_State *L, int sz);
+
+LUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API int             (lua_isnumber) (lua_State *L, int idx);
+LUA_API int             (lua_isstring) (lua_State *L, int idx);
+LUA_API int             (lua_iscfunction) (lua_State *L, int idx);
+LUA_API int             (lua_isuserdata) (lua_State *L, int idx);
+LUA_API int             (lua_type) (lua_State *L, int idx);
+LUA_API const char     *(lua_typename) (lua_State *L, int tp);
+
+LUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);
+LUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);
+LUA_API lua_Unsigned    (lua_tounsignedx) (lua_State *L, int idx, int *isnum);
+LUA_API int             (lua_toboolean) (lua_State *L, int idx);
+LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);
+LUA_API size_t          (lua_rawlen) (lua_State *L, int idx);
+LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);
+LUA_API void	       *(lua_touserdata) (lua_State *L, int idx);
+LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);
+LUA_API const void     *(lua_topointer) (lua_State *L, int idx);
+
+
+/*
+** Comparison and arithmetic functions
+*/
+
+#define LUA_OPADD	0	/* ORDER TM */
+#define LUA_OPSUB	1
+#define LUA_OPMUL	2
+#define LUA_OPDIV	3
+#define LUA_OPMOD	4
+#define LUA_OPPOW	5
+#define LUA_OPUNM	6
+
+LUA_API void  (lua_arith) (lua_State *L, int op);
+
+#define LUA_OPEQ	0
+#define LUA_OPLT	1
+#define LUA_OPLE	2
+
+LUA_API int   (lua_rawequal) (lua_State *L, int idx1, int idx2);
+LUA_API int   (lua_compare) (lua_State *L, int idx1, int idx2, int op);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void        (lua_pushnil) (lua_State *L);
+LUA_API void        (lua_pushnumber) (lua_State *L, lua_Number n);
+LUA_API void        (lua_pushinteger) (lua_State *L, lua_Integer n);
+LUA_API void        (lua_pushunsigned) (lua_State *L, lua_Unsigned n);
+LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t l);
+LUA_API const char *(lua_pushstring) (lua_State *L, const char *s);
+LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
+                                                      va_list argp);
+LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
+LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
+LUA_API void  (lua_pushboolean) (lua_State *L, int b);
+LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
+LUA_API int   (lua_pushthread) (lua_State *L);
+
+
+/*
+** get functions (Lua -> stack)
+*/
+LUA_API void  (lua_getglobal) (lua_State *L, const char *var);
+LUA_API void  (lua_gettable) (lua_State *L, int idx);
+LUA_API void  (lua_getfield) (lua_State *L, int idx, const char *k);
+LUA_API void  (lua_rawget) (lua_State *L, int idx);
+LUA_API void  (lua_rawgeti) (lua_State *L, int idx, int n);
+LUA_API void  (lua_rawgetp) (lua_State *L, int idx, const void *p);
+LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);
+LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);
+LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);
+LUA_API void  (lua_getuservalue) (lua_State *L, int idx);
+
+
+/*
+** set functions (stack -> Lua)
+*/
+LUA_API void  (lua_setglobal) (lua_State *L, const char *var);
+LUA_API void  (lua_settable) (lua_State *L, int idx);
+LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);
+LUA_API void  (lua_rawset) (lua_State *L, int idx);
+LUA_API void  (lua_rawseti) (lua_State *L, int idx, int n);
+LUA_API void  (lua_rawsetp) (lua_State *L, int idx, const void *p);
+LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);
+LUA_API void  (lua_setuservalue) (lua_State *L, int idx);
+
+
+/*
+** 'load' and 'call' functions (load and run Lua code)
+*/
+LUA_API void  (lua_callk) (lua_State *L, int nargs, int nresults, int ctx,
+                           lua_CFunction k);
+#define lua_call(L,n,r)		lua_callk(L, (n), (r), 0, NULL)
+
+LUA_API int   (lua_getctx) (lua_State *L, int *ctx);
+
+LUA_API int   (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc,
+                            int ctx, lua_CFunction k);
+#define lua_pcall(L,n,r,f)	lua_pcallk(L, (n), (r), (f), 0, NULL)
+
+LUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,
+                                        const char *chunkname,
+                                        const char *mode);
+
+LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data);
+
+
+/*
+** coroutine functions
+*/
+LUA_API int  (lua_yieldk) (lua_State *L, int nresults, int ctx,
+                           lua_CFunction k);
+#define lua_yield(L,n)		lua_yieldk(L, (n), 0, NULL)
+LUA_API int  (lua_resume) (lua_State *L, lua_State *from, int narg);
+LUA_API int  (lua_status) (lua_State *L);
+
+/*
+** garbage-collection function and options
+*/
+
+#define LUA_GCSTOP		0
+#define LUA_GCRESTART		1
+#define LUA_GCCOLLECT		2
+#define LUA_GCCOUNT		3
+#define LUA_GCCOUNTB		4
+#define LUA_GCSTEP		5
+#define LUA_GCSETPAUSE		6
+#define LUA_GCSETSTEPMUL	7
+#define LUA_GCSETMAJORINC	8
+#define LUA_GCISRUNNING		9
+#define LUA_GCGEN		10
+#define LUA_GCINC		11
+
+LUA_API int (lua_gc) (lua_State *L, int what, int data);
+
+
+/*
+** miscellaneous functions
+*/
+
+LUA_API int   (lua_error) (lua_State *L);
+
+LUA_API int   (lua_next) (lua_State *L, int idx);
+
+LUA_API void  (lua_concat) (lua_State *L, int n);
+LUA_API void  (lua_len)    (lua_State *L, int idx);
+
+LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
+LUA_API void      (lua_setallocf) (lua_State *L, lua_Alloc f, void *ud);
+
+
+
+/*
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+#define lua_tonumber(L,i)	lua_tonumberx(L,i,NULL)
+#define lua_tointeger(L,i)	lua_tointegerx(L,i,NULL)
+#define lua_tounsigned(L,i)	lua_tounsignedx(L,i,NULL)
+
+#define lua_pop(L,n)		lua_settop(L, -(n)-1)
+
+#define lua_newtable(L)		lua_createtable(L, 0, 0)
+
+#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
+
+#define lua_pushcfunction(L,f)	lua_pushcclosure(L, (f), 0)
+
+#define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
+#define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
+#define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
+#define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
+#define lua_isboolean(L,n)	(lua_type(L, (n)) == LUA_TBOOLEAN)
+#define lua_isthread(L,n)	(lua_type(L, (n)) == LUA_TTHREAD)
+#define lua_isnone(L,n)		(lua_type(L, (n)) == LUA_TNONE)
+#define lua_isnoneornil(L, n)	(lua_type(L, (n)) <= 0)
+
+#define lua_ref(L, lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \
+    (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
+
+#define lua_pushliteral(L, s)	\
+	lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
+
+#define lua_pushglobaltable(L)  \
+	lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS)
+
+#define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)
+
+
+
+/*
+** {======================================================================
+** Debug API
+** =======================================================================
+*/
+
+
+/*
+** Event codes
+*/
+#define LUA_HOOKCALL	0
+#define LUA_HOOKRET	1
+#define LUA_HOOKLINE	2
+#define LUA_HOOKCOUNT	3
+#define LUA_HOOKTAILCALL 4
+
+
+/*
+** Event masks
+*/
+#define LUA_MASKCALL	(1 << LUA_HOOKCALL)
+#define LUA_MASKRET	(1 << LUA_HOOKRET)
+#define LUA_MASKLINE	(1 << LUA_HOOKLINE)
+#define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)
+
+typedef struct lua_Debug lua_Debug;  /* activation record */
+
+
+/* Functions to be called by the debugger in specific events */
+typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
+
+
+LUA_API int (lua_getstack) (lua_State *L, int level, lua_Debug *ar);
+LUA_API int (lua_getinfo) (lua_State *L, const char *what, lua_Debug *ar);
+LUA_API const char *(lua_getlocal) (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *(lua_setlocal) (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *(lua_getupvalue) (lua_State *L, int funcindex, int n);
+LUA_API const char *(lua_setupvalue) (lua_State *L, int funcindex, int n);
+
+LUA_API void *(lua_upvalueid) (lua_State *L, int fidx, int n);
+LUA_API void  (lua_upvaluejoin) (lua_State *L, int fidx1, int n1,
+                                               int fidx2, int n2);
+
+LUA_API int (lua_sethook) (lua_State *L, lua_Hook func, int mask, int count);
+LUA_API lua_Hook (lua_gethook) (lua_State *L);
+LUA_API int (lua_gethookmask) (lua_State *L);
+LUA_API int (lua_gethookcount) (lua_State *L);
+
+
+struct lua_Debug {
+  int event;
+  const char *name;	/* (n) */
+  const char *namewhat;	/* (n) 'global', 'local', 'field', 'method' */
+  const char *what;	/* (S) 'Lua', 'C', 'main', 'tail' */
+  const char *source;	/* (S) */
+  int currentline;	/* (l) */
+  int linedefined;	/* (S) */
+  int lastlinedefined;	/* (S) */
+  unsigned char nups;	/* (u) number of upvalues */
+  unsigned char nparams;/* (u) number of parameters */
+  char isvararg;        /* (u) */
+  char istailcall;	/* (t) */
+  char short_src[LUA_IDSIZE]; /* (S) */
+  /* private part */
+  struct CallInfo *i_ci;  /* active function */
+};
+
+/* }====================================================================== */
+
+
+/******************************************************************************
+* Copyright (C) 1994-2012 Lua.org, PUC-Rio.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* "Software"), to deal in the Software without restriction, including
+* without limitation the rights to use, copy, modify, merge, publish,
+* distribute, sublicense, and/or sell copies of the Software, and to
+* permit persons to whom the Software is furnished to do so, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be
+* included in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+******************************************************************************/
+
+
+#endif
diff --git a/dep/lualib/lua.hpp b/dep/lualib/lua.hpp
new file mode 100644
index 0000000..ec417f5
--- /dev/null
+++ b/dep/lualib/lua.hpp
@@ -0,0 +1,9 @@
+// lua.hpp
+// Lua header files for C++
+// <<extern "C">> not supplied automatically because Lua also compiles as C++
+
+extern "C" {
+#include "lua.h"
+#include "lualib.h"
+#include "lauxlib.h"
+}
diff --git a/dep/lualib/luaconf.h b/dep/lualib/luaconf.h
new file mode 100644
index 0000000..e4335df
--- /dev/null
+++ b/dep/lualib/luaconf.h
@@ -0,0 +1,546 @@
+/*
+** $Id: luaconf.h,v 1.172 2012/05/11 14:14:42 roberto Exp $
+** Configuration file for Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lconfig_h
+#define lconfig_h
+
+#include <limits.h>
+#include <stddef.h>
+
+
+/*
+** ==================================================================
+** Search for "@@" to find all configurable definitions.
+** ===================================================================
+*/
+
+
+/*
+@@ LUA_ANSI controls the use of non-ansi features.
+** CHANGE it (define it) if you want Lua to avoid the use of any
+** non-ansi feature or library.
+*/
+#if !defined(LUA_ANSI) && defined(__STRICT_ANSI__)
+#define LUA_ANSI
+#endif
+
+
+#if !defined(LUA_ANSI) && defined(_WIN32) && !defined(_WIN32_WCE)
+#define LUA_WIN		/* enable goodies for regular Windows platforms */
+#endif
+
+#if defined(LUA_WIN)
+#define LUA_DL_DLL
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#endif
+
+
+
+#if defined(LUA_USE_LINUX)
+#define LUA_USE_POSIX
+#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
+#define LUA_USE_READLINE	/* needs some extra libraries */
+#define LUA_USE_STRTODHEX	/* assume 'strtod' handles hexa formats */
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#define LUA_USE_LONGLONG	/* assume support for long long */
+#endif
+
+#if defined(LUA_USE_MACOSX)
+#define LUA_USE_POSIX
+#define LUA_USE_DLOPEN		/* does not need -ldl */
+#define LUA_USE_READLINE	/* needs an extra library: -lreadline */
+#define LUA_USE_STRTODHEX	/* assume 'strtod' handles hexa formats */
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#define LUA_USE_LONGLONG	/* assume support for long long */
+#endif
+
+
+
+/*
+@@ LUA_USE_POSIX includes all functionality listed as X/Open System
+@* Interfaces Extension (XSI).
+** CHANGE it (define it) if your system is XSI compatible.
+*/
+#if defined(LUA_USE_POSIX)
+#define LUA_USE_MKSTEMP
+#define LUA_USE_ISATTY
+#define LUA_USE_POPEN
+#define LUA_USE_ULONGJMP
+#define LUA_USE_GMTIME_R
+#endif
+
+
+
+/*
+@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
+@* Lua libraries.
+@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
+@* C libraries.
+** CHANGE them if your machine has a non-conventional directory
+** hierarchy or if you want to install your libraries in
+** non-conventional directories.
+*/
+#if defined(_WIN32)	/* { */
+/*
+** In Windows, any exclamation mark ('!') in the path is replaced by the
+** path of the directory of the executable file of the current process.
+*/
+#define LUA_LDIR	"!\\lua\\"
+#define LUA_CDIR	"!\\"
+#define LUA_PATH_DEFAULT  \
+		LUA_LDIR"?.lua;"  LUA_LDIR"?\\init.lua;" \
+		LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua;" ".\\?.lua"
+#define LUA_CPATH_DEFAULT \
+		LUA_CDIR"?.dll;" LUA_CDIR"loadall.dll;" ".\\?.dll"
+
+#else			/* }{ */
+
+#define LUA_VDIR	LUA_VERSION_MAJOR "." LUA_VERSION_MINOR "/"
+#define LUA_ROOT	"/usr/local/"
+#define LUA_LDIR	LUA_ROOT "share/lua/" LUA_VDIR
+#define LUA_CDIR	LUA_ROOT "lib/lua/" LUA_VDIR
+#define LUA_PATH_DEFAULT  \
+		LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
+		LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua;" "./?.lua"
+#define LUA_CPATH_DEFAULT \
+		LUA_CDIR"?.so;" LUA_CDIR"loadall.so;" "./?.so"
+#endif			/* } */
+
+
+/*
+@@ LUA_DIRSEP is the directory separator (for submodules).
+** CHANGE it if your machine does not use "/" as the directory separator
+** and is not Windows. (On Windows Lua automatically uses "\".)
+*/
+#if defined(_WIN32)
+#define LUA_DIRSEP	"\\"
+#else
+#define LUA_DIRSEP	"/"
+#endif
+
+
+/*
+@@ LUA_ENV is the name of the variable that holds the current
+@@ environment, used to access global names.
+** CHANGE it if you do not like this name.
+*/
+#define LUA_ENV		"_ENV"
+
+
+/*
+@@ LUA_API is a mark for all core API functions.
+@@ LUALIB_API is a mark for all auxiliary library functions.
+@@ LUAMOD_API is a mark for all standard library opening functions.
+** CHANGE them if you need to define those functions in some special way.
+** For instance, if you want to create one Windows DLL with the core and
+** the libraries, you may want to use the following definition (define
+** LUA_BUILD_AS_DLL to get it).
+*/
+#if defined(LUA_BUILD_AS_DLL)	/* { */
+
+#if defined(LUA_CORE) || defined(LUA_LIB)	/* { */
+#define LUA_API __declspec(dllexport)
+#else						/* }{ */
+#define LUA_API __declspec(dllimport)
+#endif						/* } */
+
+#else				/* }{ */
+
+#define LUA_API		extern
+
+#endif				/* } */
+
+
+/* more often than not the libs go together with the core */
+#define LUALIB_API	LUA_API
+#define LUAMOD_API	LUALIB_API
+
+
+/*
+@@ LUAI_FUNC is a mark for all extern functions that are not to be
+@* exported to outside modules.
+@@ LUAI_DDEF and LUAI_DDEC are marks for all extern (const) variables
+@* that are not to be exported to outside modules (LUAI_DDEF for
+@* definitions and LUAI_DDEC for declarations).
+** CHANGE them if you need to mark them in some special way. Elf/gcc
+** (versions 3.2 and later) mark them as "hidden" to optimize access
+** when Lua is compiled as a shared library. Not all elf targets support
+** this attribute. Unfortunately, gcc does not offer a way to check
+** whether the target offers that support, and those without support
+** give a warning about it. To avoid these warnings, change to the
+** default definition.
+*/
+#if defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
+    defined(__ELF__)		/* { */
+#define LUAI_FUNC	__attribute__((visibility("hidden"))) extern
+#define LUAI_DDEC	LUAI_FUNC
+#define LUAI_DDEF	/* empty */
+
+#else				/* }{ */
+#define LUAI_FUNC	extern
+#define LUAI_DDEC	extern
+#define LUAI_DDEF	/* empty */
+#endif				/* } */
+
+
+
+/*
+@@ LUA_QL describes how error messages quote program elements.
+** CHANGE it if you want a different appearance.
+*/
+#define LUA_QL(x)	"'" x "'"
+#define LUA_QS		LUA_QL("%s")
+
+
+/*
+@@ LUA_IDSIZE gives the maximum size for the description of the source
+@* of a function in debug information.
+** CHANGE it if you want a different size.
+*/
+#define LUA_IDSIZE	60
+
+
+/*
+@@ luai_writestring/luai_writeline define how 'print' prints its results.
+** They are only used in libraries and the stand-alone program. (The #if
+** avoids including 'stdio.h' everywhere.)
+*/
+#if defined(LUA_LIB) || defined(lua_c)
+#include <stdio.h>
+#define luai_writestring(s,l)	fwrite((s), sizeof(char), (l), stdout)
+#define luai_writeline()	(luai_writestring("\n", 1), fflush(stdout))
+#endif
+
+/*
+@@ luai_writestringerror defines how to print error messages.
+** (A format string with one argument is enough for Lua...)
+*/
+#define luai_writestringerror(s,p) \
+	(fprintf(stderr, (s), (p)), fflush(stderr))
+
+
+/*
+@@ LUAI_MAXSHORTLEN is the maximum length for short strings, that is,
+** strings that are internalized. (Cannot be smaller than reserved words
+** or tags for metamethods, as these strings must be internalized;
+** #("function") = 8, #("__newindex") = 10.)
+*/
+#define LUAI_MAXSHORTLEN        40
+
+
+
+/*
+** {==================================================================
+** Compatibility with previous versions
+** ===================================================================
+*/
+
+/*
+@@ LUA_COMPAT_ALL controls all compatibility options.
+** You can define it to get all options, or change specific options
+** to fit your specific needs.
+*/
+#if defined(LUA_COMPAT_ALL)	/* { */
+
+/*
+@@ LUA_COMPAT_UNPACK controls the presence of global 'unpack'.
+** You can replace it with 'table.unpack'.
+*/
+#define LUA_COMPAT_UNPACK
+
+/*
+@@ LUA_COMPAT_LOADERS controls the presence of table 'package.loaders'.
+** You can replace it with 'package.searchers'.
+*/
+#define LUA_COMPAT_LOADERS
+
+/*
+@@ macro 'lua_cpcall' emulates deprecated function lua_cpcall.
+** You can call your C function directly (with light C functions).
+*/
+#define lua_cpcall(L,f,u)  \
+	(lua_pushcfunction(L, (f)), \
+	 lua_pushlightuserdata(L,(u)), \
+	 lua_pcall(L,1,0,0))
+
+
+/*
+@@ LUA_COMPAT_LOG10 defines the function 'log10' in the math library.
+** You can rewrite 'log10(x)' as 'log(x, 10)'.
+*/
+#define LUA_COMPAT_LOG10
+
+/*
+@@ LUA_COMPAT_LOADSTRING defines the function 'loadstring' in the base
+** library. You can rewrite 'loadstring(s)' as 'load(s)'.
+*/
+#define LUA_COMPAT_LOADSTRING
+
+/*
+@@ LUA_COMPAT_MAXN defines the function 'maxn' in the table library.
+*/
+#define LUA_COMPAT_MAXN
+
+/*
+@@ The following macros supply trivial compatibility for some
+** changes in the API. The macros themselves document how to
+** change your code to avoid using them.
+*/
+#define lua_strlen(L,i)		lua_rawlen(L, (i))
+
+#define lua_objlen(L,i)		lua_rawlen(L, (i))
+
+#define lua_equal(L,idx1,idx2)		lua_compare(L,(idx1),(idx2),LUA_OPEQ)
+#define lua_lessthan(L,idx1,idx2)	lua_compare(L,(idx1),(idx2),LUA_OPLT)
+
+/*
+@@ LUA_COMPAT_MODULE controls compatibility with previous
+** module functions 'module' (Lua) and 'luaL_register' (C).
+*/
+#define LUA_COMPAT_MODULE
+
+#endif				/* } */
+
+/* }================================================================== */
+
+
+
+/*
+@@ LUAI_BITSINT defines the number of bits in an int.
+** CHANGE here if Lua cannot automatically detect the number of bits of
+** your machine. Probably you do not need to change this.
+*/
+/* avoid overflows in comparison */
+#if INT_MAX-20 < 32760		/* { */
+#define LUAI_BITSINT	16
+#elif INT_MAX > 2147483640L	/* }{ */
+/* int has at least 32 bits */
+#define LUAI_BITSINT	32
+#else				/* }{ */
+#error "you must define LUA_BITSINT with number of bits in an integer"
+#endif				/* } */
+
+
+/*
+@@ LUA_INT32 is an signed integer with exactly 32 bits.
+@@ LUAI_UMEM is an unsigned integer big enough to count the total
+@* memory used by Lua.
+@@ LUAI_MEM is a signed integer big enough to count the total memory
+@* used by Lua.
+** CHANGE here if for some weird reason the default definitions are not
+** good enough for your machine. Probably you do not need to change
+** this.
+*/
+#if LUAI_BITSINT >= 32		/* { */
+#define LUA_INT32	int
+#define LUAI_UMEM	size_t
+#define LUAI_MEM	ptrdiff_t
+#else				/* }{ */
+/* 16-bit ints */
+#define LUA_INT32	long
+#define LUAI_UMEM	unsigned long
+#define LUAI_MEM	long
+#endif				/* } */
+
+
+/*
+@@ LUAI_MAXSTACK limits the size of the Lua stack.
+** CHANGE it if you need a different limit. This limit is arbitrary;
+** its only purpose is to stop Lua to consume unlimited stack
+** space (and to reserve some numbers for pseudo-indices).
+*/
+#if LUAI_BITSINT >= 32
+#define LUAI_MAXSTACK		1000000
+#else
+#define LUAI_MAXSTACK		15000
+#endif
+
+/* reserve some space for error handling */
+#define LUAI_FIRSTPSEUDOIDX	(-LUAI_MAXSTACK - 1000)
+
+
+
+
+/*
+@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
+** CHANGE it if it uses too much C-stack space.
+*/
+#define LUAL_BUFFERSIZE		BUFSIZ
+
+
+
+
+/*
+** {==================================================================
+@@ LUA_NUMBER is the type of numbers in Lua.
+** CHANGE the following definitions only if you want to build Lua
+** with a number type different from double. You may also need to
+** change lua_number2int & lua_number2integer.
+** ===================================================================
+*/
+
+#define LUA_NUMBER_DOUBLE
+#define LUA_NUMBER	double
+
+/*
+@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
+@* over a number.
+*/
+#define LUAI_UACNUMBER	double
+
+
+/*
+@@ LUA_NUMBER_SCAN is the format for reading numbers.
+@@ LUA_NUMBER_FMT is the format for writing numbers.
+@@ lua_number2str converts a number to a string.
+@@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
+*/
+#define LUA_NUMBER_SCAN		"%lf"
+#define LUA_NUMBER_FMT		"%.14g"
+#define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))
+#define LUAI_MAXNUMBER2STR	32 /* 16 digits, sign, point, and \0 */
+
+
+/*
+@@ lua_str2number converts a decimal numeric string to a number.
+@@ lua_strx2number converts an hexadecimal numeric string to a number.
+** In C99, 'strtod' do both conversions. C89, however, has no function
+** to convert floating hexadecimal strings to numbers. For these
+** systems, you can leave 'lua_strx2number' undefined and Lua will
+** provide its own implementation.
+*/
+#define lua_str2number(s,p)	strtod((s), (p))
+
+#if defined(LUA_USE_STRTODHEX)
+#define lua_strx2number(s,p)	strtod((s), (p))
+#endif
+
+
+/*
+@@ The luai_num* macros define the primitive operations over numbers.
+*/
+
+/* the following operations need the math library */
+#if defined(lobject_c) || defined(lvm_c)
+#include <math.h>
+#define luai_nummod(L,a,b)	((a) - floor((a)/(b))*(b))
+#define luai_numpow(L,a,b)	(pow(a,b))
+#endif
+
+/* these are quite standard operations */
+#if defined(LUA_CORE)
+#define luai_numadd(L,a,b)	((a)+(b))
+#define luai_numsub(L,a,b)	((a)-(b))
+#define luai_nummul(L,a,b)	((a)*(b))
+#define luai_numdiv(L,a,b)	((a)/(b))
+#define luai_numunm(L,a)	(-(a))
+#define luai_numeq(a,b)		((a)==(b))
+#define luai_numlt(L,a,b)	((a)<(b))
+#define luai_numle(L,a,b)	((a)<=(b))
+#define luai_numisnan(L,a)	(!luai_numeq((a), (a)))
+#endif
+
+
+
+/*
+@@ LUA_INTEGER is the integral type used by lua_pushinteger/lua_tointeger.
+** CHANGE that if ptrdiff_t is not adequate on your machine. (On most
+** machines, ptrdiff_t gives a good choice between int or long.)
+*/
+#define LUA_INTEGER	ptrdiff_t
+
+/*
+@@ LUA_UNSIGNED is the integral type used by lua_pushunsigned/lua_tounsigned.
+** It must have at least 32 bits.
+*/
+#define LUA_UNSIGNED	unsigned LUA_INT32
+
+
+
+/*
+** Some tricks with doubles
+*/
+
+#if defined(LUA_CORE) && \
+    defined(LUA_NUMBER_DOUBLE) && !defined(LUA_ANSI)	/* { */
+/*
+** The next definitions activate some tricks to speed up the
+** conversion from doubles to integer types, mainly to LUA_UNSIGNED.
+**
+@@ MS_ASMTRICK uses Microsoft assembler to avoid clashes with a
+** DirectX idiosyncrasy.
+**
+@@ LUA_IEEE754TRICK uses a trick that should work on any machine
+** using IEEE754 with a 32-bit integer type.
+**
+@@ LUA_IEEELL extends the trick to LUA_INTEGER; should only be
+** defined when LUA_INTEGER is a 32-bit integer.
+**
+@@ LUA_IEEEENDIAN is the endianness of doubles in your machine
+** (0 for little endian, 1 for big endian); if not defined, Lua will
+** check it dynamically for LUA_IEEE754TRICK (but not for LUA_NANTRICK).
+**
+@@ LUA_NANTRICK controls the use of a trick to pack all types into
+** a single double value, using NaN values to represent non-number
+** values. The trick only works on 32-bit machines (ints and pointers
+** are 32-bit values) with numbers represented as IEEE 754-2008 doubles
+** with conventional endianess (12345678 or 87654321), in CPUs that do
+** not produce signaling NaN values (all NaNs are quiet).
+*/
+
+/* Microsoft compiler on a Pentium (32 bit) ? */
+#if defined(LUA_WIN) && defined(_MSC_VER) && defined(_M_IX86)	/* { */
+
+#define MS_ASMTRICK
+#define LUA_IEEEENDIAN		0
+#define LUA_NANTRICK
+
+
+/* pentium 32 bits? */
+#elif defined(__i386__) || defined(__i386) || defined(__X86__) /* }{ */
+
+#define LUA_IEEE754TRICK
+#define LUA_IEEELL
+#define LUA_IEEEENDIAN		0
+#define LUA_NANTRICK
+
+/* pentium 64 bits? */
+#elif defined(__x86_64)						/* }{ */
+
+#define LUA_IEEE754TRICK
+#define LUA_IEEEENDIAN		0
+
+#elif defined(__POWERPC__) || defined(__ppc__)			/* }{ */
+
+#define LUA_IEEE754TRICK
+#define LUA_IEEEENDIAN		1
+
+#else								/* }{ */
+
+/* assume IEEE754 and a 32-bit integer type */
+#define LUA_IEEE754TRICK
+
+#endif								/* } */
+
+#endif							/* } */
+
+/* }================================================================== */
+
+
+
+
+/* =================================================================== */
+
+/*
+** Local configuration. You can use this space to add your redefinitions
+** without modifying the main part of the file.
+*/
+
+
+
+#endif
+
diff --git a/dep/lualib/lualib.h b/dep/lualib/lualib.h
new file mode 100644
index 0000000..9fd126b
--- /dev/null
+++ b/dep/lualib/lualib.h
@@ -0,0 +1,55 @@
+/*
+** $Id: lualib.h,v 1.43 2011/12/08 12:11:37 roberto Exp $
+** Lua standard libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lualib_h
+#define lualib_h
+
+#include "lua.h"
+
+
+
+LUAMOD_API int (luaopen_base) (lua_State *L);
+
+#define LUA_COLIBNAME	"coroutine"
+LUAMOD_API int (luaopen_coroutine) (lua_State *L);
+
+#define LUA_TABLIBNAME	"table"
+LUAMOD_API int (luaopen_table) (lua_State *L);
+
+#define LUA_IOLIBNAME	"io"
+LUAMOD_API int (luaopen_io) (lua_State *L);
+
+#define LUA_OSLIBNAME	"os"
+LUAMOD_API int (luaopen_os) (lua_State *L);
+
+#define LUA_STRLIBNAME	"string"
+LUAMOD_API int (luaopen_string) (lua_State *L);
+
+#define LUA_BITLIBNAME	"bit32"
+LUAMOD_API int (luaopen_bit32) (lua_State *L);
+
+#define LUA_MATHLIBNAME	"math"
+LUAMOD_API int (luaopen_math) (lua_State *L);
+
+#define LUA_DBLIBNAME	"debug"
+LUAMOD_API int (luaopen_debug) (lua_State *L);
+
+#define LUA_LOADLIBNAME	"package"
+LUAMOD_API int (luaopen_package) (lua_State *L);
+
+
+/* open all previous libraries */
+LUALIB_API void (luaL_openlibs) (lua_State *L);
+
+
+
+#if !defined(lua_assert)
+#define lua_assert(x)	((void)0)
+#endif
+
+
+#endif
diff --git a/dep/lualib/lundump.c b/dep/lualib/lundump.c
new file mode 100644
index 0000000..54de011
--- /dev/null
+++ b/dep/lualib/lundump.c
@@ -0,0 +1,258 @@
+/*
+** $Id: lundump.c,v 2.22 2012/05/08 13:53:33 roberto Exp $
+** load precompiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#include <string.h>
+
+#define lundump_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstring.h"
+#include "lundump.h"
+#include "lzio.h"
+
+typedef struct {
+ lua_State* L;
+ ZIO* Z;
+ Mbuffer* b;
+ const char* name;
+} LoadState;
+
+static l_noret error(LoadState* S, const char* why)
+{
+ luaO_pushfstring(S->L,"%s: %s precompiled chunk",S->name,why);
+ luaD_throw(S->L,LUA_ERRSYNTAX);
+}
+
+#define LoadMem(S,b,n,size)	LoadBlock(S,b,(n)*(size))
+#define LoadByte(S)		(lu_byte)LoadChar(S)
+#define LoadVar(S,x)		LoadMem(S,&x,1,sizeof(x))
+#define LoadVector(S,b,n,size)	LoadMem(S,b,n,size)
+
+#if !defined(luai_verifycode)
+#define luai_verifycode(L,b,f)	/* empty */
+#endif
+
+static void LoadBlock(LoadState* S, void* b, size_t size)
+{
+ if (luaZ_read(S->Z,b,size)!=0) error(S,"truncated");
+}
+
+static int LoadChar(LoadState* S)
+{
+ char x;
+ LoadVar(S,x);
+ return x;
+}
+
+static int LoadInt(LoadState* S)
+{
+ int x;
+ LoadVar(S,x);
+ if (x<0) error(S,"corrupted");
+ return x;
+}
+
+static lua_Number LoadNumber(LoadState* S)
+{
+ lua_Number x;
+ LoadVar(S,x);
+ return x;
+}
+
+static TString* LoadString(LoadState* S)
+{
+ size_t size;
+ LoadVar(S,size);
+ if (size==0)
+  return NULL;
+ else
+ {
+  char* s=luaZ_openspace(S->L,S->b,size);
+  LoadBlock(S,s,size*sizeof(char));
+  return luaS_newlstr(S->L,s,size-1);		/* remove trailing '\0' */
+ }
+}
+
+static void LoadCode(LoadState* S, Proto* f)
+{
+ int n=LoadInt(S);
+ f->code=luaM_newvector(S->L,n,Instruction);
+ f->sizecode=n;
+ LoadVector(S,f->code,n,sizeof(Instruction));
+}
+
+static void LoadFunction(LoadState* S, Proto* f);
+
+static void LoadConstants(LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f->k=luaM_newvector(S->L,n,TValue);
+ f->sizek=n;
+ for (i=0; i<n; i++) setnilvalue(&f->k[i]);
+ for (i=0; i<n; i++)
+ {
+  TValue* o=&f->k[i];
+  int t=LoadChar(S);
+  switch (t)
+  {
+   case LUA_TNIL:
+	setnilvalue(o);
+	break;
+   case LUA_TBOOLEAN:
+	setbvalue(o,LoadChar(S));
+	break;
+   case LUA_TNUMBER:
+	setnvalue(o,LoadNumber(S));
+	break;
+   case LUA_TSTRING:
+	setsvalue2n(S->L,o,LoadString(S));
+	break;
+    default: lua_assert(0);
+  }
+ }
+ n=LoadInt(S);
+ f->p=luaM_newvector(S->L,n,Proto*);
+ f->sizep=n;
+ for (i=0; i<n; i++) f->p[i]=NULL;
+ for (i=0; i<n; i++)
+ {
+  f->p[i]=luaF_newproto(S->L);
+  LoadFunction(S,f->p[i]);
+ }
+}
+
+static void LoadUpvalues(LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f->upvalues=luaM_newvector(S->L,n,Upvaldesc);
+ f->sizeupvalues=n;
+ for (i=0; i<n; i++) f->upvalues[i].name=NULL;
+ for (i=0; i<n; i++)
+ {
+  f->upvalues[i].instack=LoadByte(S);
+  f->upvalues[i].idx=LoadByte(S);
+ }
+}
+
+static void LoadDebug(LoadState* S, Proto* f)
+{
+ int i,n;
+ f->source=LoadString(S);
+ n=LoadInt(S);
+ f->lineinfo=luaM_newvector(S->L,n,int);
+ f->sizelineinfo=n;
+ LoadVector(S,f->lineinfo,n,sizeof(int));
+ n=LoadInt(S);
+ f->locvars=luaM_newvector(S->L,n,LocVar);
+ f->sizelocvars=n;
+ for (i=0; i<n; i++) f->locvars[i].varname=NULL;
+ for (i=0; i<n; i++)
+ {
+  f->locvars[i].varname=LoadString(S);
+  f->locvars[i].startpc=LoadInt(S);
+  f->locvars[i].endpc=LoadInt(S);
+ }
+ n=LoadInt(S);
+ for (i=0; i<n; i++) f->upvalues[i].name=LoadString(S);
+}
+
+static void LoadFunction(LoadState* S, Proto* f)
+{
+ f->linedefined=LoadInt(S);
+ f->lastlinedefined=LoadInt(S);
+ f->numparams=LoadByte(S);
+ f->is_vararg=LoadByte(S);
+ f->maxstacksize=LoadByte(S);
+ LoadCode(S,f);
+ LoadConstants(S,f);
+ LoadUpvalues(S,f);
+ LoadDebug(S,f);
+}
+
+/* the code below must be consistent with the code in luaU_header */
+#define N0	LUAC_HEADERSIZE
+#define N1	(sizeof(LUA_SIGNATURE)-sizeof(char))
+#define N2	N1+2
+#define N3	N2+6
+
+static void LoadHeader(LoadState* S)
+{
+ lu_byte h[LUAC_HEADERSIZE];
+ lu_byte s[LUAC_HEADERSIZE];
+ luaU_header(h);
+ memcpy(s,h,sizeof(char));			/* first char already read */
+ LoadBlock(S,s+sizeof(char),LUAC_HEADERSIZE-sizeof(char));
+ if (memcmp(h,s,N0)==0) return;
+ if (memcmp(h,s,N1)!=0) error(S,"not a");
+ if (memcmp(h,s,N2)!=0) error(S,"version mismatch in");
+ if (memcmp(h,s,N3)!=0) error(S,"incompatible"); else error(S,"corrupted");
+}
+
+/*
+** load precompiled chunk
+*/
+Closure* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)
+{
+ LoadState S;
+ Closure* cl;
+ if (*name=='@' || *name=='=')
+  S.name=name+1;
+ else if (*name==LUA_SIGNATURE[0])
+  S.name="binary string";
+ else
+  S.name=name;
+ S.L=L;
+ S.Z=Z;
+ S.b=buff;
+ LoadHeader(&S);
+ cl=luaF_newLclosure(L,1);
+ setclLvalue(L,L->top,cl); incr_top(L);
+ cl->l.p=luaF_newproto(L);
+ LoadFunction(&S,cl->l.p);
+ if (cl->l.p->sizeupvalues != 1)
+ {
+  Proto* p=cl->l.p;
+  cl=luaF_newLclosure(L,cl->l.p->sizeupvalues);
+  cl->l.p=p;
+  setclLvalue(L,L->top-1,cl);
+ }
+ luai_verifycode(L,buff,cl->l.p);
+ return cl;
+}
+
+#define MYINT(s)	(s[0]-'0')
+#define VERSION		MYINT(LUA_VERSION_MAJOR)*16+MYINT(LUA_VERSION_MINOR)
+#define FORMAT		0		/* this is the official format */
+
+/*
+* make header for precompiled chunks
+* if you change the code below be sure to update LoadHeader and FORMAT above
+* and LUAC_HEADERSIZE in lundump.h
+*/
+void luaU_header (lu_byte* h)
+{
+ int x=1;
+ memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-sizeof(char));
+ h+=sizeof(LUA_SIGNATURE)-sizeof(char);
+ *h++=cast_byte(VERSION);
+ *h++=cast_byte(FORMAT);
+ *h++=cast_byte(*(char*)&x);			/* endianness */
+ *h++=cast_byte(sizeof(int));
+ *h++=cast_byte(sizeof(size_t));
+ *h++=cast_byte(sizeof(Instruction));
+ *h++=cast_byte(sizeof(lua_Number));
+ *h++=cast_byte(((lua_Number)0.5)==0);		/* is lua_Number integral? */
+ memcpy(h,LUAC_TAIL,sizeof(LUAC_TAIL)-sizeof(char));
+}
diff --git a/dep/lualib/lundump.h b/dep/lualib/lundump.h
new file mode 100644
index 0000000..2b8acce
--- /dev/null
+++ b/dep/lualib/lundump.h
@@ -0,0 +1,28 @@
+/*
+** $Id: lundump.h,v 1.39 2012/05/08 13:53:33 roberto Exp $
+** load precompiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lundump_h
+#define lundump_h
+
+#include "lobject.h"
+#include "lzio.h"
+
+/* load one chunk; from lundump.c */
+LUAI_FUNC Closure* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name);
+
+/* make header; from lundump.c */
+LUAI_FUNC void luaU_header (lu_byte* h);
+
+/* dump one chunk; from ldump.c */
+LUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip);
+
+/* data to catch conversion errors */
+#define LUAC_TAIL		"\x19\x93\r\n\x1a\n"
+
+/* size in bytes of header of binary files */
+#define LUAC_HEADERSIZE		(sizeof(LUA_SIGNATURE)-sizeof(char)+2+6+sizeof(LUAC_TAIL)-sizeof(char))
+
+#endif
diff --git a/dep/lualib/lvm.c b/dep/lualib/lvm.c
new file mode 100644
index 0000000..b77eac2
--- /dev/null
+++ b/dep/lualib/lvm.c
@@ -0,0 +1,868 @@
+/*
+** $Id: lvm.c,v 2.152 2012/06/08 15:14:04 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lvm_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lvm.h"
+
+
+
+/* limit for table tag-method chains (to avoid loops) */
+#define MAXTAGLOOP	100
+
+
+const TValue *luaV_tonumber (const TValue *obj, TValue *n) {
+  lua_Number num;
+  if (ttisnumber(obj)) return obj;
+  if (ttisstring(obj) && luaO_str2d(svalue(obj), tsvalue(obj)->len, &num)) {
+    setnvalue(n, num);
+    return n;
+  }
+  else
+    return NULL;
+}
+
+
+int luaV_tostring (lua_State *L, StkId obj) {
+  if (!ttisnumber(obj))
+    return 0;
+  else {
+    char s[LUAI_MAXNUMBER2STR];
+    lua_Number n = nvalue(obj);
+    int l = lua_number2str(s, n);
+    setsvalue2s(L, obj, luaS_newlstr(L, s, l));
+    return 1;
+  }
+}
+
+
+static void traceexec (lua_State *L) {
+  CallInfo *ci = L->ci;
+  lu_byte mask = L->hookmask;
+  int counthook = ((mask & LUA_MASKCOUNT) && L->hookcount == 0);
+  if (counthook)
+    resethookcount(L);  /* reset count */
+  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */
+    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */
+    return;  /* do not call hook again (VM yielded, so it did not move) */
+  }
+  if (counthook)
+    luaD_hook(L, LUA_HOOKCOUNT, -1);  /* call count hook */
+  if (mask & LUA_MASKLINE) {
+    Proto *p = ci_func(ci)->p;
+    int npc = pcRel(ci->u.l.savedpc, p);
+    int newline = getfuncline(p, npc);
+    if (npc == 0 ||  /* call linehook when enter a new function, */
+        ci->u.l.savedpc <= L->oldpc ||  /* when jump back (loop), or when */
+        newline != getfuncline(p, pcRel(L->oldpc, p)))  /* enter a new line */
+      luaD_hook(L, LUA_HOOKLINE, newline);  /* call line hook */
+  }
+  L->oldpc = ci->u.l.savedpc;
+  if (L->status == LUA_YIELD) {  /* did hook yield? */
+    if (counthook)
+      L->hookcount = 1;  /* undo decrement to zero */
+    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */
+    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yieled */
+    ci->func = L->top - 1;  /* protect stack below results */
+    luaD_throw(L, LUA_YIELD);
+  }
+}
+
+
+static void callTM (lua_State *L, const TValue *f, const TValue *p1,
+                    const TValue *p2, TValue *p3, int hasres) {
+  ptrdiff_t result = savestack(L, p3);
+  setobj2s(L, L->top++, f);  /* push function */
+  setobj2s(L, L->top++, p1);  /* 1st argument */
+  setobj2s(L, L->top++, p2);  /* 2nd argument */
+  if (!hasres)  /* no result? 'p3' is third argument */
+    setobj2s(L, L->top++, p3);  /* 3rd argument */
+  luaD_checkstack(L, 0);
+  /* metamethod may yield only when called from Lua code */
+  luaD_call(L, L->top - (4 - hasres), hasres, isLua(L->ci));
+  if (hasres) {  /* if has result, move it to its place */
+    p3 = restorestack(L, result);
+    setobjs2s(L, p3, --L->top);
+  }
+}
+
+
+void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {
+  int loop;
+  for (loop = 0; loop < MAXTAGLOOP; loop++) {
+    const TValue *tm;
+    if (ttistable(t)) {  /* `t' is a table? */
+      Table *h = hvalue(t);
+      const TValue *res = luaH_get(h, key); /* do a primitive get */
+      if (!ttisnil(res) ||  /* result is not nil? */
+          (tm = fasttm(L, h->metatable, TM_INDEX)) == NULL) { /* or no TM? */
+        setobj2s(L, val, res);
+        return;
+      }
+      /* else will try the tag method */
+    }
+    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))
+      luaG_typeerror(L, t, "index");
+    if (ttisfunction(tm)) {
+      callTM(L, tm, t, key, val, 1);
+      return;
+    }
+    t = tm;  /* else repeat with 'tm' */
+  }
+  luaG_runerror(L, "loop in gettable");
+}
+
+
+void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
+  int loop;
+  for (loop = 0; loop < MAXTAGLOOP; loop++) {
+    const TValue *tm;
+    if (ttistable(t)) {  /* `t' is a table? */
+      Table *h = hvalue(t);
+      TValue *oldval = cast(TValue *, luaH_get(h, key));
+      /* if previous value is not nil, there must be a previous entry
+         in the table; moreover, a metamethod has no relevance */
+      if (!ttisnil(oldval) ||
+         /* previous value is nil; must check the metamethod */
+         ((tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL &&
+         /* no metamethod; is there a previous entry in the table? */
+         (oldval != luaO_nilobject ||
+         /* no previous entry; must create one. (The next test is
+            always true; we only need the assignment.) */
+         (oldval = luaH_newkey(L, h, key), 1)))) {
+        /* no metamethod and (now) there is an entry with given key */
+        setobj2t(L, oldval, val);  /* assign new value to that entry */
+        invalidateTMcache(h);
+        luaC_barrierback(L, obj2gco(h), val);
+        return;
+      }
+      /* else will try the metamethod */
+    }
+    else  /* not a table; check metamethod */
+      if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
+        luaG_typeerror(L, t, "index");
+    /* there is a metamethod */
+    if (ttisfunction(tm)) {
+      callTM(L, tm, t, key, val, 0);
+      return;
+    }
+    t = tm;  /* else repeat with 'tm' */
+  }
+  luaG_runerror(L, "loop in settable");
+}
+
+
+static int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,
+                       StkId res, TMS event) {
+  const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
+  if (ttisnil(tm))
+    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
+  if (ttisnil(tm)) return 0;
+  callTM(L, tm, p1, p2, res, 1);
+  return 1;
+}
+
+
+static const TValue *get_equalTM (lua_State *L, Table *mt1, Table *mt2,
+                                  TMS event) {
+  const TValue *tm1 = fasttm(L, mt1, event);
+  const TValue *tm2;
+  if (tm1 == NULL) return NULL;  /* no metamethod */
+  if (mt1 == mt2) return tm1;  /* same metatables => same metamethods */
+  tm2 = fasttm(L, mt2, event);
+  if (tm2 == NULL) return NULL;  /* no metamethod */
+  if (luaV_rawequalobj(tm1, tm2))  /* same metamethods? */
+    return tm1;
+  return NULL;
+}
+
+
+static int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,
+                         TMS event) {
+  if (!call_binTM(L, p1, p2, L->top, event))
+    return -1;  /* no metamethod */
+  else
+    return !l_isfalse(L->top);
+}
+
+
+static int l_strcmp (const TString *ls, const TString *rs) {
+  const char *l = getstr(ls);
+  size_t ll = ls->tsv.len;
+  const char *r = getstr(rs);
+  size_t lr = rs->tsv.len;
+  for (;;) {
+    int temp = strcoll(l, r);
+    if (temp != 0) return temp;
+    else {  /* strings are equal up to a `\0' */
+      size_t len = strlen(l);  /* index of first `\0' in both strings */
+      if (len == lr)  /* r is finished? */
+        return (len == ll) ? 0 : 1;
+      else if (len == ll)  /* l is finished? */
+        return -1;  /* l is smaller than r (because r is not finished) */
+      /* both strings longer than `len'; go on comparing (after the `\0') */
+      len++;
+      l += len; ll -= len; r += len; lr -= len;
+    }
+  }
+}
+
+
+int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {
+  int res;
+  if (ttisnumber(l) && ttisnumber(r))
+    return luai_numlt(L, nvalue(l), nvalue(r));
+  else if (ttisstring(l) && ttisstring(r))
+    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) < 0;
+  else if ((res = call_orderTM(L, l, r, TM_LT)) < 0)
+    luaG_ordererror(L, l, r);
+  return res;
+}
+
+
+int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r) {
+  int res;
+  if (ttisnumber(l) && ttisnumber(r))
+    return luai_numle(L, nvalue(l), nvalue(r));
+  else if (ttisstring(l) && ttisstring(r))
+    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) <= 0;
+  else if ((res = call_orderTM(L, l, r, TM_LE)) >= 0)  /* first try `le' */
+    return res;
+  else if ((res = call_orderTM(L, r, l, TM_LT)) < 0)  /* else try `lt' */
+    luaG_ordererror(L, l, r);
+  return !res;
+}
+
+
+/*
+** equality of Lua values. L == NULL means raw equality (no metamethods)
+*/
+int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2) {
+  const TValue *tm;
+  lua_assert(ttisequal(t1, t2));
+  switch (ttype(t1)) {
+    case LUA_TNIL: return 1;
+    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));
+    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
+    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
+    case LUA_TLCF: return fvalue(t1) == fvalue(t2);
+    case LUA_TSHRSTR: return eqshrstr(rawtsvalue(t1), rawtsvalue(t2));
+    case LUA_TLNGSTR: return luaS_eqlngstr(rawtsvalue(t1), rawtsvalue(t2));
+    case LUA_TUSERDATA: {
+      if (uvalue(t1) == uvalue(t2)) return 1;
+      else if (L == NULL) return 0;
+      tm = get_equalTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable, TM_EQ);
+      break;  /* will try TM */
+    }
+    case LUA_TTABLE: {
+      if (hvalue(t1) == hvalue(t2)) return 1;
+      else if (L == NULL) return 0;
+      tm = get_equalTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);
+      break;  /* will try TM */
+    }
+    default:
+      lua_assert(iscollectable(t1));
+      return gcvalue(t1) == gcvalue(t2);
+  }
+  if (tm == NULL) return 0;  /* no TM? */
+  callTM(L, tm, t1, t2, L->top, 1);  /* call TM */
+  return !l_isfalse(L->top);
+}
+
+
+void luaV_concat (lua_State *L, int total) {
+  lua_assert(total >= 2);
+  do {
+    StkId top = L->top;
+    int n = 2;  /* number of elements handled in this pass (at least 2) */
+    if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {
+      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
+        luaG_concaterror(L, top-2, top-1);
+    }
+    else if (tsvalue(top-1)->len == 0)  /* second operand is empty? */
+      (void)tostring(L, top - 2);  /* result is first operand */
+    else if (ttisstring(top-2) && tsvalue(top-2)->len == 0) {
+      setobjs2s(L, top - 2, top - 1);  /* result is second op. */
+    }
+    else {
+      /* at least two non-empty string values; get as many as possible */
+      size_t tl = tsvalue(top-1)->len;
+      char *buffer;
+      int i;
+      /* collect total length */
+      for (i = 1; i < total && tostring(L, top-i-1); i++) {
+        size_t l = tsvalue(top-i-1)->len;
+        if (l >= (MAX_SIZET/sizeof(char)) - tl)
+          luaG_runerror(L, "string length overflow");
+        tl += l;
+      }
+      buffer = luaZ_openspace(L, &G(L)->buff, tl);
+      tl = 0;
+      n = i;
+      do {  /* concat all strings */
+        size_t l = tsvalue(top-i)->len;
+        memcpy(buffer+tl, svalue(top-i), l * sizeof(char));
+        tl += l;
+      } while (--i > 0);
+      setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));
+    }
+    total -= n-1;  /* got 'n' strings to create 1 new */
+    L->top -= n-1;  /* popped 'n' strings and pushed one */
+  } while (total > 1);  /* repeat until only 1 result left */
+}
+
+
+void luaV_objlen (lua_State *L, StkId ra, const TValue *rb) {
+  const TValue *tm;
+  switch (ttypenv(rb)) {
+    case LUA_TTABLE: {
+      Table *h = hvalue(rb);
+      tm = fasttm(L, h->metatable, TM_LEN);
+      if (tm) break;  /* metamethod? break switch to call it */
+      setnvalue(ra, cast_num(luaH_getn(h)));  /* else primitive len */
+      return;
+    }
+    case LUA_TSTRING: {
+      setnvalue(ra, cast_num(tsvalue(rb)->len));
+      return;
+    }
+    default: {  /* try metamethod */
+      tm = luaT_gettmbyobj(L, rb, TM_LEN);
+      if (ttisnil(tm))  /* no metamethod? */
+        luaG_typeerror(L, rb, "get length of");
+      break;
+    }
+  }
+  callTM(L, tm, rb, rb, ra, 1);
+}
+
+
+void luaV_arith (lua_State *L, StkId ra, const TValue *rb,
+                 const TValue *rc, TMS op) {
+  TValue tempb, tempc;
+  const TValue *b, *c;
+  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
+      (c = luaV_tonumber(rc, &tempc)) != NULL) {
+    lua_Number res = luaO_arith(op - TM_ADD + LUA_OPADD, nvalue(b), nvalue(c));
+    setnvalue(ra, res);
+  }
+  else if (!call_binTM(L, rb, rc, ra, op))
+    luaG_aritherror(L, rb, rc);
+}
+
+
+/*
+** check whether cached closure in prototype 'p' may be reused, that is,
+** whether there is a cached closure with the same upvalues needed by
+** new closure to be created.
+*/
+static Closure *getcached (Proto *p, UpVal **encup, StkId base) {
+  Closure *c = p->cache;
+  if (c != NULL) {  /* is there a cached closure? */
+    int nup = p->sizeupvalues;
+    Upvaldesc *uv = p->upvalues;
+    int i;
+    for (i = 0; i < nup; i++) {  /* check whether it has right upvalues */
+      TValue *v = uv[i].instack ? base + uv[i].idx : encup[uv[i].idx]->v;
+      if (c->l.upvals[i]->v != v)
+        return NULL;  /* wrong upvalue; cannot reuse closure */
+    }
+  }
+  return c;  /* return cached closure (or NULL if no cached closure) */
+}
+
+
+/*
+** create a new Lua closure, push it in the stack, and initialize
+** its upvalues. Note that the call to 'luaC_barrierproto' must come
+** before the assignment to 'p->cache', as the function needs the
+** original value of that field.
+*/
+static void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,
+                         StkId ra) {
+  int nup = p->sizeupvalues;
+  Upvaldesc *uv = p->upvalues;
+  int i;
+  Closure *ncl = luaF_newLclosure(L, nup);
+  ncl->l.p = p;
+  setclLvalue(L, ra, ncl);  /* anchor new closure in stack */
+  for (i = 0; i < nup; i++) {  /* fill in its upvalues */
+    if (uv[i].instack)  /* upvalue refers to local variable? */
+      ncl->l.upvals[i] = luaF_findupval(L, base + uv[i].idx);
+    else  /* get upvalue from enclosing function */
+      ncl->l.upvals[i] = encup[uv[i].idx];
+  }
+  luaC_barrierproto(L, p, ncl);
+  p->cache = ncl;  /* save it on cache for reuse */
+}
+
+
+/*
+** finish execution of an opcode interrupted by an yield
+*/
+void luaV_finishOp (lua_State *L) {
+  CallInfo *ci = L->ci;
+  StkId base = ci->u.l.base;
+  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */
+  OpCode op = GET_OPCODE(inst);
+  switch (op) {  /* finish its execution */
+    case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV:
+    case OP_MOD: case OP_POW: case OP_UNM: case OP_LEN:
+    case OP_GETTABUP: case OP_GETTABLE: case OP_SELF: {
+      setobjs2s(L, base + GETARG_A(inst), --L->top);
+      break;
+    }
+    case OP_LE: case OP_LT: case OP_EQ: {
+      int res = !l_isfalse(L->top - 1);
+      L->top--;
+      /* metamethod should not be called when operand is K */
+      lua_assert(!ISK(GETARG_B(inst)));
+      if (op == OP_LE &&  /* "<=" using "<" instead? */
+          ttisnil(luaT_gettmbyobj(L, base + GETARG_B(inst), TM_LE)))
+        res = !res;  /* invert result */
+      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);
+      if (res != GETARG_A(inst))  /* condition failed? */
+        ci->u.l.savedpc++;  /* skip jump instruction */
+      break;
+    }
+    case OP_CONCAT: {
+      StkId top = L->top - 1;  /* top when 'call_binTM' was called */
+      int b = GETARG_B(inst);      /* first element to concatenate */
+      int total = cast_int(top - 1 - (base + b));  /* yet to concatenate */
+      setobj2s(L, top - 2, top);  /* put TM result in proper position */
+      if (total > 1) {  /* are there elements to concat? */
+        L->top = top - 1;  /* top is one after last element (at top-2) */
+        luaV_concat(L, total);  /* concat them (may yield again) */
+      }
+      /* move final result to final position */
+      setobj2s(L, ci->u.l.base + GETARG_A(inst), L->top - 1);
+      L->top = ci->top;  /* restore top */
+      break;
+    }
+    case OP_TFORCALL: {
+      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_TFORLOOP);
+      L->top = ci->top;  /* correct top */
+      break;
+    }
+    case OP_CALL: {
+      if (GETARG_C(inst) - 1 >= 0)  /* nresults >= 0? */
+        L->top = ci->top;  /* adjust results */
+      break;
+    }
+    case OP_TAILCALL: case OP_SETTABUP:  case OP_SETTABLE:
+      break;
+    default: lua_assert(0);
+  }
+}
+
+
+
+/*
+** some macros for common tasks in `luaV_execute'
+*/
+
+#if !defined luai_runtimecheck
+#define luai_runtimecheck(L, c)		/* void */
+#endif
+
+
+#define RA(i)	(base+GETARG_A(i))
+/* to be used after possible stack reallocation */
+#define RB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
+#define RC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
+#define RKB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \
+	ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
+#define RKC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \
+	ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
+#define KBx(i)  \
+  (k + (GETARG_Bx(i) != 0 ? GETARG_Bx(i) - 1 : GETARG_Ax(*ci->u.l.savedpc++)))
+
+
+/* execute a jump instruction */
+#define dojump(ci,i,e) \
+  { int a = GETARG_A(i); \
+    if (a > 0) luaF_close(L, ci->u.l.base + a - 1); \
+    ci->u.l.savedpc += GETARG_sBx(i) + e; }
+
+/* for test instructions, execute the jump instruction that follows it */
+#define donextjump(ci)	{ i = *ci->u.l.savedpc; dojump(ci, i, 1); }
+
+
+#define Protect(x)	{ {x;}; base = ci->u.l.base; }
+
+#define checkGC(L,c)  \
+  Protect( luaC_condGC(L,{L->top = (c);  /* limit of live values */ \
+                          luaC_step(L); \
+                          L->top = ci->top;})  /* restore top */ \
+           luai_threadyield(L); )
+
+
+#define arith_op(op,tm) { \
+        TValue *rb = RKB(i); \
+        TValue *rc = RKC(i); \
+        if (ttisnumber(rb) && ttisnumber(rc)) { \
+          lua_Number nb = nvalue(rb), nc = nvalue(rc); \
+          setnvalue(ra, op(L, nb, nc)); \
+        } \
+        else { Protect(luaV_arith(L, ra, rb, rc, tm)); } }
+
+
+#define vmdispatch(o)	switch(o)
+#define vmcase(l,b)	case l: {b}  break;
+#define vmcasenb(l,b)	case l: {b}		/* nb = no break */
+
+void luaV_execute (lua_State *L) {
+  CallInfo *ci = L->ci;
+  LClosure *cl;
+  TValue *k;
+  StkId base;
+ newframe:  /* reentry point when frame changes (call/return) */
+  lua_assert(ci == L->ci);
+  cl = clLvalue(ci->func);
+  k = cl->p->k;
+  base = ci->u.l.base;
+  /* main loop of interpreter */
+  for (;;) {
+    Instruction i = *(ci->u.l.savedpc++);
+    StkId ra;
+    if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
+        (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
+      Protect(traceexec(L));
+    }
+    /* WARNING: several calls may realloc the stack and invalidate `ra' */
+    ra = RA(i);
+    lua_assert(base == ci->u.l.base);
+    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
+    vmdispatch (GET_OPCODE(i)) {
+      vmcase(OP_MOVE,
+        setobjs2s(L, ra, RB(i));
+      )
+      vmcase(OP_LOADK,
+        TValue *rb = k + GETARG_Bx(i);
+        setobj2s(L, ra, rb);
+      )
+      vmcase(OP_LOADKX,
+        TValue *rb;
+        lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
+        rb = k + GETARG_Ax(*ci->u.l.savedpc++);
+        setobj2s(L, ra, rb);
+      )
+      vmcase(OP_LOADBOOL,
+        setbvalue(ra, GETARG_B(i));
+        if (GETARG_C(i)) ci->u.l.savedpc++;  /* skip next instruction (if C) */
+      )
+      vmcase(OP_LOADNIL,
+        int b = GETARG_B(i);
+        do {
+          setnilvalue(ra++);
+        } while (b--);
+      )
+      vmcase(OP_GETUPVAL,
+        int b = GETARG_B(i);
+        setobj2s(L, ra, cl->upvals[b]->v);
+      )
+      vmcase(OP_GETTABUP,
+        int b = GETARG_B(i);
+        Protect(luaV_gettable(L, cl->upvals[b]->v, RKC(i), ra));
+      )
+      vmcase(OP_GETTABLE,
+        Protect(luaV_gettable(L, RB(i), RKC(i), ra));
+      )
+      vmcase(OP_SETTABUP,
+        int a = GETARG_A(i);
+        Protect(luaV_settable(L, cl->upvals[a]->v, RKB(i), RKC(i)));
+      )
+      vmcase(OP_SETUPVAL,
+        UpVal *uv = cl->upvals[GETARG_B(i)];
+        setobj(L, uv->v, ra);
+        luaC_barrier(L, uv, ra);
+      )
+      vmcase(OP_SETTABLE,
+        Protect(luaV_settable(L, ra, RKB(i), RKC(i)));
+      )
+      vmcase(OP_NEWTABLE,
+        int b = GETARG_B(i);
+        int c = GETARG_C(i);
+        Table *t = luaH_new(L);
+        sethvalue(L, ra, t);
+        if (b != 0 || c != 0)
+          luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
+        checkGC(L, ra + 1);
+      )
+      vmcase(OP_SELF,
+        StkId rb = RB(i);
+        setobjs2s(L, ra+1, rb);
+        Protect(luaV_gettable(L, rb, RKC(i), ra));
+      )
+      vmcase(OP_ADD,
+        arith_op(luai_numadd, TM_ADD);
+      )
+      vmcase(OP_SUB,
+        arith_op(luai_numsub, TM_SUB);
+      )
+      vmcase(OP_MUL,
+        arith_op(luai_nummul, TM_MUL);
+      )
+      vmcase(OP_DIV,
+        arith_op(luai_numdiv, TM_DIV);
+      )
+      vmcase(OP_MOD,
+        arith_op(luai_nummod, TM_MOD);
+      )
+      vmcase(OP_POW,
+        arith_op(luai_numpow, TM_POW);
+      )
+      vmcase(OP_UNM,
+        TValue *rb = RB(i);
+        if (ttisnumber(rb)) {
+          lua_Number nb = nvalue(rb);
+          setnvalue(ra, luai_numunm(L, nb));
+        }
+        else {
+          Protect(luaV_arith(L, ra, rb, rb, TM_UNM));
+        }
+      )
+      vmcase(OP_NOT,
+        TValue *rb = RB(i);
+        int res = l_isfalse(rb);  /* next assignment may change this value */
+        setbvalue(ra, res);
+      )
+      vmcase(OP_LEN,
+        Protect(luaV_objlen(L, ra, RB(i)));
+      )
+      vmcase(OP_CONCAT,
+        int b = GETARG_B(i);
+        int c = GETARG_C(i);
+        StkId rb;
+        L->top = base + c + 1;  /* mark the end of concat operands */
+        Protect(luaV_concat(L, c - b + 1));
+        ra = RA(i);  /* 'luav_concat' may invoke TMs and move the stack */
+        rb = b + base;
+        setobjs2s(L, ra, rb);
+        checkGC(L, (ra >= rb ? ra + 1 : rb));
+        L->top = ci->top;  /* restore top */
+      )
+      vmcase(OP_JMP,
+        dojump(ci, i, 0);
+      )
+      vmcase(OP_EQ,
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        Protect(
+          if (cast_int(equalobj(L, rb, rc)) != GETARG_A(i))
+            ci->u.l.savedpc++;
+          else
+            donextjump(ci);
+        )
+      )
+      vmcase(OP_LT,
+        Protect(
+          if (luaV_lessthan(L, RKB(i), RKC(i)) != GETARG_A(i))
+            ci->u.l.savedpc++;
+          else
+            donextjump(ci);
+        )
+      )
+      vmcase(OP_LE,
+        Protect(
+          if (luaV_lessequal(L, RKB(i), RKC(i)) != GETARG_A(i))
+            ci->u.l.savedpc++;
+          else
+            donextjump(ci);
+        )
+      )
+      vmcase(OP_TEST,
+        if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra))
+            ci->u.l.savedpc++;
+          else
+          donextjump(ci);
+      )
+      vmcase(OP_TESTSET,
+        TValue *rb = RB(i);
+        if (GETARG_C(i) ? l_isfalse(rb) : !l_isfalse(rb))
+          ci->u.l.savedpc++;
+        else {
+          setobjs2s(L, ra, rb);
+          donextjump(ci);
+        }
+      )
+      vmcase(OP_CALL,
+        int b = GETARG_B(i);
+        int nresults = GETARG_C(i) - 1;
+        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
+        if (luaD_precall(L, ra, nresults)) {  /* C function? */
+          if (nresults >= 0) L->top = ci->top;  /* adjust results */
+          base = ci->u.l.base;
+        }
+        else {  /* Lua function */
+          ci = L->ci;
+          ci->callstatus |= CIST_REENTRY;
+          goto newframe;  /* restart luaV_execute over new Lua function */
+        }
+      )
+      vmcase(OP_TAILCALL,
+        int b = GETARG_B(i);
+        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
+        lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
+        if (luaD_precall(L, ra, LUA_MULTRET))  /* C function? */
+          base = ci->u.l.base;
+        else {
+          /* tail call: put called frame (n) in place of caller one (o) */
+          CallInfo *nci = L->ci;  /* called frame */
+          CallInfo *oci = nci->previous;  /* caller frame */
+          StkId nfunc = nci->func;  /* called function */
+          StkId ofunc = oci->func;  /* caller function */
+          /* last stack slot filled by 'precall' */
+          StkId lim = nci->u.l.base + getproto(nfunc)->numparams;
+          int aux;
+          /* close all upvalues from previous call */
+          if (cl->p->sizep > 0) luaF_close(L, oci->u.l.base);
+          /* move new frame into old one */
+          for (aux = 0; nfunc + aux < lim; aux++)
+            setobjs2s(L, ofunc + aux, nfunc + aux);
+          oci->u.l.base = ofunc + (nci->u.l.base - nfunc);  /* correct base */
+          oci->top = L->top = ofunc + (L->top - nfunc);  /* correct top */
+          oci->u.l.savedpc = nci->u.l.savedpc;
+          oci->callstatus |= CIST_TAIL;  /* function was tail called */
+          ci = L->ci = oci;  /* remove new frame */
+          lua_assert(L->top == oci->u.l.base + getproto(ofunc)->maxstacksize);
+          goto newframe;  /* restart luaV_execute over new Lua function */
+        }
+      )
+      vmcasenb(OP_RETURN,
+        int b = GETARG_B(i);
+        if (b != 0) L->top = ra+b-1;
+        if (cl->p->sizep > 0) luaF_close(L, base);
+        b = luaD_poscall(L, ra);
+        if (!(ci->callstatus & CIST_REENTRY))  /* 'ci' still the called one */
+          return;  /* external invocation: return */
+        else {  /* invocation via reentry: continue execution */
+          ci = L->ci;
+          if (b) L->top = ci->top;
+          lua_assert(isLua(ci));
+          lua_assert(GET_OPCODE(*((ci)->u.l.savedpc - 1)) == OP_CALL);
+          goto newframe;  /* restart luaV_execute over new Lua function */
+        }
+      )
+      vmcase(OP_FORLOOP,
+        lua_Number step = nvalue(ra+2);
+        lua_Number idx = luai_numadd(L, nvalue(ra), step); /* increment index */
+        lua_Number limit = nvalue(ra+1);
+        if (luai_numlt(L, 0, step) ? luai_numle(L, idx, limit)
+                                   : luai_numle(L, limit, idx)) {
+          ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
+          setnvalue(ra, idx);  /* update internal index... */
+          setnvalue(ra+3, idx);  /* ...and external index */
+        }
+      )
+      vmcase(OP_FORPREP,
+        const TValue *init = ra;
+        const TValue *plimit = ra+1;
+        const TValue *pstep = ra+2;
+        if (!tonumber(init, ra))
+          luaG_runerror(L, LUA_QL("for") " initial value must be a number");
+        else if (!tonumber(plimit, ra+1))
+          luaG_runerror(L, LUA_QL("for") " limit must be a number");
+        else if (!tonumber(pstep, ra+2))
+          luaG_runerror(L, LUA_QL("for") " step must be a number");
+        setnvalue(ra, luai_numsub(L, nvalue(ra), nvalue(pstep)));
+        ci->u.l.savedpc += GETARG_sBx(i);
+      )
+      vmcasenb(OP_TFORCALL,
+        StkId cb = ra + 3;  /* call base */
+        setobjs2s(L, cb+2, ra+2);
+        setobjs2s(L, cb+1, ra+1);
+        setobjs2s(L, cb, ra);
+        L->top = cb + 3;  /* func. + 2 args (state and index) */
+        Protect(luaD_call(L, cb, GETARG_C(i), 1));
+        L->top = ci->top;
+        i = *(ci->u.l.savedpc++);  /* go to next instruction */
+        ra = RA(i);
+        lua_assert(GET_OPCODE(i) == OP_TFORLOOP);
+        goto l_tforloop;
+      )
+      vmcase(OP_TFORLOOP,
+        l_tforloop:
+        if (!ttisnil(ra + 1)) {  /* continue loop? */
+          setobjs2s(L, ra, ra + 1);  /* save control variable */
+           ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
+        }
+      )
+      vmcase(OP_SETLIST,
+        int n = GETARG_B(i);
+        int c = GETARG_C(i);
+        int last;
+        Table *h;
+        if (n == 0) n = cast_int(L->top - ra) - 1;
+        if (c == 0) {
+          lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
+          c = GETARG_Ax(*ci->u.l.savedpc++);
+        }
+        luai_runtimecheck(L, ttistable(ra));
+        h = hvalue(ra);
+        last = ((c-1)*LFIELDS_PER_FLUSH) + n;
+        if (last > h->sizearray)  /* needs more space? */
+          luaH_resizearray(L, h, last);  /* pre-allocate it at once */
+        for (; n > 0; n--) {
+          TValue *val = ra+n;
+          luaH_setint(L, h, last--, val);
+          luaC_barrierback(L, obj2gco(h), val);
+        }
+        L->top = ci->top;  /* correct top (in case of previous open call) */
+      )
+      vmcase(OP_CLOSURE,
+        Proto *p = cl->p->p[GETARG_Bx(i)];
+        Closure *ncl = getcached(p, cl->upvals, base);  /* cached closure */
+        if (ncl == NULL)  /* no match? */
+          pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
+        else
+          setclLvalue(L, ra, ncl);  /* push cashed closure */
+        checkGC(L, ra + 1);
+      )
+      vmcase(OP_VARARG,
+        int b = GETARG_B(i) - 1;
+        int j;
+        int n = cast_int(base - ci->func) - cl->p->numparams - 1;
+        if (b < 0) {  /* B == 0? */
+          b = n;  /* get all var. arguments */
+          Protect(luaD_checkstack(L, n));
+          ra = RA(i);  /* previous call may change the stack */
+          L->top = ra + n;
+        }
+        for (j = 0; j < b; j++) {
+          if (j < n) {
+            setobjs2s(L, ra + j, base - n + j);
+          }
+          else {
+            setnilvalue(ra + j);
+          }
+        }
+      )
+      vmcase(OP_EXTRAARG,
+        lua_assert(0);
+      )
+    }
+  }
+}
+
diff --git a/dep/lualib/lvm.h b/dep/lualib/lvm.h
new file mode 100644
index 0000000..ec35822
--- /dev/null
+++ b/dep/lualib/lvm.h
@@ -0,0 +1,45 @@
+/*
+** $Id: lvm.h,v 2.17 2011/05/31 18:27:56 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lvm_h
+#define lvm_h
+
+
+#include "ldo.h"
+#include "lobject.h"
+#include "ltm.h"
+
+
+#define tostring(L,o) (ttisstring(o) || (luaV_tostring(L, o)))
+
+#define tonumber(o,n)	(ttisnumber(o) || (((o) = luaV_tonumber(o,n)) != NULL))
+
+#define equalobj(L,o1,o2)  (ttisequal(o1, o2) && luaV_equalobj_(L, o1, o2))
+
+#define luaV_rawequalobj(t1,t2)  \
+        (ttisequal(t1,t2) && luaV_equalobj_(NULL,t1,t2))
+
+
+/* not to called directly */
+LUAI_FUNC int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2);
+
+
+LUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);
+LUAI_FUNC int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r);
+LUAI_FUNC const TValue *luaV_tonumber (const TValue *obj, TValue *n);
+LUAI_FUNC int luaV_tostring (lua_State *L, StkId obj);
+LUAI_FUNC void luaV_gettable (lua_State *L, const TValue *t, TValue *key,
+                                            StkId val);
+LUAI_FUNC void luaV_settable (lua_State *L, const TValue *t, TValue *key,
+                                            StkId val);
+LUAI_FUNC void luaV_finishOp (lua_State *L);
+LUAI_FUNC void luaV_execute (lua_State *L);
+LUAI_FUNC void luaV_concat (lua_State *L, int total);
+LUAI_FUNC void luaV_arith (lua_State *L, StkId ra, const TValue *rb,
+                           const TValue *rc, TMS op);
+LUAI_FUNC void luaV_objlen (lua_State *L, StkId ra, const TValue *rb);
+
+#endif
diff --git a/dep/lualib/lzio.c b/dep/lualib/lzio.c
new file mode 100644
index 0000000..8b77054
--- /dev/null
+++ b/dep/lualib/lzio.c
@@ -0,0 +1,76 @@
+/*
+** $Id: lzio.c,v 1.35 2012/05/14 13:34:18 roberto Exp $
+** Buffered streams
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lzio_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "llimits.h"
+#include "lmem.h"
+#include "lstate.h"
+#include "lzio.h"
+
+
+int luaZ_fill (ZIO *z) {
+  size_t size;
+  lua_State *L = z->L;
+  const char *buff;
+  lua_unlock(L);
+  buff = z->reader(L, z->data, &size);
+  lua_lock(L);
+  if (buff == NULL || size == 0)
+    return EOZ;
+  z->n = size - 1;  /* discount char being returned */
+  z->p = buff;
+  return cast_uchar(*(z->p++));
+}
+
+
+void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {
+  z->L = L;
+  z->reader = reader;
+  z->data = data;
+  z->n = 0;
+  z->p = NULL;
+}
+
+
+/* --------------------------------------------------------------- read --- */
+size_t luaZ_read (ZIO *z, void *b, size_t n) {
+  while (n) {
+    size_t m;
+    if (z->n == 0) {  /* no bytes in buffer? */
+      if (luaZ_fill(z) == EOZ)  /* try to read more */
+        return n;  /* no more input; return number of missing bytes */
+      else {
+        z->n++;  /* luaZ_fill consumed first byte; put it back */
+        z->p--;
+      }
+    }
+    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */
+    memcpy(b, z->p, m);
+    z->n -= m;
+    z->p += m;
+    b = (char *)b + m;
+    n -= m;
+  }
+  return 0;
+}
+
+/* ------------------------------------------------------------------------ */
+char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {
+  if (n > buff->buffsize) {
+    if (n < LUA_MINBUFFER) n = LUA_MINBUFFER;
+    luaZ_resizebuffer(L, buff, n);
+  }
+  return buff->buffer;
+}
+
+
diff --git a/dep/lualib/lzio.h b/dep/lualib/lzio.h
new file mode 100644
index 0000000..0868230
--- /dev/null
+++ b/dep/lualib/lzio.h
@@ -0,0 +1,65 @@
+/*
+** $Id: lzio.h,v 1.26 2011/07/15 12:48:03 roberto Exp $
+** Buffered streams
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lzio_h
+#define lzio_h
+
+#include "lua.h"
+
+#include "lmem.h"
+
+
+#define EOZ	(-1)			/* end of stream */
+
+typedef struct Zio ZIO;
+
+#define zgetc(z)  (((z)->n--)>0 ?  cast_uchar(*(z)->p++) : luaZ_fill(z))
+
+
+typedef struct Mbuffer {
+  char *buffer;
+  size_t n;
+  size_t buffsize;
+} Mbuffer;
+
+#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
+
+#define luaZ_buffer(buff)	((buff)->buffer)
+#define luaZ_sizebuffer(buff)	((buff)->buffsize)
+#define luaZ_bufflen(buff)	((buff)->n)
+
+#define luaZ_resetbuffer(buff) ((buff)->n = 0)
+
+
+#define luaZ_resizebuffer(L, buff, size) \
+	(luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), \
+	(buff)->buffsize = size)
+
+#define luaZ_freebuffer(L, buff)	luaZ_resizebuffer(L, buff, 0)
+
+
+LUAI_FUNC char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n);
+LUAI_FUNC void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader,
+                                        void *data);
+LUAI_FUNC size_t luaZ_read (ZIO* z, void* b, size_t n);	/* read next n bytes */
+
+
+
+/* --------- Private Part ------------------ */
+
+struct Zio {
+  size_t n;			/* bytes still unread */
+  const char *p;		/* current position in buffer */
+  lua_Reader reader;		/* reader function */
+  void* data;			/* additional data */
+  lua_State *L;			/* Lua state (for reader) */
+};
+
+
+LUAI_FUNC int luaZ_fill (ZIO *z);
+
+#endif
diff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt
index 646b89b..46c0259 100644
--- a/src/server/CMakeLists.txt
+++ b/src/server/CMakeLists.txt
@@ -27,6 +27,7 @@ if( SERVERS )
   add_subdirectory(authserver)
   add_subdirectory(scripts)
   add_subdirectory(worldserver)
+  add_subdirectory(LuaEngine)
 else()
   if( TOOLS )
     add_subdirectory(collision)
diff --git a/src/server/LuaEngine/AuraMethods.cpp b/src/server/LuaEngine/AuraMethods.cpp
new file mode 100644
index 0000000..593332c
--- /dev/null
+++ b/src/server/LuaEngine/AuraMethods.cpp
@@ -0,0 +1,134 @@
+#include "LuaEngine.h"
+#include "AuraMethods.h"
+
+int LuaAura::GetUnitType(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    sEluna->PushString(L, "Aura");
+    return 1;
+}
+
+int LuaAura::GetCaster(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    sEluna->PushUnit(L, aura->GetCaster());
+    return 1;
+}
+
+int LuaAura::GetCasterGUID(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    sEluna->PushULong(L, aura->GetCasterGUID());
+    return 1;
+}
+
+int LuaAura::GetCasterLevel(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    sEluna->PushUnsigned(L, aura->GetCasterLevel());
+    return 1;
+}
+
+int LuaAura::GetDuration(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    sEluna->PushInteger(L, aura->GetDuration());
+    return 1;
+}
+
+int LuaAura::GetCharges(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    sEluna->PushUnsigned(L, aura->GetCharges());
+    return 1;
+}
+
+int LuaAura::GetAuraId(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    sEluna->PushUnsigned(L, aura->GetId());
+    return 1;
+}
+
+int LuaAura::GetMaxDuration(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    sEluna->PushInteger(L, aura->GetMaxDuration());
+    return 1;
+}
+
+int LuaAura::GetStackAmount(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    sEluna->PushUnsigned(L, aura->GetStackAmount());
+    return 1;
+}
+
+int LuaAura::SetDuration(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    int duration = luaL_checkinteger(L, 1);
+    aura->SetDuration(duration, false);
+    return 0;
+}
+
+int LuaAura::SetMaxDuration(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    int duration = luaL_checkinteger(L, 1);
+    aura->SetMaxDuration(duration);
+    return 0;
+}
+
+int LuaAura::SetStackAmount(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    int amount = luaL_checkunsigned(L, 1);
+    aura->SetStackAmount(amount);
+    return 0;
+}
+
+int LuaAura::Remove(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    aura->Remove();
+    return 0;
+}
+
+int LuaAura::GetOwner(lua_State* L, Aura* aura)
+{
+    if (!aura)
+        return 0;
+
+    if (aura->GetType() != UNIT_AURA_TYPE)
+        return 0;
+
+    sEluna->PushUnit(L, aura->GetUnitOwner());
+    return 1;
+}
diff --git a/src/server/LuaEngine/AuraMethods.h b/src/server/LuaEngine/AuraMethods.h
new file mode 100644
index 0000000..a0249e3
--- /dev/null
+++ b/src/server/LuaEngine/AuraMethods.h
@@ -0,0 +1,21 @@
+#ifndef AURAMETHODS_H
+#define AURAMETHODS_H
+
+namespace LuaAura
+{
+    int GetUnitType(lua_State*, Aura*);
+    int GetCaster(lua_State*, Aura*);
+    int GetCasterGUID(lua_State*, Aura*);
+    int GetCasterLevel(lua_State*, Aura*);
+    int GetDuration(lua_State*, Aura*);
+    int GetCharges(lua_State*, Aura*);
+    int GetAuraId(lua_State*, Aura*);
+    int GetMaxDuration(lua_State*, Aura*);
+    int GetStackAmount(lua_State*, Aura*);
+    int SetDuration(lua_State*, Aura*);
+    int SetMaxDuration(lua_State*, Aura*);
+    int SetStackAmount(lua_State*, Aura*);
+    int Remove(lua_State*, Aura*);
+    int GetOwner(lua_State*, Aura*);
+};
+#endif
diff --git a/src/server/LuaEngine/CMakeLists.txt b/src/server/LuaEngine/CMakeLists.txt
new file mode 100644
index 0000000..0cd6a55
--- /dev/null
+++ b/src/server/LuaEngine/CMakeLists.txt
@@ -0,0 +1,135 @@
+# Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+if ( USE_COREPCH )
+  include_directories(${CMAKE_CURRENT_BINARY_DIR})
+  include_directories(${CMAKE_SOURCE_DIR})
+endif ()
+
+file(GLOB sources_localdir *.cpp *.h)
+
+set(LuaEngine_STAT_SRCS
+  ${LuaEngine_STAT_SRCS}
+  ${sources_localdir}
+)
+
+include_directories(
+  ${CMAKE_BINARY_DIR}
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
+  ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
+  ${CMAKE_SOURCE_DIR}/dep/SFMT
+  ${CMAKE_SOURCE_DIR}/dep/mersennetwister
+  ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/dep/lualib
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Database
+  ${CMAKE_SOURCE_DIR}/src/server/shared/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/CountedReference
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/LinkedReference
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Logging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Policies
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
+  ${CMAKE_SOURCE_DIR}/src/server/collision
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Models
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Database
+  ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Achievements
+  ${CMAKE_SOURCE_DIR}/src/server/game/Addons
+  ${CMAKE_SOURCE_DIR}/src/server/game/Handlers
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/CoreAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/EventAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat/Channels
+  ${CMAKE_SOURCE_DIR}/src/server/game/Conditions
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
+  ${CMAKE_SOURCE_DIR}/src/server/game/Combat
+  ${CMAKE_SOURCE_DIR}/src/server/game/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/game/DungeonFinding
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Corpse
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Creature
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/DynamicObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item/Container
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/GameObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object/Updates
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Pet
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Player
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Transport
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Unit
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Vehicle
+  ${CMAKE_SOURCE_DIR}/src/server/game/Events
+  ${CMAKE_SOURCE_DIR}/src/server/game/Globals
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Cells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Notifiers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Groups
+  ${CMAKE_SOURCE_DIR}/src/server/game/Guilds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Instances
+  ${CMAKE_SOURCE_DIR}/src/server/game/LookingForGroup
+  ${CMAKE_SOURCE_DIR}/src/server/game/Loot
+  ${CMAKE_SOURCE_DIR}/src/server/game/Mails
+  ${CMAKE_SOURCE_DIR}/src/server/game/Miscellaneous
+  ${CMAKE_SOURCE_DIR}/src/server/game/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/MovementGenerators
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Spline
+  ${CMAKE_SOURCE_DIR}/src/server/game/Opcodes
+  ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
+  ${CMAKE_SOURCE_DIR}/src/server/game/Pools
+  ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
+  ${CMAKE_SOURCE_DIR}/src/server/game/Quests
+  ${CMAKE_SOURCE_DIR}/src/server/game/Reputation
+  ${CMAKE_SOURCE_DIR}/src/server/game/Scripting
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol/Handlers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Skills
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
+  ${CMAKE_SOURCE_DIR}/src/server/game/Texts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tickets
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tools
+  ${CMAKE_SOURCE_DIR}/src/server/game/Weather
+  ${CMAKE_SOURCE_DIR}/src/server/game/World
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
+  ${ACE_INCLUDE_DIR}
+  ${MYSQL_INCLUDE_DIR}
+)
+
+add_library(LuaEngine STATIC 
+  ${LuaEngine_STAT_SRCS}
+  ${game_STAT_SRCS}
+  ${game_STAT_PCH_SRC}
+)
+
+target_link_libraries(LuaEngine
+  game
+)
+
+add_dependencies(LuaEngine game)
\ No newline at end of file
diff --git a/src/server/LuaEngine/GameObjectMethods.cpp b/src/server/LuaEngine/GameObjectMethods.cpp
new file mode 100644
index 0000000..a74eaba
--- /dev/null
+++ b/src/server/LuaEngine/GameObjectMethods.cpp
@@ -0,0 +1,537 @@
+#include "LuaEngine.h"
+#include "GameObjectMethods.h"
+
+int LuaGameObject::GetHeight(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    float x = luaL_checknumber(L, 1);
+    float y = luaL_checknumber(L, 2);
+
+    float z = go->GetMap()->GetHeight(go->GetPhaseMask(), x, y, MAX_HEIGHT);
+    if (z == INVALID_HEIGHT)
+        z = go->GetPositionZ();
+    sEluna->PushFloat(L, z);
+    return 1;
+}
+
+int LuaGameObject::GetRelativePoint(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    float dist = luaL_checknumber(L, 1);
+    int deg = luaL_checkinteger(L, 2);
+
+    float o = Position::NormalizeOrientation(go->GetOrientation() + (deg*M_PI/180));
+    sEluna->PushFloat(L, go->GetPositionX()+(dist*cosf(o)));
+    sEluna->PushFloat(L, go->GetPositionY()+(dist*sinf(o)));
+    sEluna->PushFloat(L, o);
+    return 3;
+}
+
+int LuaGameObject::GetUnitType(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushString(L, "GameObject");
+    return 1;
+}
+
+int LuaGameObject::GetGUID(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushULong(L, go->GetGUID());
+    return 1;
+}
+
+int LuaGameObject::CastSpell(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint32 spell = luaL_checkunsigned(L, 1);
+    Unit* target = sEluna->CHECK_UNIT(L, 2);
+    if (target)
+        go->CastSpell(target, spell);
+    return 0;
+}
+
+int LuaGameObject::GetX(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushFloat(L, go->GetPositionX());
+    return 1;
+}
+
+int LuaGameObject::GetY(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushFloat(L, go->GetPositionY());
+    return 1;
+}
+
+int LuaGameObject::GetZ(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushFloat(L, go->GetPositionZ());
+    return 1;
+}
+
+int LuaGameObject::GetO(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushFloat(L, go->GetOrientation());
+    return 1;
+}
+
+int LuaGameObject::GetLocation(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushFloat(L, go->GetPositionX());
+    sEluna->PushFloat(L, go->GetPositionY());
+    sEluna->PushFloat(L, go->GetPositionZ());
+    sEluna->PushFloat(L, go->GetOrientation());
+    return 4;
+}
+
+int LuaGameObject::GetMapId(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushFloat(L, go->GetMapId());
+    return 1;
+}
+
+int LuaGameObject::GetZoneId(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushFloat(L, go->GetZoneId());
+    return 1;
+}
+
+int LuaGameObject::GetAreaId(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushFloat(L, go->GetAreaId());
+    return 1;
+}
+
+int LuaGameObject::GetName(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushString(L, go->GetName().c_str());
+    return 1;
+}
+
+int LuaGameObject::GetEntry(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushUnsigned(L, go->GetEntry());
+    return 1;
+}
+
+int LuaGameObject::SummonCreature(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+    float x = luaL_checknumber(L, 2);
+    float y = luaL_checknumber(L, 3);
+    float z = luaL_checknumber(L, 4);
+    float o = luaL_checknumber(L, 5);
+    uint32 despawn = luaL_optunsigned(L, 6, 0);
+
+    TempSummonType summontype;
+    if (despawn)
+        summontype = TEMPSUMMON_TIMED_OR_DEAD_DESPAWN;
+    else
+        summontype = TEMPSUMMON_MANUAL_DESPAWN;
+    sEluna->PushUnit(L, go->SummonCreature(entry, x, y, z, o, summontype, despawn));
+    return 1;
+}
+
+int LuaGameObject::SummonGameObject(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+    float x = luaL_checknumber(L, 2);
+    float y = luaL_checknumber(L, 3);
+    float z = luaL_checknumber(L, 4);
+    float o = luaL_checknumber(L, 5);
+    uint32 respawnDelay = luaL_optunsigned(L, 6, 30);
+    sEluna->PushGO(L, go->SummonGameObject(entry, x, y, z, o, 0, 0, 0, 0, respawnDelay));
+    return 1;
+}
+
+int LuaGameObject::Despawn(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    go->RemoveFromWorld();
+    return 0;
+}
+
+int LuaGameObject::GetDisplayId(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushUnsigned(L, go->GetDisplayId());
+    return 1;
+}
+
+int LuaGameObject::GetScale(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushFloat(L, go->GetObjectSize());
+    return 1;
+}
+
+int LuaGameObject::IsInWorld(lua_State* L, GameObject* go)
+{
+    if (!go)
+        sEluna->PushBoolean(L, false);
+    else
+        sEluna->PushBoolean(L, go->IsInWorld());
+    return 1;
+}
+
+int LuaGameObject::HasQuest(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        sEluna->PushBoolean(L, false);
+    else
+    {
+        uint32 questId = luaL_checkunsigned(L, 1);
+        sEluna->PushBoolean(L, go->hasQuest(questId));
+    }
+    return 1;
+}
+
+int LuaGameObject::IsInvisibleDueToDespawn(lua_State* L, GameObject * go)
+{
+    if (!go || !go->IsInWorld())
+        sEluna->PushBoolean(L, false);
+    else
+    {
+        sEluna->PushBoolean(L, go->IsInvisibleDueToDespawn());
+    }
+    return 1;
+}
+
+int LuaGameObject::IsTransport(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        sEluna->PushBoolean(L, false);
+    else
+        sEluna->PushBoolean(L, go->IsTransport());
+    return 1;
+}
+
+int LuaGameObject::IsDestructible(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        sEluna->PushBoolean(L, false);
+    else
+        sEluna->PushBoolean(L, go->IsDestructibleBuilding());
+    return 1;
+}
+
+int LuaGameObject::IsActive(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        sEluna->PushBoolean(L, false);
+    else
+        sEluna->PushBoolean(L, go->isActiveObject());
+    return 1;
+}
+
+int LuaGameObject::Move(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    float x = luaL_checknumber(L, 1);
+    float y = luaL_checknumber(L, 2);
+    float z = luaL_checknumber(L, 3);
+    float o = luaL_checknumber(L, 4);
+    go->Relocate(x, y, z, o);
+    return 0;
+}
+
+int LuaGameObject::SetScale(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    float scale = luaL_checknumber(L, 1);
+    go->SetObjectScale(scale);
+    return 0;
+}
+
+int LuaGameObject::RegisterEvent(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    luaL_checktype(L, 1, LUA_TFUNCTION);
+    uint32 delay = luaL_checkunsigned(L, 2);
+    uint32 repeats = luaL_checkunsigned(L, 3);
+
+    lua_settop(L, 1);
+    Eluna::LuaEventMap* eventMap = Eluna::LuaEventMap::GetEvents(go);
+    if (!eventMap)
+    {
+        luaL_error(L, "You need to use RegisterGameObjectEvent for the gameobject first");
+        return 0;
+    }
+
+    int functionRef = lua_ref(L, true);
+    eventMap->ScriptEventCreate(functionRef, delay, repeats);
+    sEluna->PushInteger(L, functionRef);
+    return 1;
+}
+
+int LuaGameObject::RemoveEventById(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    int eventID = luaL_checkinteger(L, 1);
+    Eluna::LuaEventMap* eventMap = Eluna::LuaEventMap::GetEvents(go);
+    if (eventMap)
+        eventMap->ScriptEventCancel(eventID);
+    return 0;
+}
+
+int LuaGameObject::RemoveEvents(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    Eluna::LuaEventMap* eventMap = Eluna::LuaEventMap::GetEvents(go);
+    if (eventMap)
+        eventMap->ScriptEventsReset();
+    return 0;
+}
+
+int LuaGameObject::GetInt32Value(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    sEluna->PushInteger(L, go->GetInt32Value(index));
+    return 1;
+}
+
+int LuaGameObject::GetUInt32Value(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    sEluna->PushUnsigned(L, go->GetUInt32Value(index));
+    return 1;
+}
+
+int LuaGameObject::GetFloatValue(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    sEluna->PushFloat(L, go->GetFloatValue(index));
+    return 1;
+}
+
+int LuaGameObject::GetByteValue(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint8 offset = luaL_checkunsigned(L, 2);
+    sEluna->PushUnsigned(L, go->GetByteValue(index, offset));
+    return 1;
+}
+
+int LuaGameObject::GetUInt16Value(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint8 offset = luaL_checkunsigned(L, 2);
+    sEluna->PushUnsigned(L, go->GetUInt16Value(index, offset));
+    return 1;
+}
+
+int LuaGameObject::SetInt32Value(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    int32 value = luaL_checkinteger(L, 2);
+    go->SetInt32Value(index, value);
+    return 0;
+}
+
+int LuaGameObject::SetUInt32Value(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint32 value = luaL_checkunsigned(L, 2);
+    go->SetUInt32Value(index, value);
+    return 0;
+}
+
+int LuaGameObject::UpdateUInt32Value(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint32 value = luaL_checkunsigned(L, 2);
+    go->UpdateUInt32Value(index, value);
+    return 0;
+}
+
+int LuaGameObject::SetFloatValue(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    float value = luaL_checknumber(L, 2);
+    go->SetFloatValue(index, value);
+    return 0;
+}
+
+int LuaGameObject::SetByteValue(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint8 offset = luaL_checkunsigned(L, 2);
+    uint8 value = luaL_checkunsigned(L, 3);
+    go->SetByteValue(index, offset, value);
+    return 0;
+}
+
+int LuaGameObject::SetUInt16Value(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint8 offset = luaL_checkunsigned(L, 2);
+    uint16 value = luaL_checkunsigned(L, 3);
+    go->SetUInt16Value(index, offset, value);
+    return 0;
+}
+
+int LuaGameObject::SetInt16Value(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint8 offset = luaL_checkunsigned(L, 2);
+    int16 value = luaL_checkinteger(L, 3);
+    go->SetInt16Value(index, offset, value);
+    return 0;
+}
+
+int LuaGameObject::GetGUIDLow(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    sEluna->PushUnsigned(L, go->GetGUIDLow());
+    return 1;
+}
+
+int LuaGameObject::GetNearestPlayer(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    float distance = luaL_optnumber(L, 1, SIZE_OF_GRIDS);
+
+    Player* target = NULL;
+    Eluna::NearestTypeWithEntryInRangeCheck checker(go, distance, TYPEID_PLAYER);
+    Trinity::PlayerLastSearcher<Eluna::NearestTypeWithEntryInRangeCheck> searcher(go, target, checker);
+    go->VisitNearbyObject(distance, searcher);
+
+    sEluna->PushUnit(L, target);
+    return 1;
+}
+
+int LuaGameObject::GetNearestGameObject(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint32 entry = luaL_optunsigned(L, 1, 0);
+    float range = luaL_optnumber(L, 2, SIZE_OF_GRIDS);
+
+    GameObject* target = NULL;
+    Eluna::NearestTypeWithEntryInRangeCheck checker(go, range, TYPEID_GAMEOBJECT, entry);
+    Trinity::GameObjectLastSearcher<Eluna::NearestTypeWithEntryInRangeCheck> searcher(go, target, checker);
+    go->VisitNearbyGridObject(range, searcher);
+
+    sEluna->PushGO(L, target);
+    return 1;
+}
+
+int LuaGameObject::GetNearestCreature(lua_State* L, GameObject* go)
+{
+    if (!go || !go->IsInWorld())
+        return 0;
+
+    uint32 entry = luaL_optunsigned(L, 1, 0);
+    float range = luaL_optnumber(L, 2, SIZE_OF_GRIDS);
+
+    Creature* target = NULL;
+    Eluna::NearestTypeWithEntryInRangeCheck checker(go, range, TYPEID_UNIT, entry);
+    Trinity::CreatureLastSearcher<Eluna::NearestTypeWithEntryInRangeCheck> searcher(go, target, checker);
+    go->VisitNearbyGridObject(range, searcher);
+
+    sEluna->PushUnit(L, target);
+    return 1;
+}
diff --git a/src/server/LuaEngine/GameObjectMethods.h b/src/server/LuaEngine/GameObjectMethods.h
new file mode 100644
index 0000000..ebd847f
--- /dev/null
+++ b/src/server/LuaEngine/GameObjectMethods.h
@@ -0,0 +1,54 @@
+#ifndef GAMEOBJECTMETHODS_H
+#define GAMEOBJECTMETHODS_H
+
+namespace LuaGameObject
+{
+    int GetHeight(lua_State*, GameObject*);
+    int GetRelativePoint(lua_State*, GameObject*);
+    int GetUnitType(lua_State*, GameObject*);
+    int GetGUID(lua_State*, GameObject*);
+    int CastSpell(lua_State*, GameObject*);
+    int GetX(lua_State*, GameObject*);
+    int GetY(lua_State*, GameObject*);
+    int GetZ(lua_State*, GameObject*);
+    int GetO(lua_State*, GameObject*);
+    int GetLocation(lua_State*, GameObject*);
+    int GetMapId(lua_State*, GameObject*);
+    int GetZoneId(lua_State*, GameObject*);
+    int GetAreaId(lua_State*, GameObject*);
+    int GetName(lua_State*, GameObject*);
+    int GetEntry(lua_State*, GameObject*);
+    int SummonCreature(lua_State*, GameObject*);
+    int SummonGameObject(lua_State*, GameObject*);
+    int Despawn(lua_State*, GameObject*);
+    int GetDisplayId(lua_State*, GameObject*);
+    int GetScale(lua_State*, GameObject*);
+    int IsInWorld(lua_State*, GameObject*);
+    int HasQuest(lua_State*, GameObject*);
+    int IsInvisibleDueToDespawn(lua_State*, GameObject*);
+    int IsTransport(lua_State*, GameObject*);
+    int IsDestructible(lua_State*, GameObject*);
+    int IsActive(lua_State*, GameObject*);
+    int Move(lua_State*, GameObject*);
+    int SetScale(lua_State*, GameObject*);
+    int RegisterEvent(lua_State*, GameObject*);
+    int RemoveEventById(lua_State*, GameObject*);
+    int RemoveEvents(lua_State*, GameObject*);
+    int GetInt32Value(lua_State*, GameObject*);
+    int GetUInt32Value(lua_State*, GameObject*);
+    int GetFloatValue(lua_State*, GameObject*);
+    int GetByteValue(lua_State*, GameObject*);
+    int GetUInt16Value(lua_State*, GameObject*);
+    int SetInt32Value(lua_State*, GameObject*);
+    int SetUInt32Value(lua_State*, GameObject*);
+    int UpdateUInt32Value(lua_State*, GameObject*);
+    int SetFloatValue(lua_State*, GameObject*);
+    int SetByteValue(lua_State*, GameObject*);
+    int SetUInt16Value(lua_State*, GameObject*);
+    int SetInt16Value(lua_State*, GameObject*);
+    int GetGUIDLow(lua_State*, GameObject*);
+    int GetNearestPlayer(lua_State*, GameObject*);
+    int GetNearestGameObject(lua_State*, GameObject*);
+    int GetNearestCreature(lua_State*, GameObject*);
+};
+#endif
diff --git a/src/server/LuaEngine/GlobalMethods.h b/src/server/LuaEngine/GlobalMethods.h
new file mode 100644
index 0000000..6649d1e
--- /dev/null
+++ b/src/server/LuaEngine/GlobalMethods.h
@@ -0,0 +1,1022 @@
+#include "MapManager.h"
+#include "SharedDefines.h"
+#include "Guild.h"
+#include "GuildMgr.h"
+#include "AccountMgr.h"
+
+#ifndef GLOBALMETHODS_H
+#define GLOBALMETHODS_H
+
+namespace LuaGlobalFunctions
+{
+    // RegisterServerHook(event, function)
+    static int RegisterServerHook(lua_State* L)
+    {
+        lua_settop(L, 2);
+        uint32 ev = luaL_checkunsigned(L, 1);
+        if (ev == 0)
+        {
+            luaL_error(L, "0 is not a valid event");
+            return 0;
+        }
+        luaL_checktype(L, lua_gettop(L), LUA_TFUNCTION);
+
+        int functionRef  = lua_ref(L, true);
+        if (functionRef > 0)
+            sEluna->Register(REGTYPE_SERVER, 0, ev, functionRef);
+        return 0;
+    }
+
+    //RegisterCreatureGossipEvent(entry, event, function)
+    static int RegisterCreatureGossipEvent(lua_State* L)
+    {
+        lua_settop(L, 3);
+        uint32 entry = luaL_checkunsigned(L, 1);
+        uint32 ev = luaL_checkunsigned(L, 2);
+        if (ev == 0)
+        {
+            luaL_error(L, "0 is not a valid event");
+            return 0;
+        }
+        luaL_checktype(L, lua_gettop(L), LUA_TFUNCTION);
+
+        int functionRef  = lua_ref(L, true);
+        if (functionRef > 0)
+            sEluna->Register(REGTYPE_CREATURE_GOSSIP, entry, ev, functionRef);
+        return 0;
+    }
+
+    // RegisterGameObjectGossipEvent(entry, event, function)
+    static int RegisterGameObjectGossipEvent(lua_State* L)
+    {
+        lua_settop(L, 3);
+        uint32 entry = luaL_checkunsigned(L, 1);
+        uint32 ev = luaL_checkunsigned(L, 2);
+        if (ev == 0)
+        {
+            luaL_error(L, "0 is not a valid event");
+            return 0;
+        }
+        luaL_checktype(L, lua_gettop(L), LUA_TFUNCTION);
+
+        int functionRef  = lua_ref(L, true);
+        if (functionRef > 0)
+            sEluna->Register(REGTYPE_GAMEOBJECT_GOSSIP, entry, ev, functionRef);
+        return 0;
+    }
+
+    // RegisterItemEvent(entry, event, function)
+    static int RegisterItemEvent(lua_State* L)
+    {
+        lua_settop(L, 3);
+        uint32 entry = luaL_checkunsigned(L, 1);
+        uint32 ev = luaL_checkunsigned(L, 2);
+        if (ev == 0)
+        {
+            luaL_error(L, "0 is not a valid event");
+            return 0;
+        }
+        luaL_checktype(L, lua_gettop(L), LUA_TFUNCTION);
+
+        int functionRef  = lua_ref(L, true);
+        if (functionRef > 0)
+            sEluna->Register(REGTYPE_ITEM, entry, ev, functionRef);
+        return 0;
+    }
+
+    // RegisterItemGossipEvent(entry, event, function)
+    static int RegisterItemGossipEvent(lua_State* L)
+    {
+        lua_settop(L, 3);
+        uint32 entry = luaL_checkunsigned(L, 1);
+        uint32 ev = luaL_checkunsigned(L, 2);
+        if (ev == 0)
+        {
+            luaL_error(L, "0 is not a valid event");
+            return 0;
+        }
+        luaL_checktype(L, lua_gettop(L), LUA_TFUNCTION);
+
+        int functionRef  = lua_ref(L, true);
+        if (functionRef > 0)
+            sEluna->Register(REGTYPE_ITEM_GOSSIP, entry, ev, functionRef);
+        return 0;
+    }
+
+    // RegisterPlayerGossipEvent(menu_id, event, function)
+    static int RegisterPlayerGossipEvent(lua_State* L)
+    {
+        lua_settop(L, 3);
+        uint32 menu_id = luaL_checkunsigned(L, 1);
+        uint32 ev = luaL_checkunsigned(L, 2);
+        if (ev == 0)
+        {
+            luaL_error(L, "0 is not a valid event");
+            return 0;
+        }
+        luaL_checktype(L, lua_gettop(L), LUA_TFUNCTION);
+
+        int functionRef  = lua_ref(L, true);
+        if (functionRef > 0)
+            sEluna->Register(REGTYPE_PLAYER_GOSSIP, menu_id, ev, functionRef);
+        return 0;
+    }
+
+    // RegisterCreatureEvent(entry, event, function)
+    static int RegisterCreatureEvent(lua_State* L)
+    {
+        lua_settop(L, 3);
+        uint32 entry = luaL_checkunsigned(L, 1);
+        uint32 ev = luaL_checkunsigned(L, 2);
+        if (ev == 0)
+        {
+            luaL_error(L, "0 is not a valid event");
+            return 0;
+        }
+        luaL_checktype(L, lua_gettop(L), LUA_TFUNCTION);
+
+        int functionRef  = lua_ref(L, true);
+        if (functionRef > 0)
+            sEluna->Register(REGTYPE_CREATURE, entry, ev, functionRef);
+        return 0;
+    }
+
+    // RegisterGameObjectEvent(entry, event, function)
+    static int RegisterGameObjectEvent(lua_State* L)
+    {
+        lua_settop(L, 3);
+        uint32 entry = luaL_checkunsigned(L, 1);
+        uint32 ev = luaL_checkunsigned(L, 2);
+        if (ev == 0)
+        {
+            luaL_error(L, "0 is not a valid event");
+            return 0;
+        }
+        luaL_checktype(L, lua_gettop(L), LUA_TFUNCTION);
+
+        int functionRef  = lua_ref(L, true);
+        if (functionRef > 0)
+            sEluna->Register(REGTYPE_GAMEOBJECT, entry, ev, functionRef);
+        return 0;
+    }
+
+    // GetLuaEngine() - Gets lua engine name
+    static int GetLuaEngine(lua_State* L)
+    {
+        sEluna->PushString(L, "ElunaEngine");
+        return 1;
+    }
+
+    // ReloadEluna() - Gets core version as a string
+    static int GetCoreVersion(lua_State* L)
+    {
+        sEluna->PushString(L, _FULLVERSION);
+        return 1;
+    }
+
+    // GetQuest(questId)
+    static int GetQuest(lua_State* L)
+    {
+        uint32 questId = luaL_checkunsigned(L, 1);
+        if (!questId)
+            return 0;
+
+        sEluna->PushQuest(L, sObjectMgr->GetQuestTemplate(questId));
+        return 1;
+    }
+
+    // ReloadEluna() - Reloads eluna
+    static int ReloadEluna(lua_State* L)
+    {
+        sEluna->StartEluna(true);
+        return 0;
+    }
+
+    // GetPlayerByGUID(guid) - Gets Player object by its guid
+    static int GetPlayerByGUID(lua_State* L)
+    {
+        uint64 guid = sEluna->CHECK_ULONG(L, 1);
+        sEluna->PushUnit(L, sObjectAccessor->FindPlayer(guid));
+        return 1;
+    }
+
+    // GetPlayerByName("name") - Gets player object by name
+    static int GetPlayerByName(lua_State* L)
+    {
+        const char* message = luaL_checkstring(L, 1);
+        sEluna->PushUnit(L, sObjectAccessor->FindPlayerByName(message));
+        return 1;
+    }
+
+    // GetGameTime() - Gets ingame time as seconds (server time?)
+    static int GetGameTime(lua_State* L)
+    {
+        sEluna->PushUnsigned(L, sWorld->GetGameTime());
+        return 1;
+    }
+
+    // SendWorldMessage("msg") - Sends a broadcast message to everyone
+    static int SendWorldMessage(lua_State* L)
+    {
+        const char* message = luaL_checkstring(L, 1);
+        sWorld->SendServerMessage(SERVER_MSG_STRING, message);
+        return 0;
+    }
+
+    // GetPlayersInWorld([team, onlyGM]) - Gets a table with players in world. Team can be 0 for ally, 1 for horde and 2 for both.
+    static int GetPlayersInWorld(lua_State* L)
+    {
+        uint32 team = luaL_optunsigned(L, 1, TEAM_NEUTRAL);
+        bool onlyGM = luaL_optbool(L, 2, false);
+
+        lua_newtable(L);
+        int tbl = lua_gettop(L);
+        uint32 i = 0;
+
+        SessionMap const& sessions = sWorld->GetAllSessions();
+        for (SessionMap::const_iterator it = sessions.begin(); it != sessions.end(); ++it)
+        {
+            if (Player* player = it->second->GetPlayer())
+            {
+                if (player->GetSession() && ((team >= TEAM_NEUTRAL || player->GetTeamId() == team) && (!onlyGM || player->IsGameMaster())))
+                {
+                    ++i;
+                    sEluna->PushUnsigned(L, i);
+                    sEluna->PushUnit(L, player);
+                    lua_settable(L, tbl);
+                }
+            }
+        }
+
+        lua_settop(L, tbl); // push table to top of stack
+        return 1;
+    }
+
+    // GetPlayersInMap(mapid[, instanceid, team]) - Gets a table with players in the map. Instanceid optional (0 for normal map). Team can be 0 for ally, 1 for horde and 2 for both
+    static int GetPlayersInMap(lua_State* L)
+    {
+        uint32 mapID = luaL_checkunsigned(L, 1);
+        uint32 instanceID = luaL_optunsigned(L, 2, 0);
+        uint32 team = luaL_optunsigned(L, 3, TEAM_NEUTRAL);
+
+        Map* map = sMapMgr->FindMap(mapID, instanceID);
+        if (!map)
+            return 0;
+
+        lua_newtable(L);
+        int tbl = lua_gettop(L);
+        uint32 i = 0;
+
+        Map::PlayerList const& players = map->GetPlayers();
+        for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+        {
+            Player* player = itr->GetSource();
+            if (!player)
+                continue;
+            if (player->GetSession() && (team >= TEAM_NEUTRAL || player->GetTeamId() == team))
+            {
+                ++i;
+                sEluna->PushUnsigned(L, i);
+                sEluna->PushUnit(L, player);
+                lua_settable(L, tbl);
+            }
+        }
+
+        lua_settop(L, tbl);
+        return 1;
+    }
+
+    // WorldDBQuery("sql") - Executes SQL to world database and returns the query Result or nil (instant)
+    static int WorldDBQuery(lua_State* L)
+    {
+        const char* query = luaL_checkstring(L, 1);
+        if (!query)
+            return 0;
+
+        QueryResult Result = WorldDatabase.Query(query);
+        if (!Result)
+            return 0;
+
+        sEluna->PushQueryResult(L, new QueryResult(Result));
+        return 1;
+    }
+
+    // WorldDBExecute("sql") - Executes SQL to world database (not instant)
+    static int WorldDBExecute(lua_State* L)
+    {
+        const char* query = luaL_checkstring(L, 1);
+        if (!query)
+            return 0;
+
+        WorldDatabase.Execute(query);
+        return 0;
+    }
+
+    // CharDBQuery("sql") - Executes SQL to characters database and returns the query Result or nil (instant)
+    static int CharDBQuery(lua_State* L)
+    {
+        const char* query = luaL_checkstring(L, 1);
+        if (!query)
+            return 0;
+
+        QueryResult Result = CharacterDatabase.Query(query);
+        if (!Result)
+            return 0;
+
+        sEluna->PushQueryResult(L, new QueryResult(Result));
+        return 1;
+    }
+
+    // CharDBExecute("sql") - Executes SQL to characters database (not instant)
+    static int CharDBExecute(lua_State* L)
+    {
+        const char* query = luaL_checkstring(L, 1);
+        if (!query)
+            return 0;
+
+        CharacterDatabase.Execute(query);
+        return 0;
+    }
+
+    // AuthDBQuery("sql") - Executes SQL to auth database and returns the query Result or nil (instant)
+    static int AuthDBQuery(lua_State* L)
+    {
+        const char* query = luaL_checkstring(L, 1);
+        if (!query)
+            return 0;
+
+        QueryResult Result = LoginDatabase.Query(query);
+        if (!Result)
+            return 0;
+
+        sEluna->PushQueryResult(L, new QueryResult(Result));
+        return 1;
+    }
+
+    // AuthDBExecute("sql") - Executes SQL to auth database (not instant)
+    static int AuthDBExecute(lua_State* L)
+    {
+        const char* query = luaL_checkstring(L, 1);
+        if (!query)
+            return 0;
+
+        LoginDatabase.Execute(query);
+        return 0;
+    }
+
+    // GetGuildByName("name") - Gets guild object
+    static int GetGuildByName(lua_State* L)
+    {
+        const char* name = luaL_checkstring(L, 1);
+        sEluna->PushGuild(L, sGuildMgr->GetGuildByName(name));
+        return 1;
+    }
+
+    // GetGuildByLeaderGUID(leaderGUID) - Gets guild object
+    static int GetGuildByLeaderGUID(lua_State* L)
+    {
+        uint64 guid = sEluna->CHECK_ULONG(L, 1);
+        sEluna->PushGuild(L, sGuildMgr->GetGuildByLeader(guid));
+        return 1;
+    }
+
+    // GetPlayerCount() - Gets server player count
+    static int GetPlayerCount(lua_State* L)
+    {
+        sEluna->PushUnsigned(L, sWorld->GetPlayerCount());
+        return 1;
+    }
+
+    // FindUnit(guid)
+    static int FindUnit(lua_State* L)
+    {
+        uint64 guid = sEluna->CHECK_ULONG(L, 1);
+        sEluna->PushUnit(L, sObjectAccessor->FindUnit(guid));
+        return 1;
+    }
+
+    // GetPlayerGUID(lowguid)
+    static int GetPlayerGUID(lua_State* L)
+    {
+        uint32 lowguid = luaL_checkunsigned(L, 1);
+        sEluna->PushULong(L, MAKE_NEW_GUID(lowguid, 0, HIGHGUID_PLAYER));
+        return 1;
+    }
+
+    // GetItemGUID(lowguid)
+    static int GetItemGUID(lua_State* L)
+    {
+        uint32 lowguid = luaL_checkunsigned(L, 1);
+        sEluna->PushULong(L, MAKE_NEW_GUID(lowguid, 0, HIGHGUID_ITEM));
+        return 1;
+    }
+
+    // GetObjectGUID(lowguid, entry)
+    static int GetObjectGUID(lua_State* L)
+    {
+        uint32 lowguid = luaL_checkunsigned(L, 1);
+        uint32 entry = luaL_checkunsigned(L, 2);
+        sEluna->PushULong(L, MAKE_NEW_GUID(lowguid, entry, HIGHGUID_GAMEOBJECT));
+        return 1;
+    }
+
+    // GetUnitGUID(lowguid, entry)
+    static int GetUnitGUID(lua_State* L)
+    {
+        uint32 lowguid = luaL_checkunsigned(L, 1);
+        uint32 entry = luaL_checkunsigned(L, 2);
+        sEluna->PushULong(L, MAKE_NEW_GUID(lowguid, entry, HIGHGUID_UNIT));
+        return 1;
+    }
+
+    // CreateLuaEvent(function, delay, calls) - Creates a timed event. Calls set to 0 will call inf returns eventID.
+    static int CreateLuaEvent(lua_State* L)
+    {
+        luaL_checktype(L, 1, LUA_TFUNCTION);
+        uint32 delay = luaL_checkunsigned(L, 2);
+        uint32 repeats = luaL_checkunsigned(L, 3);
+
+        lua_settop(L, 1);
+        int functionRef = lua_ref(L, true);
+        sEluna->LuaWorldAI->ScriptEventCreate(functionRef, delay, repeats);
+        sEluna->PushInteger(L, functionRef);
+        return 1;
+    }
+
+    // DestroyEventByID(eventID) - removes all global lua events with eventid
+    static int DestroyEventByID(lua_State* L)
+    {
+        int functionRef = luaL_checkinteger(L, 1);
+        sEluna->LuaWorldAI->ScriptEventCancel(functionRef);
+        return 0;
+    }
+
+    // DestroyEvents([all_events]) - removes all global lua events, if all_events is true, removes creature and gameobject events too
+    static int DestroyEvents(lua_State* L)
+    {
+        bool all_Events = luaL_optbool(L, 1, false);
+
+        if (all_Events)
+        {
+            Eluna::LuaEventMap::ScriptEventsResetAll();
+            Eluna::LuaEventData::RemoveAll();
+        }
+        else
+            sEluna->LuaWorldAI->ScriptEventsReset();
+        return 0;
+    }
+
+    // PerformIngameSpawn(spawntype, entry, mapid, instanceid, x, y, z, o[, save, DurOrResptime, phase])
+    // spawntype: 1 Creature, 2 Object. DurOrResptime is respawntime for gameobjects and despawntime for creatures if creature is not saved
+    static int PerformIngameSpawn(lua_State* L)
+    {
+        int spawntype = luaL_checkinteger(L, 1);
+        uint32 entry = luaL_checkunsigned(L, 2);
+        uint32 mapID = luaL_checkunsigned(L, 3);
+        uint32 instanceID = luaL_checkunsigned(L, 4);
+        float x = luaL_checknumber(L, 5);
+        float y = luaL_checknumber(L, 6);
+        float z = luaL_checknumber(L, 7);
+        float o = luaL_checknumber(L, 8);
+        bool save = luaL_optbool(L, 9, false);
+        uint32 durorresptime = luaL_optunsigned(L, 10, 0);
+        uint32 phase = luaL_optunsigned(L, 11, PHASEMASK_NORMAL);
+        if (!phase)
+            return 0;
+
+        Map* map = sMapMgr->FindMap(mapID, instanceID);
+        if (!map)
+            return 0;
+
+        Position pos = {x,y,z,o};
+
+        if (spawntype == 1) // spawn creature
+        {
+            if (save)
+            {
+                Creature* creature = new Creature();
+                if (!creature->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_UNIT), map, phase, entry, 0, 0, x, y, z, o))
+                {
+                    delete creature;
+                    return 0;
+                }
+
+                creature->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), phase);
+
+                uint32 db_lowguid = creature->GetDBTableGUIDLow();
+                if (!creature->LoadCreatureFromDB(db_lowguid, map))
+                {
+                    delete creature;
+                    return 0;
+                }
+
+                sObjectMgr->AddCreatureToGrid(db_lowguid, sObjectMgr->GetCreatureData(db_lowguid));
+                sEluna->PushUnit(L, creature);
+            }
+            else
+            {
+                TempSummon* creature = map->SummonCreature(entry, pos, NULL, durorresptime);
+                if (!creature)
+                    return 0;
+
+                if (durorresptime)
+                    creature->SetTempSummonType(TEMPSUMMON_TIMED_OR_DEAD_DESPAWN);
+                else
+                    creature->SetTempSummonType(TEMPSUMMON_MANUAL_DESPAWN);
+
+                sEluna->PushUnit(L, creature);
+            }
+
+            return 1;
+        }
+
+        if (spawntype == 2) // Spawn object
+        {
+
+            const GameObjectTemplate* objectInfo = sObjectMgr->GetGameObjectTemplate(entry);
+            if (!objectInfo)
+                return 0;
+
+            if (objectInfo->displayId && !sGameObjectDisplayInfoStore.LookupEntry(objectInfo->displayId))
+                return 0;
+
+            GameObject* object = new GameObject;
+            uint32 lowguid = sObjectMgr->GenerateLowGuid(HIGHGUID_GAMEOBJECT);
+
+            if (!object->Create(lowguid, objectInfo->entry, map, phase, x, y, z, o, 0.0f, 0.0f, 0.0f, 0.0f, 0, GO_STATE_READY))
+            {
+                delete object;
+                return 0;
+            }
+
+            if (durorresptime)
+                object->SetRespawnTime(durorresptime);
+
+            if (save)
+            {
+                // fill the gameobject data and save to the db
+                object->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), phase);
+
+                // this will generate a new lowguid if the object is in an instance
+                if (!object->LoadGameObjectFromDB(lowguid, map))
+                {
+                    delete object;
+                    return false;
+                }
+
+                sObjectMgr->AddGameobjectToGrid(lowguid, sObjectMgr->GetGOData(lowguid));
+            }
+            else
+                map->AddToMap(object);
+            sEluna->PushGO(L, object);
+            return 1;
+        }
+
+        return 0;
+    }
+
+    // CreatePacket(opcode, size)
+    static int CreatePacket(lua_State* L)
+    {
+        uint16 opcode = luaL_checkunsigned(L, 1);
+        size_t size = luaL_checkunsigned(L, 2);
+
+        if (opcode >= NUM_MSG_TYPES)
+            luaL_error(L, "Invalid opcode type (%d)", opcode);
+        else
+        {
+            WorldPacket* _packet = new WorldPacket(opcode, size);
+            sEluna->PushPacket(L, _packet);
+            return 1;
+        }
+        return 0;
+    }
+
+    // AddVendorItem(entry, itemId, maxcount, incrtime, extendedcost[, persist(bool)])
+    static int AddVendorItem(lua_State* L)
+    {
+        uint32 entry = luaL_checkunsigned(L, 1);
+        uint32 item = luaL_checkunsigned(L, 2);
+        int maxcount = luaL_checkinteger(L, 3);
+        uint32 incrtime = luaL_checkunsigned(L, 4);
+        uint32 extendedcost = luaL_checkunsigned(L, 5);
+        bool persist = luaL_optbool(L, 6, true);
+        if (!sObjectMgr->GetCreatureTemplate(entry))
+        {
+            luaL_error(L, "Couldn't find a creature with (ID: %d)!", entry);
+            return 0;
+        }
+
+        if (!sObjectMgr->IsVendorItemValid(entry, item, maxcount, incrtime, extendedcost))
+            return 0;
+        sObjectMgr->AddVendorItem(entry, item, maxcount, incrtime, extendedcost, persist);
+        return 0;
+    }
+
+    // VendorRemoveItem(entry, item[, persist(bool)])
+    static int VendorRemoveItem(lua_State* L)
+    {
+        uint32 entry = luaL_checkunsigned(L, 1);
+        uint32 item = luaL_checkunsigned(L, 2);
+        bool persist = luaL_optbool(L, 3, true);
+        if (!sObjectMgr->GetCreatureTemplate(entry))
+        {
+            luaL_error(L, "Couldn't find a creature with (ID: %d)!", entry);
+            return 0;
+        }
+
+        sObjectMgr->RemoveVendorItem(entry, item, persist);
+        return 0;
+    }
+
+    // VendorRemoveAllItems(entry, persist(bool))
+    static int VendorRemoveAllItems(lua_State* L)
+    {
+        uint32 entry = luaL_checkunsigned(L, 1);
+        bool persist = luaL_optbool(L, 2, true);
+
+        VendorItemData const* items = sObjectMgr->GetNpcVendorItemList(entry);
+        if (!items || items->Empty())
+            return 0;
+
+        for (VendorItemList::const_iterator itr = items->m_items.begin(); itr != items->m_items.end(); ++itr)
+            sObjectMgr->RemoveVendorItem(entry, (*itr)->item, persist);
+        return 0;
+    }
+
+    // Kick(player)
+    static int Kick(lua_State* L)
+    {
+        Player* player = sEluna->CHECK_PLAYER(L, 1);
+        if (!player)
+            return 0;
+        player->GetSession()->KickPlayer();
+        return 0;
+    }
+
+    // Ban(banMode(integer), nameOrIP(string), duration(string), reason(string), player(whoBanned))
+    static int Ban(lua_State* L)
+    {
+        int banMode = luaL_checkint(L, 1);
+        std::string nameOrIP = luaL_checkstring(L, 2);
+        const char* duration = luaL_checkstring(L, 3);
+        const char* reason = luaL_checkstring(L, 4);
+        Player* whoBanned = sEluna->CHECK_PLAYER(L, 5);
+        if (!whoBanned)
+            return 0;
+
+        switch (banMode)
+        {
+        case BAN_ACCOUNT:
+            if (!AccountMgr::normalizeString(nameOrIP))
+                return 0;
+            break;
+        case BAN_CHARACTER:
+            if (!normalizePlayerName(nameOrIP))
+                return 0;
+            break;
+        case BAN_IP:
+            if (!IsIPAddress(nameOrIP.c_str()))
+                return 0;
+            break;
+        default:
+            return 0;
+        }
+
+        switch (sWorld->BanAccount((BanMode)banMode, nameOrIP, duration, reason, whoBanned->GetSession() ? whoBanned->GetName() : ""))
+        {
+        case BAN_SUCCESS:
+            if (atoi(duration) > 0)
+                ChatHandler(whoBanned->GetSession()).PSendSysMessage(LANG_BAN_YOUBANNED, nameOrIP.c_str(), secsToTimeString(TimeStringToSecs(duration), true).c_str(), reason);
+            else
+                ChatHandler(whoBanned->GetSession()).PSendSysMessage(LANG_BAN_YOUPERMBANNED, nameOrIP.c_str(), reason);
+            break;
+        case BAN_SYNTAX_ERROR:
+            return 0;
+        case BAN_NOTFOUND:
+            return 0;
+        }
+        return 0;
+    }
+
+    // SaveAllPlayers()
+    static int SaveAllPlayers(lua_State* L)
+    {
+        sObjectAccessor->SaveAllPlayers();
+        return 0;
+    }
+
+    // GetGUIDLow(guid)
+    static int GetGUIDLow(lua_State* L)
+    {
+        uint64 guid = sEluna->CHECK_ULONG(L, 1);
+
+        sEluna->PushUnsigned(L, GUID_LOPART(guid));
+        return 1;
+    }
+
+    // SendMail(subject, text, receiverLowGUID[, sender, stationary, delay, itemEntry, itemAmount, itemEntry2, itemAmount2...])
+    static int SendMail(lua_State* L)
+    {
+        int i = 0;
+        std::string subject = luaL_checkstring(L, ++i);
+        std::string text = luaL_checkstring(L, ++i);
+        uint32 receiverGUIDLow = luaL_checkunsigned(L, ++i);
+        Player* senderPlayer = sEluna->CHECK_PLAYER(L, ++i);
+        uint32 stationary = luaL_optunsigned(L, ++i, MAIL_STATIONERY_DEFAULT);
+        uint32 delay = luaL_optunsigned(L, ++i, 0);
+        int32 argAmount = lua_gettop(L);
+
+        MailSender sender(MAIL_NORMAL, senderPlayer ? senderPlayer->GetGUIDLow() : 0, (MailStationery)stationary);
+        MailDraft draft(subject, text);
+
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        uint8 addedItems = 0;
+        while (addedItems <= MAX_MAIL_ITEMS && i+2 <= argAmount)
+        {
+            uint32 entry = luaL_checkunsigned(L, ++i);
+            uint32 amount = luaL_checkunsigned(L, ++i);
+
+            ItemTemplate const* item_proto = sObjectMgr->GetItemTemplate(entry);
+            if (!item_proto)
+            {
+                luaL_error(L, "Item entry %d does not exist", entry);
+                continue;
+            }
+            if (amount < 1 || (item_proto->MaxCount > 0 && amount > uint32(item_proto->MaxCount)))
+            {
+                luaL_error(L, "Item entry %d has invalid amount %d", entry, amount);
+                continue;
+            }
+            if (Item* item = Item::CreateItem(entry, amount, senderPlayer ? senderPlayer : 0))
+            {
+                item->SaveToDB(trans);
+                draft.AddItem(item);
+                ++addedItems;
+            }
+        }
+
+        draft.SendMailTo(trans, MailReceiver(receiverGUIDLow), sender, MAIL_CHECK_MASK_NONE, delay);
+        CharacterDatabase.CommitTransaction(trans);
+        return 0;
+    }
+
+    // bit_and(a, b)
+    static int bit_and(lua_State* L)
+    {
+        uint32 a = luaL_checkunsigned(L, 1);
+        uint32 b = luaL_checkunsigned(L, 2);
+        sEluna->PushUnsigned(L, a & b);
+        return 1;
+    }
+
+    // bit_or(a, b)
+    static int bit_or(lua_State* L)
+    {
+        uint32 a = luaL_checkunsigned(L, 1);
+        uint32 b = luaL_checkunsigned(L, 2);
+        sEluna->PushUnsigned(L, a | b);
+        return 1;
+    }
+
+    // bit_lshift(a, b)
+    static int bit_lshift(lua_State* L)
+    {
+        uint32 a = luaL_checkunsigned(L, 1);
+        uint32 b = luaL_checkunsigned(L, 2);
+        sEluna->PushUnsigned(L, a << b);
+        return 1;
+    }
+
+    // bit_rshift(a, b)
+    static int bit_rshift(lua_State* L)
+    {
+        uint32 a = luaL_checkunsigned(L, 1);
+        uint32 b = luaL_checkunsigned(L, 2);
+        sEluna->PushUnsigned(L, a >> b);
+        return 1;
+    }
+
+    // bit_xor(a, b)
+    static int bit_xor(lua_State* L)
+    {
+        uint32 a = luaL_checkunsigned(L, 1);
+        uint32 b = luaL_checkunsigned(L, 2);
+        sEluna->PushUnsigned(L, a ^ b);
+        return 1;
+    }
+
+    // bit_not(a)
+    static int bit_not(lua_State* L)
+    {
+        uint32 a = luaL_checkunsigned(L, 1);
+        sEluna->PushUnsigned(L, ~ a);
+        return 1;
+    }
+
+    static int GetGUIDType(lua_State* L)
+    {
+        uint64 guid = sEluna->CHECK_ULONG(L, 1);
+        sEluna->PushUnsigned(L, GUID_HIPART(guid));
+        return 1;
+    }
+
+    static int GetGUIDEntry(lua_State* L)
+    {
+        uint64 guid = sEluna->CHECK_ULONG(L, 1);
+        sEluna->PushUnsigned(L, GUID_ENPART(guid));
+        return 1;
+    }
+
+    // AddTaxiPath(pathTable, mountA, mountH[, price, pathId])
+    static int AddTaxiPath(lua_State* L)
+    {
+        luaL_checktype(L, 1, LUA_TTABLE);
+        uint32 mountA = luaL_checkunsigned(L, 2);
+        uint32 mountH = luaL_checkunsigned(L, 3);
+        uint32 price = luaL_optunsigned(L, 4, 0);
+        uint32 pathId = luaL_optunsigned(L, 5, 0);
+        lua_settop(L, 1);
+
+        std::list<TaxiPathNodeEntry> nodes;
+
+        int start = lua_gettop(L);
+        int end = start;
+
+        lua_pushnil(L);
+        while (lua_next(L, -2) != 0)
+        {
+            luaL_checktype(L, -1, LUA_TTABLE);
+            lua_pushnil(L);
+            while (lua_next(L, -2) != 0)
+            {
+                lua_insert(L, end++);
+            }
+            if (start == end)
+                continue;
+            if (end-start < 4) // no mandatory args, dont add
+            {
+                while (end != start)
+                    lua_remove(L, --end);
+                continue;
+            }
+
+            while (end-start < 8) // fill optional args with 0
+            {
+                lua_pushunsigned(L, 0);
+                lua_insert(L, end++);
+            }
+            TaxiPathNodeEntry* entry = new TaxiPathNodeEntry();
+            // mandatory
+            entry->mapid = luaL_checkunsigned(L, start);
+            entry->x = luaL_checknumber(L, start+1);
+            entry->y = luaL_checknumber(L, start+2);
+            entry->z = luaL_checknumber(L, start+3);
+            // optional
+            entry->actionFlag = luaL_checkunsigned(L, start+4);
+            entry->delay = luaL_checkunsigned(L, start+5);
+            entry->arrivalEventID = luaL_checkunsigned(L, start+6);
+            entry->departureEventID = luaL_checkunsigned(L, start+7);
+
+            nodes.push_back(*entry);
+
+            while (end != start) // remove args
+                lua_remove(L, --end);
+
+            lua_pop(L, 1);
+        }
+
+        sEluna->PushUnsigned(L, LuaTaxiMgr::AddPath(nodes, mountA, mountH, price, pathId));
+        return 1;
+    }
+
+    static int GetItemLink(lua_State* L)
+    {
+        /*
+        LOCALE_enUS = 0,
+        LOCALE_koKR = 1,
+        LOCALE_frFR = 2,
+        LOCALE_deDE = 3,
+        LOCALE_zhCN = 4,
+        LOCALE_zhTW = 5,
+        LOCALE_esES = 6,
+        LOCALE_esMX = 7,
+        LOCALE_ruRU = 8
+        */
+        uint32 entry = luaL_checkunsigned(L, 1);
+        int loc_idx = luaL_optint(L, 2, DEFAULT_LOCALE);
+        if (loc_idx < 0 || loc_idx >= TOTAL_LOCALES)
+        {
+            luaL_error(L, "Invalid locale index (%d)", loc_idx);
+            return 0;
+        }
+
+        const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+        if (!temp)
+        {
+            luaL_error(L, "Invalid item entry (%d)", entry);
+            return 0;
+        }
+
+        std::string name = temp->Name1;
+        if (ItemLocale const* il = sObjectMgr->GetItemLocale(entry))
+            ObjectMgr::GetLocaleString(il->Name, loc_idx, name);
+
+        std::ostringstream oss;
+        oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+            "|Hitem:" << entry << ":0:0:0:0:0:0:0:0:0|h[" << name << "]|h|r";
+
+        sEluna->PushString(L, oss.str().c_str());
+        return 1;
+    }
+
+    static int GetPlayersInRange(lua_State* L)
+    {
+        WorldObject* obj = sEluna->CHECK_WORLDOBJECT(L, 1);
+        float range = luaL_optnumber(L, 2, SIZE_OF_GRIDS);
+        if (!obj)
+            return 0;
+
+        std::list<Player*> list;
+        Trinity::AnyPlayerInObjectRangeCheck checker(obj, range);
+        Trinity::PlayerListSearcher<Trinity::AnyPlayerInObjectRangeCheck> searcher(obj, list, checker);
+        obj->VisitNearbyWorldObject(range, searcher);
+        Trinity::ObjectGUIDCheck guidCheck(obj->GetGUID());
+        list.remove_if(guidCheck);
+
+        lua_newtable(L);
+        int tbl = lua_gettop(L);
+        uint32 i = 0;
+
+        for (std::list<Player*>::const_iterator it = list.begin(); it != list.end(); ++it)
+        {
+            sEluna->PushUnsigned(L, ++i);
+            sEluna->PushUnit(L, *it);
+            lua_settable(L, tbl);
+        }
+
+        lua_settop(L, tbl);
+        return 1;
+    }
+
+    static int GetCreaturesInRange(lua_State* L)
+    {
+        WorldObject* obj = sEluna->CHECK_WORLDOBJECT(L, 1);
+        float range = luaL_optnumber(L, 2, SIZE_OF_GRIDS);
+        if (!obj)
+            return 0;
+
+        std::list<Creature*> list;
+        Trinity::AnyUnitInObjectRangeCheck checker(obj, range);
+        Trinity::CreatureListSearcher<Trinity::AnyUnitInObjectRangeCheck> searcher(obj, list, checker);
+        obj->VisitNearbyGridObject(range, searcher);
+        Trinity::ObjectGUIDCheck guidCheck(obj->GetGUID());
+        list.remove_if(guidCheck);
+
+        lua_newtable(L);
+        int tbl = lua_gettop(L);
+        uint32 i = 0;
+
+        for (std::list<Creature*>::const_iterator it = list.begin(); it != list.end(); ++it)
+        {
+            sEluna->PushUnsigned(L, ++i);
+            sEluna->PushUnit(L, *it);
+            lua_settable(L, tbl);
+        }
+
+        lua_settop(L, tbl);
+        return 1;
+    }
+
+    static int GetGameObjectsInRange(lua_State* L)
+    {
+        WorldObject* obj = sEluna->CHECK_WORLDOBJECT(L, 1);
+        float range = luaL_optnumber(L, 2, SIZE_OF_GRIDS);
+        if (!obj)
+            return 0;
+
+        float x, y, z;
+        obj->GetPosition(x, y, z);
+        std::list<GameObject*> list;
+        Trinity::GameObjectInRangeCheck checker(x, y, z, range);
+        Trinity::GameObjectListSearcher<Trinity::GameObjectInRangeCheck> searcher(obj, list, checker);
+        obj->VisitNearbyGridObject(range, searcher);
+        Trinity::ObjectGUIDCheck guidCheck(obj->GetGUID());
+        list.remove_if(guidCheck);
+
+        lua_newtable(L);
+        int tbl = lua_gettop(L);
+        uint32 i = 0;
+
+        for (std::list<GameObject*>::const_iterator it = list.begin(); it != list.end(); ++it)
+        {
+            sEluna->PushUnsigned(L, ++i);
+            sEluna->PushGO(L, *it);
+            lua_settable(L, tbl);
+        }
+
+        lua_settop(L, tbl);
+        return 1;
+    }
+}
+#endif
diff --git a/src/server/LuaEngine/GroupMethods.h b/src/server/LuaEngine/GroupMethods.h
new file mode 100644
index 0000000..6c53290
--- /dev/null
+++ b/src/server/LuaEngine/GroupMethods.h
@@ -0,0 +1,332 @@
+#ifndef GROUPMETHODS_H
+#define GROUPMETHODS_H
+
+class LuaGroup
+{
+public:
+
+    static int GetMembers(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        lua_newtable(L);
+        int tbl = lua_gettop(L);
+        uint32 i = 0;
+
+        for (GroupReference* itr = group->GetFirstMember(); itr; itr = itr->next())
+        {
+            Player* member = itr->GetSource();
+
+            if (!member || !member->GetSession())
+                continue;
+
+            ++i;
+            sEluna->PushUnsigned(L, i);
+            sEluna->PushUnit(L, member);
+            lua_settable(L, tbl);
+        }
+
+        lua_settop(L, tbl); // push table to top of stack
+        return 1;
+    }
+
+    static int GetLeaderGUID(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        sEluna->PushULong(L, group->GetLeaderGUID());
+        return 1;
+    }
+
+    static int GetLeader(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        sEluna->PushUnit(L, sObjectAccessor->FindPlayer(group->GetLeaderGUID()));
+        return 1;
+    }
+
+    static int GetUnitType(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        sEluna->PushString(L, "Group");
+        return 1;
+    }
+
+    static int GetGUID(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        sEluna->PushULong(L, group->GetGUID());
+        return 1;
+    }
+
+    static int ChangeLeader(lua_State* L, Group* group)
+    {
+        if (!group)
+        {
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+
+        Player* leader = sEluna->CHECK_PLAYER(L, 1);
+        if (leader)
+        {
+            group->ChangeLeader(leader->GetGUID());
+            sEluna->PushBoolean(L, true);
+        }
+        else
+            sEluna->PushBoolean(L, false);
+        return 1;
+    }
+
+    static int IsLeader(lua_State* L, Group* group)
+    {
+        if (!group)
+        {
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+
+        Player* player = sEluna->CHECK_PLAYER(L, 1);
+        if (!player)
+            if (const char* name = luaL_checkstring(L, 1))
+                player = sObjectAccessor->FindPlayerByName(name);
+
+        if (player)
+            sEluna->PushBoolean(L, group->IsLeader(player->GetGUID()));
+        else
+            sEluna->PushBoolean(L, false);
+        return 1;
+    }
+
+    // SendPacket(packet, sendToPlayersInBattleground[, ignoreguid])
+    static int SendPacket(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        WorldPacket* data = sEluna->CHECK_PACKET(L, 1);
+        bool ignorePlayersInBg = luaL_checkbool(L, 2);
+        uint64 ignore = sEluna->CHECK_ULONG(L, 3);
+
+        if (data)
+            group->BroadcastPacket(data, ignorePlayersInBg, -1, ignore);
+        return 0;
+    }
+
+    static int AddInvite(lua_State* L, Group* group)
+    {
+        if (!group)
+        {
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+
+        Player* player = sEluna->CHECK_PLAYER(L, 1);
+        if (player)
+            sEluna->PushBoolean(L, group->AddInvite(player));
+        else
+            sEluna->PushBoolean(L, false);
+        return 1;
+    }
+
+    static int RemoveMember(lua_State* L, Group* group)
+    {
+        if (!group)
+        {
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+
+        Player* player = sEluna->CHECK_PLAYER(L, 1);
+        if (player)
+            sEluna->PushBoolean(L, group->RemoveMember(player->GetGUID()));
+        else
+            sEluna->PushBoolean(L, false);
+        return 1;
+    }
+
+    static int Disband(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        group->Disband();
+        return 0;
+    }
+
+    static int IsFull(lua_State* L, Group* group)
+    {
+        if (!group)
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, group->IsFull());
+        return 1;
+    }
+
+    static int isLFGGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, group->isLFGGroup());
+        return 1;
+    }
+
+    static int isRaidGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, group->isRaidGroup());
+        return 1;
+    }
+
+    static int isBGGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, group->isBGGroup());
+        return 1;
+    }
+
+    static int isBFGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, group->isBFGroup());
+        return 1;
+    }
+
+    static int IsMember(lua_State* L, Group* group)
+    {
+        if (!group)
+            sEluna->PushBoolean(L, false);
+        else
+        {
+            Player* player = sEluna->CHECK_PLAYER(L, 1);
+            if (player)
+                sEluna->PushBoolean(L, group->IsMember(player->GetGUID()));
+            else
+                sEluna->PushBoolean(L, false);
+        }
+        return 1;
+    }
+
+    static int IsAssistant(lua_State* L, Group* group)
+    {
+        if (!group)
+            sEluna->PushBoolean(L, false);
+        else
+        {
+            Player* player = sEluna->CHECK_PLAYER(L, 1);
+            if (player)
+                sEluna->PushBoolean(L, group->IsAssistant(player->GetGUID()));
+            else
+                sEluna->PushBoolean(L, false);
+        }
+        return 1;
+    }
+
+    static int SameSubGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            sEluna->PushBoolean(L, false);
+        else
+        {
+            Player* player1 = sEluna->CHECK_PLAYER(L, 1);
+            Player* player2 = sEluna->CHECK_PLAYER(L, 2);
+            if (player1 && player2)
+                sEluna->PushBoolean(L, group->SameSubGroup(player1, player2));
+            else
+                sEluna->PushBoolean(L, false);
+        }
+        return 1;
+    }
+
+    static int HasFreeSlotSubGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            sEluna->PushBoolean(L, false);
+        else
+        {
+            uint8 subGroup = luaL_checkunsigned(L, 1);
+            sEluna->PushBoolean(L, group->HasFreeSlotSubGroup(subGroup));
+        }
+        return 1;
+    }
+
+    static int GetMemberGUID(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        const char* name = luaL_checkstring(L, 1);
+        sEluna->PushULong(L, group->GetMemberGUID(name));
+        return 1;
+    }
+
+    static int GetMembersCount(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        sEluna->PushUnsigned(L, group->GetMembersCount());
+        return 1;
+    }
+
+    static int ConvertToLFG(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        group->ConvertToLFG();
+        return 0;
+    }
+
+    static int ConvertToRaid(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        group->ConvertToRaid();
+        return 0;
+    }
+
+    static int ChangeMembersGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        Player* player = sEluna->CHECK_PLAYER(L, 1);
+        uint8 groupID = luaL_checkunsigned(L, 2);
+
+        if (player)
+            group->ChangeMembersGroup(player->GetGUID(), groupID);
+        return 0;
+    }
+
+    static int GetMemberGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        Player* player = sEluna->CHECK_PLAYER(L, 1);
+        if (!player)
+            return 0;
+
+        sEluna->PushUnsigned(L, group->GetMemberGroup(player->GetGUID()));
+        return 1;
+    }
+
+};
+#endif
diff --git a/src/server/LuaEngine/GuildMethods.h b/src/server/LuaEngine/GuildMethods.h
new file mode 100644
index 0000000..3700fb3
--- /dev/null
+++ b/src/server/LuaEngine/GuildMethods.h
@@ -0,0 +1,178 @@
+#ifndef GUILDMETHODS_H
+#define GUILDMETHODS_H
+
+class LuaGuild
+{
+public:
+
+    static int GetMembers(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        lua_newtable(L);
+        int tbl = lua_gettop(L);
+        uint32 i = 0;
+
+        // Note that the following is very hacky, I don't like it and it SHOULD be changed ASAP.
+
+        TRINITY_READ_GUARD(HashMapHolder<Player>::LockType, *HashMapHolder<Player>::GetLock());
+        HashMapHolder<Player>::MapType const& m = sObjectAccessor->GetPlayers();
+        for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+        {
+            if (itr->second->GetGuildId() == guild->GetId())
+            {
+                ++i;
+                sEluna->PushUnsigned(L, i);
+                sEluna->PushUnit(L, itr->second);
+                lua_settable(L, tbl);
+            }
+        }
+
+        lua_settop(L, tbl); // push table to top of stack
+        return 1;
+    }
+
+    static int GetUnitType(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        sEluna->PushString(L, "Guild");
+        return 1;
+    }
+
+    static int GetLeaderGUID(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        sEluna->PushULong(L, guild->GetLeaderGUID());
+        return 1;
+    }
+
+    // SendPacketToGuild(packet)
+    static int SendPacket(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        WorldPacket* data = sEluna->CHECK_PACKET(L, 1);
+
+        if (data)
+            guild->BroadcastPacket(data);
+        return 0;
+    }
+
+    // SendPacketToRankedInGuild(packet, rankId)
+    static int SendPacketToRanked(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        WorldPacket* data = sEluna->CHECK_PACKET(L, 1);
+        uint8 ranked = luaL_checkunsigned(L, 2);
+
+        if (data)
+            guild->BroadcastPacketToRank(data, ranked);
+        return 0;
+    }
+
+    static int Disband(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        guild->Disband();
+        return 0;
+    }
+
+    static int GetId(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        sEluna->PushUnsigned(L, guild->GetId());
+        return 1;
+    }
+
+    static int GetName(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        sEluna->PushString(L, guild->GetName().c_str());
+        return 1;
+    }
+
+    static int GetMOTD(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        sEluna->PushString(L, guild->GetMOTD().c_str());
+        return 1;
+    }
+
+    static int GetInfo(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        sEluna->PushString(L, guild->GetInfo().c_str());
+        return 1;
+    }
+
+    static int AddMember(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        Player* player = sEluna->CHECK_PLAYER(L, 1);
+        uint8 rankId = luaL_optint(L, 2, GUILD_RANK_NONE);
+
+        if (player)
+            guild->AddMember(player->GetGUID(), rankId);
+        return 0;
+    }
+
+    static int DeleteMember(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        Player* player = sEluna->CHECK_PLAYER(L, 1);
+        bool isDisbanding = luaL_optbool(L, 2, false);
+        bool isKicked = luaL_optbool(L, 3, false);
+
+        if (player)
+            guild->DeleteMember(player->GetGUID(), isDisbanding, isKicked);
+        return 0;
+    }
+
+    static int ChangeMemberRank(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        Player* player = sEluna->CHECK_PLAYER(L, 1);
+        uint8 newRank = luaL_checkunsigned(L, 2);
+
+        if (player)
+            guild->ChangeMemberRank(player->GetGUID(), newRank);
+        return 0;
+    }
+
+    static int SetBankTabText(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        uint8 tabId = luaL_checkunsigned(L, 1);
+        const char* text = luaL_checkstring(L, 2);
+
+        guild->SetBankTabText(tabId, text);
+        return 0;
+    }
+};
+#endif
diff --git a/src/server/LuaEngine/HookMgr.cpp b/src/server/LuaEngine/HookMgr.cpp
new file mode 100644
index 0000000..3a473c3
--- /dev/null
+++ b/src/server/LuaEngine/HookMgr.cpp
@@ -0,0 +1,300 @@
+#include "HookMgr.h"
+#include "LuaEngine.h"
+
+// misc
+void HookMgr::OnLootItem(Player* player, Item* item, uint32 count, uint64 guid)
+{
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->OnLootItem(player, item, count, guid);
+}
+void HookMgr::OnFirstLogin(Player* player)
+{
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->OnFirstLogin(player);
+}
+void HookMgr::OnEquip(Player* player, Item* item, uint8 bag, uint8 slot)
+{
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->OnEquip(player, item, bag, slot);
+}
+InventoryResult HookMgr::OnCanUseItem(const Player* player, uint32 itemEntry)
+{
+    Player* player2 = const_cast<Player*>(player);
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+    {
+        InventoryResult value = (*it)->OnCanUseItem(player2, itemEntry);
+        if (value != EQUIP_ERR_OK)
+            return value;
+    }
+    return EQUIP_ERR_OK;
+}
+void HookMgr::HandleGossipSelectOption(Player* player, uint64 guid, uint32 sender, uint32 action, std::string code, uint32 menuId)
+{
+    if (!player || !player->IsInWorld() || player->PlayerTalkClass->GetGossipMenu().GetMenuId() != menuId)
+        return;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->HandleGossipSelectOption(player, guid, sender, action, code, menuId);
+}
+bool HookMgr::OnChat(Player* player, uint32 type, uint32 lang, std::string& msg)
+{
+    bool result = true;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if (!(*it)->OnChat(player, type, lang, msg))
+            result = false;
+    return result;
+}
+bool HookMgr::OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Group* group)
+{
+    bool result = true;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if (!(*it)->OnChat(player, type, lang, msg, group))
+            result = false;
+    return result;
+}
+bool HookMgr::OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Guild* guild)
+{
+    bool result = true;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if (!(*it)->OnChat(player, type, lang, msg, guild))
+            result = false;
+    return result;
+}
+bool HookMgr::OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Channel* channel)
+{
+    bool result = true;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if (!(*it)->OnChat(player, type, lang, msg, channel))
+            result = false;
+    return result;
+}
+void HookMgr::OnEngineRestart()
+{
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->OnEngineRestart();
+}
+// item
+bool HookMgr::OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, Item* target)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnDummyEffect(caster, spellId, effIndex, target))
+            result = true;
+    return result;
+}
+bool HookMgr::OnQuestAccept(Player* player, Item* item, Quest const* quest)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnQuestAccept(player, item, quest))
+            result = true;
+    return result;
+}
+bool HookMgr::OnUse(Player* player, Item* item, SpellCastTargets const& targets)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnUse(player, item, targets))
+            result = true;
+    return result;
+}
+bool HookMgr::OnExpire(Player* player, ItemTemplate const* proto)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnExpire(player, proto))
+            result = true;
+    return result;
+}
+// creature
+bool HookMgr::OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, Creature* target)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnDummyEffect(caster, spellId, effIndex, target))
+            result = true;
+    return result;
+}
+bool HookMgr::OnGossipHello(Player* player, Creature* creature)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnGossipHello(player, creature))
+            result = true;
+    return result;
+}
+bool HookMgr::OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnGossipSelect(player, creature, sender, action))
+            result = true;
+    return result;
+}
+bool HookMgr::OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnGossipSelectCode(player, creature, sender, action, code))
+            result = true;
+    return result;
+}
+bool HookMgr::OnQuestAccept(Player* player, Creature* creature, Quest const* quest)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnQuestAccept(player, creature, quest))
+            result = true;
+    return result;
+}
+bool HookMgr::OnQuestSelect(Player* player, Creature* creature, Quest const* quest)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnQuestSelect(player, creature, quest))
+            result = true;
+    return result;
+}
+bool HookMgr::OnQuestComplete(Player* player, Creature* creature, Quest const* quest)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnQuestComplete(player, creature, quest))
+            result = true;
+    return result;
+}
+bool HookMgr::OnQuestReward(Player* player, Creature* creature, Quest const* quest, uint32 opt)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnQuestReward(player, creature, quest, opt))
+            result = true;
+    return result;
+}
+uint32 HookMgr::GetDialogStatus(Player* player, Creature* creature)
+{
+    uint32 result = 0;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        result = (*it)->GetDialogStatus(player, creature);
+    return result;
+}
+// gameobject
+bool HookMgr::OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, GameObject* target)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnDummyEffect(caster, spellId, effIndex, target))
+            result = true;
+    return result;
+}
+bool HookMgr::OnGossipHello(Player* player, GameObject* go)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnGossipHello(player, go))
+            result = true;
+    return result;
+}
+bool HookMgr::OnGossipSelect(Player* player, GameObject* go, uint32 sender, uint32 action)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnGossipSelect(player, go, sender, action))
+            result = true;
+    return result;
+}
+bool HookMgr::OnGossipSelectCode(Player* player, GameObject* go, uint32 sender, uint32 action, const char* code)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnGossipSelectCode(player, go, sender, action, code))
+            result = true;
+    return result;
+}
+bool HookMgr::OnQuestAccept(Player* player, GameObject* go, Quest const* quest)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnQuestAccept(player, go, quest))
+            result = true;
+    return result;
+}
+bool HookMgr::OnQuestReward(Player* player, GameObject* go, Quest const* quest, uint32 opt)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnQuestReward(player, go, quest, opt))
+            result = true;
+    return result;
+}
+uint32 HookMgr::GetDialogStatus(Player* player, GameObject* go)
+{
+    bool result = 0;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        result = (*it)->GetDialogStatus(player, go);
+    return result;
+}
+void HookMgr::OnDestroyed(GameObject* go, Player* player)
+{
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->OnDestroyed(go, player);
+}
+void HookMgr::OnDamaged(GameObject* go, Player* player)
+{
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->OnDamaged(go, player);
+}
+void HookMgr::OnLootStateChanged(GameObject* go, uint32 state, Unit* unit)
+{
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->OnLootStateChanged(go, state, unit);
+}
+void HookMgr::OnGameObjectStateChanged(GameObject* go, uint32 state)
+{
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->OnGameObjectStateChanged(go, state);
+}
+// areatrigger
+bool HookMgr::OnTrigger(Player* player, AreaTriggerEntry const* trigger)
+{
+    bool result = false;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if ((*it)->OnTrigger(player, trigger))
+            result = true;
+    return result;
+}
+// weather
+void HookMgr::OnChange(Weather* weather, WeatherState state, float grade)
+{
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->OnChange(weather, state, grade);
+}
+// condition
+bool HookMgr::OnConditionCheck(Condition* condition, ConditionSourceInfo& sourceInfo)
+{
+    bool result = true;
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        if (!(*it)->OnConditionCheck(condition, sourceInfo))
+            result = false;
+    return result;
+}
+// transport
+void HookMgr::OnAddPassenger(Transport* transport, Player* player)
+{
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->OnAddPassenger(transport, player);
+}
+void HookMgr::OnAddCreaturePassenger(Transport* transport, Creature* creature)
+{
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->OnAddCreaturePassenger(transport, creature);
+}
+void HookMgr::OnRemovePassenger(Transport* transport, Player* player)
+{
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->OnRemovePassenger(transport, player);
+}
+void HookMgr::OnRelocate(Transport* transport, uint32 waypointId, uint32 mapId, float x, float y, float z)
+{
+    for (HookPointerSet::const_iterator it = hookPointers.begin(); it != hookPointers.end(); ++it)
+        (*it)->OnRelocate(transport, waypointId, mapId, x, y, z);
+}
diff --git a/src/server/LuaEngine/HookMgr.h b/src/server/LuaEngine/HookMgr.h
new file mode 100644
index 0000000..4c587c8
--- /dev/null
+++ b/src/server/LuaEngine/HookMgr.h
@@ -0,0 +1,132 @@
+#include "ScriptMgr.h"
+#include "ScriptPCH.h"
+#include "LuaEngine.h"
+
+#ifndef LUAHOOKS_H
+#define LUAHOOKS_H
+
+// void Eluna_AddScriptHooks();
+
+class HookScript;
+class HookMgr
+{
+public:
+    typedef std::set<HookScript*> HookPointerSet;
+    HookPointerSet hookPointers;
+
+    HookMgr() { }
+
+    // misc
+    void OnLootItem(Player* player, Item* item, uint32 count, uint64 guid);
+    void OnFirstLogin(Player* player);
+    void OnEquip(Player* player, Item* item, uint8 bag, uint8 slot);
+    InventoryResult OnCanUseItem(const Player* player, uint32 itemEntry);
+    void HandleGossipSelectOption(Player* player, uint64 guid, uint32 sender, uint32 action, std::string code, uint32 menuId);
+    bool OnChat(Player* player, uint32 type, uint32 lang, std::string& msg);
+    bool OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Group* group);
+    bool OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Guild* guild);
+    bool OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Channel* channel);
+    void OnEngineRestart();
+    // item
+    bool OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, Item* target);
+    bool OnQuestAccept(Player* player, Item* item, Quest const* quest);
+    bool OnUse(Player* player, Item* item, SpellCastTargets const& targets);
+    bool OnExpire(Player* player, ItemTemplate const* proto);
+    // creature
+    bool OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, Creature* target);
+    bool OnGossipHello(Player* player, Creature* creature);
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action);
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code);
+    bool OnQuestAccept(Player* player, Creature* creature, Quest const* quest);
+    bool OnQuestSelect(Player* player, Creature* creature, Quest const* quest);
+    bool OnQuestComplete(Player* player, Creature* creature, Quest const* quest);
+    bool OnQuestReward(Player* player, Creature* creature, Quest const* quest, uint32 opt);
+    uint32 GetDialogStatus(Player* player, Creature* creature);
+    // gameobject
+    bool OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, GameObject* target);
+    bool OnGossipHello(Player* player, GameObject* go);
+    bool OnGossipSelect(Player* player, GameObject* go, uint32 sender, uint32 action);
+    bool OnGossipSelectCode(Player* player, GameObject* go, uint32 sender, uint32 action, const char* code);
+    bool OnQuestAccept(Player* player, GameObject* go, Quest const* quest);
+    bool OnQuestReward(Player* player, GameObject* go, Quest const* quest, uint32 opt);
+    uint32 GetDialogStatus(Player* player, GameObject* go);
+    void OnDestroyed(GameObject* go, Player* player);
+    void OnDamaged(GameObject* go, Player* player);
+    void OnLootStateChanged(GameObject* go, uint32 state, Unit* unit);
+    void OnGameObjectStateChanged(GameObject* go, uint32 state);
+    // areatrigger
+    bool OnTrigger(Player* player, AreaTriggerEntry const* trigger);
+    // weather
+    void OnChange(Weather* weather, WeatherState state, float grade);
+    // condition
+    bool OnConditionCheck(Condition* condition, ConditionSourceInfo& sourceInfo);
+    // transport
+    void OnAddPassenger(Transport* transport, Player* player);
+    void OnAddCreaturePassenger(Transport* transport, Creature* creature);
+    void OnRemovePassenger(Transport* transport, Player* player);
+    void OnRelocate(Transport* transport, uint32 waypointId, uint32 mapId, float x, float y, float z);
+};
+#define sHookMgr ACE_Singleton<HookMgr, ACE_Null_Mutex>::instance()
+
+class HookScript
+{
+public:
+    HookScript()
+    {
+        sHookMgr->hookPointers.insert(this);
+    }
+    ~HookScript()
+    {
+        sHookMgr->hookPointers.erase(this);
+    }
+    // misc
+    virtual void OnLootItem(Player* player, Item* item, uint32 count, uint64 guid) { }
+    virtual void OnFirstLogin(Player* player) { }
+    virtual void OnEquip(Player* player, Item* item, uint8 bag, uint8 slot) { }
+    virtual InventoryResult OnCanUseItem(Player* player, uint32 itemEntry) { return EQUIP_ERR_OK; }
+    virtual void HandleGossipSelectOption(Player* player, uint64 guid, uint32 sender, uint32 action, std::string code, uint32 menuId) { }
+    virtual bool OnChat(Player* player, uint32 type, uint32 lang, std::string& msg) { return true; }
+    virtual bool OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Group* group) { return true; }
+    virtual bool OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Guild* guild) { return true; }
+    virtual bool OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Channel* channel) { return true; }
+    virtual void OnEngineRestart() { }
+    // item
+    virtual bool OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, Item* target) { return false; }
+    virtual bool OnQuestAccept(Player* player, Item* item, Quest const* quest) { return false; }
+    virtual bool OnUse(Player* player, Item* item, SpellCastTargets const& targets) { return false; }
+    virtual bool OnExpire(Player* player, ItemTemplate const* proto) { return false; }
+    // creature
+    virtual bool OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, Creature* target) { return false; }
+    virtual bool OnGossipHello(Player* player, Creature* creature) { return false; }
+    virtual bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) { return false; }
+    virtual bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code) { return false; }
+    virtual bool OnQuestAccept(Player* player, Creature* creature, Quest const* quest) { return false; }
+    virtual bool OnQuestSelect(Player* player, Creature* creature, Quest const* quest) { return false; }
+    virtual bool OnQuestComplete(Player* player, Creature* creature, Quest const* quest) { return false; }
+    virtual bool OnQuestReward(Player* player, Creature* creature, Quest const* quest, uint32 opt) { return false; }
+    virtual uint32 GetDialogStatus(Player* player, Creature* creature) { return 100; }
+    // gameobject
+    virtual bool OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, GameObject* target) { return false; }
+    virtual bool OnGossipHello(Player* player, GameObject* go) { return false; }
+    virtual bool OnGossipSelect(Player* player, GameObject* go, uint32 sender, uint32 action) { return false; }
+    virtual bool OnGossipSelectCode(Player* player, GameObject* go, uint32 sender, uint32 action, const char* code) { return false; }
+    virtual bool OnQuestAccept(Player* player, GameObject* go, Quest const* quest) { return false; }
+    virtual bool OnQuestReward(Player* player, GameObject* go, Quest const* quest, uint32 opt) { return false; }
+    virtual uint32 GetDialogStatus(Player* player, GameObject* go) { return 100; }
+    virtual void OnDestroyed(GameObject* go, Player* player) { }
+    virtual void OnDamaged(GameObject* go, Player* player) { }
+    virtual void OnLootStateChanged(GameObject* go, uint32 state, Unit* unit) { }
+    virtual void OnGameObjectStateChanged(GameObject* go, uint32 state) { }
+    // areatrigger
+    virtual bool OnTrigger(Player* player, AreaTriggerEntry const* trigger) { return false; }
+    // weather
+    virtual void OnChange(Weather* weather, WeatherState state, float grade) { }
+    // condition
+    virtual bool OnConditionCheck(Condition* condition, ConditionSourceInfo& sourceInfo) { return true; }
+    // transport
+    virtual void OnAddPassenger(Transport* transport, Player* player) { }
+    virtual void OnAddCreaturePassenger(Transport* transport, Creature* creature) { }
+    virtual void OnRemovePassenger(Transport* transport, Player* player) { }
+    virtual void OnRelocate(Transport* transport, uint32 waypointId, uint32 mapId, float x, float y, float z) { }
+};
+#endif
diff --git a/src/server/LuaEngine/ItemMethods.h b/src/server/LuaEngine/ItemMethods.h
new file mode 100644
index 0000000..f6873b4
--- /dev/null
+++ b/src/server/LuaEngine/ItemMethods.h
@@ -0,0 +1,715 @@
+#ifndef ITEMMETHODS_H
+#define ITEMMETHODS_H
+
+class LuaItem
+{
+public:
+    static int GetQuality(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetTemplate()->Quality);
+        return 1;
+    }
+
+    static int GetItemLink(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        /*
+        LOCALE_enUS = 0,
+        LOCALE_koKR = 1,
+        LOCALE_frFR = 2,
+        LOCALE_deDE = 3,
+        LOCALE_zhCN = 4,
+        LOCALE_zhTW = 5,
+        LOCALE_esES = 6,
+        LOCALE_esMX = 7,
+        LOCALE_ruRU = 8
+        */
+        int loc_idx = luaL_optint(L, 1, DEFAULT_LOCALE);
+        if (loc_idx < 0 || loc_idx >= TOTAL_LOCALES)
+        {
+            luaL_error(L, "Invalid locale index (%d)", loc_idx);
+            return 0;
+        }
+
+        const ItemTemplate* temp = item->GetTemplate();
+        std::string name = temp->Name1;
+        if (ItemLocale const* il = sObjectMgr->GetItemLocale(temp->ItemId))
+            ObjectMgr::GetLocaleString(il->Name, loc_idx, name);
+
+        if (int32 itemRandPropId = item->GetItemRandomPropertyId())
+        {
+            char* const* suffix = NULL;
+            if (itemRandPropId < 0)
+            {
+                const ItemRandomSuffixEntry* itemRandEntry = sItemRandomSuffixStore.LookupEntry(-item->GetItemRandomPropertyId());
+                if (itemRandEntry)
+                    suffix = itemRandEntry->nameSuffix;
+            }
+            else
+            {
+                const ItemRandomPropertiesEntry* itemRandEntry = sItemRandomPropertiesStore.LookupEntry(item->GetItemRandomPropertyId());
+                if (itemRandEntry)
+                    suffix = itemRandEntry->nameSuffix;
+            }
+            if (suffix)
+            {
+                std::string test(suffix[(name != temp->Name1) ? loc_idx : DEFAULT_LOCALE]);
+                if (!test.empty())
+                {
+                    name += ' ';
+                    name += test;
+                }
+            }
+        }
+
+        std::ostringstream oss;
+        oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+            "|Hitem:" << temp->ItemId <<":" <<
+            item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":" <<
+            item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT) << ":" <<
+            item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_2) << ":" <<
+            item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_3) << ":" <<
+            item->GetEnchantmentId(BONUS_ENCHANTMENT_SLOT) << ":" <<
+            item->GetItemRandomPropertyId() << ":" << item->GetItemSuffixFactor() << ":" <<
+            (uint32)item->GetOwner()->getLevel() << "|h[" << name << "]|h|r";
+
+        sEluna->PushString(L, oss.str().c_str());
+        return 1;
+    }
+
+    static int GetUnitType(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushString(L, "Item");
+        return 1;
+    }
+
+    static int GetGUID(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushULong(L, item->GetGUID());
+        return 1;
+    }
+
+    static int GetOwnerGUID(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushULong(L, item->GetOwnerGUID());
+        return 1;
+    }
+
+    static int GetOwner(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnit(L, item->GetOwner());
+        return 1;
+    }
+
+    static int SetOwner(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        Player* player = sEluna->CHECK_PLAYER(L, 1);
+
+        if (player)
+            item->SetOwnerGUID(player->GetGUID());
+        return 0;
+    }
+
+    static int SetBinding(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        bool soulbound = luaL_checkbool(L, 1);
+
+        item->SetBinding(soulbound);
+        return 0;
+    }
+
+    static int IsSoulBound(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsSoulBound());
+        return 1;
+    }
+
+    static int IsBoundAccountWide(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsBoundAccountWide());
+        return 1;
+    }
+
+    static int IsBoundByEnchant(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsBoundByEnchant());
+        return 1;
+    }
+
+    static int IsNotBoundToPlayer(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+        {
+            Player* player = sEluna->CHECK_PLAYER(L, 1);
+            if (player)
+                sEluna->PushBoolean(L, item->IsBindedNotWith(player));
+            else
+                sEluna->PushBoolean(L, false);
+        }
+        return 1;
+    }
+
+    static int IsLocked(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsLocked());
+        return 1;
+    }
+
+    static int IsBag(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsBag());
+        return 1;
+    }
+
+    static int IsCurrencyToken(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsCurrencyToken());
+        return 1;
+    }
+
+    static int IsNotEmptyBag(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsNotEmptyBag());
+        return 1;
+    }
+
+    static int IsBroken(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsBroken());
+        return 1;
+    }
+
+    static int CanBeTraded(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+        {
+            bool mail = luaL_optbool(L, 1, false);
+            bool trade = luaL_optbool(L, 2, false);
+            sEluna->PushBoolean(L, item->CanBeTraded(mail, trade));
+        }
+        return 1;
+    }
+
+    static int IsInTrade(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsInTrade());
+        return 1;
+    }
+
+    static int GetCount(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetCount());
+        return 1;
+    }
+
+    static int SetCount(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint32 count = luaL_checkunsigned(L, 1);
+        item->SetCount(count);
+        return 0;
+    }
+
+    static int GetMaxStackCount(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetMaxStackCount());
+        return 1;
+    }
+
+    static int GetSlot(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetSlot());
+        return 1;
+    }
+
+    static int GetBagSlot(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetBagSlot());
+        return 1;
+    }
+
+    static int IsInBag(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsInBag());
+        return 1;
+    }
+
+    static int IsEquipped(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsEquipped());
+        return 1;
+    }
+
+    static int hasQuest(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+        {
+            uint32 quest = luaL_checkunsigned(L, 1);
+            sEluna->PushBoolean(L, item->hasQuest(quest));
+        }
+        return 1;
+    }
+
+    static int IsPotion(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsPotion());
+        return 1;
+    }
+
+    static int IsWeaponVellum(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsWeaponVellum());
+        return 1;
+    }
+
+    static int IsArmorVellum(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsArmorVellum());
+        return 1;
+    }
+
+    static int IsConjuredConsumable(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsConjuredConsumable());
+        return 1;
+    }
+
+    static int IsRefundExpired(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, item->IsRefundExpired());
+        return 1;
+    }
+
+    static int GetEntry(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetEntry());
+        return 1;
+    }
+
+    static int GetInt32Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        sEluna->PushInteger(L, item->GetInt32Value(index));
+        return 1;
+    }
+
+    static int GetUInt32Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        sEluna->PushUnsigned(L, item->GetUInt32Value(index));
+        return 1;
+    }
+
+    static int GetFloatValue(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        sEluna->PushFloat(L, item->GetFloatValue(index));
+        return 1;
+    }
+
+    static int GetByteValue(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        sEluna->PushUnsigned(L, item->GetByteValue(index, offset));
+        return 1;
+    }
+
+    static int GetUInt16Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        sEluna->PushUnsigned(L, item->GetUInt16Value(index, offset));
+        return 1;
+    }
+
+    static int SetInt32Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        int32 value = luaL_checkinteger(L, 2);
+        item->SetInt32Value(index, value);
+        return 0;
+    }
+
+    static int SetUInt32Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint32 value = luaL_checkunsigned(L, 2);
+        item->SetUInt32Value(index, value);
+        return 0;
+    }
+
+    static int UpdateUInt32Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint32 value = luaL_checkunsigned(L, 2);
+        item->UpdateUInt32Value(index, value);
+        return 0;
+    }
+
+    static int SetFloatValue(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        float value = luaL_checknumber(L, 2);
+        item->SetFloatValue(index, value);
+        return 0;
+    }
+
+    static int SetByteValue(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        uint8 value = luaL_checkunsigned(L, 3);
+        item->SetByteValue(index, offset, value);
+        return 0;
+    }
+
+    static int SetUInt16Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        uint16 value = luaL_checkunsigned(L, 3);
+        item->SetUInt16Value(index, offset, value);
+        return 0;
+    }
+
+    static int SetInt16Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        int16 value = luaL_checkinteger(L, 3);
+        item->SetInt16Value(index, offset, value);
+        return 0;
+    }
+
+    static int SetEnchantment(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+        {
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+
+        Player* owner = item->GetOwner();
+        if (!owner)
+        {
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+
+        uint32 enchant = luaL_checkunsigned(L, 1);
+        if (!sSpellItemEnchantmentStore.LookupEntry(enchant))
+        {
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+
+        EnchantmentSlot slot = EnchantmentSlot(luaL_checkunsigned(L, 2));
+        if(slot >= MAX_INSPECTED_ENCHANTMENT_SLOT)
+        {
+            luaL_error(L, "Invalid enchantment slot (%d)", slot);
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+
+        owner->ApplyEnchantment(item, slot, false);
+        item->SetEnchantment(slot, enchant, 0, 0);
+        owner->ApplyEnchantment(item, slot, true);
+        sEluna->PushBoolean(L, true);
+        return 1;
+    }
+
+    static int ClearEnchantment(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+        {
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+
+        Player* owner = item->GetOwner();
+        if (!owner)
+        {
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+
+        EnchantmentSlot slot = EnchantmentSlot(luaL_checkunsigned(L, 1));
+        if(slot >= MAX_INSPECTED_ENCHANTMENT_SLOT)
+        {
+            luaL_error(L, "Invalid enchantment slot (%d)", slot);
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+
+        if (!item->GetEnchantmentId(slot))
+        {
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+
+        owner->ApplyEnchantment(item, slot, false);
+        item->ClearEnchantment(slot);
+        sEluna->PushBoolean(L, true);
+        return 1;
+    }
+
+    static int GetGUIDLow(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetGUIDLow());
+        return 1;
+    }
+
+    static int GetEnchantmentId(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint32 enchant_slot = luaL_checkunsigned(L, 1);
+        
+        EnchantmentSlot slot = EnchantmentSlot(luaL_checkunsigned(L, 2));
+        if(slot >= MAX_INSPECTED_ENCHANTMENT_SLOT)
+            sEluna->PushUnsigned(L, 0);
+        else
+            sEluna->PushUnsigned(L, item->GetEnchantmentId(EnchantmentSlot(enchant_slot)));
+        return 1;
+    }
+
+    static int GetName(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushString(L, item->GetTemplate()->Name1.c_str());
+        return 1;
+    }
+
+    static int GetClass(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetTemplate()->Class);
+        return 1;
+    }
+
+    static int GetSubClass(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetTemplate()->SubClass);
+        return 1;
+    }
+
+    static int GetInventoryType(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetTemplate()->InventoryType);
+        return 1;
+    }
+
+    static int GetSpellId(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint32 index = luaL_checkunsigned(L, 1);
+        if (index >= MAX_ITEM_PROTO_SPELLS)
+        {
+            luaL_error(L, "Invalid index (%d)", index);
+            return 0;
+        }
+
+        sEluna->PushUnsigned(L, item->GetTemplate()->Spells[index].SpellId);
+        return 1;
+    }
+
+    static int GetSpellTrigger(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint32 index = luaL_checkunsigned(L, 1);
+        if (index >= MAX_ITEM_PROTO_SPELLS)
+        {
+            luaL_error(L, "Invalid index (%d)", index);
+            return 0;
+        }
+
+        sEluna->PushUnsigned(L, item->GetTemplate()->Spells[index].SpellTrigger);
+        return 1;
+    }
+
+    static int GetItemLevel(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetTemplate()->ItemLevel);
+        return 1;
+    }
+
+    static int GetRequiredLevel(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetTemplate()->RequiredLevel);
+        return 1;
+    }
+
+    static int GetBuyPrice(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetTemplate()->BuyPrice);
+        return 1;
+    }
+
+    static int GetSellPrice(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        sEluna->PushUnsigned(L, item->GetTemplate()->SellPrice);
+        return 1;
+    }
+};
+#endif
diff --git a/src/server/LuaEngine/LuaEngine.cpp b/src/server/LuaEngine/LuaEngine.cpp
new file mode 100644
index 0000000..b1dea4f
--- /dev/null
+++ b/src/server/LuaEngine/LuaEngine.cpp
@@ -0,0 +1,750 @@
+#include "LuaEngine.h"
+#include "HookMgr.h"
+#include "GlobalMethods.h"
+#include "UnitMethods.h"
+#include "GroupMethods.h"
+#include "GuildMethods.h"
+#include "GameObjectMethods.h"
+#include "QueryMethods.h"
+#include "AuraMethods.h"
+#include "ItemMethods.h"
+#include "WorldPacketMethods.h"
+#include "SpellMethods.h"
+#include "QuestMethods.h"
+#include "LuaFunctions.h"
+
+#if PLATFORM == PLATFORM_UNIX
+#include <dirent.h>
+#endif
+
+template<typename T> const char* GetTName() { return "UNK"; }
+template<> const char* GetTName<Unit>() { return "Unit"; }
+template<> const char* GetTName<GameObject>() { return "GameObject"; }
+template<> const char* GetTName<Group>() { return "Group"; }
+template<> const char* GetTName<Guild>() { return "Guild"; }
+template<> const char* GetTName<Log>() { return "Log"; }
+template<> const char* GetTName<QueryResult>() { return "QueryResult"; }
+template<> const char* GetTName<Aura>() { return "Aura"; }
+template<> const char* GetTName<WorldPacket>() { return "WorldPacket"; }
+template<> const char* GetTName<Item>() { return "Item"; }
+template<> const char* GetTName<Spell>() { return "Spell"; }
+template<> const char* GetTName<Quest>() { return "Quest"; }
+
+void Eluna::StartEluna(bool restart)
+{
+    if (restart)
+    {
+        sHookMgr->OnEngineRestart();
+        TC_LOG_INFO(LOG_FILTER_GENERAL, "Eluna Nova::Restarting Engine");
+
+        if (LuaState)
+        {
+            // Unregisters and stops all timed events
+            LuaEventMap::ScriptEventsResetAll();
+            LuaEventData::RemoveAll();
+
+            // Remove bindings
+            for (std::map<int, std::vector<int> >::iterator itr = ServerEventBindings.begin(); itr != ServerEventBindings.end(); ++itr)
+            {
+                for (std::vector<int>::const_iterator it = itr->second.begin(); it != itr->second.end(); ++it)
+                    luaL_unref(LuaState, LUA_REGISTRYINDEX, (*it));
+                itr->second.clear();
+            }
+            CreatureEventBindings->Clear();
+            CreatureGossipBindings->Clear();
+            GameObjectEventBindings->Clear();
+            GameObjectGossipBindings->Clear();
+            ItemEventBindings->Clear();
+            ItemGossipBindings->Clear();
+            playerGossipBindings->Clear();
+
+            lua_close(LuaState);
+        }
+    }
+    else
+        AddScriptHooks();
+
+    LuaState = luaL_newstate();
+    TC_LOG_INFO(LOG_FILTER_SERVER_LOADING, "Eluna Nova Lua Engine loaded.");
+
+    LoadedScripts loadedScripts;
+    LoadDirectory("scripts", &loadedScripts);
+    luaL_openlibs(LuaState);
+    //Register Globals Here
+    RegisterGlobals(LuaState);
+    //Register Templates Here
+    ElunaTemplate<Unit>::Register(LuaState);
+    ElunaTemplate<GameObject>::Register(LuaState);
+    ElunaTemplate<Group>::Register(LuaState);
+    ElunaTemplate<Guild>::Register(LuaState);
+    ElunaTemplate<QueryResult>::Register(LuaState);
+    ElunaTemplate<Aura>::Register(LuaState);
+    ElunaTemplate<WorldPacket>::Register(LuaState);
+    ElunaTemplate<Item>::Register(LuaState);
+    ElunaTemplate<Spell>::Register(LuaState);
+    ElunaTemplate<Quest>::Register(LuaState);
+
+    uint32 count = 0;
+    char filename[200];
+    for (std::set<std::string>::const_iterator itr = loadedScripts.luaFiles.begin(); itr !=  loadedScripts.luaFiles.end(); ++itr)
+    {
+        strcpy(filename, itr->c_str());
+        if (luaL_loadfile(LuaState, filename) != 0)
+        {
+            TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Eluna Nova::Error loading `%s`.", itr->c_str());
+            report(LuaState);
+        }
+        else
+        {
+            int err = lua_pcall(LuaState, 0, 0, 0);
+            if (err != 0 && err == LUA_ERRRUN)
+            {
+                TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Eluna Nova::Error loading `%s`.", itr->c_str());
+                report(LuaState);
+            }
+        }
+        ++count;
+    }
+    TC_LOG_INFO(LOG_FILTER_SERVER_LOADING, "Eluna Nova::Loaded %u Lua scripts", count);
+}
+
+// Loads lua scripts from given directory
+void Eluna::LoadDirectory(char* Dirname, LoadedScripts* lscr)
+{
+#ifdef WIN32
+    HANDLE hFile;
+    WIN32_FIND_DATA FindData;
+    memset(&FindData, 0, sizeof(FindData));
+    char SearchName[MAX_PATH];
+
+    strcpy(SearchName, Dirname);
+    strcat(SearchName, "\\*.*");
+
+    hFile = FindFirstFile(SearchName, &FindData);
+
+    // break if we don't find dir
+    if (!hFile)
+    {
+        TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Eluna Nova::No `scripts` directory found!");
+        return;
+    }
+
+    FindNextFile(hFile, &FindData);
+    while ( FindNextFile(hFile, &FindData) )
+    {
+        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+        {
+            strcpy(SearchName, Dirname);
+            strcat(SearchName, "\\");
+            strcat(SearchName, FindData.cFileName);
+            LoadDirectory(SearchName, lscr);
+        }
+        else
+        {
+            std::string fname = Dirname;
+            fname += "\\";
+            fname += FindData.cFileName;
+            size_t len = strlen(fname.c_str());
+            int i = 0;
+            char ext[MAX_PATH];
+            while (len > 0)
+            {
+                ext[i++] = fname[--len];
+                if (fname[len] == '.')
+                    break;
+            }
+            ext[i++] = '\0';
+            if (!_stricmp(ext,"aul."))
+                lscr->luaFiles.insert(fname);
+        }
+    }
+    FindClose(hFile);
+#else    
+    char* dir = strrchr(Dirname, '/');
+    if (strcmp(Dirname, "..") == 0 || strcmp(Dirname, ".") == 0)
+        return;
+
+    if (dir && (strcmp(dir, "/..") == 0 || strcmp(dir, "/.") == 0 || strcmp(dir, "/.svn") == 0))
+        return;
+
+    struct dirent** list;
+    int fileCount = scandir(Dirname, &list, 0, 0);
+
+    if (fileCount <= 0 || !list)
+        return;
+
+    struct stat attributes;
+    bool error;
+    while (fileCount--)
+    {
+        char _path[200];
+        sprintf(_path, "%s/%s", Dirname, list[fileCount]->d_name);
+        if (stat(_path, &attributes) == -1)
+        {
+            error = true;
+            TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Eluna Nova::Error opening `%s`", _path);
+        }
+        else
+            error = false;
+
+        if (!error && S_ISDIR(attributes.st_mode))
+            LoadDirectory((char*)_path, lscr);
+        else
+        {
+            char* ext = strrchr(list[fileCount]->d_name, '.');
+            if (ext && !strcmp(ext, ".lua"))
+                lscr->luaFiles.insert(_path);
+        }
+        free(list[fileCount]);
+    }
+    free(list);
+#endif
+}
+
+void Eluna::report(lua_State* L)
+{
+    const char* msg = lua_tostring(L, -1);
+    while (msg)
+    {
+        lua_pop(L, -1);
+        printf("\t%s\n",msg);
+        msg = lua_tostring(L, -1);
+    }
+}
+
+void Eluna::BeginCall(int fReference)
+{
+    lua_settop(LuaState, 0); //stack should be empty
+    lua_rawgeti(LuaState, LUA_REGISTRYINDEX, (fReference));
+}
+
+bool Eluna::ExecuteCall(uint8 params, uint8 res)
+{
+    bool ret = true;
+    int top = lua_gettop(LuaState);
+
+    if (lua_type(LuaState, top-params) == LUA_TFUNCTION) // is function
+    {
+        if (lua_pcall(LuaState,params,res,0) )
+        {
+            report(LuaState);
+            ret = false;
+        }
+    }
+    else
+    {
+        ret = false;
+        if (params > 0)
+        {
+            for (int i = top; i >= (top-params); i--)
+            {
+                if (!lua_isnone(LuaState, i) )
+                    lua_remove(LuaState, i);
+            }
+        }
+    }
+    return ret;
+}
+
+void Eluna::EndCall(uint8 res)
+{
+    for (int i = res; i > 0; i--)
+    {
+        if (!lua_isnone(LuaState,res))
+            lua_remove(LuaState,res);
+    }
+}
+
+/* Pushes */
+void Eluna::PushULong(lua_State* L, uint64 l)
+{
+    if (!L) L = LuaState;
+    std::ostringstream ss;
+    ss << "0x" << std::hex << l;
+    sEluna->PushString(L, ss.str().c_str());
+}
+
+void Eluna::PushLong(lua_State* L, int64 l)
+{
+    if (!L) L = LuaState;
+    std::ostringstream ss;
+    if (l < 0)
+        ss << "-0x" << std::hex << -l;
+    else
+        ss << "0x" << std::hex << l;
+    sEluna->PushString(L, ss.str().c_str());
+}
+
+void Eluna::PushInteger(lua_State* L, int i)
+{
+    if (!L) L = LuaState;
+    lua_pushinteger(L, i);
+}
+
+void Eluna::PushUnsigned(lua_State* L, uint32 u)
+{
+    if (!L) L = LuaState;
+    lua_pushunsigned(L, u);
+}
+
+void Eluna::PushFloat(lua_State* L, float f)
+{
+    if (!L) L = LuaState;
+    lua_pushnumber(L, f);
+}
+
+void Eluna::PushDouble(lua_State* L, double d)
+{
+    if (!L) L = LuaState;
+    lua_pushnumber(L, d);
+}
+
+void Eluna::PushBoolean(lua_State* L, bool b)
+{
+    if (!L) L = LuaState;
+    if (b)
+        lua_pushboolean(L, 1);
+    else
+        lua_pushboolean(L, 0);
+}
+
+void Eluna::PushString(lua_State* L, const char* str)
+{
+    if (!L) L = LuaState;
+    lua_pushstring(L, str);
+}
+
+void Eluna::PushGroup(lua_State* L, Group* group)
+{
+    if (!L) L = LuaState;
+    if (group)
+        ElunaTemplate<Group>::push(L, group);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushGuild(lua_State* L, Guild* guild)
+{
+    if (!L) L = LuaState;
+    if (guild)
+        ElunaTemplate<Guild>::push(L, guild);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushUnit(lua_State* L, Unit* unit)
+{
+    if (!L) L = LuaState;
+    if (unit)
+        ElunaTemplate<Unit>::push(L, unit);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushQueryResult(lua_State* L, QueryResult* result)
+{
+    if (!L) L = LuaState;
+    if (result)
+        ElunaTemplate<QueryResult>::push(L, result);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushGO(lua_State* L, GameObject* _go)
+{
+    if (!L) L = LuaState;
+    if (_go)
+        ElunaTemplate<GameObject>::push(L, _go);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushAura(lua_State* L, Aura* aura)
+{
+    if (!L) L = LuaState;
+    if (aura)
+        ElunaTemplate<Aura>::push(L, aura);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushItem(lua_State* L, Item* item)
+{
+    if (!L) L = LuaState;
+    if (item)
+        ElunaTemplate<Item>::push(L, item);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushSpell(lua_State* L, Spell* spell)
+{
+    if (!L) L = LuaState;
+    if (spell)
+        ElunaTemplate<Spell>::push(L, spell);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushQuest(lua_State* L, Quest const* quest)
+{
+    if (!L) L = LuaState;
+    if (quest)
+        ElunaTemplate<Quest>::push(L, const_cast<Quest*>(quest));
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushPacket(lua_State* L, WorldPacket* packet)
+{
+    if (!L) L = LuaState;
+    if (packet)
+        ElunaTemplate<WorldPacket>::push(L, packet);
+    else
+        lua_pushnil(L);
+}
+
+Object* Eluna::CHECK_OBJECT(lua_State* L, int narg)
+{
+    if (!L)
+        return ElunaTemplate<Object>::check(LuaState, narg);
+    else
+        return ElunaTemplate<Object>::check(L, narg);
+}
+
+WorldObject* Eluna::CHECK_WORLDOBJECT(lua_State* L, int narg)
+{
+    if (!L)
+        return ElunaTemplate<WorldObject>::check(LuaState, narg);
+    else
+        return ElunaTemplate<WorldObject>::check(L, narg);
+}
+
+Unit * Eluna::CHECK_UNIT(lua_State* L, int narg)
+{
+    WorldObject* obj = CHECK_WORLDOBJECT(L, narg);
+    if(!obj)
+        return NULL;
+    return obj->ToUnit();
+}
+
+Player * Eluna::CHECK_PLAYER(lua_State* L, int narg)
+{
+    WorldObject* obj = CHECK_WORLDOBJECT(L, narg);
+    if(!obj)
+        return NULL;
+    return obj->ToPlayer();
+}
+
+Creature * Eluna::CHECK_CREATURE(lua_State* L, int narg)
+{
+    WorldObject* obj = CHECK_WORLDOBJECT(L, narg);
+    if(!obj)
+        return NULL;
+    return obj->ToCreature();
+}
+
+GameObject* Eluna::CHECK_GAMEOBJECT(lua_State* L, int narg)
+{
+    WorldObject* obj = CHECK_WORLDOBJECT(L, narg);
+    if(!obj)
+        return NULL;
+    return obj->ToGameObject();
+}
+
+WorldPacket* Eluna::CHECK_PACKET(lua_State* L, int narg)
+{
+    if (!L)
+        return ElunaTemplate<WorldPacket>::check(LuaState, narg);
+    else
+        return ElunaTemplate<WorldPacket>::check(L, narg);
+}
+
+Quest* Eluna::CHECK_QUEST(lua_State* L, int narg)
+{
+    if (!L)
+        return ElunaTemplate<Quest>::check(LuaState, narg);
+    else
+        return ElunaTemplate<Quest>::check(L, narg);
+}
+
+Spell* Eluna::CHECK_SPELL(lua_State* L, int narg)
+{
+    if (!L)
+        return ElunaTemplate<Spell>::check(LuaState, narg);
+    else
+        return ElunaTemplate<Spell>::check(L, narg);
+}
+
+uint64 Eluna::CHECK_ULONG(lua_State* L, int narg)
+{
+    const char* c_str;
+    if (!L)
+        c_str = luaL_optstring(LuaState, narg, "0x0");
+    else
+        c_str = luaL_optstring(L, narg, "0x0");
+    return strtoul(c_str, NULL, 0);
+}
+
+int64 Eluna::CHECK_LONG(lua_State* L, int narg)
+{
+    const char* c_str;
+    if (!L)
+        c_str = luaL_optstring(LuaState, narg, "0x0");
+    else
+        c_str = luaL_optstring(L, narg, "0x0");
+    return strtol(c_str, NULL, 0);
+}
+
+// Saves the function reference ID given to the register type's store for given entry under the given event
+void Eluna::Register(uint8 regtype, uint32 id, uint32 evt, int functionRef)
+{
+    switch(regtype)
+    {
+    case REGTYPE_SERVER:
+        if (evt < SERVER_EVENT_COUNT)
+        {
+            ServerEventBindings[evt].push_back(functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_CREATURE:
+        if (evt < CREATURE_EVENT_COUNT)
+        {
+            if (!sObjectMgr->GetCreatureTemplate(id))
+            {
+                luaL_error(LuaState, "Couldn't find a creature with (ID: %d)!", id);
+                return;
+            }
+
+            sEluna->CreatureEventBindings->Insert(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_CREATURE_GOSSIP:
+        if (evt < GOSSIP_EVENT_COUNT)
+        {
+            if (!sObjectMgr->GetCreatureTemplate(id))
+            {
+                luaL_error(LuaState, "Couldn't find a creature with (ID: %d)!", id);
+                return;
+            }
+
+            sEluna->CreatureGossipBindings->Insert(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_GAMEOBJECT:
+        if (evt < GAMEOBJECT_EVENT_COUNT)
+        {
+            if (!sObjectMgr->GetGameObjectTemplate(id))
+            {
+                luaL_error(LuaState, "Couldn't find a gameobject with (ID: %d)!", id);
+                return;
+            }
+
+            sEluna->GameObjectEventBindings->Insert(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_GAMEOBJECT_GOSSIP:
+        if (evt < GOSSIP_EVENT_COUNT)
+        {
+            if (!sObjectMgr->GetGameObjectTemplate(id))
+            {
+                luaL_error(LuaState, "Couldn't find a gameobject with (ID: %d)!", id);
+                return;
+            }
+
+            sEluna->GameObjectGossipBindings->Insert(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_ITEM:
+        if (evt < ITEM_EVENT_COUNT)
+        {
+            if (!sObjectMgr->GetItemTemplate(id))
+            {
+                luaL_error(LuaState, "Couldn't find a item with (ID: %d)!", id);
+                return;
+            }
+
+            sEluna->ItemEventBindings->Insert(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_ITEM_GOSSIP:
+        if (evt < GOSSIP_EVENT_COUNT)
+        {
+            if (!sObjectMgr->GetItemTemplate(id))
+            {
+                luaL_error(LuaState, "Couldn't find a item with (ID: %d)!", id);
+                return;
+            }
+
+            sEluna->ItemGossipBindings->Insert(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_PLAYER_GOSSIP:
+        if (evt < GOSSIP_EVENT_COUNT)
+        {
+            sEluna->playerGossipBindings->Insert(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    default:
+        luaL_error(LuaState, "Unknown register type (regtype %d, id %d, event %d)", regtype, id, evt);
+        return;
+    }
+    luaL_error(LuaState, "Unknown event type (regtype %d, id %d, event %d)", regtype, id, evt);
+}
+void Eluna::ElunaBind::Clear()
+{
+    for (ElunaEntryMap::iterator itr = Bindings.begin(); itr != Bindings.end(); ++itr)
+    {
+        for (ElunaBindingMap::const_iterator it = itr->second.begin(); it != itr->second.end(); ++it)
+            luaL_unref(sEluna->LuaState, LUA_REGISTRYINDEX, it->second);
+        itr->second.clear();
+    }
+    Bindings.clear();
+}
+void Eluna::ElunaBind::Insert(uint32 entryId, uint32 eventId, int funcRef)
+{
+    if (Bindings[entryId][eventId])
+    {
+        luaL_error(sEluna->LuaState, "A function is already registered for entry (%d) event (%d)", entryId, eventId);
+        luaL_unref(sEluna->LuaState, LUA_REGISTRYINDEX, funcRef); // free the unused ref
+    }
+    else
+        Bindings[entryId][eventId] = funcRef;
+}
+
+UNORDERED_MAP<uint64, Eluna::LuaEventMap*> Eluna::LuaEventMap::LuaEventMaps;
+UNORDERED_MAP<int, Eluna::LuaEventData*> Eluna::LuaEventData::LuaEvents;
+UNORDERED_MAP<uint64, std::set<int> > Eluna::LuaEventData::EventIDs;
+
+void Eluna::LuaEventMap::ScriptEventsResetAll()
+{
+    // GameObject events reset
+    if (!LuaEventMaps.empty())
+        for (UNORDERED_MAP<uint64, LuaEventMap*>::const_iterator itr = LuaEventMaps.begin(); itr != LuaEventMaps.end(); ++itr)
+            if (itr->second)
+                itr->second->ScriptEventsReset();
+    // Global events reset
+    sEluna->LuaWorldAI->ScriptEventsReset();
+}
+void Eluna::LuaEventMap::ScriptEventsReset()
+{
+    _time = 0;
+    if (ScriptEventsEmpty())
+        return;
+    for (EventStore::const_iterator itr = _eventMap.begin(); itr != _eventMap.end();)
+    {
+        luaL_unref(sEluna->LuaState, LUA_REGISTRYINDEX, itr->second.funcRef);
+        ++itr;
+    }
+    _eventMap.clear();
+}
+void Eluna::LuaEventMap::ScriptEventCancel(int funcRef)
+{
+    if (ScriptEventsEmpty())
+        return;
+
+    for (EventStore::iterator itr = _eventMap.begin(); itr != _eventMap.end();)
+    {
+        if (funcRef == itr->second.funcRef)
+        {
+            luaL_unref(sEluna->LuaState, LUA_REGISTRYINDEX, itr->second.funcRef);
+            _eventMap.erase(itr++);
+        }
+        else
+            ++itr;
+    }
+}
+void Eluna::LuaEventMap::ScriptEventsExecute()
+{
+    if (ScriptEventsEmpty())
+        return;
+
+    for (EventStore::iterator itr = _eventMap.begin(); itr != _eventMap.end();)
+    {
+        if (itr->first > _time)
+        {
+            ++itr;
+            continue;
+        }
+
+        OnScriptEvent(itr->second.funcRef, itr->second.delay, itr->second.calls);
+
+        if (itr->second.calls != 1)
+        {
+            if (itr->second.calls > 1)
+                itr->second.calls = itr->second.calls-1;
+            _eventMap.insert(EventStore::value_type(_time + itr->second.delay, itr->second));
+        }
+        else
+            luaL_unref(sEluna->LuaState, LUA_REGISTRYINDEX, itr->second.funcRef);
+        _eventMap.erase(itr++);
+    }
+}
+
+// Lua taxi helper functions
+uint32 LuaTaxiMgr::nodeId = 500;
+void LuaTaxiMgr::StartTaxi(Player* player, uint32 pathid)
+{
+    if (pathid >= sTaxiPathNodesByPath.size())
+        return;
+
+    TaxiPathNodeList const& path = sTaxiPathNodesByPath[pathid];
+    if (path.size() < 2)
+        return;
+
+    std::vector<uint32> nodes;
+    nodes.resize(2);
+    nodes[0] = path[0].index;
+    nodes[1] = path[path.size()-1].index;
+
+    player->ActivateTaxiPathTo(nodes);
+}
+uint32 LuaTaxiMgr::AddPath(std::list<TaxiPathNodeEntry> nodes, uint32 mountA, uint32 mountH, uint32 price, uint32 pathId)
+{
+    if (nodes.size() < 2)
+        return 0;
+    if (!pathId)
+        pathId = sTaxiPathNodesByPath.size();
+    if (sTaxiPathNodesByPath.size() <= pathId)
+        sTaxiPathNodesByPath.resize(pathId+1);
+    sTaxiPathNodesByPath[pathId].clear();
+    sTaxiPathNodesByPath[pathId].resize(nodes.size());
+    uint32 startNode = nodeId;
+    uint32 index = 0;
+    for (std::list<TaxiPathNodeEntry>::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
+    {
+        TaxiPathNodeEntry entry = *it;
+        entry.path = pathId;
+        TaxiNodesEntry* nodeEntry = new TaxiNodesEntry();
+        nodeEntry->ID = index;
+        nodeEntry->map_id = entry.mapid;
+        nodeEntry->MountCreatureID[0] = mountH;
+        nodeEntry->MountCreatureID[1] = mountA;
+        nodeEntry->x = entry.x;
+        nodeEntry->y = entry.y;
+        nodeEntry->z = entry.z;
+        sTaxiNodesStore.SetEntry(nodeId, nodeEntry);
+        entry.index = nodeId++;
+        sTaxiPathNodesByPath[pathId].set(index++, TaxiPathNodePtr(new TaxiPathNodeEntry(entry)));
+    }
+    if (startNode >= nodeId)
+        return 0;
+    sTaxiPathSetBySource[startNode][nodeId-1] = TaxiPathBySourceAndDestination(pathId, price);
+    return pathId;
+}
\ No newline at end of file
diff --git a/src/server/LuaEngine/LuaEngine.h b/src/server/LuaEngine/LuaEngine.h
new file mode 100644
index 0000000..56dddfc
--- /dev/null
+++ b/src/server/LuaEngine/LuaEngine.h
@@ -0,0 +1,1361 @@
+#ifndef __ELUNA__H
+#define __ELUNA__H
+
+extern "C"
+{
+#include "lua.h"
+#include "lualib.h"
+#include "lauxlib.h"
+};
+
+#include <string>
+#include <map>
+#include "AccountMgr.h"
+#include "Chat.h"
+#include "Channel.h"
+#include "Creature.h"
+#include "GameObjectAI.h"
+#include "Group.h"
+#include "Guild.h"
+#include "GuildMgr.h"
+#include "QuestDef.h"
+#include "ScriptPCH.h"
+#include "ScriptMgr.h"
+#include "ScriptedCreature.h"
+#include "ArenaTeam.h"
+#include "Vehicle.h"
+#include "SystemConfig.h"
+#include "MapManager.h"
+#include "Language.h"
+#include "Pet.h"
+#include "AuctionHouseMgr.h"
+
+enum RegisterTypes
+{
+    REGTYPE_SERVER,
+    REGTYPE_CREATURE,
+    REGTYPE_CREATURE_GOSSIP,
+    REGTYPE_GAMEOBJECT,
+    REGTYPE_GAMEOBJECT_GOSSIP,
+    REGTYPE_ITEM,
+    REGTYPE_ITEM_GOSSIP,
+    REGTYPE_PLAYER_GOSSIP,
+    REGTYPE_COUNT
+};
+
+// RegisterServerHook(EventId, function)
+enum ServerEvents
+{
+    // Player
+    PLAYER_EVENT_ON_CHARACTER_CREATE        =     1,            // (event, player)
+    PLAYER_EVENT_ON_CHARACTER_DELETE        =     2,            // (event, guid)
+    PLAYER_EVENT_ON_LOGIN                   =     3,            // (event, player)
+    PLAYER_EVENT_ON_LOGOUT                  =     4,            // (event, player)
+    PLAYER_EVENT_ON_SPELL_CAST              =     5,            // (event, player, spell, skipCheck)
+    PLAYER_EVENT_ON_KILL_PLAYER             =     6,            // (event, killer, killed)
+    PLAYER_EVENT_ON_KILL_CREATURE           =     7,            // (event, killer, killed)
+    PLAYER_EVENT_ON_KILLED_BY_CREATURE      =     8,            // (event, killer, killed)
+    PLAYER_EVENT_ON_DUEL_REQUEST            =     9,            // (event, target, challenger)
+    PLAYER_EVENT_ON_DUEL_START              =     10,           // (event, player1, player2)
+    PLAYER_EVENT_ON_DUEL_END                =     11,           // (event, winner, loser, type)
+    PLAYER_EVENT_ON_GIVE_XP                 =     12,           // (event, player, amount, victim)
+    PLAYER_EVENT_ON_LEVEL_CHANGE            =     13,           // (event, player, oldLevel)
+    PLAYER_EVENT_ON_MONEY_CHANGE            =     14,           // (event, player, amount)
+    PLAYER_EVENT_ON_REPUTATION_CHANGE       =     15,           // (event, player, factionId, standing, incremental)
+    PLAYER_EVENT_ON_TALENTS_CHANGE          =     16,           // (event, player, points)
+    PLAYER_EVENT_ON_TALENTS_RESET           =     17,           // (event, player, noCost)
+    PLAYER_EVENT_ON_CHAT                    =     18,           // (event, player, msg, Type, lang) - Can return false
+    PLAYER_EVENT_ON_WHISPER                 =     19,           // (event, player, msg, Type, lang, receiver)
+    PLAYER_EVENT_ON_GROUP_CHAT              =     20,           // (event, player, msg, Type, lang, group) - Can return false
+    PLAYER_EVENT_ON_GUILD_CHAT              =     21,           // (event, player, msg, Type, lang, guild) - Can return false
+    PLAYER_EVENT_ON_CHANNEL_CHAT            =     22,           // (event, player, msg, Type, lang, channel) - Can return false
+    PLAYER_EVENT_ON_EMOTE                   =     23,           // (event, player, emote) - Not triggered on any known emote
+    PLAYER_EVENT_ON_TEXT_EMOTE              =     24,           // (event, player, textEmote, emoteNum, guid)
+    PLAYER_EVENT_ON_SAVE                    =     25,           // (event, player)
+    PLAYER_EVENT_ON_BIND_TO_INSTANCE        =     26,           // (event, player, difficulty, mapid, permanent)
+    PLAYER_EVENT_ON_UPDATE_ZONE             =     27,           // (event, player, newZone, newArea)
+    PLAYER_EVENT_ON_MAP_CHANGE              =     28,           // (event, player)
+
+    // Guild
+    GUILD_EVENT_ON_ADD_MEMBER               =     29,           // Implemented -- Commented out
+    GUILD_EVENT_ON_REMOVE_MEMBER            =     30,           // Implemented -- Commented out
+    GUILD_EVENT_ON_MOTD_CHANGE              =     31,           // Implemented -- Commented out
+    GUILD_EVENT_ON_INFO_CHANGE              =     32,           // Implemented -- Commented out
+    GUILD_EVENT_ON_CREATE                   =     33,           // Implemented -- Commented out
+    GUILD_EVENT_ON_DISBAND                  =     34,           // Implemented -- Commented out
+    GUILD_EVENT_ON_MONEY_WITHDRAW           =     35,           // Implemented -- Commented out
+    GUILD_EVENT_ON_MONEY_DEPOSIT            =     36,           // Implemented -- Commented out
+    GUILD_EVENT_ON_ITEM_MOVE                =     37,           // Implemented -- Commented out
+    GUILD_EVENT_ON_EVENT                    =     38,           // Implemented -- Commented out
+    GUILD_EVENT_ON_BANK_EVENT               =     39,           // Implemented -- Commented out
+
+    // Server
+    SERVER_EVENT_ON_NETWORK_START           =     40,           // Not Implemented
+    SERVER_EVENT_ON_NETWORK_STOP            =     41,           // Not Implemented
+    SERVER_EVENT_ON_SOCKET_OPEN             =     42,           // Not Implemented
+    SERVER_EVENT_ON_SOCKET_CLOSE            =     43,           // Not Implemented
+    SERVER_EVENT_ON_PACKET_RECEIVE          =     44,           // Not Implemented
+    SERVER_EVENT_ON_PACKET_RECEIVE_UNKNOWN  =     45,           // Not Implemented
+    SERVER_EVENT_ON_PACKET_SEND             =     46,           // Not Implemented
+
+    // World
+    WORLD_EVENT_ON_OPEN_STATE_CHANGE        =     47,           // (event, open)
+    WORLD_EVENT_ON_CONFIG_LOAD              =     48,           // (event, reload)
+    WORLD_EVENT_ON_MOTD_CHANGE              =     49,           // (event, newMOTD)
+    WORLD_EVENT_ON_SHUTDOWN_INIT            =     50,           // (event, code, mask)
+    WORLD_EVENT_ON_SHUTDOWN_CANCEL          =     51,           // (event)
+    WORLD_EVENT_ON_UPDATE                   =     52,           // (event, diff)
+    WORLD_EVENT_ON_STARTUP                  =     53,           // (event)
+    WORLD_EVENT_ON_SHUTDOWN                 =     54,           // (event)
+
+    // Eluna
+    ELUNA_EVENT_ON_RESTART                  =     55,           // (event)
+
+    // Map
+    MAP_EVENT_ON_CREATE                     =     56,           // Not Implemented
+    MAP_EVENT_ON_DESTROY                    =     57,           // Not Implemented
+    MAP_EVENT_ON_LOAD                       =     58,           // Not Implemented
+    MAP_EVENT_ON_UNLOAD                     =     59,           // Not Implemented
+    MAP_EVENT_ON_PLAYER_ENTER               =     60,           // Not Implemented
+    MAP_EVENT_ON_PLAYER_LEAVE               =     61,           // Not Implemented
+    MAP_EVENT_ON_UPDATE                     =     62,           // Not Implemented
+
+    // Area trigger
+    TRIGGER_EVENT_ON_TRIGGER                =     63,           // (event, player, triggerId)
+
+    // Weather
+    WEATHER_EVENT_ON_CHANGE                 =     64,           // (event, weather, state, grade)
+
+    // Auction house
+    AUCTION_EVENT_ON_ADD                    =     65,           // Not Implemented
+    AUCTION_EVENT_ON_REMOVE                 =     66,           // Not Implemented
+    AUCTION_EVENT_ON_SUCCESFUL              =     67,           // Not Implemented
+    AUCTION_EVENT_ON_EXPIRE                 =     68,           // Not Implemented
+
+    // Group
+    GROUP_EVENT_ON_MEMBER_ADD               =     69,           // (event, group, guid)
+    GROUP_EVENT_ON_MEMBER_INVITE            =     70,           // (event, group, guid)
+    GROUP_EVENT_ON_MEMBER_REMOVE            =     71,           // (event, group, guid, method, kicker, reason)
+    GROUP_EVENT_ON_LEADER_CHANGE            =     72,           // (event, group, newLeaderGuid, oldLeaderGuid)
+    GROUP_EVENT_ON_DISBAND                  =     73,           // (event, group)
+
+    // Custom
+    PLAYER_EVENT_ON_EQUIP                   =     74,           // (event, player, item, bag, slot)
+    PLAYER_EVENT_ON_FIRST_LOGIN             =     75,           // (event, player)
+    PLAYER_EVENT_ON_CAN_USE_ITEM            =     76,           // (event, player, itemEntry)
+    PLAYER_EVENT_ON_LOOT_ITEM               =     77,           // (event, player, item, count)
+    PLAYER_EVENT_ON_ENTER_COMBAT            =     78,           // (event, player, enemy)
+    PLAYER_EVENT_ON_LEAVE_COMBAT            =     79,           // (event, player)
+
+    SERVER_EVENT_COUNT
+};
+
+// RegisterCreatureEvent(entry, EventId, function)
+enum CreatureEvents
+{
+    CREATURE_EVENT_ON_ENTER_COMBAT                    = 1,      // (event, creature, target)
+    CREATURE_EVENT_ON_LEAVE_COMBAT                    = 2,      // (event, creature)
+    CREATURE_EVENT_ON_TARGET_DIED                     = 3,      // (event, creature, victim)
+    CREATURE_EVENT_ON_DIED                            = 4,      // (event, creature, killer)
+    CREATURE_EVENT_ON_SPAWN                           = 5,      // (event, creature)
+    CREATURE_EVENT_ON_REACH_WP                        = 6,      // (event, creature, type, id)
+    CREATURE_EVENT_ON_AIUPDATE                        = 7,      // (event, creature, diff)
+    CREATURE_EVENT_ON_RECEIVE_EMOTE                   = 8,      // (event, creature, player, emoteid)
+    CREATURE_EVENT_ON_DAMAGE_TAKEN                    = 9,      // (event, creature, attacker, damage)
+    CREATURE_EVENT_ON_PRE_COMBAT                      = 10,     // (event, creature, target)
+    CREATURE_EVENT_ON_ATTACKED_AT                     = 11,     // (event, creature, attacker)
+    CREATURE_EVENT_ON_OWNER_ATTACKED                  = 12,     // (event, creature, target)
+    CREATURE_EVENT_ON_OWNER_ATTACKED_AT               = 13,     // (event, creature, attacker)
+    CREATURE_EVENT_ON_HIT_BY_SPELL                    = 14,     // (event, creature, caster, spellid)
+    CREATURE_EVENT_ON_SPELL_HIT_TARGET                = 15,     // (event, creature, target, spellid)
+    CREATURE_EVENT_ON_SPELL_CLICK                     = 16,     // (event, creature, clicker)
+    CREATURE_EVENT_ON_CHARMED                         = 17,     // (event, creature, apply)
+    CREATURE_EVENT_ON_POSSESS                         = 18,     // (event, creature, apply)
+    CREATURE_EVENT_ON_JUST_SUMMONED_CREATURE          = 19,     // (event, creature, summon)
+    CREATURE_EVENT_ON_SUMMONED_CREATURE_DESPAWN       = 20,     // (event, creature, summon)
+    CREATURE_EVENT_ON_SUMMONED_CREATURE_DIED          = 21,     // (event, creature, summon, killer)
+    CREATURE_EVENT_ON_SUMMONED                        = 22,     // (event, creature, summoner)
+    CREATURE_EVENT_ON_RESET                           = 23,     // (event, creature)
+    CREATURE_EVENT_ON_REACH_HOME                      = 24,     // (event, creature)
+    CREATURE_EVENT_ON_CAN_RESPAWN                     = 25,     // (event, creature)
+    CREATURE_EVENT_ON_CORPSE_REMOVED                  = 26,     // (event, creature, respawndelay)
+    CREATURE_EVENT_ON_MOVE_IN_LOS                     = 27,     // (event, creature, unit)
+    CREATURE_EVENT_ON_VISIBLE_MOVE_IN_LOS             = 28,     // (event, creature, unit)
+    CREATURE_EVENT_ON_PASSANGER_BOARDED               = 29,     // (event, creature, passanger, seatid, apply)
+    CREATURE_EVENT_ON_DUMMY_EFFECT                    = 30,     // (event, caster, spellid, effindex, creature)
+    CREATURE_EVENT_ON_QUEST_ACCEPT                    = 31,     // (event, player, creature, quest)
+    CREATURE_EVENT_ON_QUEST_SELECT                    = 32,     // (event, player, creature, quest)
+    CREATURE_EVENT_ON_QUEST_COMPLETE                  = 33,     // (event, player, creature, quest)
+    CREATURE_EVENT_ON_QUEST_REWARD                    = 34,     // (event, player, creature, quest, opt)
+    CREATURE_EVENT_ON_DIALOG_STATUS                   = 35,     // (event, player, creature)
+    CREATURE_EVENT_COUNT
+};
+
+// RegisterGameObjectEvent(entry, EventId, function)
+enum GameObjectEvents
+{
+    GAMEOBJECT_EVENT_ON_AIUPDATE                    = 1,        // (event, go, diff)
+    GAMEOBJECT_EVENT_ON_RESET                       = 2,        // (event, go)
+    GAMEOBJECT_EVENT_ON_DUMMY_EFFECT                = 3,        // (event, caster, spellid, effindex, go)
+    GAMEOBJECT_EVENT_ON_QUEST_ACCEPT                = 4,        // (event, player, go, quest)
+    GAMEOBJECT_EVENT_ON_QUEST_REWARD                = 5,        // (event, player, go, quest, opt)
+    GAMEOBJECT_EVENT_ON_DIALOG_STATUS               = 6,        // (event, player, go)
+    GAMEOBJECT_EVENT_ON_DESTROYED                   = 7,        // (event, go, player)
+    GAMEOBJECT_EVENT_ON_DAMAGED                     = 8,        // (event, go, player)
+    GAMEOBJECT_EVENT_ON_LOOT_STATE_CHANGE           = 9,        // (event, go, state, unit)
+    GAMEOBJECT_EVENT_ON_GO_STATE_CHANGED            = 10,       // (event, go, state)
+    GAMEOBJECT_EVENT_COUNT
+};
+
+// RegisterItemEvent(entry, EventId, function)
+enum ItemEvents
+{
+    ITEM_EVENT_ON_DUMMY_EFFECT                      = 1,        // (event, caster, spellid, effindex, item)
+    ITEM_EVENT_ON_USE                               = 2,        // (event, player, item, target)
+    ITEM_EVENT_ON_QUEST_ACCEPT                      = 3,        // (event, player, item, quest)
+    ITEM_EVENT_ON_EXPIRE                            = 4,        // (event, player, itemid)
+    ITEM_EVENT_COUNT
+};
+
+// RegisterCreatureGossipEvent(entry, EventId, function)
+// RegisterGameObjectGossipEvent(entry, EventId, function)
+// RegisterItemGossipEvent(entry, EventId, function)
+// RegisterPlayerGossipEvent(menu_id, EventId, function)
+enum GossipEvents
+{
+    GOSSIP_EVENT_ON_HELLO                           = 1,        // (event, player, object) - Object is the Creature/GameObject/Item
+    GOSSIP_EVENT_ON_SELECT                          = 2,        // (event, player, object, sender, intid, code, menu_id) - Object is the Creature/GameObject/Item/Player, menu_id is only for player gossip
+    GOSSIP_EVENT_COUNT
+};
+
+struct LoadedScripts
+{
+    std::set<std::string> luaFiles;
+};
+
+template<class T>
+struct ElunaRegister
+{
+    const char* name;
+    int(*mfunc)(lua_State*, T*);
+};
+
+template<typename T> ElunaRegister<T>* GetMethodTable();
+template<typename T> const char* GetTName();
+
+class Eluna
+{
+public:
+    friend class ScriptMgr;
+    lua_State* LuaState;
+
+    class LuaEventMap;
+    struct LuaEventData;
+    class Eluna_WorldScript;
+    class Eluna_CreatureScript;
+    class Eluna_GameObjectScript;
+    Eluna_CreatureScript* LuaCreatureAI;
+    Eluna_GameObjectScript* LuaGameObjectAI;
+    Eluna_WorldScript* LuaWorldAI;
+
+    typedef std::map<int, int> ElunaBindingMap;
+    typedef UNORDERED_MAP<uint32, ElunaBindingMap> ElunaEntryMap;
+    struct ElunaBind;
+    std::map<int, std::vector<int> > ServerEventBindings;
+    ElunaBind* CreatureEventBindings;
+    ElunaBind* CreatureGossipBindings;
+    ElunaBind* GameObjectEventBindings;
+    ElunaBind* GameObjectGossipBindings;
+    ElunaBind* ItemEventBindings;
+    ElunaBind* ItemGossipBindings;
+    ElunaBind* playerGossipBindings;
+
+    void StartEluna(bool restart);
+    void AddScriptHooks();
+    static void report(lua_State*);
+    void Register(uint8 reg, uint32 id, uint32 evt, int func);
+    void BeginCall(int fReference);
+    bool ExecuteCall(uint8 params, uint8 res);
+    void EndCall(uint8 res);
+    void LoadDirectory(char* directory, LoadedScripts* scr);
+    // Pushes
+    void PushULong(lua_State*, uint64);
+    void PushLong(lua_State*, int64);
+    void PushInteger(lua_State*, int);
+    void PushUnsigned(lua_State*, uint32);
+    void PushBoolean(lua_State*, bool);
+    void PushFloat(lua_State*, float);
+    void PushDouble(lua_State*, double);
+    void PushString(lua_State*, const char*);
+    void PushGroup(lua_State*, Group*);
+    void PushGuild(lua_State*, Guild*);
+    void PushUnit(lua_State*, Unit*);
+    void PushGO(lua_State*, GameObject*);
+    void PushQueryResult(lua_State*, QueryResult*);
+    void PushAura(lua_State*, Aura*);
+    void PushItem(lua_State*, Item*);
+    void PushSpell(lua_State*, Spell*);
+    void PushQuest(lua_State*, Quest const*);
+    void PushPacket(lua_State*, WorldPacket*);
+    // Checks
+    WorldPacket* CHECK_PACKET(lua_State* L, int narg);
+    Object* CHECK_OBJECT(lua_State* L, int narg);
+    WorldObject* CHECK_WORLDOBJECT(lua_State* L, int narg);
+    Unit * CHECK_UNIT(lua_State* L, int narg);
+    Player * CHECK_PLAYER(lua_State* L, int narg);
+    Creature * CHECK_CREATURE(lua_State* L, int narg);
+    GameObject* CHECK_GAMEOBJECT(lua_State* L, int narg);
+    Quest* CHECK_QUEST(lua_State* L, int narg);
+    Spell* CHECK_SPELL(lua_State* L, int narg);
+    uint64 CHECK_ULONG(lua_State* L, int narg);
+    int64 CHECK_LONG(lua_State* L, int narg);
+
+    // Creates new binding stores
+    Eluna()
+    {
+        LuaState = NULL;
+        LuaCreatureAI = NULL;
+        LuaGameObjectAI = NULL;
+        LuaWorldAI = NULL;
+
+        for (int i = 0; i < SERVER_EVENT_COUNT; ++i)
+        {
+            std::vector<int> _vector;
+            ServerEventBindings.insert(std::pair<int, std::vector<int> >(i, _vector));
+        }
+        CreatureEventBindings = new ElunaBind;
+        CreatureGossipBindings = new ElunaBind;
+        GameObjectEventBindings = new ElunaBind;
+        GameObjectGossipBindings = new ElunaBind;
+        ItemEventBindings = new ElunaBind;
+        ItemGossipBindings = new ElunaBind;
+        playerGossipBindings = new ElunaBind;
+    }
+
+    ~Eluna()
+    {
+        for (std::map<int, std::vector<int> >::iterator itr = ServerEventBindings.begin(); itr != ServerEventBindings.end(); ++itr)
+        {
+            for (std::vector<int>::iterator it = itr->second.begin(); it != itr->second.end(); ++it)
+                luaL_unref(LuaState, LUA_REGISTRYINDEX, (*it));
+            itr->second.clear();
+        }
+        ServerEventBindings.clear();
+        CreatureEventBindings->Clear();
+        CreatureGossipBindings->Clear();
+        GameObjectEventBindings->Clear();
+        GameObjectGossipBindings->Clear();
+        ItemEventBindings->Clear();
+        ItemGossipBindings->Clear();
+        playerGossipBindings->Clear();
+
+        lua_close(LuaState); // Closing
+    }
+
+    struct ElunaBind
+    {
+        void Clear(); // unregisters all registered functions and clears all registered events from the bind std::maps (reset)
+        void Insert(uint32 entryId, uint32 eventId, int funcRef); // Inserts a new registered event
+
+        // Gets the function ref of an entry for an event
+        int GetBind(uint32 entryId, uint32 eventId)
+        {
+            ElunaEntryMap::iterator itr = Bindings.find(entryId);
+            if (itr == Bindings.end())
+                return 0;
+
+            return itr->second[eventId];
+        }
+
+        // Gets the binding std::map containing all registered events with the function refs for the entry
+        ElunaBindingMap* GetBindMap(uint32 entryId) 
+        {
+            ElunaEntryMap::iterator itr = Bindings.find(entryId);
+            if (itr == Bindings.end())
+                return NULL;
+
+            return &itr->second;
+        }
+
+        ElunaEntryMap Bindings; // Binding store Bindings[entryId][eventId] = funcRef;
+    };
+
+    Item* CHECK_ITEM(lua_State* L, int narg)
+    {
+        if (!L)
+            return ElunaTemplate<Item>::check(LuaState, narg);
+        else
+            return ElunaTemplate<Item>::check(L, narg);
+    }
+
+    class NearestTypeWithEntryInRangeCheck // not self
+    {
+    public:
+        NearestTypeWithEntryInRangeCheck(WorldObject const* obj, float range, TypeID typeId, uint32 entry = 0) : i_obj(obj), i_range(range), i_typeId(typeId), i_entry(entry)
+        {
+        }
+
+        bool operator()(WorldObject* u)
+        {
+            if (u->GetTypeId() == i_typeId && i_obj->GetGUID() != u->GetGUID() && (!i_entry || u->GetEntry() == i_entry) && i_obj->IsWithinDistInMap(u, i_range))
+            {
+                if (Unit* unit = u->ToUnit())
+                {
+                    if (!unit->IsAlive())
+                        return false;
+                }
+
+                i_range = i_obj->GetDistance(u);
+                return true;
+            }
+
+            return false;
+        }
+    private:
+        WorldObject const* i_obj;
+        float i_range;
+        TypeID i_typeId;
+        uint32 i_entry;
+
+        NearestTypeWithEntryInRangeCheck(NearestTypeWithEntryInRangeCheck const&);
+    };
+
+protected:
+    template<typename T>
+    class ElunaTemplate
+    {
+    public:
+        typedef int (*_funcptr)(lua_State* L, T* ptr);
+        typedef struct { const char* name; _funcptr mfunc; } ElunaRegister;
+
+        static void Register(lua_State* L)
+        {
+            lua_newtable(L);
+            int methods = lua_gettop(L);
+
+            luaL_newmetatable(L, GetTName<T>());
+            int metatable = lua_gettop(L);
+
+            // store method table in globals so that
+            // scripts can add functions in Lua
+            lua_pushvalue(L, methods);
+            lua_setglobal(L, GetTName<T>());
+
+            // hide metatable
+            lua_pushvalue(L, methods);
+            lua_setfield(L, metatable, "__metatable");
+
+            lua_pushvalue(L, methods);
+            lua_setfield(L, metatable, "__index");
+
+            lua_pushcfunction(L, tostringT);
+            lua_setfield(L, metatable, "__tostring");
+
+            lua_pushcfunction(L, gcT);
+            lua_setfield(L, metatable, "__gc");
+
+            lua_newtable(L);
+            lua_setmetatable(L, methods);
+
+            // fill method table.
+            if (!GetMethodTable<T>())
+            {
+                lua_pop(L, 2);
+                return;
+            }
+
+            for (ElunaRegister* l = ((ElunaRegister*)GetMethodTable<T>()); l->name; ++l)
+            {
+                lua_pushstring(L, l->name);
+                lua_pushlightuserdata(L, (void*)l);
+                lua_pushcclosure(L, thunk, 1);
+                lua_settable(L, methods);
+            }
+
+            lua_pop(L, 2);
+        }
+
+        static int push(lua_State* L, T* obj, bool gc = false)
+        {
+            if (!obj)
+            {
+                lua_pushnil(L);
+                return lua_gettop(L);
+            }
+            luaL_getmetatable(L, GetTName<T>());
+            if (lua_isnil(L, -1))
+                luaL_error(L, "%s missing metatable", GetTName<T>());
+            int idxMt = lua_gettop(L);
+            T** ptrHold = (T**)lua_newuserdata(L, sizeof(T**));
+            int ud = lua_gettop(L);
+            if (ptrHold)
+            {
+                *ptrHold = obj;
+                lua_pushvalue(L, idxMt);
+                lua_setmetatable(L, -2);
+                char name[32];
+                tostring(name, obj);
+                lua_getfield(L, LUA_REGISTRYINDEX, "DO NOT TRASH");
+                if (lua_isnil(L, -1))
+                {
+                    luaL_newmetatable(L, "DO NOT TRASH");
+                    lua_pop(L, 1);
+                }
+                lua_getfield(L, LUA_REGISTRYINDEX, "DO NOT TRASH");
+                if (gc == false)
+                {
+                    lua_pushboolean(L, 1);
+                    lua_setfield(L, -2, name);
+                }
+                lua_pop(L, 1);
+            }
+            lua_settop(L, ud);
+            lua_replace(L, idxMt);
+            lua_settop(L, idxMt);
+            return idxMt;
+        }
+
+        static T* check(lua_State* L, int narg)
+        {
+            T** ptrHold = static_cast<T**>(lua_touserdata(L, narg));
+            if (!ptrHold)
+                return NULL;
+            return *ptrHold;
+        }
+
+    private:
+        static int thunk(lua_State* L)
+        {
+            T* obj = check(L, 1); // get self
+            lua_remove(L, 1); // remove self
+            ElunaRegister* l = static_cast<ElunaRegister*>(lua_touserdata(L, lua_upvalueindex(1)));
+            return l->mfunc(L, obj);
+        }
+
+        static int gcT(lua_State* L)
+        {
+            T* obj = check(L, 1);
+            if (!obj)
+                return 0;
+            lua_getfield(L, LUA_REGISTRYINDEX, "DO NO TRASH");
+            if (lua_istable(L, -1))
+            {
+                char name[32];
+                tostring(name, obj);
+                lua_getfield(L, -1, std::string(name).c_str());
+                if (lua_isnil(L, -1))
+                {
+                    delete obj;
+                    obj = NULL;
+                }
+            }
+            return 1;
+        }
+
+        static int tostringT(lua_State* L)
+        {
+            char buff[32];
+            T** ptrHold = (T**)lua_touserdata(L, 1);
+            T* obj = *ptrHold;
+            sprintf(buff, "%p", obj);
+            lua_pushfstring(L, "%s (%s)", GetTName<T>(), buff);
+            return 1;
+        }
+
+        inline static void tostring(char* buff, void* obj)
+        {
+            sprintf(buff, "%p", obj);
+        }
+
+        static int index(lua_State* L)
+        {
+            lua_getglobal(L, GetTName<T>());
+            const char* key = lua_tostring(L, 2);
+            if (lua_istable(L, - 1))
+            {
+                lua_pushvalue(L, 2);
+                lua_rawget(L, -2);
+                if (lua_isnil(L, -1))
+                {
+                    lua_getmetatable(L, -2);
+                    if (lua_istable(L, -1))
+                    {
+                        lua_getfield(L, -1, "__index");
+                        if (lua_isfunction(L, -1))
+                        {
+                            lua_pushvalue(L, 1);
+                            lua_pushvalue(L, 2);
+                            lua_pcall(L, 2, 1, 0);
+                        }
+                        else if (lua_istable(L, -1))
+                            lua_getfield(L, -1, key);
+                        else
+                            lua_pushnil(L);
+                    }
+                    else
+                        lua_pushnil(L);
+                }
+                else if (lua_istable(L, -1))
+                {
+                    lua_pushvalue(L, 2);
+                    lua_rawget(L, -2);
+                }
+            }
+            else
+                lua_pushnil(L);
+            lua_insert(L, 1);
+            lua_settop(L, 1);
+            return 1;
+        }
+    };
+};
+#define sEluna ACE_Singleton<Eluna, ACE_Null_Mutex>::instance()
+
+class Eluna::LuaEventMap
+{
+public:
+    LuaEventMap() { }
+    ~LuaEventMap() { ScriptEventsReset(); }
+
+    struct eventData
+    {
+        int funcRef; uint32 delay; uint32 calls;
+        eventData(int _funcRef, uint32 _delay, uint32 _calls) :
+            funcRef(_funcRef), delay(_delay), calls(_calls) {}
+    };
+
+    typedef std::multimap<uint32, eventData> EventStore; // Not to use multimap? Can same function ref ID be used multiple times?
+
+    virtual void OnScriptEvent(int funcRef, uint32 delay, uint32 calls) { }
+
+    static void ScriptEventsResetAll(); // Unregisters and stops all timed events
+    void ScriptEventsReset();
+    void ScriptEventCancel(int funcRef);
+    void ScriptEventsExecute();
+
+    // Gets the event map saved for a guid
+    static LuaEventMap* GetEvents(WorldObject* obj)
+    {
+        if (!obj)
+            return NULL;
+        UNORDERED_MAP<uint64, LuaEventMap*>::const_iterator it = LuaEventMaps.find(obj->GetGUID());
+        if (it != LuaEventMaps.end())
+            return it->second;
+        return NULL;
+    }
+
+    void ScriptEventsUpdate(uint32 time)
+    {
+        _time += time;
+    }
+
+    bool ScriptEventsEmpty() const
+    {
+        return _eventMap.empty();
+    }
+
+    void ScriptEventCreate(int funcRef, uint32 delay, uint32 calls)
+    {
+        _eventMap.insert(EventStore::value_type(_time + delay, eventData(funcRef, delay, calls)));
+    }
+
+    static UNORDERED_MAP<uint64, LuaEventMap*> LuaEventMaps; // Creature and gameobject timed events
+
+private:
+    EventStore _eventMap;
+    uint32 _time;
+};
+class Eluna::Eluna_WorldScript : public WorldScript, public Eluna::LuaEventMap
+{
+public:
+    Eluna_WorldScript() : WorldScript("SmartEluna_WorldScript"), LuaEventMap()
+    {
+    }
+    ~Eluna_WorldScript()
+    {
+    }
+
+    void OnOpenStateChange(bool open)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[WORLD_EVENT_ON_OPEN_STATE_CHANGE].begin();
+            itr != sEluna->ServerEventBindings[WORLD_EVENT_ON_OPEN_STATE_CHANGE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, WORLD_EVENT_ON_OPEN_STATE_CHANGE);
+            sEluna->PushBoolean(sEluna->LuaState, open);
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+    void OnConfigLoad(bool reload)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[WORLD_EVENT_ON_CONFIG_LOAD].begin();
+            itr != sEluna->ServerEventBindings[WORLD_EVENT_ON_CONFIG_LOAD].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, WORLD_EVENT_ON_CONFIG_LOAD);
+            sEluna->PushBoolean(sEluna->LuaState, reload);
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+    void OnMotdChange(std::string& newMotd)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[WORLD_EVENT_ON_MOTD_CHANGE].begin();
+            itr != sEluna->ServerEventBindings[WORLD_EVENT_ON_MOTD_CHANGE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, WORLD_EVENT_ON_MOTD_CHANGE);
+            sEluna->PushString(sEluna->LuaState, newMotd.c_str());
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+    void OnShutdownInitiate(ShutdownExitCode code, ShutdownMask mask)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[WORLD_EVENT_ON_SHUTDOWN_INIT].begin();
+            itr != sEluna->ServerEventBindings[WORLD_EVENT_ON_SHUTDOWN_INIT].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, WORLD_EVENT_ON_SHUTDOWN_INIT);
+            sEluna->PushInteger(sEluna->LuaState, code);
+            sEluna->PushInteger(sEluna->LuaState, mask);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnShutdownCancel()
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[WORLD_EVENT_ON_SHUTDOWN_CANCEL].begin();
+            itr != sEluna->ServerEventBindings[WORLD_EVENT_ON_SHUTDOWN_CANCEL].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, WORLD_EVENT_ON_SHUTDOWN_CANCEL);
+            sEluna->ExecuteCall(1, 0);
+        }
+    }
+    void OnUpdate(uint32 diff)
+    {
+        ScriptEventsUpdate(diff);
+        ScriptEventsExecute();
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[WORLD_EVENT_ON_UPDATE].begin();
+            itr != sEluna->ServerEventBindings[WORLD_EVENT_ON_UPDATE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, WORLD_EVENT_ON_UPDATE);
+            sEluna->PushUnsigned(sEluna->LuaState, diff);
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+    // executed when a  timed event fires
+    void OnScriptEvent(int funcRef, uint32 delay, uint32 calls)
+    {
+        sEluna->BeginCall(funcRef);
+        sEluna->PushUnsigned(sEluna->LuaState, funcRef);
+        sEluna->PushUnsigned(sEluna->LuaState, delay);
+        sEluna->PushUnsigned(sEluna->LuaState, calls);
+        sEluna->ExecuteCall(3, 0);
+    }
+    void OnStartup()
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[WORLD_EVENT_ON_STARTUP].begin();
+            itr != sEluna->ServerEventBindings[WORLD_EVENT_ON_STARTUP].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, WORLD_EVENT_ON_STARTUP);
+            sEluna->ExecuteCall(1, 0);
+        }
+    }
+    void OnShutdown()
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[WORLD_EVENT_ON_SHUTDOWN].begin();
+            itr != sEluna->ServerEventBindings[WORLD_EVENT_ON_SHUTDOWN].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, WORLD_EVENT_ON_SHUTDOWN);
+            sEluna->ExecuteCall(1, 0);
+        }
+    }
+};
+class Eluna::Eluna_CreatureScript : public CreatureScript
+{
+public:
+    Eluna_CreatureScript() : CreatureScript("SmartEluna_CreatureScript") // Smart suppressing error @startup
+    {
+    }
+    ~Eluna_CreatureScript()
+    {
+    }
+
+    struct ScriptCreatureAI : ScriptedAI
+    {
+        ScriptCreatureAI(Creature* creature) : ScriptedAI(creature)
+        {
+        }
+        ~ScriptCreatureAI()
+        {
+        }
+
+        //Called at World update tick
+        void UpdateAI(uint32 diff)
+        {
+            ScriptedAI::UpdateAI(diff);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_AIUPDATE);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_AIUPDATE);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnsigned(sEluna->LuaState, diff);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        //Called for reaction at enter to combat if not in combat yet (enemy can be NULL)
+        //Called at creature aggro either by MoveInLOS or Attack Start
+        void EnterCombat(Unit* target)
+        {
+            ScriptedAI::EnterCombat(target);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_ENTER_COMBAT);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_ENTER_COMBAT);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, target);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        // Called at any Damage from any attacker (before damage apply)
+        void DamageTaken(Unit* attacker, uint32& damage)
+        {
+            ScriptedAI::DamageTaken(attacker, damage);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_DAMAGE_TAKEN);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_DAMAGE_TAKEN);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, attacker);
+            sEluna->PushUnsigned(sEluna->LuaState, damage);
+            sEluna->ExecuteCall(4, 0);
+        }
+
+        //Called at creature death
+        void JustDied(Unit* killer)
+        {
+            ScriptedAI::JustDied(killer);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_DIED);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_DIED);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, killer);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        //Called at creature killing another unit
+        void KilledUnit(Unit* victim)
+        {
+            ScriptedAI::KilledUnit(victim);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_TARGET_DIED);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_TARGET_DIED);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, victim);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        // Called when the creature summon successfully other creature
+        void JustSummoned(Creature* summon)
+        {
+            ScriptedAI::JustSummoned(summon);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_JUST_SUMMONED_CREATURE);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_JUST_SUMMONED_CREATURE);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, summon);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        // Called when a summoned creature is despawned
+        void SummonedCreatureDespawn(Creature* summon)
+        {
+            ScriptedAI::SummonedCreatureDespawn(summon);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_SUMMONED_CREATURE_DESPAWN);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_SUMMONED_CREATURE_DESPAWN);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, summon);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        // Called when hit by a spell
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            ScriptedAI::SpellHit(caster, spell);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_HIT_BY_SPELL);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_HIT_BY_SPELL);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, caster);
+            sEluna->PushUnsigned(sEluna->LuaState, spell->Id); // Pass spell object?
+            sEluna->ExecuteCall(4, 0);
+        }
+
+        // Called when spell hits a target
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            ScriptedAI::SpellHitTarget(target, spell);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_SPELL_HIT_TARGET);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_SPELL_HIT_TARGET);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, target);
+            sEluna->PushUnsigned(sEluna->LuaState, spell->Id); // Pass spell object?
+            sEluna->ExecuteCall(4, 0);
+        }
+
+        //Called at waypoint reached or PointMovement end
+        void MovementInform(uint32 type, uint32 id)
+        {
+            ScriptedAI::MovementInform(type, id);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_REACH_WP);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_REACH_WP);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnsigned(sEluna->LuaState, type);
+            sEluna->PushUnsigned(sEluna->LuaState, id);
+            sEluna->ExecuteCall(4, 0);
+        }
+
+        // Called when AI is temporarily replaced or put back when possess is applied or removed
+        void OnPossess(bool apply)
+        {
+            ScriptedAI::OnPossess(apply);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_POSSESS);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_POSSESS);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushBoolean(sEluna->LuaState, apply);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        //Called at creature reset either by death or evade
+        void Reset()
+        {
+            ScriptedAI::Reset();
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_RESET);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_RESET);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->ExecuteCall(2, 0);
+        }
+
+        // Called before EnterCombat even before the creature is in combat.
+        void AttackStart(Unit* target)
+        {
+            ScriptedAI::AttackStart(target);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_PRE_COMBAT);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_PRE_COMBAT);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, target);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        // Called in Creature::Update when deathstate = DEAD. Inherited classes may maniuplate the ability to respawn based on scripted events.
+        bool CanRespawn()
+        {
+            ScriptedAI::CanRespawn();
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_CAN_RESPAWN);
+            if (!bind)
+                return true;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_CAN_RESPAWN);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->ExecuteCall(2, 0);
+            return true;
+        }
+
+        // Called for reaction at stopping attack at no attackers or targets
+        void EnterEvadeMode()
+        {
+            ScriptedAI::EnterEvadeMode();
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_LEAVE_COMBAT);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_LEAVE_COMBAT);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->ExecuteCall(2, 0);
+        }
+
+        // Called when the creature is summoned successfully by other creature
+        void IsSummonedBy(Unit* summoner)
+        {
+            ScriptedAI::IsSummonedBy(summoner);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_SUMMONED);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_SUMMONED);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, summoner);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        void SummonedCreatureDies(Creature* summon, Unit* killer)
+        {
+            ScriptedAI::SummonedCreatureDies(summon, killer);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_SUMMONED_CREATURE_DIED);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_SUMMONED_CREATURE_DIED);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, summon);
+            sEluna->PushUnit(sEluna->LuaState, killer);
+            sEluna->ExecuteCall(4, 0);
+        }
+
+        // Called when the creature is target of hostile action: swing, hostile spell landed, fear/etc)
+        void AttackedBy(Unit* attacker)
+        {
+            ScriptedAI::AttackedBy(attacker);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_ATTACKED_AT);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_ATTACKED_AT);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, attacker);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        // Called when creature is spawned or respawned (for reseting variables)
+        void JustRespawned()
+        {
+            ScriptedAI::JustRespawned();
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_SPAWN);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_SPAWN);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->ExecuteCall(2, 0);
+        }
+
+        void OnCharmed(bool apply)
+        {
+            ScriptedAI::OnCharmed(apply);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_CHARMED);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_CHARMED);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushBoolean(sEluna->LuaState, apply);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        // Called at reaching home after evade
+        void JustReachedHome()
+        {
+            ScriptedAI::JustReachedHome();
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_REACH_HOME);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_REACH_HOME);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->ExecuteCall(2, 0);
+        }
+
+        // Called at text emote receive from player
+        void ReceiveEmote(Player* player, uint32 emoteId)
+        {
+            ScriptedAI::ReceiveEmote(player, emoteId);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_RECEIVE_EMOTE);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_RECEIVE_EMOTE);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnsigned(sEluna->LuaState, emoteId);
+            sEluna->ExecuteCall(4, 0);
+        }
+
+        // Called when owner takes damage
+        void OwnerAttackedBy(Unit* attacker)
+        {
+            ScriptedAI::OwnerAttackedBy(attacker);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_OWNER_ATTACKED_AT);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_OWNER_ATTACKED_AT);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, attacker);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        // Called when owner attacks something
+        void OwnerAttacked(Unit* target)
+        {
+            ScriptedAI::OwnerAttacked(target);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_OWNER_ATTACKED);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_OWNER_ATTACKED);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, target);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        // called when the corpse of this creature gets removed
+        void CorpseRemoved(uint32& respawnDelay)
+        {
+            ScriptedAI::CorpseRemoved(respawnDelay);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_CORPSE_REMOVED);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_CORPSE_REMOVED);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnsigned(sEluna->LuaState, respawnDelay);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        void PassengerBoarded(Unit* passenger, int8 seatId, bool apply)
+        {
+            ScriptedAI::PassengerBoarded(passenger, seatId, apply);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_PASSANGER_BOARDED);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_PASSANGER_BOARDED);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, passenger);
+            sEluna->PushInteger(sEluna->LuaState, seatId);
+            sEluna->PushBoolean(sEluna->LuaState, apply);
+            sEluna->ExecuteCall(5, 0);
+        }
+
+        void OnSpellClick(Unit* clicker, bool& result)
+        {
+            ScriptedAI::OnSpellClick(clicker, result);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_SPELL_CLICK);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_SPELL_CLICK);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, clicker);
+            sEluna->PushBoolean(sEluna->LuaState, result);
+            sEluna->ExecuteCall(4, 0);
+        }
+
+        void MoveInLineOfSight(Unit* who)
+        {
+            ScriptedAI::MoveInLineOfSight(who);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_MOVE_IN_LOS);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_MOVE_IN_LOS);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, who);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        // Called if IsVisible(Unit* who) is true at each who move, reaction at visibility zone enter
+        void MoveInLineOfSight_Safe(Unit* who)
+        {
+            ScriptedAI::MoveInLineOfSight_Safe(who);
+            int bind = sEluna->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_VISIBLE_MOVE_IN_LOS);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_VISIBLE_MOVE_IN_LOS);
+            sEluna->PushUnit(sEluna->LuaState, me);
+            sEluna->PushUnit(sEluna->LuaState, who);
+            sEluna->ExecuteCall(3, 0);
+        }
+    };
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        if (!sEluna->CreatureEventBindings->GetBindMap(creature->GetEntry()))
+            return NULL;
+
+        ScriptCreatureAI* luaCreatureAI = new ScriptCreatureAI(creature);
+        return luaCreatureAI;
+    }
+};
+class Eluna::Eluna_GameObjectScript : public GameObjectScript
+{
+public:
+    Eluna_GameObjectScript() : GameObjectScript("SmartEluna_GameObjectScript") // Smart suppressing error @startup
+    {
+    }
+    ~Eluna_GameObjectScript()
+    {
+    }
+
+    struct ScriptGameObjectAI : public GameObjectAI, public Eluna::LuaEventMap
+    {
+        ScriptGameObjectAI(GameObject* _go) : GameObjectAI(_go), LuaEventMap()
+        {
+        }
+        ~ScriptGameObjectAI()
+        {
+            LuaEventMap::LuaEventMaps.erase(go->GetGUID());
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ScriptEventsUpdate(diff);
+            ScriptEventsExecute();
+            int bind = sEluna->GameObjectEventBindings->GetBind(go->GetEntry(), GAMEOBJECT_EVENT_ON_AIUPDATE);
+            if (!bind)
+                return;
+            sEluna->BeginCall(bind);
+            sEluna->PushInteger(sEluna->LuaState, GAMEOBJECT_EVENT_ON_AIUPDATE);
+            sEluna->PushGO(sEluna->LuaState, go);
+            sEluna->PushUnsigned(sEluna->LuaState, diff);
+            sEluna->ExecuteCall(3, 0);
+        }
+
+        // executed when a timed event fires
+        void OnScriptEvent(int funcRef, uint32 delay, uint32 calls)
+        {
+            sEluna->BeginCall(funcRef);
+            sEluna->PushUnsigned(sEluna->LuaState, funcRef);
+            sEluna->PushUnsigned(sEluna->LuaState, delay);
+            sEluna->PushUnsigned(sEluna->LuaState, calls);
+            sEluna->PushGO(sEluna->LuaState, go);
+            sEluna->ExecuteCall(4, 0);
+        }
+
+        void Reset()
+        {
+            sEluna->BeginCall(sEluna->GameObjectEventBindings->GetBind(go->GetEntry(), GAMEOBJECT_EVENT_ON_RESET));
+            sEluna->PushInteger(sEluna->LuaState, GAMEOBJECT_EVENT_ON_RESET);
+            sEluna->PushGO(sEluna->LuaState, go);
+            sEluna->ExecuteCall(2, 0);
+        }
+    };
+
+    GameObjectAI* GetAI(GameObject* gameObject) const
+    {
+        if (!sEluna->GameObjectEventBindings->GetBindMap(gameObject->GetEntry()))
+            return NULL;
+
+        ScriptGameObjectAI* luaGameObjectAI = new ScriptGameObjectAI(gameObject);
+        LuaEventMap::LuaEventMaps[gameObject->GetGUID()] = luaGameObjectAI;
+        return luaGameObjectAI;
+    }
+};
+struct Eluna::LuaEventData : public BasicEvent, public Eluna::LuaEventMap::eventData
+{
+    static UNORDERED_MAP<int, LuaEventData*> LuaEvents;
+    static UNORDERED_MAP<uint64, std::set<int> > EventIDs;
+    Unit* _unit;
+    uint64 GUID;
+
+    LuaEventData(int funcRef, uint32 delay, uint32 calls, Unit* unit) :
+        _unit(unit), GUID(unit->GetGUID()), Eluna::LuaEventMap::eventData(funcRef, delay, calls)
+    {
+        LuaEvents[funcRef] = this;
+        EventIDs[unit->GetGUID()].insert(funcRef);
+    }
+
+    ~LuaEventData()
+    {
+        luaL_unref(sEluna->LuaState, LUA_REGISTRYINDEX, funcRef);
+        LuaEvents.erase(funcRef);
+        EventIDs[GUID].erase(funcRef);
+    }
+
+    static void RemoveAll()
+    {
+        for (UNORDERED_MAP<uint64, std::set<int> >::const_iterator it = EventIDs.begin(); it != EventIDs.end(); ++it)
+        {
+            if(it->second.empty())
+                continue;
+            for(std::set<int>::const_iterator itr = it->second.begin(); itr != it->second.end(); ++itr)
+            {
+                if(LuaEvents.find(*itr) == LuaEvents.end())
+                    continue;
+                if(LuaEvents[*itr]->_unit)
+                {
+                    LuaEvents[*itr]->_unit->m_Events.KillAllEvents(true);
+                    break;
+                }
+            }
+        }
+        LuaEvents.clear();
+        EventIDs.clear();
+    }
+    static void RemoveAll(Unit* unit)
+    {
+        if(!unit)
+            return;
+        unit->m_Events.KillAllEvents(true); // should delete the objects
+        for (std::set<int>::const_iterator it = EventIDs[unit->GetGUID()].begin(); it != EventIDs[unit->GetGUID()].end(); ++it)
+            LuaEvents.erase(*it); // deletes pointers
+        EventIDs.erase(unit->GetGUID());
+    }
+    static void Remove(uint64 guid, int eventID)
+    {
+        if(LuaEvents.find(eventID) != LuaEvents.end())
+        {
+            LuaEvents[eventID]->to_Abort = true; // delete on next cycle
+            LuaEvents.erase(eventID);
+        }
+        EventIDs[guid].erase(eventID);
+    }
+
+    bool Execute(uint64 time, uint32 diff) // Should NEVER execute on dead events
+    {
+        sEluna->BeginCall(funcRef);
+        sEluna->PushUnsigned(sEluna->LuaState, funcRef);
+        sEluna->PushUnsigned(sEluna->LuaState, delay);
+        sEluna->PushUnsigned(sEluna->LuaState, calls);
+        sEluna->PushUnit(sEluna->LuaState, _unit);
+        sEluna->ExecuteCall(4, 0);
+        if (calls && !--calls) // dont repeat anymore
+        {
+            Remove(GUID, funcRef);
+            return true; // destory event
+        }
+        _unit->m_Events.AddEvent(this, _unit->m_Events.CalculateTime(delay));
+        return false; // dont destory event
+    }
+};
+class LuaTaxiMgr
+{
+private:
+    static uint32 nodeId;
+public:
+    static void StartTaxi(Player* player, uint32 pathid);
+    static uint32 AddPath(std::list<TaxiPathNodeEntry> nodes, uint32 mountA, uint32 mountH, uint32 price = 0, uint32 pathId = 0);
+};
+#endif
diff --git a/src/server/LuaEngine/LuaFunctions.h b/src/server/LuaEngine/LuaFunctions.h
new file mode 100644
index 0000000..00b53c7
--- /dev/null
+++ b/src/server/LuaEngine/LuaFunctions.h
@@ -0,0 +1,929 @@
+#ifndef FUNCTION_TABLES_H
+#define FUNCTION_TABLES_H
+
+void RegisterGlobals(lua_State* L)
+{
+    // Hooks
+    lua_register(L, "RegisterServerHook", &LuaGlobalFunctions::RegisterServerHook);                         // RegisterServerHook(event, function)
+    lua_register(L, "RegisterCreatureEvent", &LuaGlobalFunctions::RegisterCreatureEvent);                   // RegisterCreatureEvent(entry, event, function)
+    lua_register(L, "RegisterCreatureGossipEvent", &LuaGlobalFunctions::RegisterCreatureGossipEvent);       // RegisterCreatureGossipEvent(entry, event, function)
+    lua_register(L, "RegisterGameObjectEvent", &LuaGlobalFunctions::RegisterGameObjectEvent);               // RegisterGameObjectEvent(entry, event, function)
+    lua_register(L, "RegisterGameObjectGossipEvent", &LuaGlobalFunctions::RegisterGameObjectGossipEvent);   // RegisterGameObjectGossipEvent(entry, event, function)
+    lua_register(L, "RegisterItemEvent", &LuaGlobalFunctions::RegisterItemEvent);                           // RegisterItemEvent(entry, event, function)
+    lua_register(L, "RegisterItemGossipEvent", &LuaGlobalFunctions::RegisterItemGossipEvent);               // RegisterItemGossipEvent(entry, event, function)
+    lua_register(L, "RegisterPlayerGossipEvent", &LuaGlobalFunctions::RegisterPlayerGossipEvent);           // RegisterPlayerGossipEvent(menu_id, event, function)
+
+    // Getters
+    lua_register(L, "GetLuaEngine", &LuaGlobalFunctions::GetLuaEngine);                                     // GetLuaEngine() - Returns ElunaEngine
+    lua_register(L, "GetLUAEngine", &LuaGlobalFunctions::GetLuaEngine);                                     // GetLUAEngine() - Returns ElunaEngine
+    lua_register(L, "GetCoreVersion", &LuaGlobalFunctions::GetCoreVersion);                                 // GetCoreVersion() - Returns core version string
+    lua_register(L, "GetQuest", &LuaGlobalFunctions::GetQuest);                                             // GetQuest(questId) - Returns quest object
+    lua_register(L, "GetPlayerByGUID", &LuaGlobalFunctions::GetPlayerByGUID);                               // GetPlayerByGUID(guid) - Returns player object by GUID
+    lua_register(L, "GetPlayerByName", &LuaGlobalFunctions::GetPlayerByName);                               // GetPlayerByName(name) - Returns player object by player name
+    lua_register(L, "GetGameTime", &LuaGlobalFunctions::GetGameTime);                                       // GetGameTime() - Returns game time
+    lua_register(L, "GetPlayersInWorld", &LuaGlobalFunctions::GetPlayersInWorld);                           // GetPlayersInWorld([team, onlyGM]) - Returns a table with all player objects. Team can be 0 for ally, 1 for horde and 2 for neutral
+    lua_register(L, "GetPlayersInMap", &LuaGlobalFunctions::GetPlayersInMap);                               // GetPlayersInWorld(mapId[, instanceId, team]) - Returns a table with all player objects in map. Team can be 0 for ally, 1 for horde and 2 for neutral
+    lua_register(L, "GetGuildByName", &LuaGlobalFunctions::GetGuildByName);                                 // GetGuildByName(name) - Returns guild object by the guild name
+    lua_register(L, "GetGuildByLeaderGUID", &LuaGlobalFunctions::GetGuildByLeaderGUID);                     // GetGuildByLeaderGUID(guid) - Returns guild by it's leader's guid
+    lua_register(L, "GetPlayerCount", &LuaGlobalFunctions::GetPlayerCount);                                 // GetPlayerCount() - Returns the server's player count
+    lua_register(L, "FindUnit", &LuaGlobalFunctions::FindUnit);                                             // FindUnit(guid) - Returns unit by it's guid
+    lua_register(L, "GetPlayerGUID", &LuaGlobalFunctions::GetPlayerGUID);                                   // GetPlayerGUID(lowguid) - Generates GUID (uint64) string from player lowguid UNDOCUMENTED
+    lua_register(L, "GetItemGUID", &LuaGlobalFunctions::GetItemGUID);                                       // GetItemGUID(lowguid) - Generates GUID (uint64) string from item lowguid UNDOCUMENTED
+    lua_register(L, "GetObjectGUID", &LuaGlobalFunctions::GetObjectGUID);                                   // GetObjectGUID(lowguid, entry) - Generates GUID (uint64) string from gameobject lowguid and entry UNDOCUMENTED
+    lua_register(L, "GetUnitGUID", &LuaGlobalFunctions::GetUnitGUID);                                       // GetUnitGUID(lowguid, entry) - Generates GUID (uint64) string from unit (creature) lowguid and entry UNDOCUMENTED
+    lua_register(L, "GetGUIDLow", &LuaGlobalFunctions::GetGUIDLow);                                         // GetGUIDLow(guid) - Returns GUIDLow (uint32) from guid (uint64 as string) UNDOCUMENTED
+    lua_register(L, "GetGUIDType", &LuaGlobalFunctions::GetGUIDType);                                       // GetGUIDType(guid) - Returns Type (uint32) from guid (uint64 as string) UNDOCUMENTED
+    lua_register(L, "GetGUIDEntry", &LuaGlobalFunctions::GetGUIDEntry);                                     // GetGUIDLow(guid) - Returns Entry (uint32) from guid (uint64 as string), may be always 0 UNDOCUMENTED
+    lua_register(L, "bit_not", &LuaGlobalFunctions::bit_not);                                               // bit_not(a) - Returns ~a UNDOCUMENTED
+    lua_register(L, "bit_xor", &LuaGlobalFunctions::bit_xor);                                               // bit_xor(a, b) - Returns a ^ b UNDOCUMENTED
+    lua_register(L, "bit_rshift", &LuaGlobalFunctions::bit_rshift);                                         // bit_rshift(a, b) - Returns a >> b UNDOCUMENTED
+    lua_register(L, "bit_lshift", &LuaGlobalFunctions::bit_lshift);                                         // bit_lshift(a, b) - Returns a << b UNDOCUMENTED
+    lua_register(L, "bit_or", &LuaGlobalFunctions::bit_or);                                                 // bit_or(a, b) - Returns a | b UNDOCUMENTED
+    lua_register(L, "bit_and", &LuaGlobalFunctions::bit_and);                                               // bit_and(a, b) - Returns a & b UNDOCUMENTED
+    lua_register(L, "GetItemLink", &LuaGlobalFunctions::GetItemLink);                                       // GetItemLink(entry[, localeIndex]) - Returns the shift clickable link of the item. Item name translated if translate available for provided locale index UNDOCUMENTED
+    lua_register(L, "GetPlayersInRange", &LuaGlobalFunctions::GetPlayersInRange);                           // GetPlayersInRange(WorldObject[, range]) - Returns a table with players in range of the object inserted (player, npc, gameobject..), range defaults to max. Can return nil
+    lua_register(L, "GetCreaturesInRange", &LuaGlobalFunctions::GetCreaturesInRange);                       // GetCreaturesInRange(WorldObject[, range]) - Returns a table with creatures in range of the object inserted (player, npc, gameobject..), range defaults to max. Can return nil
+    lua_register(L, "GetGameObjectsInRange", &LuaGlobalFunctions::GetGameObjectsInRange);                   // GetGameObjectsInRange(WorldObject[, range]) - Returns a table with gameobjects in range of the object inserted (player, npc, gameobject..), range defaults to max. Can return nil
+
+    // Other
+    lua_register(L, "ReloadEluna", &LuaGlobalFunctions::ReloadEluna);                                       // ReloadEluna() - Reload's Eluna engine
+    lua_register(L, "SendWorldMessage", &LuaGlobalFunctions::SendWorldMessage);                             // SendWorldMessage(msg) - Sends a broadcast message to everyone
+    lua_register(L, "WorldDBQuery", &LuaGlobalFunctions::WorldDBQuery);                                     // WorldDBQuery(sql) - Executes given SQL query to world database instantly and returns a QueryResult object
+    lua_register(L, "WorldDBExecute", &LuaGlobalFunctions::WorldDBExecute);                                 // WorldDBExecute(sql) - Executes given SQL query to world database (not instant)
+    lua_register(L, "CharDBQuery", &LuaGlobalFunctions::CharDBQuery);                                       // CharDBQuery(sql) - Executes given SQL query to character database instantly and returns a QueryResult object
+    lua_register(L, "CharDBExecute", &LuaGlobalFunctions::CharDBExecute);                                   // CharDBExecute(sql) - Executes given SQL query to character database (not instant)
+    lua_register(L, "AuthDBQuery", &LuaGlobalFunctions::AuthDBQuery);                                       // AuthDBQuery(sql) - Executes given SQL query to auth/logon database instantly and returns a QueryResult object
+    lua_register(L, "AuthDBExecute", &LuaGlobalFunctions::AuthDBExecute);                                   // AuthDBExecute(sql) - Executes given SQL query to auth/logon database (not instant)
+    lua_register(L, "CreateLuaEvent", &LuaGlobalFunctions::CreateLuaEvent);                                 // CreateLuaEvent(function, delay, calls) - Creates a timed event. Returns Event ID
+    lua_register(L, "RegisterTimedEvent", &LuaGlobalFunctions::CreateLuaEvent);                             // RegisterTimedEvent(function, delay, calls) - Creates a timed event. Returns Event ID
+    lua_register(L, "DestroyEventByID", &LuaGlobalFunctions::DestroyEventByID);                             // DestroyEventByID(eventId) - Removes a global timed event by it's ID
+    lua_register(L, "DestroyEvents", &LuaGlobalFunctions::DestroyEvents);                                   // DestroyEvents([allEvents]) - Removes all global timed events. Removes all timed events (creature and gameobject) if allEvents is true
+    lua_register(L, "PerformIngameSpawn", &LuaGlobalFunctions::PerformIngameSpawn);                         // PerformIngameSpawn(spawntype, entry, mapid, instanceid, x, y, z, o[, save, DurOrResptime, phase]) - spawntype: 1 Creature, 2 Object. DurOrResptime is respawntime for gameobjects and despawntime for creatures if creature is not saved. Returns spawned creature/gameobject
+    lua_register(L, "CreatePacket", &LuaGlobalFunctions::CreatePacket);                                     // CreatePacket(opcode, size) - Creates a new packet object
+    lua_register(L, "AddVendorItem", &LuaGlobalFunctions::AddVendorItem);                                   // AddVendorItem(entry, itemId, maxcount, incrtime, extendedcost[, persist(bool)]) - Adds an item to vendor entry. If persist is false, wont be saved to database.
+    lua_register(L, "VendorRemoveItem", &LuaGlobalFunctions::VendorRemoveItem);                             // VendorRemoveItem(entry, item[, persist(bool)]) - Removes an item from vendor entry. If persist is false, wont be saved to database.
+    lua_register(L, "VendorRemoveAllItems", &LuaGlobalFunctions::VendorRemoveAllItems);                     // VendorRemoveAllItems(entry[, persist(bool)]) - Removes all items from vendor entry. If persist is false, wont be saved to database.
+    lua_register(L, "Kick", &LuaGlobalFunctions::Kick);                                                     // Kick(player) - Kicks given player
+    lua_register(L, "Ban", &LuaGlobalFunctions::Ban);                                                       // Ban(banMode(integer), nameOrIP(string), duration(string), reason(string), player(whoBanned)) - Banmode: 0 account, 1 character, 2 IP
+    lua_register(L, "SaveAllPlayers", &LuaGlobalFunctions::SaveAllPlayers);                                 // SaveAllPlayers() - Saves all players
+    lua_register(L, "SendMail", &LuaGlobalFunctions::SendMail);                                             // SendMail(subject, text, receiverLowGUID[, sender, stationary, delay, itemEntry, itemAmount, itemEntry2, itemAmount2...]) - Sends a mail to player with lowguid. use nil to use default values on optional arguments. Sender is an optional player object. UNDOCUMENTED
+    lua_register(L, "AddTaxiPath", &LuaGlobalFunctions::AddTaxiPath);                                       // AddTaxiPath(pathTable, mountA, mountH[, price, pathId]) - Adds a new taxi path. Returns the path's ID. Will replace an existing path if pathId provided and already used. path table structure: T = {{map, x, y, z[, actionFlag, delay, arrivalEvId, departEvId]}, {...}, ...} UDOCUMENTED
+}
+
+ElunaRegister<Unit> UnitMethods[] =
+{
+    // Player Methods
+    // Getters
+    {"GetSelection", &LuaUnit::GetSelection},                                                               // :GetSelection()
+    {"GetGMRank", &LuaUnit::GetGMRank},                                                                     // :GetSecurity()
+    {"GetGuildId", &LuaUnit::GetGuildId},                                                                   // :GetGuildId() - nil on no guild
+    {"GetCoinage", &LuaUnit::GetCoinage},                                                                   // :GetCoinage()
+    {"GetTeam", &LuaUnit::GetTeam},                                                                         // :GetTeam() - returns the player's team. 0 for ally, 1 for horde
+    {"GetItemCount", &LuaUnit::GetItemCount},                                                               // :GetItemCount(item_id[, check_bank])
+    {"GetGroup", &LuaUnit::GetGroup},                                                                       // :GetGroup()
+    {"GetGuild", &LuaUnit::GetGuild},                                                                       // :GetGuild()
+    {"GetGearLevel", &LuaUnit::GetGearLevel},                                                               // :GetGearLevel() - Returns the player's average gear level
+    {"GetAccountId", &LuaUnit::GetAccountId},                                                               // :GetAccountId()
+    {"GetAccountName", &LuaUnit::GetAccountName},                                                           // :GetAccountName()
+    {"GetArenaPoints", &LuaUnit::GetArenaPoints},                                                           // :GetArenaPoints()
+    {"GetHonorPoints", &LuaUnit::GetHonorPoints},                                                           // :GetHonorPoints()
+    {"GetLifetimeKills", &LuaUnit::GetLifetimeKills},                                                       // :GetLifetimeKills() - Returns the player's lifetime (honorable) kills
+    {"GetPlayerIP", &LuaUnit::GetPlayerIP},                                                                 // :GetPlayerIP() - Returns the player's IP Address
+    {"GetLevelPlayedTime", &LuaUnit::GetLevelPlayedTime},                                                   // :GetLevelPlayedTime() - Returns the player's played time at that level
+    {"GetTotalPlayedTime", &LuaUnit::GetTotalPlayedTime},                                                   // :GetTotalPlayedTime() - Returns the total played time of that player
+    {"GetInventoryItem", &LuaUnit::GetInventoryItem},                                                       // :GetInventoryItem(slot) - Returns item at given inventory slot (0, 1, 2.. for equipment 19 - 23 for bags, 23 - 39 for backpack)
+    {"GetBagItem", &LuaUnit::GetBagItem},                                                                   // :GetBagItem(bagSlot, slot) - Returns item at given slot (0, 1, 2 .. max slots for bag) in a bag (19 - 23)
+    {"GetObjectGlobally", &LuaUnit::GetObjectGlobally},                                                     // :GetObjectGlobally(lowguid, entry) - Returns the gameobject of given lowguid and entry if in world
+    {"GetNearbyGameObject", &LuaUnit::GetNearbyGameObject},                                                 // :GetNearbyGameObject() - Returns nearby gameobject if found
+    {"GetReputation", &LuaUnit::GetReputation},                                                             // :GetReputation(faction) - Gets player's reputation with given faction
+    {"GetItemByEntry", &LuaUnit::GetItemByEntry},                                                           // :GetItemByEntry(entry) - Gets an item if the player has it
+    {"GetQuestLevel", &LuaUnit::GetQuestLevel},                                                             // :GetQuestLevel(quest) - Returns quest's level
+    {"GetChatTag", &LuaUnit::GetChatTag},                                                                   // :GetChatTag() - Returns player chat tag ID
+    {"GetRestBonus", &LuaUnit::GetRestBonus},                                                               // :GetRestBonus() - Gets player's rest bonus
+    {"GetRestType", &LuaUnit::GetRestType},                                                                 // :GetRestType() - Returns the player's rest type
+    {"GetPhaseMaskForSpawn", &LuaUnit::GetPhaseMaskForSpawn},                                               // :GetPhaseMaskForSpawn() - Gets the real phasemask for spawning things. Used if the player is in GM mode
+    {"GetReqKillOrCastCurrentCount", &LuaUnit::RemoveRewardedQuest},                                        // :GetReqKillOrCastCurrentCount(questId, entry) - Gets the objective (kill or cast) current count done
+    {"GetQuestStatus", &LuaUnit::GetQuestStatus},                                                           // :GetQuestStatus(entry) - Gets the quest's status
+    {"GetInGameTime", &LuaUnit::GetInGameTime},                                                             // :GetInGameTime() - Returns player's ingame time
+    {"GetComboPoints", &LuaUnit::GetComboPoints},                                                           // :GetComboPoints() - Returns player's combo points
+    {"GetComboTarget", &LuaUnit::GetComboTarget},                                                           // :GetComboTarget() - Returns the player's combo target
+    {"GetGuildName", &LuaUnit::GetGuildName},                                                               // :GetGuildName() - Returns player's guild's name or nil
+    {"GetFreeTalentPoints", &LuaUnit::GetFreeTalentPoints},                                                 // :GetFreeTalentPoints() - Returns the amount of unused talent points
+    {"GetActiveSpec", &LuaUnit::GetActiveSpec},                                                             // :GetActiveSpec() - Returns the active specID
+    {"GetSpecsCount", &LuaUnit::GetSpecsCount},                                                             // :GetSpecsCount() - Returns the player's spec count
+    {"GetSpellCooldownDelay", &LuaUnit::GetSpellCooldownDelay},                                             // :GetSpellCooldownDelay(spellId) - Returns the spell's cooldown
+    {"GetGuildRank", &LuaUnit::GetGuildRank},                                                               // :GetGuildRank() - Gets the player's guild rank
+    {"GetDifficulty", &LuaUnit::GetDifficulty},                                                             // :GetDifficulty([isRaid]) - Returns the current difficulty
+    {"GetHealthBonusFromStamina", &LuaUnit::GetHealthBonusFromStamina},                                     // :GetHealthBonusFromStamina() - Returns the HP bonus from stamina
+    {"GetManaBonusFromIntellect", &LuaUnit::GetManaBonusFromIntellect},                                     // :GetManaBonusFromIntellect() - Returns the mana bonus from intellect
+    {"GetMaxSkillValue", &LuaUnit::GetMaxSkillValue},                                                       // :GetMaxSkillValue(skill) - Gets max skill value for the given skill
+    {"GetPureMaxSkillValue", &LuaUnit::GetPureMaxSkillValue},                                               // :GetPureMaxSkillValue(skill) - Gets max base skill value
+    {"GetSkillValue", &LuaUnit::GetSkillValue},                                                             // :GetSkillValue(skill) - Gets current skill value
+    {"GetBaseSkillValue", &LuaUnit::GetBaseSkillValue},                                                     // :GetBaseSkillValue(skill) - Gets current base skill value (no temp bonus)
+    {"GetPureSkillValue", &LuaUnit::GetPureSkillValue},                                                     // :GetPureSkillValue(skill) - Gets current base skill value (no bonuses)
+    {"GetSkillStep", &LuaUnit::GetSkillStep},                                                               // :GetSkillStep(skill) - Returns current skillstep
+    {"GetSkillPermBonusValue", &LuaUnit::GetSkillPermBonusValue},                                           // :GetSkillPermBonusValue(skill) - Returns current permanent bonus
+    {"GetSkillTempBonusValue", &LuaUnit::GetSkillTempBonusValue},                                           // :GetSkillTempBonusValue(skill) - Returns current temp bonus
+    {"GetReputationRank", &LuaUnit::GetReputationRank},                                                     // :GetReputationRank(faction) - Returns the reputation rank with given faction
+    {"GetSpellCooldowns", &LuaUnit::GetSpellCooldowns},                                                     // :GetSpellCooldowns() - Gets a table where spellIDs are the keys and values are cooldowns
+    {"GetDrunkValue", &LuaUnit::GetDrunkValue},                                                             // :GetDrunkValue() - Returns the current drunkness value
+    {"GetBattlegroundId", &LuaUnit::GetBattlegroundId},                                                     // :GetBattlegroundId() - Returns the player's current battleground ID
+    {"GetBattlegroundTypeId", &LuaUnit::GetBattlegroundTypeId},                                             // :GetBattlegroundTypeId() - Returns the player's current battleground type ID
+    {"GetXPRestBonus", &LuaUnit::GetXPRestBonus},                                                           // :GetXPRestBonus(xp) - Returns the rested bonus XP from given XP
+    {"GetRestTime", &LuaUnit::GetRestTime},                                                                 // :GetRestTime() - Returns the timed rested
+    {"GetGroupInvite", &LuaUnit::GetGroupInvite},                                                           // :GetGroupInvite() - Returns the group invited to
+    {"GetSubGroup", &LuaUnit::GetSubGroup},                                                                 // :GetSubGroup() - Gets the player's current subgroup ID
+    {"GetNextRandomRaidMember", &LuaUnit::GetNextRandomRaidMember},                                         // :GetNextRandomRaidMember(radius) - Gets a random raid member in given radius
+    {"GetOriginalGroup", &LuaUnit::GetOriginalGroup},                                                       // :GetOriginalGroup() - Gets the original group object
+    {"GetOriginalSubGroup", &LuaUnit::GetOriginalSubGroup},                                                 // :GetOriginalSubGroup() - Returns the original subgroup ID
+    {"GetChampioningFaction", &LuaUnit::GetChampioningFaction},                                             // :GetChampioningFaction() - Returns the player's championing faction
+    {"GetLatency", &LuaUnit::GetLatency},                                                                   // :GetLatency() - Returns player's latency
+    {"GetRecruiterId", &LuaUnit::GetRecruiterId},                                                           // :GetRecruiterId() - Returns player's recruiter's ID
+    {"GetSelectedPlayer", &LuaUnit::GetSelectedPlayer},                                                     // :GetSelectedPlayer() - Returns player's selected player.
+    {"GetSelectedUnit", &LuaUnit::GetSelectedUnit},                                                         // :GetSelectedUnit() - Returns player's selected unit.
+
+    // Setters
+    {"AdvanceSkillsToMax", &LuaUnit::AdvanceSkillsToMax},                                                   // :AdvanceSkillsToMax() - Advances all currently known skills to the currently known max level
+    {"AdvanceSkill", &LuaUnit::AdvanceSkill},                                                               // :AdvanceSkill(skill_id, step) - Advances skill by ID and the amount(step)
+    {"AdvanceAllSkills", &LuaUnit::AdvanceAllSkills},                                                       // :AdvanceAllSkills(value) - Advances all current skills to your input(value)
+    {"AddLifetimeKills", &LuaUnit::AddLifetimeKills},                                                       // :AddLifetimeKills(val) - Adds lifetime (honorable) kills to your current lifetime kills
+    {"SetCoinage", &LuaUnit::SetCoinage},                                                                   // :SetCoinage(amount) - sets plr's coinage to this
+    {"SetKnownTitle", &LuaUnit::SetKnownTitle},                                                             // :SetKnownTitle(id)
+    {"UnsetKnownTitle", &LuaUnit::UnsetKnownTitle},                                                         // :UnsetKnownTitle(id)
+    {"SetBindPoint", &LuaUnit::SetBindPoint},                                                               // :SetBindPoint(x, y, z, map, areaid) - sets home for hearthstone
+    {"SetBindPointAtPlayerLoc", &LuaUnit::SetBindPointAtPlayerLoc},                                         // :SetBindPointAtPlayerLoc() - Set's home for hearthstone at player's location
+    {"SetArenaPoints", &LuaUnit::SetArenaPoints},                                                           // :SetArenaPoints(amount)
+    {"SetHonorPoints", &LuaUnit::SetHonorPoints},                                                           // :SetHonorPoints(amount)
+    {"SetLifetimeKills", &LuaUnit::SetLifetimeKills},                                                       // :SetLifetimeKills(val) - Sets the overall lifetime (honorable) kills of the player
+    {"SetGameMaster", &LuaUnit::SetGameMaster},                                                             // :SetGameMaster([on]) - Sets GM mode on or off
+    {"SetGMChat", &LuaUnit::SetGMChat},                                                                     // :SetGMChat([on]) - Sets GM chat on or off
+    {"SetTaxiCheat", &LuaUnit::SetTaxiCheat},                                                               // :SetTaxiCheat([on]) - Sets taxi cheat on or off
+    {"SetGMVisible", &LuaUnit::SetGMVisible},                                                               // :SetGMVisible([on]) - Sets gm visibility on or off
+    {"SetPvPDeath", &LuaUnit::SetPvPDeath},                                                                 // :SetPvPDeath([on]) - Sets PvP death on or off
+    {"SetAcceptWhispers", &LuaUnit::SetAcceptWhispers},                                                     // :SetAcceptWhispers([on]) - Sets whisper accepting death on or off
+    {"SetRestBonus", &LuaUnit::SetRestBonus},                                                               // :SetRestBonus(bonusrate) - Sets new restbonus rate
+    {"SetRestType", &LuaUnit::SetRestType},                                                                 // :SetRestType() - Sets rest type
+    {"SetSheath", &LuaUnit::SetSheath},                                                                     // :SetSheath(SheathState) - Sets player's seathstate
+    {"SetQuestStatus", &LuaUnit::SetQuestStatus},                                                           // :SetQuestStatus(entry, status) - Sets the quest's status
+    {"SetReputation", &LuaUnit::SetReputation},                                                             // :SetReputation(faction, value) - Sets the faction reputation for the player
+    {"SetFreeTalentPoints", &LuaUnit::SetFreeTalentPoints},                                                 // :SetFreeTalentPoints(points) - Sets the amount of unused talent points
+    {"SetGuildRank", &LuaUnit::SetGuildRank},                                                               // :SetGuildRank(rank) - Sets player's guild rank
+    {"SetMovement", &LuaUnit::SetMovement},                                                                 // :SetMovement(type) - Sets player's movement type
+    {"SetSkill", &LuaUnit::SetSkill},                                                                       // :SetSkill(skill, step, currVal, maxVal) - Sets the skill's boundaries and value
+    {"SetFactionForRace", &LuaUnit::SetFactionForRace},                                                     // :SetFactionForRace(race) - Sets the faction by raceID
+    {"SetDrunkValue", &LuaUnit::SetDrunkValue},                                                             // :SetDrunkValue(newDrunkValue) - Sets drunkness value
+    {"SetRestTime", &LuaUnit::SetRestTime},                                                                 // :SetRestTime(value) - Sets the rested time
+    {"SetAtLoginFlag", &LuaUnit::SetAtLoginFlag},                                                           // :SetAtLoginFlag(flag) - Adds an at login flag
+    {"SetPlayerLock", &LuaUnit::SetPlayerLock},                                                             // :SetPlayerLock(on/off)
+
+    // Boolean
+    {"IsWithinLoS", &LuaUnit::IsWithinLoS},                                                                 // :IsWithinLoS(x, y, z)
+    {"IsInGroup", &LuaUnit::IsInGroup},                                                                     // :IsInGroup()
+    {"IsInGuild", &LuaUnit::IsInGuild},                                                                     // :IsInGuild()
+    {"IsGM", &LuaUnit::IsGM},                                                                               // :IsGM()
+    {"IsAlliance", &LuaUnit::IsAlliance},                                                                   // :IsAlliance()
+    {"IsHorde", &LuaUnit::IsHorde},                                                                         // :IsHorde()
+    {"HasTitle", &LuaUnit::HasTitle},                                                                       // :HasTitle(id)
+    {"HasItem", &LuaUnit::HasItem},                                                                         // :HasItem(itemId[, count, check_bank]) - Returns true if the player has the item(itemId) and specified count, else it will return false
+    {"Teleport", &LuaUnit::Teleport},                                                                       // :Teleport(Map, X, Y, Z, O) - Teleports player to specified co - ordinates. Returns true if success and false if not
+    {"AddItem", &LuaUnit::AddItem},                                                                         // :AddItem(id, amount) - Adds amount of item to player. Returns true if success and false if not
+    {"IsInArenaTeam", &LuaUnit::IsInArenaTeam},                                                             // :IsInArenaTeam(type) - type : 0 = 2v2, 1 = 3v3, 2 = 5v5
+    {"CanEquipItem", &LuaUnit::CanEquipItem},                                                               // :CanEquipItem(entry/item, slot) - Returns true if the player can equip given item/item entry
+    {"IsFalling", &LuaUnit::IsFalling},                                                                     // :IsFalling() - Returns true if the unit is falling
+    {"ToggleAFK", &LuaUnit::ToggleAFK},                                                                     // :ToggleAFK() - Toggles AFK state for player
+    {"ToggleDND", &LuaUnit::ToggleDND},                                                                     // :ToggleDND() - Toggles DND state for player
+    {"IsAFK", &LuaUnit::IsAFK},                                                                             // :IsAFK() - Returns true if the player is afk
+    {"IsDND", &LuaUnit::IsDND},                                                                             // :IsDND() - Returns true if the player is in dnd mode
+    {"IsAcceptingWhispers", &LuaUnit::IsAcceptingWhispers},                                                 // :IsAcceptWhispers() - Returns true if the player accepts whispers
+    {"IsGMChat", &LuaUnit::IsGMChat},                                                                       // :IsGMChat() - Returns true if the player has GM chat on
+    {"IsTaxiCheater", &LuaUnit::IsTaxiCheater},                                                             // :IsTaxiCheater() - Returns true if the player has taxi cheat on
+    {"IsGMVisible", &LuaUnit::IsGMVisible},                                                                 // :IsGMVisible() - Returns true if the player is GM visible
+    {"IsActiveQuest", &LuaUnit::IsActiveQuest},                                                             // :IsActiveQuest(entry) - Returns true if the quest entry is active for the player
+    {"InBattlegroundQueue", &LuaUnit::InBattlegroundQueue},                                                 // :InBattlegroundQueue() - Returns true if the player is in a battleground queue
+    {"IsImmuneToEnvironmentalDamage", &LuaUnit::IsImmuneToEnvironmentalDamage},                             // :IsImmuneToEnvironmentalDamage() - Returns true if the player is immune to enviromental damage
+    {"CanSpeak", &LuaUnit::CanSpeak},                                                                       // :CanSpeak() - Returns true if the player can speak
+    {"HasAtLoginFlag", &LuaUnit::HasAtLoginFlag},                                                           // :HasAtLoginFlag(flag) - returns true if the player has the login flag
+    {"InRandomLfgDungeon", &LuaUnit::InRandomLfgDungeon},                                                   // :InRandomLfgDungeon() - Returns true if the player is in a random LFG dungeon
+    {"HasPendingBind", &LuaUnit::HasPendingBind},                                                           // :HasPendingBind() - Returns true if the player has a pending instance bind
+    {"HasAchieved", &LuaUnit::HasAchieved},                                                                 // :HasAchieved(achievementID) - Returns true if the player has achieved the achievement
+    {"CanUninviteFromGroup", &LuaUnit::CanUninviteFromGroup},                                               // :CanUninviteFromGroup() - Returns true if the player can uninvite from group
+    {"IsRested", &LuaUnit::IsRested},                                                                       // :IsRested() - Returns true if the player is rested
+    {"CanFlyInZone", &LuaUnit::CanFlyInZone},                                                               // :CanFlyInZone(mapid, zone) - Returns true if the player can fly in the area
+    {"IsNeverVisible", &LuaUnit::IsNeverVisible},                                                           // :IsNeverVisible() - Returns true if the player is never visible
+    {"IsVisibleForPlayer", &LuaUnit::IsVisibleForPlayer},                                                   // :IsVisibleForPlayer(player) - Returns true if the player is visible for the target player
+    {"IsUsingLfg", &LuaUnit::IsUsingLfg},                                                                   // :IsUsingLfg() - Returns true if the player is using LFG
+    {"HasQuestForItem", &LuaUnit::HasQuestForItem},                                                         // :HasQuestForItem(entry) - Returns true if the player has the quest for the item
+    {"HasQuestForGO", &LuaUnit::HasQuestForGO},                                                             // :HasQuestForGO(entry) - Returns true if the player has the quest for the gameobject
+    {"CanShareQuest", &LuaUnit::CanShareQuest},                                                             // :CanShareQuest(entry) - Returns true if the quest entry is shareable by the player
+    {"HasReceivedQuestReward", &LuaUnit::HasReceivedQuestReward},                                           // :HasReceivedQuestReward(entry) - Returns true if the player has recieved the quest's reward
+    {"HasTalent", &LuaUnit::HasTalent},                                                                     // :HasTalent(spellid, spec) - Returns true if the player has the talent spell in given spec
+    {"IsInSameGroupWith", &LuaUnit::IsInSameGroupWith},                                                     // :IsInSameGroupWith(player) - Returns true if the players are in the same group
+    {"IsInSameRaidWith", &LuaUnit::IsInSameRaidWith},                                                       // :IsInSameRaidWith(player) - Returns true if the players are in the same raid
+    {"IsGroupVisibleFor", &LuaUnit::IsGroupVisibleFor},                                                     // :IsGroupVisibleFor(player) - Player is group visible for the target
+    {"HasSkill", &LuaUnit::HasSkill},                                                                       // :HasSkill(skill) - Returns true if the player has the skill
+    {"IsHonorOrXPTarget", &LuaUnit::IsHonorOrXPTarget},                                                     // :IsHonorOrXPTarget(victim) - Returns true if the victim gives honor or XP
+    {"CanParry", &LuaUnit::CanParry},                                                                       // :CanParry() - Returns true if the player can parry
+    {"CanBlock", &LuaUnit::CanBlock},                                                                       // :CanBlock() - Returns true if the player can block
+    {"CanTitanGrip", &LuaUnit::CanTitanGrip},                                                               // :CanTitanGrip() - Returns true if the player has titan grip
+    {"CanTameExoticPets", &LuaUnit::CanTameExoticPets},                                                     // :CanTameExoticPets() - Returns true if the player can tame exotic pets
+    {"InBattleground", &LuaUnit::InBattleground},                                                           // :InBattleground() - Returns true if the player is in a battleground
+    {"InArena", &LuaUnit::InArena},                                                                         // :InArena() - Returns true if the player is in an arena
+    {"IsOutdoorPvPActive", &LuaUnit::IsOutdoorPvPActive},                                                   // :IsOutdoorPvPActive() - Returns true if the player is outdoor pvp active
+    {"IsARecruiter", &LuaUnit::IsARecruiter},                                                               // :IsARecruiter() - Returns true if the player is a recruiter
+
+    // Gossip
+    {"GossipMenuAddItem", &LuaUnit::GossipMenuAddItem},                                                     // :GossipMenuAddItem(icon, msg, sender, intid[, code, popup, money])
+    {"GossipSendMenu", &LuaUnit::GossipSendMenu},                                                           // :GossipSendMenu(npc_text, unit[, menu_id]) - If unit is a player, you need to use a menu_id. menu_id is used to hook the gossip select function to the menu
+    {"GossipComplete", &LuaUnit::GossipComplete},                                                           // :GossipComplete()
+    {"GossipClearMenu", &LuaUnit::GossipClearMenu},                                                         // :GossipClearMenu() - Clears the gossip menu of options. Pretty much only useful with player gossip. Need to use before creating a new menu for the player
+
+    // Other
+    {"SendClearCooldowns", &LuaUnit::SendClearCooldowns },                                                  // :SendClearCooldowns(spellId, (unit)target) - Clears the cooldown of the target with a specified spellId
+    {"SendBroadcastMessage", &LuaUnit::SendBroadcastMessage},                                               // :SendBroadcastMessage(message)
+    {"SendAreaTriggerMessage", &LuaUnit::SendAreaTriggerMessage},                                           // :SendAreaTriggerMessage(message) - Sends a yellow message in the middle of your screen
+    {"SendNotification", &LuaUnit::SendNotification},                                                       // :SendNotification(message) - Sends a red message in the middle of your screen
+    {"SendPacketToPlayer", &LuaUnit::SendPacketToPlayer},                                                   // :SendPacketToPlayer(packet) - Sends a specified packet to the player
+    {"SendPacket", &LuaUnit::SendPacket},                                                                   // :SendPacket(packet) - Sends a specified packet
+    {"SendPacketToGroup", &LuaUnit::SendPacketToGroup},                                                     // :SendPacketToGroup(packet[, sendToPlayersInBattleground(bool)]) - Sends a specified packet to the group with the choice (true/false) to send it to players in a battleground
+    {"SendPacketToGuild", &LuaUnit::SendPacketToGuild},                                                     // :SendPacketToGuild(packet) - Sends a specified packet to your guild
+    {"SendPacketToRankedInGuild", &LuaUnit::SendPacketToRankedInGuild},                                     // :SendPacketToRankedInGuild(packet, rankId) - Sends a specified packet to your guild, specifying a rankId will only send the packet to your ranked members
+    {"SendVendorWindow", &LuaUnit::SendVendorWindow},                                                       // :SendVendorWindow(unit) - Sends the unit's vendor window to the player
+    {"ModifyMoney", &LuaUnit::ModifyMoney},                                                                 // :ModifyMoney(amount[, sendError]) - Modifies (does not set) money (copper count) of the player. Amount can be negative to remove copper
+    {"LearnSpell", &LuaUnit::LearnSpell},                                                                   // :LearnSpell(id) - learns the given spell
+    {"RemoveItem", &LuaUnit::RemoveItem},                                                                   // :RemoveItem(item/entry, amount) - Removes amount of item from player
+    {"RemoveLifetimeKills", &LuaUnit::RemoveLifetimeKills},                                                 // :RemoveLifetimeKills(val) - Removes a specified amount(val) of the player's lifetime (honorable) kills
+    {"ResurrectPlayer", &LuaUnit::ResurrectPlayer},                                                         // :ResurrectPlayer([percent[, sickness(bool)]]) - Resurrects the player at percentage, player gets resurrection sickness if sickness set to true
+    {"PlaySoundToPlayer", &LuaUnit::PlaySoundToPlayer},                                                     // :PlaySoundToPlayer(soundId) - Plays the specified sound to the player
+    {"EquipItem", &LuaUnit::EquipItem},                                                                     // :EquipItem(entry/item, slot) - Equips given item or item entry for player to given slot. Returns the equipped item or nil
+    {"ResetSpellCooldown", &LuaUnit::ResetSpellCooldown},                                                   // :ResetSpellCooldown(spellId, update(bool~optional)) - Resets cooldown of the specified spellId. If update is true, it will send WorldPacket SMSG_CLEAR_COOLDOWN to the player, else it will just clear the spellId from m_spellCooldowns. This is true by default
+    {"ResetTypeCooldowns", &LuaUnit::ResetTypeCooldowns},                                                   // :ResetTypeCooldowns(category, update(bool~optional)) - Resets all cooldowns for the spell category(type). If update is true, it will send WorldPacket SMSG_CLEAR_COOLDOWN to the player, else it will just clear the spellId from m_spellCooldowns. This is true by default
+    {"ResetAllCooldowns", &LuaUnit::ResetAllCooldowns},                                                     // :ResetAllCooldowns() - Resets all spell cooldowns
+    {"GiveLevel", &LuaUnit::GiveLevel},                                                                     // :GiveLevel(level) - Gives levels to the player
+    {"GiveXP", &LuaUnit::GiveXP},                                                                           // :GiveXP(xp[, victim, group_rate, pureXP, triggerHook]) - Gives XP to the player. If pure is false, bonuses are count in. If triggerHook is false, GiveXp hook is not triggered.
+    {"RemovePet", &LuaUnit::RemovePet},                                                                     // :RemovePet([mode, returnreagent]) - Removes the player's pet. Mode determines if the pet is saved and how
+    {"SummonPet", &LuaUnit::SummonPet},                                                                     // :SummonPet(entry, x, y, z, o, petType, despwtime) - Summons a pet for the player
+    {"Say", &LuaUnit::Say},                                                                                 // :Say(text, lang) - The player says the text
+    {"Yell", &LuaUnit::Yell},                                                                               // :Yell(text, lang) - The player yells the text
+    {"TextEmote", &LuaUnit::TextEmote},                                                                     // :TextEmote(text) - The player does a textemote with the text
+    {"Whisper", &LuaUnit::Whisper},                                                                         // :Whisper(text, lang, receiverGuid) - The player whispers the text to the guid
+    {"CompleteQuest", &LuaUnit::CompleteQuest},                                                             // :CompleteQuest(entry) - Completes a quest by entry
+    {"IncompleteQuest", &LuaUnit::IncompleteQuest},                                                         // :IncompleteQuest(entry) - Uncompletes the quest by entry for the player
+    {"FailQuest", &LuaUnit::FailQuest},                                                                     // :FailQuest(entry) - Player fails the quest entry
+    {"RemoveActiveQuest", &LuaUnit::RemoveActiveQuest},                                                     // :RemoveActiveQuest(entry) - Removes an active quest
+    {"RemoveRewardedQuest", &LuaUnit::RemoveRewardedQuest},                                                 // :RemoveRewardedQuest(entry) - Removes a rewarded quest
+    {"AreaExploredOrEventHappens", &LuaUnit::AreaExploredOrEventHappens},                                   // :AreaExploredOrEventHappens(questId) - Satisfies an area or event requrement for the questId
+    {"GroupEventHappens", &LuaUnit::GroupEventHappens},                                                     // :GroupEventHappens(questId, worldObject) - Satisfies a group event for the questId with the world object
+    {"KilledMonsterCredit", &LuaUnit::KilledMonsterCredit},                                                 // :KilledMonsterCredit(entry) - Satisfies a monsterkill for the player
+    {"KilledPlayerCredit", &LuaUnit::KilledPlayerCredit},                                                   // :KilledPlayerCredit() - Satisfies a player kill for the player
+    {"CastedCreatureOrGO", &LuaUnit::CastedCreatureOrGO},                                                   // :CastedCreatureOrGO(creatureOrGOEntry, creatureOrGO, spellId) - Satisfies a spellcast on unit for the player
+    {"TalkedToCreature", &LuaUnit::TalkedToCreature},                                                       // :TalkedToCreature(npcEntry, creature) - Satisfies creature talk objective for the player
+    {"ResetPetTalents", &LuaUnit::ResetPetTalents},                                                         // :ResetPetTalents() - Resets player's pet's talents
+    {"RegenerateAll", &LuaUnit::RegenerateAll},                                                             // :RegenerateAll() - Regenerates all player's powers
+    {"Regenerate", &LuaUnit::Regenerate},                                                                   // :Regenerate(powerType) - Regenerates the given power type
+    {"RegenerateHealth", &LuaUnit::RegenerateHealth},                                                       // :RegenerateHealth() - Regenerates health
+    {"AddComboPoints", &LuaUnit::AddComboPoints},                                                           // :AddComboPoints(target, count[, spell]) - Adds combo points to the target for the player
+    {"GainSpellComboPoints", &LuaUnit::GainSpellComboPoints},                                               // :GainSpellComboPoints(amount) - Player gains spell combo points
+    {"ClearComboPoints", &LuaUnit::ClearComboPoints},                                                       // :ClearComboPoints() - Clears player's combo points
+    {"RemoveSpell", &LuaUnit::RemoveSpell},                                                                 // :RemoveSpell(entry[, disabled, learn_low_rank]) - Removes (unlearn) the given spell
+    {"ResetTalents", &LuaUnit::ResetTalents},                                                               // :ResetTalents([no_cost]) - Resets player's talents
+    {"ResetTalentsCost", &LuaUnit::ResetTalentsCost},                                                       // :ResetTalentsCost() - Returns the reset talents cost
+    {"AddTalent", &LuaUnit::AddTalent},                                                                     // :AddTalent(spellid, spec, learning) - Adds a talent spell for the player to given spec
+    {"RemoveFromGroup", &LuaUnit::RemoveFromGroup},                                                         // :RemoveFromGroup() - Removes the player from his group
+    {"KillPlayer", &LuaUnit::KillPlayer},                                                                   // :KillPlayer() - Kills the player
+    {"DurabilityLossAll", &LuaUnit::DurabilityLossAll},                                                     // :DurabilityLossAll(percent[, inventory]) - The player's items lose durability. Inventory true by default
+    {"DurabilityLoss", &LuaUnit::DurabilityLoss},                                                           // :DurabilityLoss(item, percent) - The given item loses durability
+    {"DurabilityPointsLoss", &LuaUnit::DurabilityPointsLoss},                                               // :DurabilityPointsLoss(item, points) - The given item loses durability
+    {"DurabilityPointsLossAll", &LuaUnit::DurabilityPointsLossAll},                                         // :DurabilityPointsLossAll(points, inventory) - Player's items lose durability
+    {"DurabilityPointLossForEquipSlot", &LuaUnit::DurabilityPointLossForEquipSlot},                         // :DurabilityPointLossForEquipSlot(slot) - Causes durability loss for the item in the given slot
+    {"DurabilityRepairAll", &LuaUnit::DurabilityRepairAll},                                                 // :DurabilityRepairAll([has_cost, discount, guildBank]) - Repairs all durability
+    {"DurabilityRepair", &LuaUnit::DurabilityRepair},                                                       // :DurabilityRepair(position[, has_cost, discount, guildBank]) - Repairs item durability of item in given position
+    {"ModifyHonorPoints", &LuaUnit::ModifyHonorPoints},                                                     // :ModifyHonorPoints(amount) - Modifies the player's honor points
+    {"ModifyArenaPoints", &LuaUnit::ModifyArenaPoints},                                                     // :ModifyArenaPoints(amount) - Modifies the player's arena points
+    {"LeaveBattleground", &LuaUnit::LeaveBattleground},                                                     // :LeaveBattleground([teleToEntryPoint]) - The player leaves the battleground
+    {"BindToInstance", &LuaUnit::BindToInstance},                                                           // :BindToInstance() - Binds the player to the current instance
+    {"UnbindInstance", &LuaUnit::UnbindInstance},                                                           // :UnbindInstance(map, difficulty) - Unbinds the player from an instance
+    {"RemoveFromBattlegroundOrBattlefieldRaid", &LuaUnit::RemoveFromBattlegroundOrBattlefieldRaid},         // :RemoveFromBattlegroundOrBattlefieldRaid() - Removes the player from a battleground or battlefield raid
+    {"ResetAchievements", &LuaUnit::ResetAchievements},                                                     // :ResetAchievements() - Resets players achievements
+    {"KickPlayer", &LuaUnit::KickPlayer},                                                                   // :KickPlayer() - Kicks player from server
+    {"LogoutPlayer", &LuaUnit::LogoutPlayer},                                                               // :LogoutPlayer([save]) - Logs the player out and saves if true
+    {"SendTrainerList", &LuaUnit::SendTrainerList},                                                         // :SendTrainerList(WorldObject) - Sends trainer list from object to player
+    {"SendListInventory", &LuaUnit::SendListInventory},                                                     // :SendListInventory(WorldObject) - Sends vendor list from object to player
+    {"SendShowBank", &LuaUnit::SendShowBank},                                                               // :SendShowBank(WorldObject) - Sends bank window from object to player
+    {"SendTabardVendorActivate", &LuaUnit::SendTabardVendorActivate},                                       // :SendTabardVendorActivate(WorldObject) - Sends tabard vendor window from object to player
+    {"SendSpiritResurrect", &LuaUnit::SendSpiritResurrect},                                                 // :SendSpiritResurrect() - Sends resurrect window to player
+    {"SendTaxiMenu", &LuaUnit::SendTaxiMenu},                                                               // :SendTaxiMenu(creature) - Sends flight window to player from creature
+    {"RewardQuest", &LuaUnit::RewardQuest},                                                                 // :RewardQuest(entry) - Gives quest rewards for the player
+    {"SendAuctionMenu", &LuaUnit::SendAuctionMenu},                                                         // :SendAuctionMenu([creature, faction]) - Sends auction window to player. Auction house is sent by creature if provided. AH entry is searched with faction or creature's faction if provided
+    {"SendMailMenu", &LuaUnit::SendMailMenu},                                                               // :SendMailMenu(object) - Sends mail window to player from gameobject
+    {"StartTaxi", &LuaUnit::StartTaxi},                                                                     // :StartTaxi(pathId) - player starts the given flight path
+    {"GossipSendPOI", &LuaUnit::GossipSendPOI},                                                             // :GossipSendPOI(X, Y, Icon, Flags, Data, Name) - Sends a point of interest to the player
+    {"GossipAddQuests", &LuaUnit::GossipAddQuests},                                                         // :GossipAddQuests(unit) - Adds unit's quests to player's gossip menu
+    {"SendQuestTemplate", &LuaUnit::SendQuestTemplate},                                                     // :SendQuestTemplate(questId, activeAccept) -- Sends quest template to player
+
+    // Creature methods
+    // Getters
+    {"GetAITarget", &LuaUnit::GetAITarget},                                                                 // :GetAITarget(type[, playeronly, position, distance, aura]) - Get an unit in threat list
+    {"GetAITargets", &LuaUnit::GetAITargets},                                                               // :GetAITargets() - Get units in threat list
+    {"GetAITargetsCount", &LuaUnit::GetAITargetsCount},                                                     // :GetAITargetsCount() - Get threat list size
+    {"GetVictim", &LuaUnit::GetVictim},                                                                     // :GetVictim() - Returns creature's current target
+    {"GetNearestTargetInAttackDistance", &LuaUnit::GetNearestTargetInAttackDistance},                       // :GetNearestTargetInAttackDistance([radius]) - Returns nearest target in attack distance and within given radius, if set
+    {"GetNearestTarget", &LuaUnit::GetNearestTarget},                                                       // :GetNearestTarget([radius]) - Returns nearest target in sight or given radius
+    {"GetNearestHostileTargetInAggroRange", &LuaUnit::GetNearestHostileTargetInAggroRange},                 // :GetNearestHostileTargetInAggroRange([checkLOS]) - Returns closest hostile target in aggro range of the creature
+    {"GetHomePosition", &LuaUnit::GetHomePosition},                                                         // :GetHomePosition() - Returns x,y,z,o of spawn position
+    {"GetTransportHomePosition", &LuaUnit::GetTransportHomePosition},                                       // :GetTransportHomePosition() - Returns x,y,z,o of transport spawn position
+    {"GetCorpseDelay", &LuaUnit::GetCorpseDelay},                                                           // :GetCorpseDelay() - Returns corpse delay
+    {"GetCreatureSpellCooldownDelay", &LuaUnit::GetCreatureSpellCooldownDelay},                             // :GetCreatureSpellCooldownDelay(spellId) - Returns spell cooldown delay
+    {"GetScriptId", &LuaUnit::GetScriptId},                                                                 // :GetScriptId() - Returns creature's script ID
+    {"GetAIName", &LuaUnit::GetAIName},                                                                     // :GetAIName() - Returns creature's AI name
+    {"GetScriptName", &LuaUnit::GetScriptName},                                                             // :GetScriptName() - Returns creature's script name
+    {"GetReactState", &LuaUnit::GetReactState},                                                             // :GetReactState() - Returns creature's react state
+    {"GetAttackDistance", &LuaUnit::GetAttackDistance},                                                     // :GetAttackDistance(unit) - Returns attack distance to unit
+    {"GetAggroRange", &LuaUnit::GetAggroRange},                                                             // :GetAggroRange(unit) - Returns aggro distance to unit
+    {"GetDefaultMovementType", &LuaUnit::GetDefaultMovementType},                                           // :GetDefaultMovementType() - Returns default movement type
+    {"GetRespawnDelay", &LuaUnit::GetRespawnDelay},                                                         // :GetRespawnDelay() - Returns respawn delay
+    {"GetRespawnRadius", &LuaUnit::GetRespawnRadius},                                                       // :GetRespawnRadius() - Returns respawn radius
+    {"GetWaypointPath", &LuaUnit::GetWaypointPath},                                                         // :GetWaypointPath() - Returns waypoint path ID
+    {"GetCurrentWaypointId", &LuaUnit::GetCurrentWaypointId},                                               // :GetCurrentWaypointId() - Returns waypoint ID
+    {"GetLootMode", &LuaUnit::GetLootMode},                                                                 // :GetLootMode() - Returns loot mode
+    {"GetLootRecipient", &LuaUnit::GetLootRecipient},                                                       // :GetLootRecipient() - Returns loot receiver
+    {"GetLootRecipientGroup", &LuaUnit::GetLootRecipientGroup},                                             // :GetLootRecipientGroup() - Returns loot receiver group
+
+    // Setters
+    {"SetHover", &LuaUnit::SetHover},                                                                       // :SetHover([enable]) - Sets hover on or off
+    {"SetDisableGravity", &LuaUnit::SetDisableGravity},                                                     // :SetDisableGravity([disable, packetOnly]) - Disables or enables gravity
+    {"SetReactState", &LuaUnit::SetReactState},                                                             // :SetReactState(state) - Sets react state
+    {"SetNoCallAssistance", &LuaUnit::SetNoCallAssistance},                                                 // :SetNoCallAssistance([noCall]) - Sets call assistance to false or true
+    {"SetNoSearchAssistance", &LuaUnit::SetNoSearchAssistance},                                             // :SetNoSearchAssistance([noSearch]) - Sets assistance searhing to false or true
+    {"SetDefaultMovementType", &LuaUnit::SetDefaultMovementType},                                           // :SetDefaultMovementType(type) - Sets default movement type
+    {"SetRespawnDelay", &LuaUnit::SetRespawnDelay},                                                         // :SetRespawnDelay(delay) - Sets the respawn delay
+    {"SetRespawnRadius", &LuaUnit::SetRespawnRadius},                                                       // :SetRespawnRadius(dist) - Sets the respawn radius
+    {"SetInCombatWithZone", &LuaUnit::SetInCombatWithZone},                                                 // :SetInCombatWithZone() - Sets the creature in combat with everyone in zone
+    {"SetDisableReputationGain", &LuaUnit::SetDisableReputationGain},                                       // :SetDisableReputationGain([disable]) - Disables or enables reputation gain from creature
+    {"SetLootMode", &LuaUnit::SetLootMode},                                                                 // :SetLootMode(lootMode) - Sets the lootmode
+
+    // Booleans
+    {"IsWorldBoss", &LuaUnit::IsWorldBoss},                                                                 // :IsWorldBoss() - Returns true if the creature is a WorldBoss, false if not
+    {"IsDungeonBoss", &LuaUnit::IsDungeonBoss},                                                             // :IsDungeonBoss() - Returns true if the creature is a DungeonBoss, false if not
+    {"IsRacialLeader", &LuaUnit::IsRacialLeader},                                                           // :IsRacialLeader() - Returns true if the creature is a racial leader, false if not
+    {"IsCivilian", &LuaUnit::IsCivilian},                                                                   // :IsCivilian() - Returns true if the creature is a civilian, false if not
+    {"IsTrigger", &LuaUnit::IsTrigger},                                                                     // :IsTrigger() - Returns true if the creature is a trigger, false if not
+    {"IsGuard", &LuaUnit::IsGuard},                                                                         // :IsGuard() - Returns true if the creature is a guard, false if not
+    {"IsElite", &LuaUnit::IsElite},                                                                         // :IsElite() - Returns true if the creature is an elite, false if not
+    {"IsInEvadeMode", &LuaUnit::IsInEvadeMode},                                                             // :IsInEvadeMode() - Returns true if the creature is in evade mode, false if not
+    {"HasCategoryCooldown", &LuaUnit::HasCategoryCooldown},                                                 // :HasCategoryCooldown(spellId) - Returns true if the creature has a cooldown for the spell's category
+    {"CanWalk", &LuaUnit::CanWalk},                                                                         // :CanWalk() - Returns true if the creature can walk
+    {"CanSwim", &LuaUnit::CanSwim},                                                                         // :CanSwim() - Returns true if the creature can swim
+    {"HasReactState", &LuaUnit::HasReactState},                                                             // :HasReactState(state) - Returns true if the creature has react state
+    {"CanStartAttack", &LuaUnit::CanStartAttack},                                                           // :CanStartAttack(unit[, force]) - Returns true if the creature can attack the unit
+    {"HasSearchedAssistance", &LuaUnit::HasSearchedAssistance},                                             // :HasSearchedAssistance() - Returns true if the creature has searched assistance
+    {"CanAssistTo", &LuaUnit::CanAssistTo},                                                                 // :CanAssistTo(unit, enemy[, checkfaction]) - Returns true if the creature can assist unit with enemy
+    {"IsTargetAcceptable", &LuaUnit::IsTargetAcceptable},                                                   // :IsTargetAcceptable(unit) - Returns true if the creature can target unit
+    {"HasInvolvedQuest", &LuaUnit::HasInvolvedQuest},                                                       // :HasInvolvedQuest(questId) - Returns true if the creature can finish the quest for players
+    {"IsRegeneratingHealth", &LuaUnit::IsRegeneratingHealth},                                               // :IsRegeneratingHealth() - Returns true if the creature is regenerating health
+    {"IsReputationGainDisabled", &LuaUnit::IsReputationGainDisabled},                                       // :IsReputationGainDisabled() - Returns true if the creature has reputation gain disabled
+    {"IsDamageEnoughForLootingAndReward", &LuaUnit::IsDamageEnoughForLootingAndReward},                     // :IsDamageEnoughForLootingAndReward()
+
+    // Other
+    {"Despawn", &LuaUnit::Despawn},                                                                         // :Despawn([despawnDelay]) - Creature despawns after given time
+    {"FleeToGetAssistance", &LuaUnit::FleeToGetAssistance},                                                 // :FleeToGetAssistance() - Creature flees for assistance
+    {"CallForHelp", &LuaUnit::CallForHelp},                                                                 // :CallForHelp(radius) - Creature calls for help from units in radius
+    {"CallAssistance", &LuaUnit::CallAssistance},                                                           // :CallAssistance() - Creature calls for assistance
+    {"RemoveCorpse", &LuaUnit::RemoveCorpse},                                                               // :RemoveCorpse([setSpawnTime]) - Removes corpse
+    {"DespawnOrUnsummon", &LuaUnit::DespawnOrUnsummon},                                                     // :DespawnOrUnsummon([Delay]) - Despawns the creature after delay if given
+    {"Respawn", &LuaUnit::Respawn},                                                                         // :Respawn([force]) - Respawns the creature
+    {"SelectVictim", &LuaUnit::SelectVictim},                                                               // :SelectVictim() - Returns a victim or nil
+    {"AddLootMode", &LuaUnit::AddLootMode},                                                                 // :AddLootMode(lootMode)
+    {"DealDamage", &LuaUnit::DealDamage},                                                                   // :DealDamage(target, amount) - Deals damage to target (if target) : if no target, unit will damage self
+
+    // Unit Methods
+    // Getters
+    {"GetName", &LuaUnit::GetName},                                                                         // :GetName()
+    {"GetLevel", &LuaUnit::GetLevel},                                                                       // :GetLevel()
+    {"GetHealth", &LuaUnit::GetHealth},                                                                     // :GetHealth()
+    {"GetDisplayId", &LuaUnit::GetDisplayId},                                                               // :GetDisplayId()
+    {"GetNativeDisplayId", &LuaUnit::GetNativeDisplayId},                                                   // :GetNativeDisplayId()
+    {"GetGUID", &LuaUnit::GetGUID},                                                                         // :GetGUID() - Returns uint64 guid as hex string
+    {"GetMapId", &LuaUnit::GetMapId},                                                                       // :GetMapId()
+    {"GetX", &LuaUnit::GetX},                                                                               // :GetX()
+    {"GetY", &LuaUnit::GetY},                                                                               // :GetY()
+    {"GetZ", &LuaUnit::GetZ},                                                                               // :GetZ()
+    {"GetO", &LuaUnit::GetO},                                                                               // :GetO()
+    {"GetLocation", &LuaUnit::GetLocation},                                                                 // :GetLocation() - returns X, Y, Z and O co - ords (in that order)
+    {"GetAreaId", &LuaUnit::GetAreaId},                                                                     // :GetAreaId()
+    {"GetZoneId", &LuaUnit::GetZoneId},                                                                     // :GetZoneId()
+    {"GetPower", &LuaUnit::GetPower},                                                                       // :GetPower(index) - returns power at index. Index can be omitted
+    {"GetMaxPower", &LuaUnit::GetMaxPower},                                                                 // :GetMaxPower(index) - returns power at index. Index can be omitted
+    {"GetPowerType", &LuaUnit::GetPowerType},                                                               // :GetPowerType() - Returns the power type
+    {"GetMaxHealth", &LuaUnit::GetMaxHealth},                                                               // :GetMaxHealth()
+    {"GetHealthPct", &LuaUnit::GetHealthPct},                                                               // :GetHealthPct()
+    {"GetPowerPct", &LuaUnit::GetPowerPct},                                                                 // :GetPowerPct(power_id)
+    {"GetGender", &LuaUnit::GetGender},                                                                     // :GetGender() - returns the gender where male = 0 female = 1
+    {"GetRace", &LuaUnit::GetRace},                                                                         // :GetRace()
+    {"GetClass", &LuaUnit::GetClass},                                                                       // :GetClass()
+    {"GetClassAsString", &LuaUnit::GetClassAsString},                                                       // :GetClassAsString()
+    {"GetUnitType", &LuaUnit::GetUnitType},                                                                 // :GetUnitType() - Returns object type, IE: Player, Creature
+    {"GetEntry", &LuaUnit::GetEntry},                                                                       // :GetEntry() - Returns the unit's entryId
+    {"GetAura", &LuaUnit::GetAura},                                                                         // :GetAura(spellID) - returns aura object
+    {"GetInt32Value", &LuaUnit::GetInt32Value},                                                             // :GetInt32Value(index) - returns an int value from unit fields
+    {"GetUInt32Value", &LuaUnit::GetUInt32Value},                                                           // :GetUInt32Value(index) - returns an uint value from unit fields
+    {"GetFloatValue", &LuaUnit::GetFloatValue},                                                             // :GetFloatValue(index) - returns a float value from unit fields
+    {"GetByteValue", &LuaUnit::GetByteValue},                                                               // :GetByteValue(index, offset) - returns a byte value from unit fields
+    {"GetUInt16Value", &LuaUnit::GetUInt16Value},                                                           // :GetUInt16Value(index, offset) - returns a uint16 value from unit fields
+    {"GetInstanceId", &LuaUnit::GetInstanceId},                                                             // :GetInstanceId() - Gets the instance id of the unit
+    {"GetPhaseMask", &LuaUnit::GetPhaseMask},                                                               // :GetPhaseMask() - gets the phase mask of the unit
+    {"GetCombatTime", &LuaUnit::GetCombatTime},                                                             // :GetCombatTime() - Returns how long the unit has been in combat
+    {"GetFaction", &LuaUnit::GetFaction},                                                                   // :GetFaction() - Returns the unit's factionId
+    {"GetCurrentSpell", &LuaUnit::GetCurrentSpell},                                                         // :GetCurrentSpell(type) - Returns the currently casted spell of given type if any
+    {"GetCreatureType", &LuaUnit::GetCreatureType},                                                         // :GetCreatureType() - Returns the unit's type
+    {"GetNearbyTarget", &LuaUnit::GetNearbyTarget},                                                         // :GetNearbyTarget([radius[, exclude]]) - Returns nearby target within sight or given radius. Excludes current target and given unit
+    {"GetShieldBlockValue", &LuaUnit::GetShieldBlockValue},                                                 // :GetShieldBlockValue() - Returns block value
+    {"GetMountId", &LuaUnit::GetMountId},                                                                   // :GetMountId()
+    {"GetScale", &LuaUnit::GetScale},                                                                       // :GetScale()
+    {"GetDistance", &LuaUnit::GetDistance},                                                                 // :GetDistance(WorldObject or x, y, z)
+    {"GetGUIDLow", &LuaUnit::GetGUIDLow},                                                                   // :GetGUIDLow() - Returns uint32 guid (low guid) that is used in database.
+    {"GetNearestPlayer", &LuaUnit::GetNearestPlayer},                                                       // :GetNearestPlayer([radius]) - Returns nearest player in sight or given radius.
+    {"GetNearestGameObject", &LuaUnit::GetNearestGameObject},                                               // :GetNearestGameObject([radius, entry]) - Returns nearest gameobject with given entry in sight or given radius.
+    {"GetNearestCreature", &LuaUnit::GetNearestCreature},                                                   // :GetNearestCreatureEntry([radius, entry]) - Returns nearest creature with given entry in sight or given radius.
+    {"GetRelativePoint", &LuaUnit::GetRelativePoint},                                                       // :GetRelativePoint(dist, degrees) - Returns the X, Y and orientation of a point dist away from unit. Degrees are - 90 for right and 90 for left.
+    {"GetHeight", &LuaUnit::GetHeight},                                                                     // :GetHeight(X, Y) - Returns the Z coord of the given location. If no valid position found, returns unit Z coordinate.
+    {"GetOwnerGUID", &LuaUnit::GetOwnerGUID},                                                               // :GetOwnerGUID() - Returns the GUID of the owner
+    {"GetOwner", &LuaUnit::GetOwner},                                                                       // :GetOwner() - Returns the owner
+    {"GetOwnerGUID", &LuaUnit::GetOwnerGUID},                                                               // :GetOwnerGUID() - Returns the GUID of the owner
+    {"GetFriendlyUnitsInRange", &LuaUnit::GetFriendlyUnitsInRange},                                         // :GetFriendlyUnitsInRange([range]) - Returns a list of friendly units in range, can return nil
+    {"GetUnfriendlyUnitsInRange", &LuaUnit::GetUnfriendlyUnitsInRange},                                     // :GetUnfriendlyUnitsInRange([range]) - Returns a list of unfriendly units in range, can return nil
+
+    // Setters
+    {"SetFaction", &LuaUnit::SetFaction},                                                                   // :SetFaction(factionId) - Sets the unit's faction
+    {"SetLevel", &LuaUnit::SetLevel},                                                                       // :SetLevel(amount)
+    {"SetHealth", &LuaUnit::SetHealth},                                                                     // :SetHealth(amount)
+    {"SetMaxHealth", &LuaUnit::SetMaxHealth},                                                               // :SetMaxHealth(amount)
+    {"SetPower", &LuaUnit::SetPower},                                                                       // :SetPower(index, amount)
+    {"SetMaxPower", &LuaUnit::SetMaxPower},                                                                 // :SetMaxPower(index, amount)
+    {"SetDisplayId", &LuaUnit::SetDisplayId},                                                               // :SetDisplayId(id)
+    {"SetNativeDisplayId", &LuaUnit::SetNativeDisplayId},                                                   // :SetNativeDisplayId(id)
+    {"SetFacing", &LuaUnit::SetFacing},                                                                     // :SetFacing(o) - Sets the Unit facing to arg
+    {"SetDeathState", &LuaUnit::SetDeathState},                                                             // :SetDeathState(value) - 0 = alive 1 = just died 2 = corpse 3 = dead
+    {"SetInt32Value", &LuaUnit::SetInt32Value},                                                             // :SetInt32Value(index, value) - Sets an int value for the unit
+    {"SetUInt32Value", &LuaUnit::SetUInt32Value},                                                           // :SetUInt32Value(index, value) - Sets an uint value for the unit
+    {"UpdateUInt32Value", &LuaUnit::UpdateUInt32Value},                                                     // :UpdateUInt32Value(index, value) - Updates an uint value for the unit
+    {"SetFloatValue", &LuaUnit::SetFloatValue},                                                             // :SetFloatValue(index, value) - Sets a float value for the unit
+    {"SetByteValue", &LuaUnit::SetByteValue},                                                               // :SetByteValue(index, offset, value) - Sets a byte value for the unit
+    {"SetUInt16Value", &LuaUnit::SetUInt16Value},                                                           // :SetUInt16Value(index, offset, value) - Sets an uint16 value for the unit
+    {"SetInt16Value", &LuaUnit::SetInt16Value},                                                             // :SetInt16Value(index, offset, value) - Sets an int16 value for the unit
+    {"SetPhaseMask", &LuaUnit::SetPhaseMask},                                                               // :SetPhaseMask(Phase[, update]) - Sets the phase of the unit
+    {"SetWalk", &LuaUnit::SetWalk},                                                                         // :SetWalk([enable]) - If false, creature runs, otherwise walks
+    {"SetSpeed", &LuaUnit::SetSpeed},                                                                       // :SetSpeed(type, speed[, forced]) - Sets speed for the movement type (0 = walk, 1 = run ..)
+    {"SetStunned", &LuaUnit::SetStunned},                                                                   // :SetStunned([enable]) - Stuns or removes stun
+    {"SetRooted", &LuaUnit::SetRooted},                                                                     // :SetRooted([enable]) - Roots or removes root
+    {"SetConfused", &LuaUnit::SetConfused},                                                                 // :SetConfused([enable]) - Sets confused or removes confusion
+    {"SetFeared", &LuaUnit::SetFeared},                                                                     // :SetFeared([enable]) - Fears or removes fear
+    {"SetGender", &LuaUnit::SetGender},                                                                     // :SetGender(value) - 0 = male 1 = female
+    {"SetPvP", &LuaUnit::SetPvP},                                                                           // :SetPvP([apply]) - Sets the units PvP on or off
+    {"SetFFA", &LuaUnit::SetFFA},                                                                           // :SetFFA([apply]) - Sets the units FFA tag on or off
+    {"SetSanctuary", &LuaUnit::SetSanctuary},                                                               // :SetSanctuary([apply]) - Enables or disables units sanctuary flag
+    {"SetScale", &LuaUnit::SetScale},                                                                       // :SetScale(scale)
+    {"SetCanFly", &LuaUnit::SetCanFly},                                                                     // :SetCanFly(apply)
+    {"SetVisible", &LuaUnit::SetVisible},                                                                   // :SetVisible(x)
+    {"SetOwnerGUID", &LuaUnit::SetOwnerGUID},                                                               // :SetOwnerGUID(guid) - Sets the guid of the owner
+    {"SetFlag", &LuaUnit::SetFlag},                                                                         // :SetFlag(index, flag)
+
+    // Boolean
+    {"IsAlive", &LuaUnit::IsAlive},                                                                         // :IsAlive()
+    {"IsDead", &LuaUnit::IsDead},                                                                           // :IsDead() - Returns true if the unit is dead, false if they are alive
+    {"IsDying", &LuaUnit::IsDying},                                                                         // :IsDying() - Returns true if the unit death state is JUST_DIED.
+    {"IsInWorld", &LuaUnit::IsInWorld},                                                                     // :IsInWorld()
+    {"IsPvPFlagged", &LuaUnit::IsPvPFlagged},                                                               // :IsPvPFlagged()
+    {"HasQuest", &LuaUnit::HasQuest},                                                                       // :HasQuest(id)
+    {"IsInCombat", &LuaUnit::IsInCombat},                                                                   // :IsInCombat()
+    {"HasSpell", &LuaUnit::HasSpell},                                                                       // :HasSpell(id)
+    {"IsBanker", &LuaUnit::IsBanker},                                                                       // :IsBanker() - Returns true if the unit is a banker, false if not
+    {"IsBattleMaster", &LuaUnit::IsBattleMaster},                                                           // :IsBattleMaster() - Returns true if the unit is a battle master, false if not
+    {"IsCharmed", &LuaUnit::IsCharmed},                                                                     // :IsCharmed() - Returns true if the unit is charmed, false if not
+    {"IsArmorer", &LuaUnit::IsArmorer},                                                                     // :IsArmorer() - Returns true if the unit is an Armorer, false if not
+    {"IsAttackingPlayer", &LuaUnit::IsAttackingPlayer},                                                     // :IsAttackingPlayer() - Returns true if the unit is attacking a player, false if not
+    {"IsInWater", &LuaUnit::IsInWater},                                                                     // :IsInWater() - Returns true if the unit is in water
+    {"IsUnderWater", &LuaUnit::IsUnderWater},                                                               // :IsUnderWater() - Returns true if the unit is under water
+    {"HasAura", &LuaUnit::HasAura},                                                                         // :HasAura(spellId[, caster]) - Returns true if the unit has the aura from the spell and casted by the caster if provided
+    {"CanFly", &LuaUnit::CanFly},                                                                           // :CanFly() - Returns true if the unit can fly
+    {"HasSpellCooldown", &LuaUnit::HasSpellCooldown},                                                       // :HasSpellCooldown(spellId) - Returns true if the spell is on cooldown
+    {"IsAuctioneer", &LuaUnit::IsAuctioneer},                                                               // :IsAuctioneer()
+    {"HealthBelowPct", &LuaUnit::HealthBelowPct},                                                           // :HealthBelowPct(int32 pct)
+    {"HealthAbovePct", &LuaUnit::HealthAbovePct},                                                           // :HealthAbovePct(int32 pct)
+    {"IsMounted", &LuaUnit::IsMounted},                                                                     // :IsMounted()
+    {"AttackStop", &LuaUnit::AttackStop},                                                                   // :AttackStop()
+    {"Attack", &LuaUnit::Attack},                                                                           // :Attack(who[, meleeAttack])
+    {"IsVisible", &LuaUnit::IsVisible},                                                                     // :IsVisible()
+    {"IsMoving", &LuaUnit::IsMoving},                                                                       // :IsMoving()
+    {"IsFlying", &LuaUnit::IsFlying},                                                                       // :IsFlying()
+    {"IsStopped", &LuaUnit::IsStopped},                                                                     // :IsStopped()
+    {"HasFlag", &LuaUnit::HasFlag},                                                                         // :HasFlag(index, flag)
+    {"HasUnitState", &LuaUnit::HasUnitState},                                                               // :HasUnitState(state) - state from UnitState enum
+
+    // Other
+    {"RegisterEvent", &LuaUnit::RegisterEvent},                                                             // :RegisterEvent(function, delay, calls)
+    {"RemoveEventById", &LuaUnit::RemoveEventById},                                                         // :RemoveEventById(eventID)
+    {"RemoveEvents", &LuaUnit::RemoveEvents},                                                               // :RemoveEvents()
+    {"AddAura", &LuaUnit::AddAura},                                                                         // :AddAura(spellId, target) - Adds an aura to the specified target
+    {"RemoveAura", &LuaUnit::RemoveAura},                                                                   // :RemoveAura(spellId[, casterGUID]) - Removes an aura from the unit by the spellId, casterGUID(Original caster) is optional
+    {"RemoveAllAuras", &LuaUnit::RemoveAllAuras},                                                           // :RemoveAllAuras() - Removes all the unit's auras
+    {"ClearInCombat", &LuaUnit::ClearInCombat},                                                             // :ClearInCombat() - Clears the unit's combat list (unit will be out of combat), resets the timer to 0, etc
+    {"DeMorph", &LuaUnit::DeMorph},                                                                         // :DeMorph() - Sets display back to native
+    {"SendUnitWhisper", &LuaUnit::SendUnitWhisper},                                                         // :SendUnitWhisper(msg, receiver[, bossWhisper]) - Sends a whisper to the receiver
+    {"SendUnitEmote", &LuaUnit::SendUnitEmote},                                                             // :SendUnitEmote(msg[, receiver, bossEmote]) - Sends a text emote
+    {"SendUnitSay", &LuaUnit::SendUnitSay},                                                                 // :SendUnitSay(msg, language) - Sends a "Say" message with the specified language (all languages: 0)
+    {"SendUnitYell", &LuaUnit::SendUnitYell},                                                               // :SendUnitYell(msg, language) - Sends a "Yell" message with the specified language (all languages: 0)
+    {"CastSpell", &LuaUnit::CastSpell},                                                                     // :CastSpell(target, spellID[, triggered]) - Casts spell on target (player/npc/object/item), if triggered is false has mana cost and cast time
+    {"CastSpellAoF", &LuaUnit::CastSpellAoF},                                                               // :CastSpellAoF(x, y, z, spellID[, triggered]) - Casts the spell on coordinates, if triggered is false has mana cost and cast time
+    {"PlayDirectSound", &LuaUnit::PlayDirectSound},                                                         // :PlayDirectSound(soundId, player) - Unit plays soundID to player, or everyone around if no player
+    {"PlayDistanceSound", &LuaUnit::PlayDistanceSound},                                                     // :PlayDistanceSound(soundId, player) - Unit plays soundID to player, or everyone around if no player. The sound fades the further you are
+    {"Kill", &LuaUnit::Kill},                                                                               // :Kill(target, durabilityLoss) - Unit kills the target, if no target then kills the unit. Durabilityloss is true by default
+    {"KnockbackFrom", &LuaUnit::KnockbackFrom},                                                             // :KnockbackFrom(x, y, speedXY, speedZ) - Knocks the player to the opposite direction from x,y at the defined speeds
+    {"JumpTo", &LuaUnit::JumpTo},                                                                           // :JumpTo(WorldObj, speedZ) - Unit jumps to world object
+    {"Jump", &LuaUnit::Jump},                                                                               // :Jump(speedXY, speedZ[, forward]) - Unit jumps at given speeds
+    {"JumpToCoords", &LuaUnit::JumpToCoords},                                                               // :JumpToCoords(x, y, z, speedXY, speedZ) - Unit jumps to coordinates at given speeds
+    {"MoveTo", &LuaUnit::MoveTo},                                                                           // :MoveTo(id, x, y, z[, generatePath]) - Unit moves to point. ID is sent to WP reach hook
+    {"MoveCharge", &LuaUnit::MoveCharge},                                                                   // :MoveCharge(x, y, z, speed) - Charges to target location
+    {"MoveChase", &LuaUnit::MoveChase},                                                                     // :MoveChase(target[, dist, angle]) - Chases target unit
+    {"MoveFollow", &LuaUnit::MoveFollow},                                                                   // :MoveFollow(target, dist, angle) - Follows target unit
+    {"MoveClear", &LuaUnit::MoveClear},                                                                     // :MoveClear() - Stops movement
+    {"MoveRandom", &LuaUnit::MoveRandom},                                                                   // :MoveRandom() - Moves randomly inside radius
+    {"MoveRotate", &LuaUnit::MoveRotate},                                                                   // :MoveRotate(time, left) - Turns left (true or nil) or right (false) for given time
+    {"SummonGameObject", &LuaUnit::SummonGameObject},                                                       // :SummonGameObject(entry, x, y, z, o[, respawnDelay]) - Spawns an object to location. Returns the object or nil
+    {"SpawnCreature", &LuaUnit::SpawnCreature},                                                             // :SpawnCreature(entry, x, y, z, o[, despawnDelay]) - Spawns a creature to location that despawns after given time (0 for infinite). Returns the creature or nil
+    {"StopSpellCast", &LuaUnit::StopSpellCast},                                                             // :StopSpellCast(spellId(optional)) - Stops the unit from casting a spell. If a spellId is defined, it will stop that unit from casting that spell
+    {"InterruptSpell", &LuaUnit::InterruptSpell},                                                           // :InterruptSpell(spellType, delayed(optional), instant(optional)) - Interrupts the unit's spell by the spellType. If delayed is true it will skip if the spell is delayed. If instant is true, it will skip that the spell has a cast time
+    {"SendChatMessageToPlayer", &LuaUnit::SendChatMessageToPlayer},                                         // :SendChatMessageToPlayer(type, lang, msg, target) - Unit sends a chat message to the given target player
+    {"SaveToDB", &LuaUnit::SaveToDB},                                                                       // :SaveToDB() - Saves the unit to database
+    {"Emote", &LuaUnit::Emote},                                                                             // :Emote(emote)
+    {"CountPctFromCurHealth", &LuaUnit::CountPctFromCurHealth},                                             // :CountPctFromCurHealth(int32 pct)
+    {"CountPctFromMaxHealth", &LuaUnit::CountPctFromMaxHealth},                                             // :CountPctFromMaxHealth()
+    {"Dismount", &LuaUnit::Dismount},                                                                       // :Dismount() - Dismounts the unit.
+    {"Mount", &LuaUnit::Mount},                                                                             // :Mount(displayId) - Mounts the unit on the specified displayId.
+    {"Mute", &LuaUnit::Mute},                                                                               // :Mute(time[, reason]) - Mutes the player for given time in seconds.
+    {"SummonPlayer", &LuaUnit::SummonPlayer},                                                               // :SummonPlayer(player, map, x, y, z, zoneId[, delay]) - Sends a popup to the player asking if he wants to be summoned if yes, teleported to coords. ZoneID defines the location name shown in the popup Delay is the time until the popup closes automatically.
+    {"RestoreDisplayId", &LuaUnit::RestoreDisplayId},                                                       // :RestoreDisplayId()
+    {"RestoreFaction", &LuaUnit::RestoreFaction},                                                           // :RestoreFaction()
+    {"RemoveBindSightAuras", &LuaUnit::RemoveBindSightAuras},                                               // :RemoveBindSightAuras()
+    {"RemoveCharmAuras", &LuaUnit::RemoveCharmAuras},                                                       // :RemoveCharmAuras()
+    {"StopMoving", &LuaUnit::StopMoving},                                                                   // :StopMoving()
+    {"ClearThreatList", &LuaUnit::ClearThreatList},                                                         // :ClearThreatList()
+    {"RemoveFlag", &LuaUnit::RemoveFlag},                                                                   // :RemoveFlag(index, flag)
+    {"ClearUnitState", &LuaUnit::ClearUnitState},                                                           // :ClearUnitState(state)
+    {"AddUnitState", &LuaUnit::AddUnitState},                                                               // :AddUnitState(state)
+    {"DisableMelee", &LuaUnit::DisableMelee},                                                               // :DisableMelee([disable]) - if true, enables
+    {"SummonGuardian", &LuaUnit::SummonGuardian},                                                           // :SummonGuardian(entry, x, y, z, o[, duration]) - summons a guardian to location. Scales with summoner, is friendly to him and guards him.
+
+    /* Vehicle */
+    {"AddVehiclePassenger", &LuaUnit::AddVehiclePassenger},                                                 // :AddVehiclePassenger(unit, seatId) - Adds a passenger to the vehicle by specifying a unit and seatId
+    {"IsOnVehicle", &LuaUnit::IsOnVehicle},                                                                 // :IsOnVehicle() - Checks if the (unit) is in a vehicle
+    {"DismissVehicle", &LuaUnit::DismissVehicle},                                                           // :DismissVehicle() - Dismisses the (unit)'s vehicle (Unmounts)
+    // {"EjectPassenger", &LuaUnit::EjectPassenger},                                                        // :EjectPassenger(unit) - Ejects a specified unit out of the vehicle
+    {"RemovePassenger", &LuaUnit::RemovePassenger},                                                         // :RemovePassenger(unit) - Removes a specific unit from the vehicle
+    {"RemoveAllPassengers", &LuaUnit::RemoveAllPassengers},                                                 // :RemoveAllPassengers() - Removes all the passengers from the vehicle
+    {"GetPassenger", &LuaUnit::GetPassenger},                                                               // :GetPassenger(seatId) - Gets a passenger by their seatId
+    {"GetNextEmptySeat", &LuaUnit::GetNextEmptySeat},                                                       // :GetNextEmptySeat(seatId) - Gets(returns) the next empty seat
+    {"GetAvailableSeats", &LuaUnit::GetAvailableSeats},                                                     // :GetAvailableSeats() - Returns the available seats count
+    {"GetVehicleBase", &LuaUnit::GetVehicleBase},                                                           // :GetVehicleBase() - Returns the unit's vehicle base
+    {"HasEmptySeat", &LuaUnit::HasEmptySeat},                                                               // :HasEmptySeat(seatId) - Checks if the specified seatId is empty(nobody in it)
+    { NULL, NULL },
+};
+
+ElunaRegister<GameObject> GameObjectMethods[] =
+{
+    // Getters
+    {"GetUnitType", &LuaGameObject::GetUnitType},                                                           // :GetUnitType() - Returns unit type Ex. GameObject
+    {"GetGUID", &LuaGameObject::GetGUID},                                                                   // :GetGUID() - Returns uint64 guid as hex string
+    {"GetName", &LuaGameObject::GetName},                                                                   // :GetName()
+    {"GetDisplayId", &LuaGameObject::GetDisplayId},                                                         // :GetDisplayId()
+    {"GetScale", &LuaGameObject::GetScale},                                                                 // :GetScale()
+    {"GetEntry", &LuaGameObject::GetEntry},                                                                 // :GetEntry()
+    {"GetMapId", &LuaGameObject::GetMapId},                                                                 // :GetMapId()
+    {"GetX", &LuaGameObject::GetX},                                                                         // :GetX()
+    {"GetY", &LuaGameObject::GetY},                                                                         // :GetY()
+    {"GetZ", &LuaGameObject::GetZ},                                                                         // :GetZ()
+    {"GetO", &LuaGameObject::GetO},                                                                         // :GetO()
+    {"GetLocation", &LuaGameObject::GetLocation},                                                           // :GetLocation() - returns X, Y, Z and O co - ords (in that order)
+    {"GetAreaId", &LuaGameObject::GetAreaId},                                                               // :GetAreaId()
+    {"GetZoneId", &LuaGameObject::GetZoneId},                                                               // :GetZoneId()
+    {"GetInt32Value", &LuaGameObject::GetInt32Value},                                                       // :GetInt32Value(index) - returns an int value from object fields
+    {"GetUInt32Value", &LuaGameObject::GetUInt32Value},                                                     // :GetUInt32Value(index) - returns an uint value from object fields
+    {"GetFloatValue", &LuaGameObject::GetFloatValue},                                                       // :GetFloatValue(index) - returns a float value from object fields
+    {"GetByteValue", &LuaGameObject::GetByteValue},                                                         // :GetByteValue(index, offset) - returns a byte value from object fields
+    {"GetUInt16Value", &LuaGameObject::GetUInt16Value},                                                     // :GetUInt16Value(index, offset) - returns a uint16 value from object fields
+    {"GetGUIDLow", &LuaGameObject::GetGUIDLow},                                                             // :GetGUIDLow() - Returns uint32 guid (low guid) that is used in database.
+    {"GetNearestPlayer", &LuaGameObject::GetNearestPlayer},                                                 // :GetNearestPlayer([radius]) - Returns nearest player in sight or given radius.
+    {"GetNearestGameObject", &LuaGameObject::GetNearestGameObject},                                         // :GetNearestGameObject([radius, entry]) - Returns nearest gameobject with given entry in sight or given radius.
+    {"GetNearestCreature", &LuaGameObject::GetNearestCreature},                                             // :GetNearestCreatureEntry([radius, entry]) - Returns nearest creature with given entry in sight or given radius.
+    {"GetRelativePoint", &LuaGameObject::GetRelativePoint},                                                 // :GetRelativePoint(dist, radians) - Returns the X, Y and orientation of a point dist away from gob. Radian 0 point is the direction the unit is facing.
+    {"GetHeight", &LuaGameObject::GetHeight},                                                               // :GetHeight(X, Y) - Returns returns the Z coord of the given location. If no valid position found, returns gob Z coordinate.
+
+    // Setters
+    {"SetScale", &LuaGameObject::SetScale},                                                                 // :SetScale(scale)
+    {"SetInt32Value", &LuaGameObject::SetInt32Value},                                                       // :SetInt32Value(index, value) - Sets an int value for the object
+    {"SetUInt32Value", &LuaGameObject::SetUInt32Value},                                                     // :SetUInt32Value(index, value) - Sets an uint value for the object
+    {"UpdateUInt32Value", &LuaGameObject::UpdateUInt32Value},                                               // :UpdateUInt32Value(index, value) - Updates an uint value for the object
+    {"SetFloatValue", &LuaGameObject::SetFloatValue},                                                       // :SetFloatValue(index, value) - Sets a float value for the object
+    {"SetByteValue", &LuaGameObject::SetByteValue},                                                         // :SetByteValue(index, offset, value) - Sets a byte value for the object
+    {"SetUInt16Value", &LuaGameObject::SetUInt16Value},                                                     // :SetUInt16Value(index, offset, value) - Sets an uint16 value for the object
+    {"SetInt16Value", &LuaGameObject::SetInt16Value},                                                       // :SetInt16Value(index, offset, value) - Sets an int16 value for the object
+
+    // Boolean
+    {"IsInWorld", &LuaGameObject::IsInWorld},                                                               // :IsInWorld()
+    {"IsTransport", &LuaGameObject::IsTransport},                                                           // :IsTransport()
+    {"IsDestructible", &LuaGameObject::IsDestructible},                                                     // :IsDestructible()
+    {"IsActive", &LuaGameObject::IsActive},                                                                 // :IsActive()
+    {"HasQuest", &LuaGameObject::HasQuest},                                                                 // :HasQuest(questId)
+    {"IsInvisibleDueToDespawn", &LuaGameObject::IsInvisibleDueToDespawn},                                   // :IsInvisibleDueToDespawn()
+
+    // Other
+    {"CastSpell", &LuaGameObject::CastSpell},                                                               // :CastSpellOnTarget(target, spellId) - Casts the spell on target, no manacost or cast time
+    {"Move", &LuaGameObject::Move},                                                                         // :Move(x, y, z, o) - Moves the GO to coordinates
+    {"SpawnCreature", &LuaGameObject::SummonCreature},                                                      // :SummonCreature(entry, x, y, z, o, despawntime) Summons a temporary creature. 0 for infinitely, otherwise despawns after despawntime (ms)
+    {"RegisterEvent", &LuaGameObject::RegisterEvent},                                                       // :RegisterEvent(function, delay, calls)
+    {"RemoveEventById", &LuaGameObject::RemoveEventById},                                                   // :RemoveEventById(eventID)
+    {"RemoveEvents", &LuaGameObject::RemoveEvents},                                                         // :RemoveEvents()
+    {"Despawn", &LuaGameObject::Despawn},                                                                   // :Despawn() - Object despawns
+    {"SummonGameObject", &LuaGameObject::SummonGameObject},                                                 // :SummonGameObject(entry, x, y, z, o[, respawnDelay]) - Spawns an object to location. Returns the object or nil
+
+    { NULL, NULL },
+};
+
+ElunaRegister<Item> ItemMethods[] =
+{
+    // Getters
+    {"GetUnitType", &LuaItem::GetUnitType},                                                                 // :GetUnitType() - Returns object type, IE: Item, Creature
+    {"GetGUID", &LuaItem::GetGUID},                                                                         // :GetGUID() - Returns uint64 guid as hex string
+    {"GetOwnerGUID", &LuaItem::GetOwnerGUID},                                                               // :GetOwnerGUID() - Returns the owner's guid
+    {"GetOwner", &LuaItem::GetOwner},                                                                       // :GetOwner() - Returns the owner object (player)
+    {"GetCount", &LuaItem::GetCount},                                                                       // :GetCount() - Returns item stack count
+    {"GetMaxStackCount", &LuaItem::GetMaxStackCount},                                                       // :GetMaxStackCount() - Returns item max stack count
+    {"GetSlot", &LuaItem::GetSlot},                                                                         // :GetSlot() - returns the slot the item is in
+    {"GetBagSlot", &LuaItem::GetBagSlot},                                                                   // :GetBagSlot() - returns the bagslot of the bag the item is in
+    {"GetEntry", &LuaItem::GetEntry},                                                                       // :GetEntry() - returns the item entry
+    {"GetInt32Value", &LuaItem::GetInt32Value},                                                             // :GetInt32Value(index) - returns an int value from item fields
+    {"GetUInt32Value", &LuaItem::GetUInt32Value},                                                           // :GetUInt32Value(index) - returns an uint value from item fields
+    {"GetFloatValue", &LuaItem::GetFloatValue},                                                             // :GetFloatValue(index) - returns a float value from item fields
+    {"GetByteValue", &LuaItem::GetByteValue},                                                               // :GetByteValue(index, offset) - returns a byte value from item fields
+    {"GetUInt16Value", &LuaItem::GetUInt16Value},                                                           // :GetUInt16Value(index, offset) - returns a uint16 value from item fields
+    {"GetGUIDLow", &LuaItem::GetGUIDLow},                                                                   // :GetGUIDLow() - Returns uint32 guid (low guid) that is used in database.
+    {"GetEnchantmentId", &LuaItem::GetEnchantmentId},                                                       // :GetEnchantmentId(enchant_slot) - Returns the enchantment in given slot. (permanent = 0)
+    {"GetName", &LuaItem::GetName},                                                                         // :GetName() - Returns item name
+    {"GetClass", &LuaItem::GetClass},                                                                       // :GetClass() - Returns item class
+    {"GetSubClass", &LuaItem::GetSubClass},                                                                 // :GetSubClass() - Returns item subclass
+    {"GetInventoryType", &LuaItem::GetInventoryType},                                                       // :GetInventoryType() - Returns item inventorytype
+    {"GetSpellId", &LuaItem::GetSpellId},                                                                   // :GetSpellId(index) - Returns spellID at given index (0 - 4)
+    {"GetSpellTrigger", &LuaItem::GetSpellTrigger},                                                         // :GetSpellTrigger(index) - Returns spell trigger at given index (0 - 4)
+    {"GetItemLevel", &LuaItem::GetItemLevel},                                                               // :GetItemLevel() - Returns the itemlevel
+    {"GetRequiredLevel", &LuaItem::GetRequiredLevel},                                                       // :GetRequiredLevel() - Returns the required level
+    {"GetBuyPrice", &LuaItem::GetBuyPrice},                                                                 // :GetBuyPrice() - Returns the buy price
+    {"GetSellPrice", &LuaItem::GetSellPrice},                                                               // :GetSellPrice() - Returns the sell price
+    {"GetItemLink", &LuaItem::GetItemLink},                                                                 // :GetItemLink([localeID]) - Returns the shift clickable link of the item. Name translated if locale given and exists
+    {"GetQuality", &LuaItem::GetQuality},                                                                   // :GetQuality() - Returns item quality
+
+    // Setters
+    {"SetOwner", &LuaItem::SetOwner},                                                                       // :SetOwner(player) - Sets the owner of the item
+    {"SetBinding", &LuaItem::SetBinding},                                                                   // :SetBinding(bound) - Sets the item binding to true or false
+    {"SetCount", &LuaItem::SetCount},                                                                       // :SetCount(count) - Sets the item count
+    {"SetInt32Value", &LuaItem::SetInt32Value},                                                             // :SetInt32Value(index, value) - Sets an int value for the item
+    {"SetUInt32Value", &LuaItem::SetUInt32Value},                                                           // :SetUInt32Value(index, value) - Sets an uint value for the item
+    {"UpdateUInt32Value", &LuaItem::UpdateUInt32Value},                                                     // :UpdateUInt32Value(index, value) - Updates an uint value for the item
+    {"SetFloatValue", &LuaItem::SetFloatValue},                                                             // :SetFloatValue(index, value) - Sets a float value for the item
+    {"SetByteValue", &LuaItem::SetByteValue},                                                               // :SetByteValue(index, offset, value) - Sets a byte value for the item
+    {"SetUInt16Value", &LuaItem::SetUInt16Value},                                                           // :SetUInt16Value(index, offset, value) - Sets an uint16 value for the item
+    {"SetInt16Value", &LuaItem::SetInt16Value},                                                             // :SetInt16Value(index, offset, value) - Sets an int16 value for the item
+
+    // Boolean
+    {"IsSoulBound", &LuaItem::IsSoulBound},                                                                 // :IsSoulBound() - Returns true if the item is soulbound
+    {"IsBoundAccountWide", &LuaItem::IsBoundAccountWide},                                                   // :IsBoundAccountWide() - Returns true if the item is account bound
+    {"IsBoundByEnchant", &LuaItem::IsBoundByEnchant},                                                       // :IsBoundByEnchant() - Returns true if the item is bound with an enchant
+    {"IsNotBoundToPlayer", &LuaItem::IsNotBoundToPlayer},                                                   // :IsNotBoundToPlayer(player) - Returns true if the item is not bound with player
+    {"IsLocked", &LuaItem::IsLocked},                                                                       // :IsLocked() - Returns true if the item is locked
+    {"IsBag", &LuaItem::IsBag},                                                                             // :IsBag() - Returns true if the item is a bag
+    {"IsCurrencyToken", &LuaItem::IsCurrencyToken},                                                         // :IsCurrencyToken() - Returns true if the item is a currency token
+    {"IsNotEmptyBag", &LuaItem::IsNotEmptyBag},                                                             // :IsNotEmptyBag() - Returns true if the item is not an empty bag
+    {"IsBroken", &LuaItem::IsBroken},                                                                       // :IsBroken() - Returns true if the item is broken
+    {"CanBeTraded", &LuaItem::CanBeTraded},                                                                 // :CanBeTraded() - Returns true if the item can be traded
+    {"IsInTrade", &LuaItem::IsInTrade},                                                                     // :IsInTrade() - Returns true if the item is in trade
+    {"IsInBag", &LuaItem::IsInBag},                                                                         // :IsInBag() - Returns true if the item is in a bag
+    {"IsEquipped", &LuaItem::IsEquipped},                                                                   // :IsEquipped() - Returns true if the item is equipped
+    {"HasQuest", &LuaItem::hasQuest},                                                                       // :HasQuest(questId) - Returns true if the item starts the quest
+    {"IsPotion", &LuaItem::IsPotion},                                                                       // :IsPotion() - Returns true if the item is a potion
+    {"IsWeaponVellum", &LuaItem::IsWeaponVellum},                                                           // :IsWeaponVellum() - Returns true if the item is a weapon vellum
+    {"IsArmorVellum", &LuaItem::IsArmorVellum},                                                             // :IsArmorVellum() - Returns true if the item is an armor vellum
+    {"IsConjuredConsumable", &LuaItem::IsConjuredConsumable},                                               // :IsConjuredConsumable() - Returns true if the item is a conjured consumable
+    {"IsRefundExpired", &LuaItem::IsRefundExpired},                                                         // :IsRefundExpired() - Returns true if the item's refund time has expired
+    {"SetEnchantment", &LuaItem::SetEnchantment},                                                           // :SetEnchantment(enchantid, enchantmentslot) - Sets a new enchantment for the item. Returns true on success
+    {"ClearEnchantment", &LuaItem::ClearEnchantment},                                                       // :ClearEnchantment(enchantmentslot) - Removes the enchantment from the item if one exists. Returns true on success
+
+    // Other
+    {NULL, NULL},
+};
+
+ElunaRegister<Aura> AuraMethods[] =
+{
+    // Getters
+    {"GetUnitType", &LuaAura::GetUnitType},                                                                 // :GetUnitType() - Returns object type, IE: Aura, Creature
+    {"GetCaster", &LuaAura::GetCaster},                                                                     // :GetCaster() - Returns caster as object
+    {"GetCasterGUID", &LuaAura::GetCasterGUID},                                                             // :GetCasterGUID() - Returns caster as GUID
+    {"GetCasterLevel", &LuaAura::GetCasterLevel},                                                           // :GetCasterLevel() - Returns casters level
+    // {"GetDuration", &LuaAura::GetDuration},                                                                 // :GetDuration() - Returns remaining duration
+    {"GetMaxDuration", &LuaAura::GetMaxDuration},                                                           // :GetMaxDuration() - Returns maximum duration
+    {"GetCharges", &LuaAura::GetCharges},                                                                   // :GetCharges() - Returns remaining charges
+    {"GetAuraId", &LuaAura::GetAuraId},                                                                     // :GetAuraId() - Returns aura ID
+    {"GetStackAmount", &LuaAura::GetStackAmount},                                                           // :GetStackAmount() - Returns current stack amount
+    {"GetOwner", &LuaAura::GetOwner},                                                                       // :GetOwner() - Gets the unit wearing the aura
+
+    // Setters
+    {"SetDuration", &LuaAura::SetDuration},                                                                 // :SetDuration(duration) - Sets remaining duration
+    {"SetMaxDuration", &LuaAura::SetMaxDuration},                                                           // :SetMaxDuration(duration) - Sets maximum duration
+    {"SetStackAmount", &LuaAura::SetStackAmount},                                                           // :SetStackAmount(amount) - Sets current stack amount
+
+    // Other
+    {"Remove", &LuaAura::Remove},                                                                           // :Remove() - Removes the aura
+    {NULL, NULL},
+};
+
+ElunaRegister<Spell> SpellMethods[] =
+{
+    // Getters
+    {"GetUnitType", &LuaSpell::GetUnitType},                                                                // :GetUnitType() - Returns the unit type (Spell)
+    {"GetCaster", &LuaSpell::GetCaster},                                                                    // :GetCaster() - Returns the spell's caster (UNIT)
+    {"GetCastTime", &LuaSpell::GetCastTime},                                                                // :GetCastTime() - Returns the spell cast time
+    {"GetEntry", &LuaSpell::GetId},                                                                         // :GetEntry() - Returns the spell's ID
+    {"GetDuration", &LuaSpell::GetDuration},                                                                // :GetDuration() - Returns the spell's duration
+    {"GetPowerCost", &LuaSpell::GetPowerCost},                                                              // :GetPowerCost() - Returns the spell's power cost (mana, energy, rage, etc)
+
+    // Setters
+    {"SetAutoRepeat", &LuaSpell::SetAutoRepeat},                                                            // :SetAutoRepeat(boolean)
+
+    // Boolean
+    {"IsAutoRepeat", &LuaSpell::IsAutoRepeat},                                                              // :IsAutoRepeat()
+
+    // Other
+    {"Cancel", &LuaSpell::cancel},                                                                          // :Cancel() - Cancels the spell casting
+    {"Cast", &LuaSpell::Cast},                                                                              // :Cast(skipCheck) - Casts the spell (if true, removes the check for instant spells, etc)
+    {"Finish", &LuaSpell::Finish},                                                                          // :Finish() - Finishes the spell (SPELL_STATE_FINISH)
+    {NULL, NULL},
+};
+
+ElunaRegister<Quest> QuestMethods[] =
+{
+    // Getters
+    {"GetUnitType", &LuaQuest::GetUnitType},                                                                // :GetUnitType() - Returns the unit type (Quest)
+    {"GetId", &LuaQuest::GetId},                                                                            // :GetId() - Returns the quest's Id
+    {"GetLevel", &LuaQuest::GetLevel},                                                                      // :GetLevel() - Returns the quest's level
+    {"GetMaxLevel", &LuaQuest::GetMaxLevel},                                                                // :GetMaxLevel() - Returns the quest's max level
+    {"GetMinLevel", &LuaQuest::GetMinLevel},                                                                // :GetMinLevel() - Returns the quest's min level
+    {"GetNextQuestId", &LuaQuest::GetNextQuestId},                                                          // :GetNextQuestId() - Returns the quest's next quest ID
+    {"GetPrevQuestId", &LuaQuest::GetPrevQuestId},                                                          // :GetPrevQuestId() - Returns the quest's previous quest ID
+    {"GetNextQuestInChain", &LuaQuest::GetNextQuestInChain},                                                // :GetNexQuestInChain() - Returns the next quest in its chain
+    {"GetFlags", &LuaQuest::GetFlags},                                                                      // :GetFlags() - Returns the quest's flags
+    {"GetType", &LuaQuest::GetType},                                                                        // :GetType() - Returns the quest's type
+
+    // Boolean
+    {"HasFlag", &LuaQuest::HasFlag},                                                                        // :HasFlag(flag) - Returns true or false if the quest has the specified flag
+    {"IsDaily", &LuaQuest::IsDaily},                                                                        // :IsDaily() - Returns true or false if the quest is a daily
+    {"IsRepeatable", &LuaQuest::IsRepeatable},                                                              // :IsRepeatable() - Returns true or false if the quest is repeatable
+
+    // Setters
+    {"SetFlag", &LuaQuest::SetFlag},                                                                        // :SetFlag(flag) - Sets the flag of the quest by the specified flag
+    {NULL, NULL},
+};
+
+ElunaRegister<Group> GroupMethods[] =
+{
+    // Getters
+    {"GetMembers", &LuaGroup::GetMembers},                                                                  // :GetMembers() - returns a table the players in this group. (Online?)
+    {"GetLeaderGUID", &LuaGroup::GetLeaderGUID},
+    {"GetLeader", &LuaGroup::GetLeader},
+    {"GetUnitType", &LuaGroup::GetUnitType},
+    {"GetGUID", &LuaGroup::GetGUID},
+    {"GetMemberGroup", &LuaGroup::GetMemberGroup},                                                          // :GetMemberGroup(player) - Returns the player's subgroup ID
+    {"GetMemberGUID", &LuaGroup::GetMemberGUID},                                                            // :GetMemberGUID("name") - Returns the member's GUID
+    {"GetMembersCount", &LuaGroup::GetMembersCount},                                                        // :GetMembersCount() - Returns the member count of the group
+
+    // Setters
+    {"SetLeader", &LuaGroup::ChangeLeader},                                                                 // :SetLeader(Player) - Sets the player as the new leader
+    {"SetMembersGroup", &LuaGroup::ChangeMembersGroup},                                                     // :ChangeMembersGroup(player, subGroup) - Changes the member's subgroup
+
+    // Boolean
+    {"IsLeader", &LuaGroup::IsLeader},                                                                      // :IsLeader("name"/Player)
+    // {"HasRole", &LuaGroup::HasRole},                                                                     // :HasRole("name"/Player, "role") - "tank" / "healer" / "dps"
+    {"AddInvite", &LuaGroup::AddInvite},                                                                    // :AddInvite(player) - Adds a an invite to player. Returns true if succesful
+    {"RemoveMember", &LuaGroup::RemoveMember},                                                              // :RemoveMember(player) - Removes player from group. Returns true on success
+    {"Disband", &LuaGroup::Disband},                                                                        // :Disband() - Disbands the group
+    {"IsFull", &LuaGroup::IsFull},                                                                          // :IsFull() - Returns true if the group is full
+    {"IsLFGGroup", &LuaGroup::isLFGGroup},                                                                  // :IsLFGGroup() - Returns true if the group is an LFG group
+    {"IsRaidGroup", &LuaGroup::isRaidGroup},                                                                // :IsRaidGroup() - Returns true if the group is a raid group
+    {"IsBGGroup", &LuaGroup::isBGGroup},                                                                    // :IsBGGroup() - Returns true if the group is a battleground group
+    {"IsBFGroup", &LuaGroup::isBFGroup},                                                                    // :IsBFGroup() - Returns true if the group is a battlefield group
+    {"IsMember", &LuaGroup::IsMember},                                                                      // :IsMember(player) - Returns true if the player is a member of the group
+    {"IsAssistant", &LuaGroup::IsAssistant},                                                                // :IsAssistant(player) - returns true if the player is an assistant in the group
+    {"SameSubGroup", &LuaGroup::SameSubGroup},                                                              // :SameSubGroup(player1, player2) - Returns true if the players are in the same subgroup in the group
+    {"HasFreeSlotSubGroup", &LuaGroup::HasFreeSlotSubGroup},                                                // :HasFreeSlotSubGroup(subGroup) - Returns true if the subgroupID has free slots
+
+    // Other
+    {"SendPacket", &LuaGroup::SendPacket},                                                                  // :SendPacket(packet, sendToPlayersInBattleground[, ignoreguid]) - Sends a specified packet to the group with the choice (true/false) to send it to players in a battleground. Optionally ignores given player guid
+    {"ConvertToLFG", &LuaGroup::ConvertToLFG},                                                              // :ConvertToLFG() - Converts the group to an LFG group
+    {"ConvertToRaid", &LuaGroup::ConvertToRaid},                                                            // :ConvertToRaid() - Converts the group to a raid group
+    {NULL, NULL},
+};
+
+ElunaRegister<Guild> GuildMethods[] =
+{
+    // Getters
+    {"GetMembers", &LuaGuild::GetMembers},                                                                  // :GetMembers() - returns a table containing the players in this guild. (Online?)
+    {"GetUnitType", &LuaGuild::GetUnitType},                                                                // :GetUnitType() - Returns the unit type. Eg: Guild
+    {"GetLeaderGUID", &LuaGuild::GetLeaderGUID},                                                            // :GetLeaderGUID() - Returns the guild learder's guid
+    {"GetId", &LuaGuild::GetId},                                                                            // :GetId() - Gets the guild's ID
+    {"GetName", &LuaGuild::GetName},                                                                        // :GetName() - Gets the guild name
+    {"GetMOTD", &LuaGuild::GetMOTD},                                                                        // :GetMOTD() - Gets the guild MOTD string
+    {"GetInfo", &LuaGuild::GetInfo},                                                                        // :GetInfo() - Gets the guild info string
+
+    // Setters
+    {"SetBankTabText", &LuaGuild::SetBankTabText},                                                          // :SetBankTabText(tabId, text)
+    {"SetMemberRank", &LuaGuild::ChangeMemberRank},                                                         // :SetMemberRank(player, newRank) - Sets the player rank in the guild to the new rank
+
+    // Boolean
+
+    // Other
+    {"SendPacket", &LuaGuild::SendPacket},                                                                  // :SendPacket(packet) - sends packet to guild
+    {"SendPacketToRanked", &LuaGuild::SendPacketToRanked},                                                  // :SendPacketToRanked(packet, rankId) - sends packet to guild, specifying a rankId will only send the packet to your ranked members
+    {"Disband", &LuaGuild::Disband},                                                                        // :Disband() - Disbands the guild
+    {"AddMember", &LuaGuild::AddMember},                                                                    // :AddMember(player, rank) - adds the player to the guild. Rank is optional
+    {"DeleteMember", &LuaGuild::DeleteMember},                                                              // :DeleteMember(player, disbanding, kicked) - Deletes the player from the guild. Disbanding and kicked are optional bools
+    {NULL, NULL},
+};
+
+ElunaRegister<QueryResult> QueryMethods[] =
+{
+    {"GetUnitType", &LuaQuery::GetUnitType},                                                                // :GetUnitType() - Returns object type, IE: QueryResult
+
+    {"NextRow", &LuaQuery::NextRow},                                                                        // :NextRow() - Advances to next rown in the query. Returns true if there is a next row, otherwise false
+    {"GetColumnCount", &LuaQuery::GetColumnCount},                                                          // :GetColumnCount() - Gets the column count of the query
+    {"GetRowCount", &LuaQuery::GetRowCount},                                                                // :GetRowCount() - Gets the row count of the query
+
+    {"GetBool", &LuaQuery::GetBool},                                                                        // :GetBool(column) - returns a bool from a number column (for example tinyint)
+    {"GetUInt8", &LuaQuery::GetUInt8},                                                                      // :GetUInt8(column) - returns the value of an unsigned tinyint column
+    {"GetUInt16", &LuaQuery::GetUInt16},                                                                    // :GetUInt16(column) - returns the value of a unsigned smallint column
+    {"GetUInt32", &LuaQuery::GetUInt32},                                                                    // :GetUInt32(column) - returns the value of an unsigned int or mediumint column
+    {"GetUInt64", &LuaQuery::GetUInt64},                                                                    // :GetUInt64(column) - returns the value of an unsigned bigint column as string
+    {"GetInt8", &LuaQuery::GetInt8},                                                                        // :GetInt8(column) - returns the value of an tinyint column
+    {"GetInt16", &LuaQuery::GetInt16},                                                                      // :GetInt16(column) - returns the value of a smallint column
+    {"GetInt32", &LuaQuery::GetInt32},                                                                      // :GetInt32(column) - returns the value of an int or mediumint column
+    {"GetInt64", &LuaQuery::GetInt64},                                                                      // :GetInt64(column) - returns the value of a bigint column as string
+    {"GetFloat", &LuaQuery::GetFloat},                                                                      // :GetFloat(column) - returns the value of a float column
+    {"GetDouble", &LuaQuery::GetDouble},                                                                    // :GetDouble(column) - returns the value of a double column
+    {"GetString", &LuaQuery::GetString},                                                                    // :GetString(column) - returns the value of a string column
+    {"IsNull", &LuaQuery::IsNull},                                                                          // :IsNull(column) - returns true if the column is null
+    {NULL, NULL},
+};
+
+ElunaRegister<WorldPacket> PacketMethods[] =
+{
+    // Getters
+    {"GetOpcode", &LuaPacket::GetOpcode},                                                                   // :GetOpcode() - Returns an opcode
+    {"GetSize", &LuaPacket::GetSize},                                                                       // :GetSize() - Returns the packet size
+    {"GetUnitType", &LuaPacket::GetOpcode},                                                                 // :GetUnitType() - Returns the unit type: Packet
+
+    // Setters
+    {"SetOpcode", &LuaPacket::SetOpcode},                                                                   // :SetOpcode(opcode) - Sets the opcode by specifying an opcode
+
+    // Readers
+    {"ReadByte", &LuaPacket::ReadByte},                                                                     // :ReadByte() - Reads an int8 value
+    {"ReadUByte", &LuaPacket::ReadUByte},                                                                   // :ReadUByte() - Reads an uint8 value
+    {"ReadShort", &LuaPacket::ReadShort},                                                                   // :ReadShort() - Reads an int16 value
+    {"ReadUShort", &LuaPacket::ReadUShort},                                                                 // :ReadUShort() - Reads an uint16 value
+    {"ReadLong", &LuaPacket::ReadLong},                                                                     // :ReadLong() - Reads an int32 value
+    {"ReadULong", &LuaPacket::ReadULong},                                                                   // :ReadULong() - Reads an uint32 value
+    {"ReadGUID", &LuaPacket::ReadGUID},                                                                     // :ReadGUID() - Reads an uint64 value
+    {"ReadString", &LuaPacket::ReadString},                                                                 // :ReadString() - Reads a string value
+    {"ReadFloat", &LuaPacket::ReadFloat},                                                                   // :ReadFloat() - Reads a float value
+    {"ReadDouble", &LuaPacket::ReadDouble},                                                                 // :ReadDouble() - Reads a double value
+
+    // Writers
+    {"WriteByte", &LuaPacket::WriteByte},                                                                   // :WriteByte(val) - Writes an int8 value
+    {"WriteUByte", &LuaPacket::WriteUByte},                                                                 // :WriteUByte(val) - Writes a uint8 value
+    {"WriteShort", &LuaPacket::WriteShort},                                                                 // :WriteShort(val) - Writes an int16 value
+    {"WriteUShort", &LuaPacket::WriteUShort},                                                               // :WriteUShort(val) - Writes a uint16 value
+    {"WriteLong", &LuaPacket::WriteLong},                                                                   // :WriteLong(val) - Writes an int32 value
+    {"WriteULong", &LuaPacket::WriteULong},                                                                 // :WriteULong(val) - Writes a uint32 value
+    {"WriteGUID", &LuaPacket::WriteGUID},                                                                   // :WriteGUID(guid) - Writes a uint64 value
+    {"WriteString", &LuaPacket::WriteString},                                                               // :WriteString(val) - Writes a string value
+    {"WriteFloat", &LuaPacket::WriteFloat},                                                                 // :WriteFloat(val) - Writes a float value
+    {"WriteDouble", &LuaPacket::WriteDouble},                                                               // :WriteDouble(val) - Writes a double value
+    {NULL, NULL},
+};
+
+template<typename T> ElunaRegister<T>* GetMethodTable() { return NULL; }
+template<> ElunaRegister<Unit>* GetMethodTable<Unit>() { return UnitMethods; }
+template<> ElunaRegister<GameObject>* GetMethodTable<GameObject>() { return GameObjectMethods; }
+template<> ElunaRegister<Group>* GetMethodTable<Group>() { return GroupMethods; }
+template<> ElunaRegister<Guild>* GetMethodTable<Guild>() { return GuildMethods; }
+template<> ElunaRegister<QueryResult>* GetMethodTable<QueryResult>() { return QueryMethods; }
+template<> ElunaRegister<Aura>* GetMethodTable<Aura>() { return AuraMethods; }
+template<> ElunaRegister<Item>* GetMethodTable<Item>() { return ItemMethods; }
+template<> ElunaRegister<WorldPacket>* GetMethodTable<WorldPacket>() { return PacketMethods; }
+template<> ElunaRegister<Spell>* GetMethodTable<Spell>() { return SpellMethods; }
+template<> ElunaRegister<Quest>* GetMethodTable<Quest>() { return QuestMethods; }
+#endif
diff --git a/src/server/LuaEngine/LuaHooks.cpp b/src/server/LuaEngine/LuaHooks.cpp
new file mode 100644
index 0000000..ad94421
--- /dev/null
+++ b/src/server/LuaEngine/LuaHooks.cpp
@@ -0,0 +1,1379 @@
+#include "HookMgr.h"
+#include "LuaEngine.h"
+
+// Custom
+class Eluna_HookScript : public HookScript
+{
+public:
+    Eluna_HookScript() : HookScript() { }
+    // misc
+    void OnLootItem(Player* player, Item* item, uint32 count, uint64 guid)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_LOOT_ITEM].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_LOOT_ITEM].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_LOOT_ITEM);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushItem(sEluna->LuaState, item);
+            sEluna->PushUnsigned(sEluna->LuaState, count);
+            sEluna->PushULong(sEluna->LuaState, guid);
+            sEluna->ExecuteCall(5, 0);
+        }
+    }
+    void OnFirstLogin(Player* player)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_FIRST_LOGIN].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_FIRST_LOGIN].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_FIRST_LOGIN);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+    void OnEquip(Player* player, Item* item, uint8 bag, uint8 slot)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_EQUIP].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_EQUIP].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_EQUIP);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushItem(sEluna->LuaState, item);
+            sEluna->PushUnsigned(sEluna->LuaState, bag);
+            sEluna->PushUnsigned(sEluna->LuaState, slot);
+            sEluna->ExecuteCall(5, 0);
+        }
+    }
+    InventoryResult OnCanUseItem(Player* player, uint32 itemEntry)
+    {
+        InventoryResult result = EQUIP_ERR_OK;
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_CAN_USE_ITEM].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_CAN_USE_ITEM].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_CAN_USE_ITEM);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnsigned(sEluna->LuaState, itemEntry);
+            if (sEluna->ExecuteCall(3, 1))
+            {
+                lua_State* L = sEluna->LuaState;
+                if (!lua_isnoneornil(L, 1))
+                    result = (InventoryResult)lua_tounsigned(L, 1);
+                sEluna->EndCall(1);
+            }
+        }
+        return result;
+    }
+    void HandleGossipSelectOption(Player* player, uint64 guid, uint32 sender, uint32 action, std::string code, uint32 menuId)
+    {
+        if (!player->IsAlive() || player->GetCharmerGUID())
+            return;
+
+        if (player->HasUnitState(UNIT_STATE_DIED))
+            player->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
+        player->PlayerTalkClass->ClearMenus();
+
+        if (IS_ITEM_GUID(guid))
+        {
+            Item* item = player->GetItemByGuid(guid);
+            if (!item)
+                return;
+
+            int bind = sEluna->ItemGossipBindings->GetBind(item->GetEntry(), GOSSIP_EVENT_ON_SELECT);
+            if (bind)
+            {
+                sEluna->BeginCall(bind);
+                sEluna->PushUnsigned(sEluna->LuaState, GOSSIP_EVENT_ON_SELECT);
+                sEluna->PushUnit(sEluna->LuaState, player);
+                sEluna->PushItem(sEluna->LuaState, item);
+                sEluna->PushUnsigned(sEluna->LuaState, sender);
+                sEluna->PushUnsigned(sEluna->LuaState, action);
+                if (code.empty())
+                    lua_pushnil(sEluna->LuaState);
+                else
+                    sEluna->PushString(sEluna->LuaState, code.c_str());
+                sEluna->ExecuteCall(6, 0);
+            }
+        }
+        else if (IS_PLAYER_GUID(guid))
+        {
+            if (player->GetGUID() != guid)
+                return;
+
+            int bind = sEluna->playerGossipBindings->GetBind(menuId, GOSSIP_EVENT_ON_SELECT);
+            if (bind)
+            {
+                sEluna->BeginCall(bind);
+                sEluna->PushUnsigned(sEluna->LuaState, GOSSIP_EVENT_ON_SELECT);
+                sEluna->PushUnit(sEluna->LuaState, player); // receiver
+                sEluna->PushUnit(sEluna->LuaState, player); // sender, just not to mess up the amount of args.
+                sEluna->PushUnsigned(sEluna->LuaState, sender);
+                sEluna->PushUnsigned(sEluna->LuaState, action);
+                if (code.empty())
+                    lua_pushnil(sEluna->LuaState);
+                else
+                    sEluna->PushString(sEluna->LuaState, code.c_str());
+                sEluna->PushUnsigned(sEluna->LuaState, menuId);
+                sEluna->ExecuteCall(7, 0);
+            }
+        }
+    }
+    bool OnChat(Player* player, uint32 type, uint32 lang, std::string& msg)
+    {
+        bool Result = true;
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_CHAT].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_CHAT].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_CHAT);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushString(sEluna->LuaState, msg.c_str());
+            sEluna->PushUnsigned(sEluna->LuaState, type);
+            sEluna->PushUnsigned(sEluna->LuaState, lang);
+            if (sEluna->ExecuteCall(5, 1))
+            {
+                lua_State* L = sEluna->LuaState;
+                if (!lua_isnoneornil(L, 1) && !lua_toboolean(L, 1))
+                    Result = false;
+                sEluna->EndCall(1);
+            }
+        }
+        return Result;
+    }
+    bool OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Group* group)
+    {
+        bool Result = true;
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_GROUP_CHAT].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_GROUP_CHAT].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_GROUP_CHAT);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushString(sEluna->LuaState, msg.c_str());
+            sEluna->PushUnsigned(sEluna->LuaState, type);
+            sEluna->PushUnsigned(sEluna->LuaState, lang);
+            sEluna->PushGroup(sEluna->LuaState, group);
+            if (sEluna->ExecuteCall(6, 1))
+            {
+                lua_State* L = sEluna->LuaState;
+                if (!lua_isnoneornil(L, 1) && !lua_toboolean(L, 1))
+                    Result = false;
+                sEluna->EndCall(1);
+            }
+        }
+        return Result;
+    }
+    bool OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Guild* guild)
+    {
+        bool Result = true;
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_GUILD_CHAT].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_GUILD_CHAT].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_GUILD_CHAT);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushString(sEluna->LuaState, msg.c_str());
+            sEluna->PushUnsigned(sEluna->LuaState, type);
+            sEluna->PushUnsigned(sEluna->LuaState, lang);
+            sEluna->PushGuild(sEluna->LuaState, guild);
+            if (sEluna->ExecuteCall(6, 1))
+            {
+                lua_State* L = sEluna->LuaState;
+                if (!lua_isnoneornil(L, 1) && !lua_toboolean(L, 1))
+                    Result = false;
+                sEluna->EndCall(1);
+            }
+        }
+        return Result;
+    }
+    bool OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Channel* channel)
+    {
+        bool Result = true;
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_CHANNEL_CHAT].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_CHANNEL_CHAT].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_CHANNEL_CHAT);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushString(sEluna->LuaState, msg.c_str());
+            sEluna->PushUnsigned(sEluna->LuaState, type);
+            sEluna->PushUnsigned(sEluna->LuaState, lang);
+            sEluna->PushUnsigned(sEluna->LuaState, channel->GetChannelId());
+            if (sEluna->ExecuteCall(6, 1))
+            {
+                lua_State* L = sEluna->LuaState;
+                if (!lua_isnoneornil(L, 1) && !lua_toboolean(L, 1))
+                    Result = false;
+                sEluna->EndCall(1);
+            }
+        }
+        return Result;
+    }
+    void OnEngineRestart()
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[ELUNA_EVENT_ON_RESTART].begin();
+            itr != sEluna->ServerEventBindings[ELUNA_EVENT_ON_RESTART].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, ELUNA_EVENT_ON_RESTART);
+            sEluna->ExecuteCall(1, 0);
+        }
+    }
+    // item
+    bool OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, Item* target)
+    {
+        int bind = sEluna->ItemEventBindings->GetBind(target->GetEntry(), ITEM_EVENT_ON_DUMMY_EFFECT);
+        if (!bind)
+            return false;
+        sEluna->BeginCall(bind);
+        sEluna->PushUnsigned(sEluna->LuaState, ITEM_EVENT_ON_DUMMY_EFFECT);
+        sEluna->PushUnit(sEluna->LuaState, caster);
+        sEluna->PushUnsigned(sEluna->LuaState, spellId);
+        sEluna->PushInteger(sEluna->LuaState, effIndex);
+        sEluna->PushItem(sEluna->LuaState, target);
+        sEluna->ExecuteCall(5, 0);
+        return true;
+    }
+    bool OnQuestAccept(Player* player, Item* item, Quest const* quest)
+    {
+        int bind = sEluna->ItemEventBindings->GetBind(item->GetEntry(), ITEM_EVENT_ON_QUEST_ACCEPT);
+        if (!bind)
+            return false;
+        sEluna->BeginCall(bind);
+        sEluna->PushUnsigned(sEluna->LuaState, ITEM_EVENT_ON_QUEST_ACCEPT);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushItem(sEluna->LuaState, item);
+        sEluna->PushQuest(sEluna->LuaState, quest);
+        sEluna->ExecuteCall(4, 0);
+        return true;
+    }
+    bool OnUse(Player* player, Item* item, SpellCastTargets const& targets)
+    {
+        int bind1 = sEluna->ItemGossipBindings->GetBind(item->GetEntry(), GOSSIP_EVENT_ON_HELLO);
+        int bind2 = sEluna->ItemEventBindings->GetBind(item->GetEntry(), ITEM_EVENT_ON_USE);
+        if (!bind1 && !bind2)
+            return false;
+        if (bind1)
+        {
+            player->PlayerTalkClass->ClearMenus();
+            sEluna->BeginCall(bind1);
+            sEluna->PushUnsigned(sEluna->LuaState, GOSSIP_EVENT_ON_HELLO);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushItem(sEluna->LuaState, item);
+            sEluna->ExecuteCall(3, 0);
+        }
+        if (bind2)
+        {
+            sEluna->BeginCall(bind2);
+            sEluna->PushUnsigned(sEluna->LuaState, ITEM_EVENT_ON_USE);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushItem(sEluna->LuaState, item);
+            if (GameObject* target = targets.GetGOTarget())
+                sEluna->PushGO(sEluna->LuaState, target);
+            else if (Item* target = targets.GetItemTarget())
+                sEluna->PushItem(sEluna->LuaState, target);
+            else if (Unit* target = targets.GetUnitTarget())
+                sEluna->PushUnit(sEluna->LuaState, target);
+            else
+                lua_pushnil(sEluna->LuaState);
+            sEluna->ExecuteCall(4, 0);
+        }
+        player->SendEquipError((InventoryResult)83, item, NULL);
+        return true;
+    }
+    bool OnExpire(Player* player, ItemTemplate const* proto)
+    {
+        int bind = sEluna->ItemEventBindings->GetBind(proto->ItemId, ITEM_EVENT_ON_EXPIRE);
+        if (!bind)
+            return false;
+        sEluna->BeginCall(bind);
+        sEluna->PushUnsigned(sEluna->LuaState, ITEM_EVENT_ON_EXPIRE);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushUnsigned(sEluna->LuaState, proto->ItemId);
+        sEluna->ExecuteCall(3, 0);
+        return true;
+    }
+    // creature
+    bool OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, Creature* target)
+    {
+        int bind = sEluna->CreatureEventBindings->GetBind(target->GetEntry(), CREATURE_EVENT_ON_DUMMY_EFFECT);
+        if (!bind)
+            return false;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_DUMMY_EFFECT);
+        sEluna->PushUnit(sEluna->LuaState, caster);
+        sEluna->PushUnsigned(sEluna->LuaState, spellId);
+        sEluna->PushInteger(sEluna->LuaState, effIndex);
+        sEluna->PushUnit(sEluna->LuaState, target);
+        sEluna->ExecuteCall(5, 0);
+        return true;
+    }
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        int bind = sEluna->CreatureGossipBindings->GetBind(creature->GetEntry(), GOSSIP_EVENT_ON_HELLO);
+        if (!bind)
+            return false;
+        player->PlayerTalkClass->ClearMenus();
+        sEluna->BeginCall(bind);
+        sEluna->PushUnsigned(sEluna->LuaState, GOSSIP_EVENT_ON_HELLO);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushUnit(sEluna->LuaState, creature);
+        sEluna->ExecuteCall(3, 0);
+        return true;
+    }
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        int bind = sEluna->CreatureGossipBindings->GetBind(creature->GetEntry(), GOSSIP_EVENT_ON_SELECT);
+        if (!bind)
+            return false;
+        player->PlayerTalkClass->ClearMenus();
+        sEluna->BeginCall(bind);
+        sEluna->PushUnsigned(sEluna->LuaState, GOSSIP_EVENT_ON_SELECT);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushUnit(sEluna->LuaState, creature);
+        sEluna->PushUnsigned(sEluna->LuaState, sender);
+        sEluna->PushUnsigned(sEluna->LuaState, action);
+        sEluna->ExecuteCall(5, 0);
+        return true;
+    }
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code)
+    {
+        int bind = sEluna->CreatureGossipBindings->GetBind(creature->GetEntry(), GOSSIP_EVENT_ON_SELECT);
+        if (!bind)
+            return false;
+        player->PlayerTalkClass->ClearMenus();
+        sEluna->BeginCall(bind);
+        sEluna->PushUnsigned(sEluna->LuaState, GOSSIP_EVENT_ON_SELECT);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushUnit(sEluna->LuaState, creature);
+        sEluna->PushUnsigned(sEluna->LuaState, sender);
+        sEluna->PushUnsigned(sEluna->LuaState, action);
+        sEluna->PushString(sEluna->LuaState, code);
+        sEluna->ExecuteCall(6, 0);
+        return true;
+    }
+    bool OnQuestAccept(Player* player, Creature* creature, Quest const* quest)
+    {
+        int bind = sEluna->CreatureEventBindings->GetBind(creature->GetEntry(), CREATURE_EVENT_ON_QUEST_ACCEPT);
+        if (!bind)
+            return false;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_QUEST_ACCEPT);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushUnit(sEluna->LuaState, creature);
+        sEluna->PushQuest(sEluna->LuaState, quest);
+        sEluna->ExecuteCall(4, 0);
+        return true;
+    }
+    bool OnQuestSelect(Player* player, Creature* creature, Quest const* quest)
+    {
+        int bind = sEluna->CreatureEventBindings->GetBind(creature->GetEntry(), CREATURE_EVENT_ON_QUEST_SELECT);
+        if (!bind)
+            return false;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_QUEST_SELECT);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushUnit(sEluna->LuaState, creature);
+        sEluna->PushQuest(sEluna->LuaState, quest);
+        sEluna->ExecuteCall(4, 0);
+        return true;
+    }
+    bool OnQuestComplete(Player* player, Creature* creature, Quest const* quest)
+    {
+        int bind = sEluna->CreatureEventBindings->GetBind(creature->GetEntry(), CREATURE_EVENT_ON_QUEST_COMPLETE);
+        if (!bind)
+            return false;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_QUEST_COMPLETE);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushUnit(sEluna->LuaState, creature);
+        sEluna->PushQuest(sEluna->LuaState, quest);
+        sEluna->ExecuteCall(4, 0);
+        return true;
+    }
+    bool OnQuestReward(Player* player, Creature* creature, Quest const* quest, uint32 opt)
+    {
+        int bind = sEluna->CreatureEventBindings->GetBind(creature->GetEntry(), CREATURE_EVENT_ON_QUEST_REWARD);
+        if (!bind)
+            return false;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_QUEST_REWARD);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushUnit(sEluna->LuaState, creature);
+        sEluna->PushQuest(sEluna->LuaState, quest);
+        sEluna->PushUnsigned(sEluna->LuaState, opt);
+        sEluna->ExecuteCall(5, 0);
+        return true;
+    }
+    uint32 GetDialogStatus(Player* player, Creature* creature)
+    {
+        int bind = sEluna->CreatureEventBindings->GetBind(creature->GetEntry(), CREATURE_EVENT_ON_DIALOG_STATUS);
+        if (!bind)
+            return 0;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, CREATURE_EVENT_ON_DIALOG_STATUS);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushUnit(sEluna->LuaState, creature);
+        sEluna->ExecuteCall(3, 0);
+        return 100;
+    }
+    // gameobject
+    bool OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, GameObject* target)
+    {
+        int bind = sEluna->GameObjectEventBindings->GetBind(target->GetEntry(), GAMEOBJECT_EVENT_ON_DUMMY_EFFECT);
+        if (!bind)
+            return false;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, GAMEOBJECT_EVENT_ON_DUMMY_EFFECT);
+        sEluna->PushUnit(sEluna->LuaState, caster);
+        sEluna->PushUnsigned(sEluna->LuaState, spellId);
+        sEluna->PushInteger(sEluna->LuaState, effIndex);
+        sEluna->PushGO(sEluna->LuaState, target);
+        sEluna->ExecuteCall(5, 0);
+        return true;
+    }
+    bool OnGossipHello(Player* player, GameObject* go)
+    {
+        int bind = sEluna->GameObjectGossipBindings->GetBind(go->GetEntry(), GOSSIP_EVENT_ON_HELLO);
+        if (!bind)
+            return false;
+        player->PlayerTalkClass->ClearMenus();
+        sEluna->BeginCall(bind);
+        sEluna->PushUnsigned(sEluna->LuaState, GOSSIP_EVENT_ON_HELLO);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushGO(sEluna->LuaState, go);
+        sEluna->ExecuteCall(3, 0);
+        return true;
+    }
+    bool OnGossipSelect(Player* player, GameObject* go, uint32 sender, uint32 action)
+    {
+        int bind = sEluna->GameObjectGossipBindings->GetBind(go->GetEntry(), GOSSIP_EVENT_ON_SELECT);
+        if (!bind)
+            return false;
+        player->PlayerTalkClass->ClearMenus();
+        sEluna->BeginCall(bind);
+        sEluna->PushUnsigned(sEluna->LuaState, GOSSIP_EVENT_ON_SELECT);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushGO(sEluna->LuaState, go);
+        sEluna->PushUnsigned(sEluna->LuaState, sender);
+        sEluna->PushUnsigned(sEluna->LuaState, action);
+        sEluna->ExecuteCall(5, 0);
+        return true;
+    }
+    bool OnGossipSelectCode(Player* player, GameObject* go, uint32 sender, uint32 action, const char* code)
+    {
+        int bind = sEluna->GameObjectGossipBindings->GetBind(go->GetEntry(), GOSSIP_EVENT_ON_SELECT);
+        if (!bind)
+            return false;
+        player->PlayerTalkClass->ClearMenus();
+        sEluna->BeginCall(bind);
+        sEluna->PushUnsigned(sEluna->LuaState, GOSSIP_EVENT_ON_SELECT);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushGO(sEluna->LuaState, go);
+        sEluna->PushUnsigned(sEluna->LuaState, sender);
+        sEluna->PushUnsigned(sEluna->LuaState, action);
+        sEluna->PushString(sEluna->LuaState, code);
+        sEluna->ExecuteCall(6, 0);
+        return true;
+    }
+    bool OnQuestAccept(Player* player, GameObject* go, Quest const* quest)
+    {
+        int bind = sEluna->GameObjectEventBindings->GetBind(go->GetEntry(), GAMEOBJECT_EVENT_ON_QUEST_ACCEPT);
+        if (!bind)
+            return false;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, GAMEOBJECT_EVENT_ON_QUEST_ACCEPT);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushGO(sEluna->LuaState, go);
+        sEluna->PushQuest(sEluna->LuaState, quest);
+        sEluna->ExecuteCall(4, 0);
+        return true;
+    }
+    bool OnQuestReward(Player* player, GameObject* go, Quest const* quest, uint32 opt)
+    {
+        int bind = sEluna->GameObjectEventBindings->GetBind(go->GetEntry(), GAMEOBJECT_EVENT_ON_QUEST_REWARD);
+        if (!bind)
+            return false;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, GAMEOBJECT_EVENT_ON_QUEST_REWARD);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushGO(sEluna->LuaState, go);
+        sEluna->PushQuest(sEluna->LuaState, quest);
+        sEluna->PushUnsigned(sEluna->LuaState, opt);
+        sEluna->ExecuteCall(5, 0);
+        return true;
+    }
+    uint32 GetDialogStatus(Player* player, GameObject* go)
+    {
+        int bind = sEluna->GameObjectEventBindings->GetBind(go->GetEntry(), GAMEOBJECT_EVENT_ON_DIALOG_STATUS);
+        if (!bind)
+            return 0;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, GAMEOBJECT_EVENT_ON_DIALOG_STATUS);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->PushGO(sEluna->LuaState, go);
+        sEluna->ExecuteCall(3, 0);
+        return 100;
+    }
+    void OnDestroyed(GameObject* go, Player* player)
+    {
+        int bind = sEluna->GameObjectEventBindings->GetBind(go->GetEntry(), GAMEOBJECT_EVENT_ON_DESTROYED);
+        if (!bind)
+            return;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, GAMEOBJECT_EVENT_ON_DESTROYED);
+        sEluna->PushGO(sEluna->LuaState, go);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->ExecuteCall(3, 0);
+    }
+    void OnDamaged(GameObject* go, Player* player)
+    {
+        int bind = sEluna->GameObjectEventBindings->GetBind(go->GetEntry(), GAMEOBJECT_EVENT_ON_DAMAGED);
+        if (!bind)
+            return;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, GAMEOBJECT_EVENT_ON_DAMAGED);
+        sEluna->PushGO(sEluna->LuaState, go);
+        sEluna->PushUnit(sEluna->LuaState, player);
+        sEluna->ExecuteCall(3, 0);
+    }
+    void OnLootStateChanged(GameObject* go, uint32 state, Unit* unit)
+    {
+        int bind = sEluna->GameObjectEventBindings->GetBind(go->GetEntry(), GAMEOBJECT_EVENT_ON_LOOT_STATE_CHANGE);
+        if (!bind)
+            return;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, GAMEOBJECT_EVENT_ON_LOOT_STATE_CHANGE);
+        sEluna->PushGO(sEluna->LuaState, go);
+        sEluna->PushUnsigned(sEluna->LuaState, state);
+        sEluna->PushUnit(sEluna->LuaState, unit);
+        sEluna->ExecuteCall(4, 0);
+    }
+    void OnGameObjectStateChanged(GameObject* go, uint32 state)
+    {
+        int bind = sEluna->GameObjectEventBindings->GetBind(go->GetEntry(), GAMEOBJECT_EVENT_ON_GO_STATE_CHANGED);
+        if (!bind)
+            return;
+        sEluna->BeginCall(bind);
+        sEluna->PushInteger(sEluna->LuaState, GAMEOBJECT_EVENT_ON_GO_STATE_CHANGED);
+        sEluna->PushGO(sEluna->LuaState, go);
+        sEluna->PushUnsigned(sEluna->LuaState, state);
+        sEluna->ExecuteCall(3, 0);
+    }
+    // areatrigger
+    bool OnTrigger(Player* player, AreaTriggerEntry const* trigger)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[TRIGGER_EVENT_ON_TRIGGER].begin();
+            itr != sEluna->ServerEventBindings[TRIGGER_EVENT_ON_TRIGGER].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, TRIGGER_EVENT_ON_TRIGGER);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnsigned(sEluna->LuaState, trigger->id);
+            sEluna->ExecuteCall(3, 0);
+        }
+        return false;
+    }
+    // weather
+    void OnChange(Weather* weather, WeatherState state, float grade)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[WEATHER_EVENT_ON_CHANGE].begin();
+            itr != sEluna->ServerEventBindings[WEATHER_EVENT_ON_CHANGE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, WEATHER_EVENT_ON_CHANGE);
+            sEluna->PushUnsigned(sEluna->LuaState, (weather->GetZone()));
+            sEluna->PushInteger(sEluna->LuaState, state);
+            sEluna->PushFloat(sEluna->LuaState, grade);
+            sEluna->ExecuteCall(4, 0);
+        }
+    }
+    // condition
+    bool OnConditionCheck(Condition* condition, ConditionSourceInfo& sourceInfo)
+    {
+        return true;
+    }
+    // transport
+    void OnAddPassenger(Transport* transport, Player* player)
+    {
+    }
+    void OnAddCreaturePassenger(Transport* transport, Creature* creature)
+    {
+    }
+    void OnRemovePassenger(Transport* transport, Player* player)
+    {
+    }
+    void OnRelocate(Transport* transport, uint32 waypointId, uint32 mapId, float x, float y, float z)
+    {
+    }
+};
+// TC
+class Eluna_ServerScript : public ServerScript
+{
+public:
+    Eluna_ServerScript() : ServerScript("Eluna_ServerScript") { }
+    void OnNetworkStart()
+    {
+    }
+    void OnNetworkStop()
+    {
+    }
+    void OnSocketOpen(WorldSocket* socket)
+    {
+    }
+    void OnSocketClose(WorldSocket* socket, bool wasNew)
+    {
+    }
+    void OnPacketSend(WorldSocket* socket, WorldPacket& packet)
+    {
+    }
+    void OnPacketReceive(WorldSocket* socket, WorldPacket& packet)
+    {
+    }
+    void OnUnknownPacketReceive(WorldSocket* socket, WorldPacket& packet)
+    {
+    }
+};
+class Eluna_FormulaScript : public FormulaScript
+{
+public:
+    Eluna_FormulaScript() : FormulaScript("Eluna_FormulaScript") { }
+    void OnHonorCalculation(float& honor, uint8 level, float multiplier)
+    {
+    }
+    void OnGrayLevelCalculation(uint8& grayLevel, uint8 playerLevel)
+    {
+    }
+    void OnColorCodeCalculation(XPColorChar& color, uint8 playerLevel, uint8 mobLevel)
+    {
+    }
+    void OnZeroDifferenceCalculation(uint8& diff, uint8 playerLevel)
+    {
+    }
+    void OnBaseGainCalculation(uint32& gain, uint8 playerLevel, uint8 mobLevel, ContentLevels content)
+    {
+    }
+    void OnGainCalculation(uint32& gain, Player* player, Unit* unit)
+    {
+    }
+    void OnGroupRateCalculation(float& rate, uint32 count, bool isRaid)
+    {
+    }
+};
+/*
+class Eluna_MapScript : public WorldMapScript
+{
+public:
+Eluna_MapScript() : WorldMapScript("Eluna_MapScript", 123) { }
+void OnCreate(Map* map)
+{
+}
+void OnDestroy(Map* map)
+{
+}
+void OnLoadGridMap(Map* map, GridMap* gmap, uint32 gx, uint32 gy)
+{
+}
+void OnUnloadGridMap(Map* map, GridMap* gmap, uint32 gx, uint32 gy)
+{
+}
+void OnPlayerEnter(Map* map, Player* player)
+{
+}
+void OnPlayerLeave(Map* map, Player* player)
+{
+}
+void OnUpdate(Map* map, uint32 diff)
+{
+}
+};
+*/
+/*
+class Eluna_InstanceMapScript : public InstanceMapScript
+{
+public:
+Eluna_InstanceMapScript() : InstanceMapScript("Eluna_InstanceMapScript") { }
+InstanceScript* GetInstanceScript(InstanceMap* map)
+{
+}
+void OnCreate(Map* map)
+{
+}
+void OnDestroy(Map* map)
+{
+}
+void OnLoadGridMap(Map* map, GridMap* gmap, uint32 gx, uint32 gy)
+{
+}
+void OnUnloadGridMap(Map* map, GridMap* gmap, uint32 gx, uint32 gy)
+{
+}
+void OnPlayerEnter(Map* map, Player* player)
+{
+}
+void OnPlayerLeave(Map* map, Player* player)
+{
+}
+void OnUpdate(Map* map, uint32 diff)
+{
+}
+};
+*/
+class Eluna_AuctionHouseScript : public AuctionHouseScript
+{
+public:
+    Eluna_AuctionHouseScript() : AuctionHouseScript("Eluna_AuctionHouseScript") { }
+    void OnAuctionAdd(AuctionHouseObject* ah, AuctionEntry* entry)
+    {
+    }
+    void OnAuctionRemove(AuctionHouseObject* ah, AuctionEntry* entry)
+    {
+    }
+    void OnAuctionSuccessful(AuctionHouseObject* ah, AuctionEntry* entry)
+    {
+    }
+    void OnAuctionExpire(AuctionHouseObject* ah, AuctionEntry* entry)
+    {
+    }
+};
+/*class Eluna_ConditionScript : public ConditionScript
+{
+public:
+Eluna_ConditionScript() : ConditionScript("Eluna_ConditionScript") { }
+bool OnConditionCheck(Condition* condition, ConditionSourceInfo& sourceInfo)
+{
+return false;
+}
+};
+*/
+class Eluna_VehicleScript : public VehicleScript
+{
+public:
+    Eluna_VehicleScript() : VehicleScript("Eluna_VehicleScript") { }
+    void OnInstall(Vehicle* veh)
+    {
+    }
+    void OnUninstall(Vehicle* veh)
+    {
+    }
+    void OnReset(Vehicle* veh)
+    {
+    }
+    void OnInstallAccessory(Vehicle* veh, Creature* accessory)
+    {
+    }
+    void OnAddPassenger(Vehicle* veh, Unit* passenger, int8 seatId)
+    {
+    }
+    void OnRemovePassenger(Vehicle* veh, Unit* passenger)
+    {
+    }
+};
+/*class Eluna_TransportScript : public TransportScript
+{
+public:
+Eluna_TransportScript() : TransportScript("Eluna_TransportScript") { }
+void OnAddPassenger(Transport* transport, Player* player)
+{
+}
+void OnAddCreaturePassenger(Transport* transport, Creature* creature)
+{
+}
+void OnRemovePassenger(Transport* transport, Player* player)
+{
+}
+void OnRelocate(Transport* transport, uint32 waypointId, uint32 mapId, float x, float y, float z)
+{
+}
+};
+*/
+class Eluna_PlayerScript : public PlayerScript
+{
+public:
+    Eluna_PlayerScript() : PlayerScript("Eluna_PlayerScript") { }
+    void OnPlayerEnterCombat(Player* player, Unit* enemy)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_ENTER_COMBAT].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_ENTER_COMBAT].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_ENTER_COMBAT);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnit(sEluna->LuaState, enemy);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnPlayerLeaveCombat(Player* player)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_LEAVE_COMBAT].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_LEAVE_COMBAT].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_LEAVE_COMBAT);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+    void OnPVPKill(Player* killer, Player* killed)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_KILL_PLAYER].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_KILL_PLAYER].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_KILL_PLAYER);
+            sEluna->PushUnit(sEluna->LuaState, killer);
+            sEluna->PushUnit(sEluna->LuaState, killed);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnCreatureKill(Player* killer, Creature* killed)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_KILL_CREATURE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_KILL_CREATURE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_KILL_CREATURE);
+            sEluna->PushUnit(sEluna->LuaState, killer);
+            sEluna->PushUnit(sEluna->LuaState, killed);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnPlayerKilledByCreature(Creature* killer, Player* killed)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_KILLED_BY_CREATURE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_KILLED_BY_CREATURE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_KILLED_BY_CREATURE);
+            sEluna->PushUnit(sEluna->LuaState, killer);
+            sEluna->PushUnit(sEluna->LuaState, killed);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnLevelChanged(Player* player, uint8 oldLevel)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_LEVEL_CHANGE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_LEVEL_CHANGE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_LEVEL_CHANGE);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnsigned(sEluna->LuaState, oldLevel);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnFreeTalentPointsChanged(Player* player, uint32 newPoints)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_TALENTS_CHANGE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_TALENTS_CHANGE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_TALENTS_CHANGE);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnsigned(sEluna->LuaState, newPoints);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnTalentsReset(Player* player, bool noCost)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_TALENTS_RESET].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_TALENTS_RESET].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_TALENTS_RESET);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushBoolean(sEluna->LuaState, noCost);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnMoneyChanged(Player* player, int32& amount)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_MONEY_CHANGE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_MONEY_CHANGE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_MONEY_CHANGE);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushInteger(sEluna->LuaState, amount);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnGiveXP(Player* player, uint32& amount, Unit* victim)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_GIVE_XP].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_GIVE_XP].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_GIVE_XP);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnsigned(sEluna->LuaState, amount);
+            sEluna->PushUnit(sEluna->LuaState, victim);
+            sEluna->ExecuteCall(4, 0);
+        }
+    }
+    void OnReputationChange(Player* player, uint32 factionID, int32& standing, bool incremental)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_REPUTATION_CHANGE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_REPUTATION_CHANGE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_REPUTATION_CHANGE);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnsigned(sEluna->LuaState, factionID);
+            sEluna->PushInteger(sEluna->LuaState, standing);
+            sEluna->PushBoolean(sEluna->LuaState, incremental);
+            sEluna->ExecuteCall(5, 0);
+        }
+    }
+    void OnDuelRequest(Player* target, Player* challenger)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_DUEL_REQUEST].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_DUEL_REQUEST].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_DUEL_REQUEST);
+            sEluna->PushUnit(sEluna->LuaState, target);
+            sEluna->PushUnit(sEluna->LuaState, challenger);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnDuelStart(Player* player1, Player* player2)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_DUEL_START].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_DUEL_START].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_DUEL_START);
+            sEluna->PushUnit(sEluna->LuaState, player1);
+            sEluna->PushUnit(sEluna->LuaState, player2);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnDuelEnd(Player* winner, Player* loser, DuelCompleteType type)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_DUEL_END].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_DUEL_END].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_DUEL_END);
+            sEluna->PushUnit(sEluna->LuaState, winner);
+            sEluna->PushUnit(sEluna->LuaState, loser);
+            sEluna->PushInteger(sEluna->LuaState, type);
+            sEluna->ExecuteCall(4, 0);
+        }
+    }
+    void OnChat(Player* player, uint32 type, uint32 lang, std::string& msg)
+    {
+        // implemented in ChatHandler.cpp
+    }
+    void OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Player* receiver)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_WHISPER].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_WHISPER].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_WHISPER);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushString(sEluna->LuaState, msg.c_str());
+            sEluna->PushUnsigned(sEluna->LuaState, type);
+            sEluna->PushUnsigned(sEluna->LuaState, lang);
+            sEluna->PushUnit(sEluna->LuaState, receiver);
+            sEluna->ExecuteCall(6, 0);
+        }
+    }
+    void OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Group* group)
+    {
+        // implemented in ChatHandler.cpp
+    }
+    void OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Guild* guild)
+    {
+        // implemented in ChatHandler.cpp
+    }
+    void OnChat(Player* player, uint32 type, uint32 lang, std::string& msg, Channel* channel)
+    {
+        // implemented in ChatHandler.cpp
+    }
+    void OnEmote(Player* player, uint32 emote)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_EMOTE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_EMOTE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_EMOTE);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnsigned(sEluna->LuaState, emote);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnTextEmote(Player* player, uint32 textEmote, uint32 emoteNum, uint64 guid)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_TEXT_EMOTE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_TEXT_EMOTE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_TEXT_EMOTE);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnsigned(sEluna->LuaState, textEmote);
+            sEluna->PushUnsigned(sEluna->LuaState, emoteNum);
+            sEluna->PushULong(sEluna->LuaState, guid);
+            sEluna->ExecuteCall(5, 0);
+        }
+    }
+    void OnSpellCast(Player* player, Spell* spell, bool skipCheck)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_SPELL_CAST].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_SPELL_CAST].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_SPELL_CAST);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushSpell(sEluna->LuaState, spell);
+            sEluna->PushBoolean(sEluna->LuaState, skipCheck);
+            sEluna->ExecuteCall(4, 0);
+        }
+    }
+    void OnLogin(Player* player)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_LOGIN].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_LOGIN].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_LOGIN);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+    void OnLogout(Player* player)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_LOGOUT].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_LOGOUT].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_LOGOUT);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+    void OnCreate(Player* player)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_CHARACTER_CREATE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_CHARACTER_CREATE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_CHARACTER_CREATE);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+    void OnDelete(uint64 guid)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_CHARACTER_DELETE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_CHARACTER_DELETE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_CHARACTER_DELETE);
+            sEluna->PushULong(sEluna->LuaState, guid);
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+    void OnSave(Player* player)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_SAVE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_SAVE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_SAVE);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+    void OnBindToInstance(Player* player, Difficulty difficulty, uint32 mapid, bool permanent)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_BIND_TO_INSTANCE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_BIND_TO_INSTANCE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_BIND_TO_INSTANCE);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushInteger(sEluna->LuaState, difficulty);
+            sEluna->PushUnsigned(sEluna->LuaState, mapid);
+            sEluna->PushBoolean(sEluna->LuaState, permanent);
+            sEluna->ExecuteCall(5, 0);
+        }
+    }
+    void OnUpdateZone(Player* player, uint32 newZone, uint32 newArea)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_UPDATE_ZONE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_UPDATE_ZONE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_UPDATE_ZONE);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnsigned(sEluna->LuaState, newZone);
+            sEluna->PushUnsigned(sEluna->LuaState, newArea);
+            sEluna->ExecuteCall(4, 0);
+        }
+    }
+    void OnMapChanged(Player* player)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[PLAYER_EVENT_ON_MAP_CHANGE].begin();
+            itr != sEluna->ServerEventBindings[PLAYER_EVENT_ON_MAP_CHANGE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, PLAYER_EVENT_ON_MAP_CHANGE);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+};
+class Eluna_GuildScript : public GuildScript
+{
+public:
+    Eluna_GuildScript() : GuildScript("Eluna_GuildScript") { }
+    void OnAddMember(Guild* guild, Player* player, uint8& plRank)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GUILD_EVENT_ON_ADD_MEMBER].begin();
+            itr != sEluna->ServerEventBindings[GUILD_EVENT_ON_ADD_MEMBER].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GUILD_EVENT_ON_ADD_MEMBER);
+            sEluna->PushGuild(sEluna->LuaState, guild);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnsigned(sEluna->LuaState, plRank);
+            sEluna->ExecuteCall(4, 0);
+        }
+    }
+    void OnRemoveMember(Guild* guild, Player* player, bool isDisbanding, bool isKicked)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GUILD_EVENT_ON_REMOVE_MEMBER].begin();
+            itr != sEluna->ServerEventBindings[GUILD_EVENT_ON_REMOVE_MEMBER].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GUILD_EVENT_ON_REMOVE_MEMBER);
+            sEluna->PushGuild(sEluna->LuaState, guild);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushBoolean(sEluna->LuaState, isDisbanding);
+            sEluna->PushBoolean(sEluna->LuaState, isKicked);
+            sEluna->ExecuteCall(5, 0);
+        }
+    }
+    void OnMOTDChanged(Guild* guild, const std::string& newMotd)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GUILD_EVENT_ON_MOTD_CHANGE].begin();
+            itr != sEluna->ServerEventBindings[GUILD_EVENT_ON_MOTD_CHANGE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GUILD_EVENT_ON_MOTD_CHANGE);
+            sEluna->PushGuild(sEluna->LuaState, guild);
+            sEluna->PushString(sEluna->LuaState, newMotd.c_str());
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnInfoChanged(Guild* guild, const std::string& newInfo)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GUILD_EVENT_ON_INFO_CHANGE].begin();
+            itr != sEluna->ServerEventBindings[GUILD_EVENT_ON_INFO_CHANGE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GUILD_EVENT_ON_INFO_CHANGE);
+            sEluna->PushGuild(sEluna->LuaState, guild);
+            sEluna->PushString(sEluna->LuaState, newInfo.c_str());
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnCreate(Guild* guild, Player* leader, const std::string& name)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GUILD_EVENT_ON_CREATE].begin();
+            itr != sEluna->ServerEventBindings[GUILD_EVENT_ON_CREATE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GUILD_EVENT_ON_CREATE);
+            sEluna->PushGuild(sEluna->LuaState, guild);
+            sEluna->PushUnit(sEluna->LuaState, leader);
+            sEluna->PushString(sEluna->LuaState, name.c_str());
+            sEluna->ExecuteCall(4, 0);
+        }
+    }
+    void OnDisband(Guild* guild)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GUILD_EVENT_ON_DISBAND].begin();
+            itr != sEluna->ServerEventBindings[GUILD_EVENT_ON_DISBAND].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GUILD_EVENT_ON_DISBAND);
+            sEluna->PushGuild(sEluna->LuaState, guild);
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+    void OnMemberWitdrawMoney(Guild* guild, Player* player, uint32 &amount, bool isRepair)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GUILD_EVENT_ON_MONEY_WITHDRAW].begin();
+            itr != sEluna->ServerEventBindings[GUILD_EVENT_ON_MONEY_WITHDRAW].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GUILD_EVENT_ON_MONEY_WITHDRAW);
+            sEluna->PushGuild(sEluna->LuaState, guild);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnsigned(sEluna->LuaState, amount);
+            sEluna->PushBoolean(sEluna->LuaState, isRepair);
+            sEluna->ExecuteCall(5, 0);
+        }
+    }
+    void OnMemberDepositMoney(Guild* guild, Player* player, uint32 &amount)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GUILD_EVENT_ON_MONEY_DEPOSIT].begin();
+            itr != sEluna->ServerEventBindings[GUILD_EVENT_ON_MONEY_DEPOSIT].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GUILD_EVENT_ON_MONEY_DEPOSIT);
+            sEluna->PushGuild(sEluna->LuaState, guild);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushUnsigned(sEluna->LuaState, amount);
+            sEluna->ExecuteCall(4, 0);
+        }
+    }
+    void OnItemMove(Guild* guild, Player* player, Item* pItem, bool isSrcBank, uint8 srcContainer, uint8 srcSlotId,
+        bool isDestBank, uint8 destContainer, uint8 destSlotId)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GUILD_EVENT_ON_ITEM_MOVE].begin();
+            itr != sEluna->ServerEventBindings[GUILD_EVENT_ON_ITEM_MOVE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GUILD_EVENT_ON_ITEM_MOVE);
+            sEluna->PushGuild(sEluna->LuaState, guild);
+            sEluna->PushUnit(sEluna->LuaState, player);
+            sEluna->PushItem(sEluna->LuaState, pItem);
+            sEluna->PushBoolean(sEluna->LuaState, isSrcBank);
+            sEluna->PushUnsigned(sEluna->LuaState, srcContainer);
+            sEluna->PushUnsigned(sEluna->LuaState, srcSlotId);
+            sEluna->PushBoolean(sEluna->LuaState, isDestBank);
+            sEluna->PushUnsigned(sEluna->LuaState, destContainer);
+            sEluna->PushUnsigned(sEluna->LuaState, destSlotId);
+            sEluna->ExecuteCall(10, 0);
+        }
+    }
+    void OnEvent(Guild* guild, uint8 eventType, uint32 playerGuid1, uint32 playerGuid2, uint8 newRank)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GUILD_EVENT_ON_EVENT].begin();
+            itr != sEluna->ServerEventBindings[GUILD_EVENT_ON_EVENT].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GUILD_EVENT_ON_EVENT);
+            sEluna->PushGuild(sEluna->LuaState, guild);
+            sEluna->PushUnsigned(sEluna->LuaState, eventType);
+            sEluna->PushUnsigned(sEluna->LuaState, playerGuid1);
+            sEluna->PushUnsigned(sEluna->LuaState, playerGuid2);
+            sEluna->PushUnsigned(sEluna->LuaState, newRank);
+            sEluna->ExecuteCall(6, 0);
+        }
+    }
+    void OnBankEvent(Guild* guild, uint8 eventType, uint8 tabId, uint32 playerGuid, uint32 itemOrMoney, uint16 itemStackCount, uint8 destTabId)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GUILD_EVENT_ON_BANK_EVENT].begin();
+            itr != sEluna->ServerEventBindings[GUILD_EVENT_ON_BANK_EVENT].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GUILD_EVENT_ON_BANK_EVENT);
+            sEluna->PushGuild(sEluna->LuaState, guild);
+            sEluna->PushUnsigned(sEluna->LuaState, eventType);
+            sEluna->PushUnsigned(sEluna->LuaState, tabId);
+            sEluna->PushUnsigned(sEluna->LuaState, playerGuid);
+            sEluna->PushUnsigned(sEluna->LuaState, itemOrMoney);
+            sEluna->PushUnsigned(sEluna->LuaState, itemStackCount);
+            sEluna->PushUnsigned(sEluna->LuaState, destTabId);
+            sEluna->ExecuteCall(8, 0);
+        }
+    }
+};
+class Eluna_GroupScript : public GroupScript
+{
+public:
+    Eluna_GroupScript() : GroupScript("Eluna_GroupScript") { }
+    void OnAddMember(Group* group, uint64 guid)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GROUP_EVENT_ON_MEMBER_ADD].begin();
+            itr != sEluna->ServerEventBindings[GROUP_EVENT_ON_MEMBER_ADD].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GROUP_EVENT_ON_MEMBER_ADD);
+            sEluna->PushGroup(sEluna->LuaState, group);
+            sEluna->PushULong(sEluna->LuaState, guid);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnInviteMember(Group* group, uint64 guid)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GROUP_EVENT_ON_MEMBER_INVITE].begin();
+            itr != sEluna->ServerEventBindings[GROUP_EVENT_ON_MEMBER_INVITE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GROUP_EVENT_ON_MEMBER_INVITE);
+            sEluna->PushGroup(sEluna->LuaState, group);
+            sEluna->PushULong(sEluna->LuaState, guid);
+            sEluna->ExecuteCall(3, 0);
+        }
+    }
+    void OnRemoveMember(Group* group, uint64 guid, RemoveMethod method, uint64 kicker, const char* reason)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GROUP_EVENT_ON_MEMBER_REMOVE].begin();
+            itr != sEluna->ServerEventBindings[GROUP_EVENT_ON_MEMBER_REMOVE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GROUP_EVENT_ON_MEMBER_REMOVE);
+            sEluna->PushGroup(sEluna->LuaState, group);
+            sEluna->PushULong(sEluna->LuaState, guid);
+            sEluna->PushInteger(sEluna->LuaState, method);
+            sEluna->PushULong(sEluna->LuaState, kicker);
+            sEluna->PushString(sEluna->LuaState, reason);
+            sEluna->ExecuteCall(6, 0);
+        }
+    }
+    void OnChangeLeader(Group* group, uint64 newLeaderGuid, uint64 oldLeaderGuid)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GROUP_EVENT_ON_LEADER_CHANGE].begin();
+            itr != sEluna->ServerEventBindings[GROUP_EVENT_ON_LEADER_CHANGE].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GROUP_EVENT_ON_LEADER_CHANGE);
+            sEluna->PushGroup(sEluna->LuaState, group);
+            sEluna->PushULong(sEluna->LuaState, newLeaderGuid);
+            sEluna->PushULong(sEluna->LuaState, oldLeaderGuid);
+            sEluna->ExecuteCall(4, 0);
+        }
+    }
+    void OnDisband(Group* group)
+    {
+        for (std::vector<int>::const_iterator itr = sEluna->ServerEventBindings[GROUP_EVENT_ON_DISBAND].begin();
+            itr != sEluna->ServerEventBindings[GROUP_EVENT_ON_DISBAND].end(); ++itr)
+        {
+            sEluna->BeginCall((*itr));
+            sEluna->PushUnsigned(sEluna->LuaState, GROUP_EVENT_ON_DISBAND);
+            sEluna->PushGroup(sEluna->LuaState, group);
+            sEluna->ExecuteCall(2, 0);
+        }
+    }
+};
+
+void Eluna::AddScriptHooks()
+{
+    // AI
+    LuaCreatureAI = new Eluna_CreatureScript;
+    LuaGameObjectAI = new Eluna_GameObjectScript;
+    LuaWorldAI = new Eluna_WorldScript;
+    // Custom
+    new Eluna_HookScript;
+    // TC
+    new Eluna_ServerScript;
+    new Eluna_FormulaScript;
+    //new Eluna_MapScript;
+    //new Eluna_InstanceMapScript;
+    new Eluna_AuctionHouseScript;
+    //new Eluna_ConditionScript;
+    new Eluna_VehicleScript;
+    //new Eluna_TransportScript;
+    new Eluna_PlayerScript;
+    new Eluna_GuildScript;
+    new Eluna_GroupScript;
+}
\ No newline at end of file
diff --git a/src/server/LuaEngine/QueryMethods.h b/src/server/LuaEngine/QueryMethods.h
new file mode 100644
index 0000000..842be15
--- /dev/null
+++ b/src/server/LuaEngine/QueryMethods.h
@@ -0,0 +1,184 @@
+#ifndef QUERYMETHODS_H
+#define QUERYMETHODS_H
+
+class LuaQuery
+{
+public:
+
+    // QueryResult methods
+
+    static int GetUnitType(lua_State* L, QueryResult* result)
+    {
+        if (!result)
+            return 0;
+
+        sEluna->PushString(L, "QueryResult");
+        return 1;
+    }
+
+    static int NextRow(lua_State* L, QueryResult* result)
+    {
+        if (!result)
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, result->get()->NextRow());
+        return 1;
+    }
+
+    static int GetColumnCount(lua_State* L, QueryResult* result)
+    {
+        if (!result)
+            sEluna->PushUnsigned(L, 0);
+        else
+            sEluna->PushUnsigned(L, result->get()->GetFieldCount());
+        return 1;
+    }
+
+    static int GetRowCount(lua_State* L, QueryResult* result)
+    {
+        if (!result)
+            sEluna->PushUnsigned(L, 0);
+        else
+        {
+            if (result->get()->GetRowCount() > (uint32)-1)
+                sEluna->PushUnsigned(L, (uint32)-1);
+            else
+                sEluna->PushUnsigned(L, result->get()->GetRowCount());
+        }
+        return 1;
+    }
+
+
+    // Field methods
+
+    static int IsNull(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            sEluna->PushBoolean(L, true);
+        else
+            sEluna->PushBoolean(L, result->get()->Fetch()[col].IsNull());
+        return 1;
+    }
+
+    static int GetBool(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            sEluna->PushBoolean(L, false);
+        else
+            sEluna->PushBoolean(L, result->get()->Fetch()[col].GetBool());
+        return 1;
+    }
+
+    static int GetUInt8(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            sEluna->PushUnsigned(L, 0);
+        else
+            sEluna->PushUnsigned(L, result->get()->Fetch()[col].GetUInt8());
+        return 1;
+    }
+
+    static int GetUInt16(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            sEluna->PushUnsigned(L, 0);
+        else
+            sEluna->PushUnsigned(L, result->get()->Fetch()[col].GetUInt16());
+        return 1;
+    }
+
+    static int GetUInt32(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            sEluna->PushUnsigned(L, 0);
+        else
+            sEluna->PushUnsigned(L, result->get()->Fetch()[col].GetUInt32());
+        return 1;
+    }
+
+    static int GetUInt64(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            sEluna->PushULong(L, 0);
+        else
+            sEluna->PushULong(L, result->get()->Fetch()[col].GetUInt64());
+        return 1;
+    }
+
+    static int GetInt8(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            sEluna->PushInteger(L, 0);
+        else
+            sEluna->PushInteger(L, result->get()->Fetch()[col].GetInt8());
+        return 1;
+    }
+
+    static int GetInt16(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            sEluna->PushInteger(L, 0);
+        else
+            sEluna->PushInteger(L, result->get()->Fetch()[col].GetInt16());
+        return 1;
+    }
+
+    static int GetInt32(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            sEluna->PushInteger(L, 0);
+        else
+            sEluna->PushInteger(L, result->get()->Fetch()[col].GetInt32());
+        return 1;
+    }
+
+    static int GetInt64(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            sEluna->PushLong(L, 0);
+        else
+            sEluna->PushLong(L, result->get()->Fetch()[col].GetInt64());
+        return 1;
+    }
+
+    static int GetFloat(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            sEluna->PushFloat(L, 0.0f);
+        else
+            sEluna->PushFloat(L, result->get()->Fetch()[col].GetFloat());
+        return 1;
+    }
+
+    static int GetDouble(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            sEluna->PushDouble(L, 0.0);
+        else
+            sEluna->PushDouble(L, result->get()->Fetch()[col].GetDouble());
+        return 1;
+    }
+
+    static int GetString(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            sEluna->PushString(L, "");
+        else
+            sEluna->PushString(L, result->get()->Fetch()[col].GetString().c_str());
+        return 1;
+    }
+};
+#endif
diff --git a/src/server/LuaEngine/QuestMethods.h b/src/server/LuaEngine/QuestMethods.h
new file mode 100644
index 0000000..2afe515
--- /dev/null
+++ b/src/server/LuaEngine/QuestMethods.h
@@ -0,0 +1,149 @@
+#ifndef QUESTMETHODS_H
+#define QUESTMETHODS_H
+
+class LuaQuest
+{
+public:
+    // :GetUnitType()
+    static int GetUnitType(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        lua_pushstring(L, "Quest");
+        return 1;
+    }
+
+    // :GetId()
+    static int GetId(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        sEluna->PushUnsigned(L, quest->GetQuestId());
+        return 1;
+    }
+
+    // :GetLevel()
+    static int GetLevel(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        sEluna->PushInteger(L, quest->GetQuestLevel());
+        return 1;
+    }
+
+    // :GetMaxLevel()
+    static int GetMaxLevel(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        sEluna->PushUnsigned(L, quest->GetMaxLevel());
+        return 1;
+    }
+
+    // :GetMinLevel()
+    static int GetMinLevel(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        sEluna->PushUnsigned(L, quest->GetMinLevel());
+        return 1;
+    }
+
+    // :GetNextQuestId()
+    static int GetNextQuestId(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        sEluna->PushInteger(L, quest->GetNextQuestId());
+        return 1;
+    }
+
+    // :GetPrevQuestId()
+    static int GetPrevQuestId(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        sEluna->PushInteger(L, quest->GetPrevQuestId());
+        return 1;
+    }
+
+    // :GetNextQuestInChain()
+    static int GetNextQuestInChain(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        sEluna->PushInteger(L, quest->GetNextQuestInChain());
+        return 1;
+    }
+
+    // :GetFlags()
+    static int GetFlags(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        sEluna->PushUnsigned(L, quest->GetFlags());
+        return 1;
+    }
+
+    // :GetType()
+    static int GetType(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        sEluna->PushUnsigned(L, quest->GetType());
+        return 1;
+    }
+
+    // :HasFlag(flag)
+    static int HasFlag(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        uint32 flag = luaL_checkunsigned(L, 1);
+        sEluna->PushBoolean(L, quest->HasFlag(flag));
+        return 1;
+    }
+
+    // :IsDaily()
+    static int IsDaily(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        sEluna->PushBoolean(L, quest->IsDaily());
+        return 1;
+    }
+
+    // :IsRepeatable()
+    static int IsRepeatable(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        sEluna->PushBoolean(L, quest->IsRepeatable());
+        return 1;
+    }
+
+    // :SetFlag(flag)
+    static int SetFlag(lua_State* L, Quest* quest)
+    {
+        if (!quest)
+            return 0;
+
+        uint32 flag = luaL_checkunsigned(L, 1);
+        quest->SetFlag(flag);
+        return 0;
+    }
+};
+#endif
\ No newline at end of file
diff --git a/src/server/LuaEngine/SpellMethods.h b/src/server/LuaEngine/SpellMethods.h
new file mode 100644
index 0000000..17a6026
--- /dev/null
+++ b/src/server/LuaEngine/SpellMethods.h
@@ -0,0 +1,122 @@
+#ifndef SPELLMETHODS_H
+#define SPELLMETHODS_H
+
+class LuaSpell
+{
+public:
+    // :GetUnitType()
+    static int GetUnitType(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        lua_pushstring(L, "Spell");
+        return 1;
+    }
+
+    // GetCaster()
+    static int GetCaster(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        sEluna->PushUnit(L, spell->GetCaster());
+        return 1;
+    }
+
+    // GetCastTime()
+    static int GetCastTime(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        sEluna->PushInteger(L, spell->GetCastTime());
+        return 1;
+    }
+
+    // GetId()
+    static int GetId(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        sEluna->PushUnsigned(L, spell->GetSpellInfo()->Id);
+        return 1;
+    }
+
+    // GetPowerCost()
+    static int GetPowerCost(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        sEluna->PushInteger(L, spell->GetPowerCost());
+        return 1;
+    }
+
+    // GetDuration()
+    static int GetDuration(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        sEluna->PushInteger(L, spell->GetSpellInfo()->GetDuration());
+        return 1;
+    }
+
+    // Cast(skipCheck)
+    static int Cast(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        bool skipCheck = lua_toboolean(L, 1);
+        spell->cast(skipCheck);
+        return 0;
+    }
+
+    //IsAutoRepeat()
+    static int IsAutoRepeat(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            sEluna->PushBoolean(L, false);
+        else
+        {
+            bool repeat = spell->IsAutoRepeat();
+            sEluna->PushBoolean(L, repeat);
+        }
+        return 1;
+    }
+
+    //SetAutoRepeat(boolean)
+    static int SetAutoRepeat(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        bool repeat = luaL_checkbool(L, 1);
+        spell->SetAutoRepeat(repeat);
+        return 0;
+    }
+
+    // Cancel()
+    static int cancel(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        spell->cancel();
+        return 0;
+    }
+
+    // Finish()
+    static int Finish(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        spell->finish();
+        return 0;
+    }
+};
+#endif
\ No newline at end of file
diff --git a/src/server/LuaEngine/UnitMethods.cpp b/src/server/LuaEngine/UnitMethods.cpp
new file mode 100644
index 0000000..d58b986
--- /dev/null
+++ b/src/server/LuaEngine/UnitMethods.cpp
@@ -0,0 +1,5428 @@
+#include "LuaEngine.h"
+#include "UnitMethods.h"
+
+#define TO_PLAYER() Player* player; if (!unit || !unit->IsInWorld() || !(player = unit->ToPlayer())) { return 0; } else (void)0;
+#define TO_CREATURE() Creature* creature; if (!unit || !unit->IsInWorld() || !(creature = unit->ToCreature())) { return 0; } else (void)0;
+#define TO_UNIT() if (!unit || !unit->IsInWorld() || !unit->ToUnit()) { return 0; } else (void)0;
+
+#define TO_PLAYER_BOOL() Player* player; if (!unit || !unit->IsInWorld() || !(player = unit->ToPlayer())) { sEluna->PushBoolean(L, false); return 1; } else (void)0;
+#define TO_CREATURE_BOOL() Creature* creature; if (!unit || !unit->IsInWorld() || !(creature = unit->ToCreature())) { sEluna->PushBoolean(L, false); return 1; } else (void)0;
+#define TO_UNIT_BOOL() if (!unit || !unit->IsInWorld() || !unit->ToUnit()) { sEluna->PushBoolean(L, false); return 1; } else (void)0;
+
+
+int LuaUnit::Attack(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    Unit* who = sEluna->CHECK_UNIT(L, 1);
+    bool meleeAttack = luaL_optbool(L, 2, false);
+
+    if (!who)
+        sEluna->PushBoolean(L, false);
+    else
+        sEluna->PushBoolean(L, unit->Attack(who, meleeAttack));
+    return 1;
+}
+
+int LuaUnit::SetFlag(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint32 flag = luaL_checkunsigned(L, 2);
+
+    unit->SetFlag(index, flag);
+    return 0;
+}
+
+int LuaUnit::RemoveFlag(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint32 flag = luaL_checkunsigned(L, 2);
+
+    unit->RemoveFlag(index, flag);
+    return 0;
+}
+
+int LuaUnit::HasFlag(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint32 flag = luaL_checkunsigned(L, 2);
+
+    unit->HasFlag(index, flag);
+    return 0;
+}
+
+int LuaUnit::ClearThreatList(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    unit->getThreatManager().clearReferences();
+    return 0;
+}
+
+int LuaUnit::SetOwnerGUID(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint64 guid = sEluna->CHECK_ULONG(L, 1);
+
+    unit->SetOwnerGUID(guid);
+    return 0;
+}
+
+int LuaUnit::GetOwner(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnit(L, unit->GetOwner());
+    return 1;
+}
+
+int LuaUnit::GetOwnerGUID(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushULong(L, unit->GetOwnerGUID());
+    return 1;
+}
+
+int LuaUnit::SummonPlayer(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    Player* target = sEluna->CHECK_PLAYER(L, 1);
+    uint32 map = luaL_checkunsigned(L, 2);
+    float x = luaL_checknumber(L, 3);
+    float y = luaL_checknumber(L, 4);
+    float z = luaL_checknumber(L, 5);
+    float zoneId = luaL_checkunsigned(L, 6);
+    uint32 delay = luaL_optunsigned(L, 7, 0);
+    if (!target || !MapManager::IsValidMapCoord(map, x, y, z))
+        return 0;
+
+    target->SetSummonPoint(map, x, y, z);
+    WorldPacket data(SMSG_SUMMON_REQUEST, 8+4+4);
+    data << uint64(player->GetGUID());
+    data << uint32(zoneId);
+    data << uint32(delay ? delay*IN_MILLISECONDS : MAX_PLAYER_SUMMON_DELAY*IN_MILLISECONDS);
+    target->GetSession()->SendPacket(&data);
+    return 0;
+}
+
+int LuaUnit::Mute(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 muteseconds = luaL_checkunsigned(L, 1);
+    const char* reason = luaL_checkstring(L, 2);
+
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_MUTE_TIME);
+    int64 muteTime = time(NULL) + muteseconds;
+    player->GetSession()->m_muteTime = muteTime;
+    stmt->setInt64(0, muteTime);
+    stmt->setString(1, reason ? reason : "");
+    stmt->setString(2, "Eluna");
+    stmt->setUInt32(3, player->GetSession()->GetAccountId());
+    LoginDatabase.Execute(stmt);
+    return 0;
+}
+
+int LuaUnit::GetHeight(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float x = luaL_checknumber(L, 1);
+    float y = luaL_checknumber(L, 2);
+
+    float z = unit->GetMap()->GetHeight(unit->GetPhaseMask(), x, y, MAX_HEIGHT);
+    if (z == INVALID_HEIGHT)
+        z = unit->GetPositionZ();
+    sEluna->PushFloat(L, z);
+    return 1;
+}
+
+int LuaUnit::GetRelativePoint(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float dist = luaL_checknumber(L, 1);
+    float rad = luaL_checknumber(L, 2);
+
+    float o = Position::NormalizeOrientation(unit->GetOrientation() + rad);
+    sEluna->PushFloat(L, unit->GetPositionX()+(dist*cosf(o)));
+    sEluna->PushFloat(L, unit->GetPositionY()+(dist*sinf(o)));
+    sEluna->PushFloat(L, o);
+    return 3;
+}
+
+int LuaUnit::Mount(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 displayId = luaL_checkunsigned(L, 1);
+
+    unit->Mount(displayId);
+    return 0;
+}
+
+int LuaUnit::Dismount(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    if (unit->IsMounted())
+    {
+        unit->Dismount();
+        unit->RemoveAurasByType(SPELL_AURA_MOUNTED);
+    }
+
+    return 0;
+}
+
+int LuaUnit::IsMounted(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsMounted());
+    return 1;
+}
+
+int LuaUnit::IsWithinLoS(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    float x = luaL_checknumber(L, 1);
+    float y = luaL_checknumber(L, 2);
+    float z = luaL_checknumber(L, 3);
+
+    sEluna->PushBoolean(L, unit->IsWithinLOS(x, y, z));
+    return 1;
+}
+
+int LuaUnit::GetScale(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushFloat(L, unit->GetFloatValue(OBJECT_FIELD_SCALE_X));
+    return 1;
+}
+
+int LuaUnit::SetScale(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float size = luaL_checknumber(L, 1);
+
+    unit->SetObjectScale(size);
+    return 0;
+}
+
+int LuaUnit::IsDamageEnoughForLootingAndReward(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->IsDamageEnoughForLootingAndReward());
+    return 1;
+}
+
+int LuaUnit::IsReputationGainDisabled(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->IsReputationGainDisabled());
+    return 1;
+}
+
+int LuaUnit::SetDisableReputationGain(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    bool disable = luaL_optbool(L, 1, true);
+
+    creature->SetDisableReputationGain(disable);
+    return 0;
+}
+
+int LuaUnit::SelectVictim(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushUnit(L, creature->SelectVictim());
+    return 1;
+}
+
+int LuaUnit::GetCurrentWaypointId(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushUnsigned(L, creature->GetCurrentWaypointID());
+    return 1;
+}
+
+int LuaUnit::GetWaypointPath(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushUnsigned(L, creature->GetWaypointPath());
+    return 1;
+}
+
+int LuaUnit::GetTransportHomePosition(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    float x,y,z,o;
+    creature->GetTransportHomePosition(x,y,z,o);
+
+    sEluna->PushFloat(L, x);
+    sEluna->PushFloat(L, y);
+    sEluna->PushFloat(L, z);
+    sEluna->PushFloat(L, o);
+    return 4;
+}
+
+int LuaUnit::IsRegeneratingHealth(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->isRegeneratingHealth());
+    return 1;
+}
+
+int LuaUnit::HasInvolvedQuest(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    uint32 quest_id = luaL_checkunsigned(L, 1);
+
+    sEluna->PushBoolean(L, creature->hasInvolvedQuest(quest_id));
+    return 1;
+}
+
+int LuaUnit::SetInCombatWithZone(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    creature->SetInCombatWithZone();
+    return 0;
+}
+
+int LuaUnit::SetRespawnRadius(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    float dist = luaL_checknumber(L, 1);
+
+    creature->SetRespawnRadius(dist);
+    return 0;
+}
+
+int LuaUnit::GetRespawnRadius(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushFloat(L, creature->GetRespawnRadius());
+    return 1;
+}
+
+int LuaUnit::Respawn(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    bool force = luaL_optbool(L, 1, false);
+
+    creature->Respawn(force);
+    return 0;
+}
+
+int LuaUnit::SetRespawnDelay(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    uint32 delay = luaL_checkunsigned(L, 1);
+
+    creature->SetRespawnDelay(delay);
+    return 0;
+}
+
+int LuaUnit::GetRespawnDelay(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushUnsigned(L, creature->GetRespawnDelay());
+    return 1;
+}
+
+int LuaUnit::DespawnOrUnsummon(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    uint32 msTimeToDespawn = luaL_optunsigned(L, 1, 0);
+
+    creature->DespawnOrUnsummon(msTimeToDespawn);
+    return 0;
+}
+
+int LuaUnit::RemoveCorpse(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    bool setSpawnTime = luaL_optbool(L, 1, true);
+
+    creature->RemoveCorpse(setSpawnTime);
+    return 0;
+}
+
+int LuaUnit::SetDefaultMovementType(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    int32 type = luaL_checkinteger(L, 1);
+
+    creature->SetDefaultMovementType((MovementGeneratorType)type);
+    return 0;
+}
+
+int LuaUnit::GetDefaultMovementType(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushInteger(L, creature->GetDefaultMovementType());
+    return 1;
+}
+
+int LuaUnit::IsTargetAcceptable(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    Unit* target = sEluna->CHECK_UNIT(L, 1);
+
+    if (!target)
+        sEluna->PushBoolean(L, false);
+    else
+        sEluna->PushBoolean(L, creature->_IsTargetAcceptable(unit));
+    return 1;
+}
+
+int LuaUnit::CanAssistTo(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    Unit* u = sEluna->CHECK_UNIT(L, 1);
+    Unit* enemy = sEluna->CHECK_UNIT(L, 2);
+    bool checkfaction = luaL_optbool(L, 3, true);
+
+    if (!u)
+        sEluna->PushBoolean(L, false);
+    if (!enemy)
+        sEluna->PushBoolean(L, false);
+    else
+        sEluna->PushBoolean(L, creature->CanAssistTo(u, enemy, checkfaction));
+    return 1;
+}
+
+int LuaUnit::HasSearchedAssistance(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->HasSearchedAssistance());
+    return 1;
+}
+
+int LuaUnit::SetNoSearchAssistance(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    bool val = luaL_optbool(L, 1, true);
+
+    creature->SetNoSearchAssistance(val);
+    return 0;
+}
+
+int LuaUnit::SetNoCallAssistance(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    bool val = luaL_optbool(L, 1, true);
+
+    creature->SetNoCallAssistance(val);
+    return 0;
+}
+
+int LuaUnit::CallAssistance(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    creature->CallAssistance();
+    return 0;
+}
+
+int LuaUnit::CallForHelp(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    float radius = luaL_checknumber(L, 1);
+
+    creature->CallForHelp(radius);
+    return 0;
+}
+
+int LuaUnit::FleeToGetAssistance(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    creature->DoFleeToGetAssistance();
+    return 0;
+}
+
+int LuaUnit::GetAggroRange(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    Unit* target = sEluna->CHECK_UNIT(L, 1);
+
+    if (!target)
+        return 0;
+
+    sEluna->PushFloat(L, creature->GetAggroRange(target));
+    return 1;
+}
+
+int LuaUnit::GetAttackDistance(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    Unit* target = sEluna->CHECK_UNIT(L, 1);
+
+    if (!target)
+        return 0;
+
+    sEluna->PushFloat(L, creature->GetAttackDistance(target));
+    return 1;
+}
+
+int LuaUnit::CanStartAttack(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    Unit* target = sEluna->CHECK_UNIT(L, 1);
+    bool force = luaL_optbool(L, 2, true);
+
+    if (!target)
+        return 0;
+
+    sEluna->PushBoolean(L, creature->CanStartAttack(target, force));
+    return 1;
+}
+
+int LuaUnit::ResetLootMode(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    creature->ResetLootMode();
+    return 0;
+}
+
+int LuaUnit::RemoveLootMode(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    uint16 lootMode = luaL_checkunsigned(L, 1);
+
+    creature->RemoveLootMode(lootMode);
+    return 0;
+}
+
+int LuaUnit::AddLootMode(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    uint16 lootMode = luaL_checkunsigned(L, 1);
+
+    creature->AddLootMode(lootMode);
+    return 0;
+}
+
+int LuaUnit::SetLootMode(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    uint16 lootMode = luaL_checkunsigned(L, 1);
+
+    creature->SetLootMode(lootMode);
+    return 0;
+}
+
+int LuaUnit::HasLootMode(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    uint16 lootMode = luaL_checkunsigned(L, 1);
+
+    sEluna->PushBoolean(L, creature->HasLootMode(lootMode));
+    return 1;
+}
+
+int LuaUnit::GetLootMode(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushUnsigned(L, creature->GetLootMode());
+    return 1;
+}
+
+int LuaUnit::IsTappedBy(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    Player* player = sEluna->CHECK_PLAYER(L, 1);
+
+    if (player)
+        sEluna->PushBoolean(L, creature->isTappedBy(player));
+    else
+        sEluna->PushBoolean(L, false);
+    return 1;
+}
+
+int LuaUnit::HasLootRecipient(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->hasLootRecipient());
+    return 1;
+}
+
+int LuaUnit::GetLootRecipientGroup(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushGroup(L, creature->GetLootRecipientGroup());
+    return 1;
+}
+
+int LuaUnit::GetLootRecipient(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushUnit(L, creature->GetLootRecipient());
+    return 1;
+}
+
+int LuaUnit::SetDeathState(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    int32 state = luaL_checkinteger(L, 1);
+
+    creature->setDeathState((DeathState)state);
+    return 0;
+}
+
+int LuaUnit::SetReactState(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    int32 state = luaL_checkinteger(L, 1);
+
+    creature->SetReactState((ReactStates)state);
+    return 0;
+}
+
+int LuaUnit::GetReactState(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushInteger(L, creature->GetReactState());
+    return 1;
+}
+
+int LuaUnit::HasReactState(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    int32 state = luaL_checkinteger(L, 1);
+
+    sEluna->PushBoolean(L, creature->HasReactState((ReactStates)state));
+    return 1;
+}
+
+int LuaUnit::CanFly(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    if (Player* player = unit->ToPlayer())
+        sEluna->PushBoolean(L, player->CanFly());
+    else if (Creature* creature = unit->ToCreature())
+        sEluna->PushBoolean(L, creature->CanFly());
+    else
+        sEluna->PushBoolean(L, unit->CanFly());
+    return 1;
+}
+
+int LuaUnit::CanSwim(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->CanSwim());
+    return 1;
+}
+
+int LuaUnit::CanWalk(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->CanWalk());
+    return 1;
+}
+
+int LuaUnit::SetDisableGravity(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    bool disable = luaL_optbool(L, 1, true);
+    bool packetOnly = luaL_optbool(L, 2, false);
+
+    sEluna->PushBoolean(L, creature->SetDisableGravity(disable, packetOnly));
+    return 1;
+}
+
+int LuaUnit::SetHover(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    bool enable = luaL_optbool(L, 1, true);
+
+    sEluna->PushBoolean(L, creature->SetHover(enable));
+    return 1;
+}
+
+int LuaUnit::IsInEvadeMode(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->IsInEvadeMode());
+    return 1;
+}
+
+int LuaUnit::IsElite(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->isElite());
+    return 1;
+}
+
+int LuaUnit::IsGuard(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->IsGuard());
+    return 1;
+}
+
+int LuaUnit::IsTrigger(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->IsTrigger());
+    return 1;
+}
+
+int LuaUnit::IsCivilian(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->IsCivilian());
+    return 1;
+}
+
+int LuaUnit::IsRacialLeader(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->IsRacialLeader());
+    return 1;
+}
+
+int LuaUnit::HasCategoryCooldown(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    uint32 spell = luaL_checkunsigned(L, 1);
+
+    sEluna->PushBoolean(L, creature->HasCategoryCooldown(spell));
+    return 1;
+}
+
+int LuaUnit::GetScriptName(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushString(L, creature->GetScriptName().c_str());
+    return 1;
+}
+
+int LuaUnit::GetAIName(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushString(L, creature->GetAIName().c_str());
+    return 1;
+}
+
+int LuaUnit::GetScriptId(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushUnsigned(L, creature->GetScriptId());
+    return 1;
+}
+
+int LuaUnit::GetCreatureSpellCooldownDelay(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    uint32 spell = luaL_checkunsigned(L, 1);
+
+    sEluna->PushUnsigned(L, creature->GetCreatureSpellCooldownDelay(spell));
+    return 1;
+}
+
+int LuaUnit::GetShieldBlockValue(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    if (Player* player = unit->ToPlayer())
+        sEluna->PushUnsigned(L, player->GetShieldBlockValue());
+    if (Creature* creature = unit->ToCreature())
+        sEluna->PushUnsigned(L, creature->GetShieldBlockValue());
+    else
+        sEluna->PushUnsigned(L, unit->GetShieldBlockValue());
+    return 1;
+}
+
+int LuaUnit::GetMountId(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetMountID());
+    return 1;
+}
+
+int LuaUnit::GetCorpseDelay(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushUnsigned(L, creature->GetCorpseDelay());
+    return 1;
+}
+
+int LuaUnit::GetHomePosition(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    float x,y,z,o;
+    creature->GetHomePosition(x,y,z,o);
+
+    sEluna->PushFloat(L, x);
+    sEluna->PushFloat(L, y);
+    sEluna->PushFloat(L, z);
+    sEluna->PushFloat(L, o);
+    return 4;
+}
+
+int LuaUnit::RewardQuest(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+
+    Quest const* quest = sObjectMgr->GetQuestTemplate(entry);
+    if (quest)
+        player->RewardQuest(quest, 0, player);
+    return 0;
+}
+
+int LuaUnit::HasAura(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 spell = luaL_checkunsigned(L, 1);
+    WorldObject* caster = sEluna->CHECK_WORLDOBJECT(L, 2);
+
+    sEluna->PushBoolean(L, player->HasAura(spell, caster ? caster->GetGUID() : 0));
+    return 1;
+}
+
+int LuaUnit::IsARecruiter(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->GetSession()->IsARecruiter() || (player->GetSession()->GetRecruiterId() != 0));
+    return 1;
+}
+
+int LuaUnit::GetRecruiterId(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetSession()->GetRecruiterId());
+    return 1;
+}
+
+int LuaUnit::GetSelectedPlayer(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnit(L, player->GetSelectedPlayer());
+    return 1;
+}
+
+int LuaUnit::GetSelectedUnit(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnit(L, player->GetSelectedUnit());
+    return 1;
+}
+
+int LuaUnit::GetDistance(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    WorldObject* obj = sEluna->CHECK_WORLDOBJECT(L, 1);
+    if (obj && obj->IsInWorld())
+        sEluna->PushFloat(L, unit->GetDistance(obj));
+    else
+    {
+        float X = luaL_checknumber(L, 1);
+        float Y = luaL_checknumber(L, 2);
+        float Z = luaL_checknumber(L, 3);
+        sEluna->PushFloat(L, unit->GetDistance(X, Y, Z));
+    }
+    return 1;
+}
+
+int LuaUnit::GetLatency(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetSession()->GetLatency());
+    return 1;
+}
+
+int LuaUnit::SendAuctionMenu(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    Creature* creature = sEluna->CHECK_CREATURE(L, 1);
+    uint32 faction = luaL_checkunsigned(L, 2);
+
+    if (player->getLevel() < sWorld->getIntConfig(CONFIG_AUCTION_LEVEL_REQ))
+    {
+        player->GetSession()->SendNotification(player->GetSession()->GetTrinityString(LANG_AUCTION_REQ), sWorld->getIntConfig(CONFIG_AUCTION_LEVEL_REQ));
+        return 0;
+    }
+
+    uint64 guid = creature ? creature->GetGUID() : player->GetGUID();
+    if (!faction)
+        faction = creature ? creature->getFaction() : player->getFaction();
+
+    AuctionHouseEntry const* ahEntry = AuctionHouseMgr::GetAuctionHouseEntry(faction);
+    if (!ahEntry)
+        return 0;
+
+    WorldPacket data(MSG_AUCTION_HELLO, 12);
+    data << uint64(guid);
+    data << uint32(ahEntry->houseId);
+    data << uint8(1);
+    player->GetSession()->SendPacket(&data);
+    return 0;
+}
+
+int LuaUnit::SendMailMenu(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    GameObject* object = sEluna->CHECK_GAMEOBJECT(L, 1);
+    if (!object)
+        return 0;
+
+    WorldPacket data(SMSG_SHOW_MAILBOX, 8);
+    data << uint64(object->GetGUID());
+    player->GetSession()->HandleGetMailList(data);
+    return 0;
+}
+
+int LuaUnit::SendTaxiMenu(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    Creature* creature = sEluna->CHECK_CREATURE(L, 1);
+
+    if (creature)
+        player->GetSession()->SendTaxiMenu(creature);
+    return 0;
+}
+
+int LuaUnit::SendSpiritResurrect(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->GetSession()->SendSpiritResurrect();
+    return 0;
+}
+
+int LuaUnit::SendTabardVendorActivate(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    WorldObject* obj = sEluna->CHECK_WORLDOBJECT(L, 1);
+
+    if (obj)
+        player->GetSession()->SendTabardVendorActivate(obj->GetGUID());
+    return 0;
+}
+
+int LuaUnit::SendShowBank(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    WorldObject* obj = sEluna->CHECK_WORLDOBJECT(L, 1);
+
+    if (obj)
+        player->GetSession()->SendShowBank(obj->GetGUID());
+    return 0;
+}
+
+int LuaUnit::SendListInventory(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    WorldObject* obj = sEluna->CHECK_WORLDOBJECT(L, 1);
+
+    if (obj)
+        player->GetSession()->SendListInventory(obj->GetGUID());
+    return 0;
+}
+
+int LuaUnit::SendTrainerList(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    WorldObject* obj = sEluna->CHECK_WORLDOBJECT(L, 1);
+
+    if (obj)
+        player->GetSession()->SendTrainerList(obj->GetGUID());
+    return 0;
+}
+
+int LuaUnit::LogoutPlayer(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    bool save = luaL_optbool(L, 1, true);
+
+    player->GetSession()->LogoutPlayer(save);
+    return 0;
+}
+
+int LuaUnit::GetChampioningFaction(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetChampioningFaction());
+    return 1;
+}
+
+int LuaUnit::ResetAchievements(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->ResetAchievements();
+    return 0;
+}
+
+int LuaUnit::HasAchieved(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 achievementId = luaL_checkunsigned(L, 1);
+
+    sEluna->PushBoolean(L, player->HasAchieved(achievementId));
+    return 1;
+}
+
+int LuaUnit::GetOriginalSubGroup(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetOriginalSubGroup());
+    return 1;
+}
+
+int LuaUnit::GetOriginalGroup(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushGroup(L, player->GetOriginalGroup());
+    return 1;
+}
+
+int LuaUnit::RemoveFromBattlegroundOrBattlefieldRaid(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->RemoveFromBattlegroundOrBattlefieldRaid();
+    return 0;
+}
+
+int LuaUnit::CanUninviteFromGroup(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->CanUninviteFromGroup() == ERR_PARTY_RESULT_OK);
+    return 1;
+}
+
+int LuaUnit::GetNextRandomRaidMember(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    float radius = luaL_checknumber(L, 1);
+
+    sEluna->PushUnit(L, player->GetNextRandomRaidMember(radius));
+    return 1;
+}
+
+int LuaUnit::GetSubGroup(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetSubGroup());
+    return 1;
+}
+
+int LuaUnit::GetGroupInvite(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushGroup(L, player->GetGroupInvite());
+    return 1;
+}
+
+int LuaUnit::HasPendingBind(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->HasPendingBind());
+    return 1;
+}
+
+int LuaUnit::UnbindInstance(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 map = luaL_checkunsigned(L, 1);
+    uint32 difficulty = luaL_checkunsigned(L, 2);
+
+    if (difficulty < MAX_DIFFICULTY)
+        player->UnbindInstance(map, (Difficulty)difficulty);
+    return 0;
+}
+
+int LuaUnit::BindToInstance(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->BindToInstance();
+    return 0;
+}
+
+int LuaUnit::SetAtLoginFlag(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 flag = luaL_checkunsigned(L, 1);
+
+    player->SetAtLoginFlag((AtLoginFlags)flag);
+    return 0;
+}
+
+int LuaUnit::InRandomLfgDungeon(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->inRandomLfgDungeon());
+    return 1;
+}
+
+int LuaUnit::IsUsingLfg(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->isUsingLfg());
+    return 1;
+}
+
+int LuaUnit::HasAtLoginFlag(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 flag = luaL_checkunsigned(L, 1);
+
+    sEluna->PushBoolean(L, player->HasAtLoginFlag((AtLoginFlags)flag));
+    return 1;
+}
+
+int LuaUnit::IsVisibleForPlayer(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    Player* target = sEluna->CHECK_PLAYER(L, 1);
+
+    if (target)
+        sEluna->PushBoolean(L, player->IsVisibleGloballyFor(target));
+    else
+        sEluna->PushBoolean(L, false);
+    return 1;
+}
+
+int LuaUnit::IsNeverVisible(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->IsNeverVisible());
+    return 1;
+}
+
+int LuaUnit::CanFlyInZone(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 mapid = luaL_checkunsigned(L, 1);
+    uint32 zone = luaL_checkunsigned(L, 1);
+
+    sEluna->PushBoolean(L, player->IsKnowHowFlyIn(mapid, zone));
+    return 1;
+}
+
+int LuaUnit::SetRestTime(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 value = luaL_checkunsigned(L, 1);
+
+    player->SetRestTime(value);
+    return 0;
+}
+
+int LuaUnit::GetRestTime(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetRestTime());
+    return 1;
+}
+
+int LuaUnit::GetXPRestBonus(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 xp = luaL_checkunsigned(L, 1);
+
+    sEluna->PushUnsigned(L, player->GetXPRestBonus(xp));
+    return 1;
+}
+
+int LuaUnit::CanSpeak(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->CanSpeak());
+    return 1;
+}
+
+int LuaUnit::IsImmuneToEnvironmentalDamage(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->IsImmuneToEnvironmentalDamage());
+    return 1;
+}
+
+int LuaUnit::IsRested(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->isRested());
+    return 1;
+}
+
+int LuaUnit::LeaveBattleground(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    bool teleToEntryPoint = luaL_optbool(L, 1, true);
+
+    player->LeaveBattleground(teleToEntryPoint);
+    return 0;
+}
+
+int LuaUnit::InBattlegroundQueue(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->InBattlegroundQueue());
+    return 1;
+}
+
+int LuaUnit::GetBattlegroundTypeId(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetBattlegroundTypeId());
+    return 1;
+}
+
+int LuaUnit::GetBattlegroundId(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetBattlegroundId());
+    return 1;
+}
+
+int LuaUnit::IsOutdoorPvPActive(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->IsOutdoorPvPActive());
+    return 1;
+}
+
+int LuaUnit::InArena(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->InArena());
+    return 1;
+}
+
+int LuaUnit::InBattleground(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->InBattleground());
+    return 1;
+}
+
+int LuaUnit::CanTameExoticPets(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->CanTameExoticPets());
+    return 1;
+}
+
+int LuaUnit::CanTitanGrip(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->CanTitanGrip());
+    return 1;
+}
+
+int LuaUnit::CanBlock(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->CanBlock());
+    return 1;
+}
+
+int LuaUnit::CanParry(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->CanParry());
+    return 1;
+}
+
+int LuaUnit::GetDrunkValue(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetDrunkValue());
+    return 1;
+}
+
+int LuaUnit::SetDrunkValue(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint8 newDrunkValue = luaL_checkunsigned(L, 1);
+
+    player->SetDrunkValue(newDrunkValue);
+    return 0;
+}
+
+int LuaUnit::GetSpellCooldowns(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    lua_newtable(L);
+    int tbl = lua_gettop(L);
+    uint32 i = 0;
+
+    for (SpellCooldowns::const_iterator it = player->GetSpellCooldowns().begin(); it != player->GetSpellCooldowns().end(); ++it)
+    {
+        ++i;
+        sEluna->PushUnsigned(L, it->first);
+        sEluna->PushUnsigned(L, it->second.end);
+        lua_settable(L, tbl);
+    }
+
+    lua_settop(L, tbl);
+    return 1;
+}
+
+int LuaUnit::ModifyArenaPoints(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    int32 amount = luaL_checkunsigned(L, 1);
+
+    player->ModifyArenaPoints(amount);
+    return 0;
+}
+
+int LuaUnit::ModifyHonorPoints(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    int32 amount = luaL_checkunsigned(L, 1);
+
+    player->ModifyHonorPoints(amount);
+    return 0;
+}
+
+int LuaUnit::GetReputationRank(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 faction = luaL_checkunsigned(L, 1);
+
+    sEluna->PushInteger(L, player->GetReputationRank(faction));
+    return 1;
+}
+
+int LuaUnit::IsHonorOrXPTarget(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    Unit* victim = sEluna->CHECK_UNIT(L, 1);
+
+    if (victim)
+        sEluna->PushBoolean(L, player->isHonorOrXPTarget(victim));
+    else
+        sEluna->PushBoolean(L, false);
+    return 1;
+}
+
+int LuaUnit::SetFactionForRace(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint8 race = luaL_checkunsigned(L, 1);
+
+    player->setFactionForRace(race);
+    return 0;
+}
+
+int LuaUnit::SetSkill(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint16 id = luaL_checkunsigned(L, 1);
+    uint16 step = luaL_checkunsigned(L, 2);
+    uint16 currVal = luaL_checkunsigned(L, 3);
+    uint16 maxVal = luaL_checkunsigned(L, 4);
+
+    player->SetSkill(id, step, currVal, maxVal);
+    return 0;
+}
+
+int LuaUnit::HasSkill(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 skill = luaL_checkunsigned(L, 1);
+
+    sEluna->PushBoolean(L, player->HasSkill(skill));
+    return 1;
+}
+
+int LuaUnit::GetSkillTempBonusValue(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 skill = luaL_checkunsigned(L, 1);
+
+    sEluna->PushInteger(L, player->GetSkillTempBonusValue(skill));
+    return 1;
+}
+
+int LuaUnit::GetSkillPermBonusValue(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 skill = luaL_checkunsigned(L, 1);
+
+    sEluna->PushInteger(L, player->GetSkillPermBonusValue(skill));
+    return 1;
+}
+
+int LuaUnit::GetSkillStep(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 skill = luaL_checkunsigned(L, 1);
+
+    sEluna->PushUnsigned(L, player->GetSkillStep(skill));
+    return 1;
+}
+
+int LuaUnit::GetPureSkillValue(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 skill = luaL_checkunsigned(L, 1);
+
+    sEluna->PushUnsigned(L, player->GetPureSkillValue(skill));
+    return 1;
+}
+
+int LuaUnit::GetBaseSkillValue(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 skill = luaL_checkunsigned(L, 1);
+
+    sEluna->PushUnsigned(L, player->GetBaseSkillValue(skill));
+    return 1;
+}
+
+int LuaUnit::GetSkillValue(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 skill = luaL_checkunsigned(L, 1);
+
+    sEluna->PushUnsigned(L, player->GetSkillValue(skill));
+    return 1;
+}
+
+int LuaUnit::GetPureMaxSkillValue(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 skill = luaL_checkunsigned(L, 1);
+
+    sEluna->PushUnsigned(L, player->GetPureMaxSkillValue(skill));
+    return 1;
+}
+
+int LuaUnit::GetMaxSkillValue(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 skill = luaL_checkunsigned(L, 1);
+
+    sEluna->PushUnsigned(L, player->GetMaxSkillValue(skill));
+    return 1;
+}
+
+int LuaUnit::SetMovement(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    int32 pType = luaL_checkinteger(L, 1);
+
+    player->SetMovement((PlayerMovementType)pType);
+    return 0;
+}
+
+int LuaUnit::DurabilityRepair(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint16 position = luaL_checkunsigned(L, 1);
+    bool cost = luaL_optbool(L, 2, true);
+    float discountMod = luaL_checkinteger(L, 3);
+    bool guildBank = luaL_optbool(L, 4, false);
+
+    sEluna->PushUnsigned(L, player->DurabilityRepair(position, cost, discountMod, guildBank));
+    return 1;
+}
+
+int LuaUnit::DurabilityRepairAll(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    bool cost = luaL_optbool(L, 1, true);
+    float discountMod = luaL_checkinteger(L, 2);
+    bool guildBank = luaL_optbool(L, 3, false);
+
+    sEluna->PushUnsigned(L, player->DurabilityRepairAll(cost, discountMod, guildBank));
+    return 1;
+}
+
+int LuaUnit::DurabilityPointLossForEquipSlot(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    int32 slot = luaL_checkinteger(L, 1);
+
+    if (slot >= EQUIPMENT_SLOT_START && slot < EQUIPMENT_SLOT_END)
+        player->DurabilityPointLossForEquipSlot((EquipmentSlots)slot);
+    return 0;
+}
+
+int LuaUnit::DurabilityPointsLossAll(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    int32 points = luaL_checkinteger(L, 1);
+    bool inventory = luaL_optbool(L, 2, true);
+
+    player->DurabilityPointsLossAll(points, inventory);
+    return 0;
+}
+
+int LuaUnit::DurabilityPointsLoss(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    Item* item = sEluna->CHECK_ITEM(L, 1);
+    int32 points = luaL_checkinteger(L, 2);
+
+    if (item)
+        player->DurabilityPointsLoss(item, points);
+    return 0;
+}
+
+int LuaUnit::DurabilityLoss(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    Item* item = sEluna->CHECK_ITEM(L, 1);
+    double percent = luaL_checknumber(L, 2);
+
+    if (item)
+        player->DurabilityLoss(item, percent);
+    return 0;
+}
+
+int LuaUnit::DurabilityLossAll(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    double percent = luaL_checknumber(L, 1);
+    bool inventory = luaL_optbool(L, 2, true);
+
+    player->DurabilityLossAll(percent, inventory);
+    return 0;
+}
+
+int LuaUnit::KillPlayer(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->KillPlayer();
+    return 0;
+}
+
+int LuaUnit::GetManaBonusFromIntellect(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushFloat(L, player->GetManaBonusFromIntellect());
+    return 1;
+}
+
+int LuaUnit::GetHealthBonusFromStamina(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushFloat(L, player->GetHealthBonusFromStamina());
+    return 1;
+}
+
+int LuaUnit::GetDifficulty(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    bool isRaid = luaL_optbool(L, 1, true);
+
+    sEluna->PushUnsigned(L, player->GetDifficulty(isRaid));
+    return 1;
+}
+
+int LuaUnit::GetGuildRank(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetRank());
+    return 1;
+}
+
+int LuaUnit::SetGuildRank(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint8 rank = luaL_checkunsigned(L, 1);
+
+    if (!player->GetGuild())
+        return 0;
+
+    player->SetRank(rank);
+    return 0;
+}
+
+int LuaUnit::RemoveFromGroup(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    if (!player->GetGroup())
+        return 0;
+
+    player->RemoveFromGroup();
+    return 0;
+}
+
+int LuaUnit::IsGroupVisibleFor(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    Player* target = sEluna->CHECK_PLAYER(L, 1);
+    if (!target)
+        sEluna->PushBoolean(L, false);
+    else
+        sEluna->PushBoolean(L, player->IsGroupVisibleFor(target));
+    return 1;
+}
+
+int LuaUnit::IsInSameRaidWith(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    Player* target = sEluna->CHECK_PLAYER(L, 1);
+    if (!target)
+        sEluna->PushBoolean(L, false);
+    else
+        sEluna->PushBoolean(L, player->IsInSameRaidWith(target));
+    return 1;
+}
+
+int LuaUnit::IsInSameGroupWith(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    Player* target = sEluna->CHECK_PLAYER(L, 1);
+    if (!target)
+        sEluna->PushBoolean(L, false);
+    else
+        sEluna->PushBoolean(L, player->IsInSameGroupWith(target));
+    return 1;
+}
+
+int LuaUnit::SetPvP(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    bool apply = luaL_optbool(L, 1, true);
+
+    unit->SetPvP(apply);
+    return 0;
+}
+
+int LuaUnit::SetFFA(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    bool apply = luaL_optbool(L, 1, true);
+
+    if (apply)
+        unit->SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+    else
+        unit->RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+
+    return 0;
+}
+
+int LuaUnit::SetSanctuary(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    bool apply = luaL_optbool(L, 1, true);
+
+    if (apply)
+    {
+        unit->SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY);
+        unit->CombatStop();
+        unit->CombatStopWithPets();
+    }
+    else
+        unit->RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY);
+
+    return 0;
+}
+
+int LuaUnit::GetSpellCooldownDelay(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 spellId = luaL_checkunsigned(L, 1);
+
+    sEluna->PushUnsigned(L, player->GetSpellCooldownDelay(spellId));
+    return 1;
+}
+
+int LuaUnit::HasSpellCooldown(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    uint32 spellId = luaL_checkunsigned(L, 1);
+
+    if (Player* player = unit->ToPlayer())
+        sEluna->PushBoolean(L, player->HasSpellCooldown(spellId));
+    else if (Creature* creature = unit->ToCreature())
+        sEluna->PushBoolean(L, creature->HasSpellCooldown(spellId));
+    else
+        sEluna->PushBoolean(L, false);
+    return 1;
+}
+
+int LuaUnit::IsAuctioneer(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsAuctioner());
+    return 1;
+}
+
+int LuaUnit::HealthBelowPct(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->HealthBelowPct(luaL_checkint(L, 1)));
+    return 1;
+}
+
+int LuaUnit::HealthAbovePct(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->HealthAbovePct(luaL_checkint(L, 1)));
+    return 1;
+}
+
+int LuaUnit::GetSpecsCount(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetSpecsCount());
+    return 1;
+}
+
+int LuaUnit::GetActiveSpec(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetActiveSpec());
+    return 1;
+}
+
+int LuaUnit::HasTalent(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 spellId = luaL_checkunsigned(L, 1);
+    uint8 spec = luaL_checkunsigned(L, 2);
+    if (spec >= MAX_TALENT_SPECS)
+        sEluna->PushBoolean(L, false);
+    else
+        sEluna->PushBoolean(L, player->HasTalent(spellId, spec));
+    return 1;
+}
+
+int LuaUnit::AddTalent(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 spellId = luaL_checkunsigned(L, 1);
+    uint8 spec = luaL_checkunsigned(L, 2);
+    bool learning = luaL_optbool(L, 3, true);
+    if (spec >= MAX_TALENT_SPECS)
+        sEluna->PushBoolean(L, false);
+    else
+        sEluna->PushBoolean(L, player->AddTalent(spellId, spec, learning));
+    return 1;
+}
+
+int LuaUnit::ResetTalentsCost(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->resetTalentsCost());
+    return 1;
+}
+
+int LuaUnit::ResetTalents(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    bool no_cost = luaL_optbool(L, 1, false);
+
+    player->resetTalents(no_cost);
+    player->SendTalentsInfoData(false);
+    return 0;
+}
+
+int LuaUnit::SetFreeTalentPoints(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 points = luaL_checkunsigned(L, 1);
+
+    player->SetFreeTalentPoints(points);
+    return 0;
+}
+
+int LuaUnit::GetFreeTalentPoints(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetFreeTalentPoints());
+    return 1;
+}
+
+int LuaUnit::GetGuildName(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    if (!player->GetGuildId())
+        return 0;
+    sEluna->PushString(L, player->GetGuildName().c_str());
+    return 1;
+}
+
+int LuaUnit::GetReputation(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 faction = luaL_checkunsigned(L, 1);
+
+    sEluna->PushUnsigned(L, player->GetReputation(faction));
+    return 1;
+}
+
+int LuaUnit::SetReputation(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 faction = luaL_checkunsigned(L, 1);
+    uint32 value = luaL_checkunsigned(L, 2);
+
+    player->SetReputation(faction, value);
+    return 0;
+}
+
+int LuaUnit::RemoveSpell(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+    bool disabled = luaL_optbool(L, 2, false);
+    bool learn_low_rank = luaL_optbool(L, 3, true);
+
+    player->removeSpell(entry, disabled, learn_low_rank);
+    return 0;
+}
+
+int LuaUnit::ClearComboPoints(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->ClearComboPoints();
+    return 0;
+}
+
+int LuaUnit::GainSpellComboPoints(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    int8 count = luaL_checkinteger(L, 1);
+
+    player->GainSpellComboPoints(count);
+    return 0;
+}
+
+int LuaUnit::AddComboPoints(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    Unit* target = sEluna->CHECK_UNIT(L, 1);
+    int8 count = luaL_checkinteger(L, 2);
+    Spell* spell = sEluna->CHECK_SPELL(L, 3);
+    if (!target)
+        return 0;
+
+    player->AddComboPoints(target, count, spell);
+    return 0;
+}
+
+int LuaUnit::GetComboTarget(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnit(L, sObjectAccessor->FindUnit(player->GetComboTarget()));
+    return 1;
+}
+
+int LuaUnit::GetComboPoints(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetComboPoints());
+    return 1;
+}
+
+int LuaUnit::HasReceivedQuestReward(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+
+    sEluna->PushBoolean(L, player->IsQuestRewarded(entry));
+    return 1;
+}
+
+int LuaUnit::RegenerateHealth(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->RegenerateHealth();
+    return 0;
+}
+
+int LuaUnit::Regenerate(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 power = luaL_checkunsigned(L, 1);
+    if (power >= MAX_POWERS)
+        return 0;
+
+    player->Regenerate((Powers)power);
+    return 0;
+}
+
+int LuaUnit::RegenerateAll(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->RegenerateAll();
+    return 0;
+}
+
+int LuaUnit::ResetPetTalents(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->ResetPetTalents();
+    return 0;
+}
+
+int LuaUnit::SaveToDB(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    if (Player* player = unit->ToPlayer())
+        player->SaveToDB();
+    if (Creature* creature = unit->ToCreature())
+        creature->SaveToDB();
+    return 0;
+}
+
+int LuaUnit::Emote(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    unit->HandleEmoteCommand(luaL_checkunsigned(L, 1));
+    return 0;
+}
+
+int LuaUnit::CountPctFromCurHealth(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->CountPctFromCurHealth(luaL_checkint(L, 1)));
+    return 1;
+}
+
+int LuaUnit::CountPctFromMaxHealth(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->CountPctFromMaxHealth(luaL_checkint(L, 1)));
+    return 1;
+}
+
+int LuaUnit::GetInGameTime(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetInGameTime());
+    return 1;
+}
+
+int LuaUnit::TalkedToCreature(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+    Creature* creature = sEluna->CHECK_CREATURE(L, 2);
+    if (!creature)
+        return 0;
+
+    player->TalkedToCreature(entry, creature->GetGUID());
+    return 0;
+}
+
+int LuaUnit::CastedCreatureOrGO(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+    Unit* creaOrGo = sEluna->CHECK_UNIT(L, 2);
+    uint32 spellId = luaL_checkunsigned(L, 3);
+    if (!creaOrGo || !creaOrGo->ToGameObject() || !creaOrGo->ToCreature())
+        return 0;
+
+    player->CastedCreatureOrGO(entry, creaOrGo->GetGUID(), spellId);
+    return 0;
+}
+
+int LuaUnit::KilledPlayerCredit(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->KilledPlayerCredit();
+    return 0;
+}
+
+int LuaUnit::KilledMonsterCredit(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+
+    player->KilledMonsterCredit(entry, 0);
+    return 0;
+}
+
+int LuaUnit::GroupEventHappens(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 questId = luaL_checkunsigned(L, 1);
+    WorldObject* obj = sEluna->CHECK_WORLDOBJECT(L, 1);
+    if (!obj)
+        return 0;
+
+    player->GroupEventHappens(questId, obj);
+    return 0;
+}
+
+int LuaUnit::AreaExploredOrEventHappens(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 questId = luaL_checkunsigned(L, 1);
+
+    player->AreaExploredOrEventHappens(questId);
+    return 0;
+}
+
+int LuaUnit::CanShareQuest(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+
+    sEluna->PushBoolean(L, player->CanShareQuest(entry));
+    return 1;
+}
+
+int LuaUnit::HasQuestForGO(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    int32 entry = luaL_checkinteger(L, 1);
+
+    sEluna->PushBoolean(L, player->HasQuestForGO(entry));
+    return 1;
+}
+
+int LuaUnit::HasQuestForItem(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+
+    sEluna->PushBoolean(L, player->HasQuestForItem(entry));
+    return 1;
+}
+
+int LuaUnit::GetReqKillOrCastCurrentCount(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 questId = luaL_checkunsigned(L, 1);
+    int32 entry = luaL_checkinteger(L, 2);
+
+    sEluna->PushUnsigned(L, player->GetReqKillOrCastCurrentCount(questId, entry));
+    return 1;
+}
+
+int LuaUnit::RemoveRewardedQuest(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+
+    player->RemoveRewardedQuest(entry);
+    return 0;
+}
+
+int LuaUnit::RemoveActiveQuest(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+
+    player->RemoveActiveQuest(entry);
+    return 0;
+}
+
+int LuaUnit::SetQuestStatus(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+    uint32 status = luaL_checkunsigned(L, 2);
+    if (status >= MAX_QUEST_STATUS)
+        return 0;
+
+    player->SetQuestStatus(entry, (QuestStatus)status);
+    return 0;
+}
+
+int LuaUnit::GetQuestStatus(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+
+    sEluna->PushInteger(L, player->GetQuestStatus(entry));
+    return 1;
+}
+
+int LuaUnit::FailQuest(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+
+    player->FailQuest(entry);
+    return 0;
+}
+
+int LuaUnit::IncompleteQuest(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+
+    player->IncompleteQuest(entry);
+    return 0;
+}
+
+int LuaUnit::CompleteQuest(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+
+    player->CompleteQuest(entry);
+    return 0;
+}
+
+int LuaUnit::IsActiveQuest(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+
+    sEluna->PushBoolean(L, player->IsActiveQuest(entry));
+    return 1;
+}
+
+int LuaUnit::GetQuestLevel(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    Quest* quest = sEluna->CHECK_QUEST(L, 1);
+    if (!quest)
+        return 0;
+
+    sEluna->PushInteger(L, player->GetQuestLevel(quest));
+    return 1;
+}
+
+int LuaUnit::GetItemByEntry(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+
+    sEluna->PushItem(L, player->GetItemByEntry(entry));
+    return 1;
+}
+
+int LuaUnit::SetSheath(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 sheathed = luaL_checkunsigned(L, 1);
+    if (sheathed >= MAX_SHEATH_STATE)
+        return 0;
+
+    if (Player* player = unit->ToPlayer())
+        player->SetSheath((SheathState)sheathed);
+    else
+        unit->SetSheath((SheathState)sheathed);
+    return 0;
+}
+
+int LuaUnit::Whisper(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    std::string text = luaL_checkstring(L, 1);
+    uint32 lang = luaL_checkunsigned(L, 2);
+    uint32 guid = sEluna->CHECK_ULONG(L, 3);
+
+    player->Whisper(text, lang, guid);
+    return 0;
+}
+
+int LuaUnit::TextEmote(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    std::string text = luaL_checkstring(L, 1);
+
+    player->TextEmote(text);
+    return 0;
+}
+
+int LuaUnit::Yell(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    std::string text = luaL_checkstring(L, 1);
+    uint32 lang = luaL_checkunsigned(L, 2);
+
+    player->Yell(text, lang);
+    return 0;
+}
+
+int LuaUnit::Say(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    std::string text = luaL_checkstring(L, 1);
+    uint32 lang = luaL_checkunsigned(L, 2);
+
+    player->Say(text, lang);
+    return 0;
+}
+
+int LuaUnit::GetPhaseMaskForSpawn(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetPhaseMaskForSpawn());
+    return 1;
+}
+
+int LuaUnit::SummonPet(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+    float x = luaL_checknumber(L, 2);
+    float y = luaL_checknumber(L, 3);
+    float z = luaL_checknumber(L, 4);
+    float o = luaL_checknumber(L, 5);
+    uint32 petType = luaL_checkunsigned(L, 6);
+    uint32 despwtime = luaL_checkunsigned(L, 7);
+
+    if (petType >= MAX_PET_TYPE)
+        return 0;
+
+    player->SummonPet(entry, x, y, z, o, (PetType)petType, despwtime);
+    return 0;
+}
+
+int LuaUnit::RemovePet(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    int mode = luaL_optint(L, 1, PET_SAVE_AS_DELETED);
+    bool returnreagent = luaL_optbool(L, 1, false);
+
+    if (!player->GetPet())
+        return 0;
+
+    player->RemovePet(player->GetPet(), (PetSaveMode)mode, returnreagent);
+    return 0;
+}
+
+int LuaUnit::GetRestType(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushInteger(L, player->GetRestType());
+    return 1;
+}
+
+int LuaUnit::SetRestType(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    int type = luaL_checkinteger(L, 1);
+
+    player->SetRestType((RestType)type);
+    return 0;
+}
+
+int LuaUnit::SetRestBonus(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    float bonus = luaL_checknumber(L, 1);
+
+    player->SetRestBonus(bonus);
+    return 0;
+}
+
+int LuaUnit::GetRestBonus(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushFloat(L, player->GetRestBonus());
+    return 1;
+}
+
+int LuaUnit::GiveLevel(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint8 level = luaL_checkunsigned(L, 1);
+
+    player->GiveLevel(level);
+    return 0;
+}
+
+int LuaUnit::GiveXP(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 xp = luaL_checkunsigned(L, 1);
+    Unit* victim = sEluna->CHECK_UNIT(L, 2);
+    float group_rate = luaL_optnumber(L, 3, 1.0f);
+    bool pureXP = luaL_optbool(L, 4, true);
+    bool triggerHook = luaL_optbool(L, 5, true);
+
+    if (xp < 1)
+        return 0;
+    if (player->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_NO_XP_GAIN))
+        return 0;
+    if (victim && victim->GetTypeId() == TYPEID_UNIT && !victim->ToCreature()->hasLootRecipient())
+        return 0;
+
+    uint8 level = player->getLevel();
+
+    if (triggerHook)
+        sScriptMgr->OnGivePlayerXP(player, xp, victim);
+
+    if (!pureXP)
+    {
+        // Favored experience increase START
+        uint32 zone = player->GetZoneId();
+        float favored_exp_mult = 0;
+        if ((player->HasAura(32096) || player->HasAura(32098)) && (zone == 3483 || zone == 3562 || zone == 3836 || zone == 3713 || zone == 3714))
+            favored_exp_mult = 0.05f; // Thrallmar's Favor and Honor Hold's Favor
+        xp = uint32(xp * (1 + favored_exp_mult));
+        // Favored experience increase END
+    }
+
+    // XP to money conversion processed in Player::RewardQuest
+    if (level >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+        return 0;
+
+    uint32 bonus_xp = 0;
+    bool recruitAFriend = pureXP ? false : player->GetsRecruitAFriendBonus(true);
+    if (!pureXP)
+    {
+        // RaF does NOT stack with rested experience
+        if (recruitAFriend)
+            bonus_xp = 2 * xp; // xp + bonus_xp must add up to 3 * xp for RaF; calculation for quests done client-side
+        else
+            bonus_xp = victim ? player->GetXPRestBonus(xp) : 0; // XP resting bonus
+    }
+
+    player->SendLogXPGain(xp, victim, bonus_xp, recruitAFriend, group_rate);
+
+    uint32 curXP = player->GetUInt32Value(PLAYER_XP);
+    uint32 nextLvlXP = player->GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
+    uint32 newXP = curXP + xp + bonus_xp;
+
+    while (newXP >= nextLvlXP && level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+    {
+        newXP -= nextLvlXP;
+
+        if (level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+            player->GiveLevel(level + 1);
+
+        level = player->getLevel();
+        nextLvlXP = player->GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
+    }
+
+    player->SetUInt32Value(PLAYER_XP, newXP);
+    return 0;
+}
+
+int LuaUnit::IsGMVisible(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->isGMVisible());
+    return 1;
+}
+
+int LuaUnit::IsTaxiCheater(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->isTaxiCheater());
+    return 1;
+}
+
+int LuaUnit::IsGMChat(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->isGMChat());
+    return 1;
+}
+
+int LuaUnit::IsAcceptingWhispers(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->isAcceptWhispers());
+    return 1;
+}
+
+int LuaUnit::SetAcceptWhispers(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    bool on = luaL_optbool(L, 1, true);
+
+    player->SetAcceptWhispers(on);
+    return 0;
+}
+
+int LuaUnit::SetPvPDeath(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    bool on = luaL_optbool(L, 1, true);
+
+    player->SetPvPDeath(on);
+    return 0;
+}
+
+int LuaUnit::SetGMVisible(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    bool on = luaL_optbool(L, 1, true);
+
+    player->SetGMVisible(on);
+    return 0;
+}
+
+int LuaUnit::SetTaxiCheat(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    bool on = luaL_optbool(L, 1, true);
+
+    player->SetTaxiCheater(on);
+    return 0;
+}
+
+int LuaUnit::SetGMChat(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    bool on = luaL_optbool(L, 1, true);
+
+    player->SetGMChat(on);
+    return 0;
+}
+
+int LuaUnit::SetGameMaster(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    bool on = luaL_optbool(L, 1, true);
+
+    player->SetGameMaster(on);
+    return 0;
+}
+
+int LuaUnit::GetChatTag(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetChatTag());
+    return 1;
+}
+
+int LuaUnit::IsDND(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->isDND());
+    return 1;
+}
+
+int LuaUnit::IsAFK(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->isAFK());
+    return 1;
+}
+
+int LuaUnit::ToggleDND(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->ToggleDND();
+    return 0;
+}
+
+int LuaUnit::ToggleAFK(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->ToggleAFK();
+    return 0;
+}
+
+int LuaUnit::IsFalling(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->IsFalling());
+    return 1;
+}
+
+int LuaUnit::IsUnderWater(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsUnderWater());
+    return 1;
+}
+
+int LuaUnit::IsInWater(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    if (Player* player = unit->ToPlayer())
+        sEluna->PushBoolean(L, player->IsInWater());
+    else
+        sEluna->PushBoolean(L, unit->IsInWater());
+    return 1;
+}
+
+int LuaUnit::GetVictim(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushUnit(L, creature->SelectVictim());
+    return 1;
+}
+
+int LuaUnit::GetNearestTargetInAttackDistance(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    float dist = luaL_optnumber(L, 1, 0.0f);
+    sEluna->PushUnit(L, creature->SelectNearestTargetInAttackDistance(dist));
+    return 1;
+}
+
+int LuaUnit::GetNearestTarget(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    float dist = luaL_optnumber(L, 1, 0.0f);
+    sEluna->PushUnit(L, creature->SelectNearestTarget(dist));
+    return 1;
+}
+
+int LuaUnit::GetNearestHostileTargetInAggroRange(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    bool checkLOS = luaL_optbool(L, 1, false);
+    sEluna->PushUnit(L, creature->SelectNearestHostileUnitInAggroRange(checkLOS));
+    return 1;
+}
+
+int LuaUnit::GetNearbyTarget(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float dist = luaL_optnumber(L, 1, 5.0f);
+    Unit* exclude = sEluna->CHECK_UNIT(L, 2);
+
+    sEluna->PushUnit(L, unit->SelectNearbyTarget(exclude, dist));
+    return 1;
+}
+
+int LuaUnit::GetObjectGlobally(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 lowguid = luaL_checkunsigned(L, 1);
+    uint32 entry = luaL_checkunsigned(L, 2);
+
+    sEluna->PushGO(L, ChatHandler(player->GetSession()).GetObjectGlobalyWithGuidOrNearWithDbGuid(lowguid, entry));
+    return 1;
+}
+
+int LuaUnit::GetNearbyGameObject(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushGO(L, ChatHandler(player->GetSession()).GetNearbyGameObject());
+    return 1;
+}
+
+int LuaUnit::SendChatMessageToPlayer(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint8 type = luaL_checkunsigned(L, 1);
+    uint32 lang = luaL_checkunsigned(L, 2);
+    const char* msg = luaL_checkstring(L, 3);
+    Player* target = sEluna->CHECK_PLAYER(L, 4);
+    if (!target || type == CHAT_MSG_CHANNEL)
+        return 0;
+
+    WorldPacket* data = new WorldPacket();
+    uint32 messageLength = (uint32)strlen(msg) + 1;
+    data->Initialize(SMSG_MESSAGECHAT, 100);
+    *data << (uint8)type;
+    *data << lang;
+    *data << unit->GetGUID();
+    *data << uint32(0);
+    *data << unit->GetGUID();
+    *data << messageLength;
+    *data << msg;
+    if (unit->ToPlayer() && type != CHAT_MSG_WHISPER_INFORM && type != CHAT_MSG_DND && type != CHAT_MSG_AFK)
+        *data << uint8(unit->ToPlayer()->GetChatTag());
+    else
+        *data << uint8(0);
+    target->GetSession()->SendPacket(data);
+    return 0;
+}
+
+int LuaUnit::GetCurrentSpell(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 type = luaL_checkunsigned(L, 1);
+    if (type >= CURRENT_MAX_SPELL)
+    {
+        luaL_error(L, "Invalid spell type (%d)", type);
+        return 0;
+    }
+    sEluna->PushSpell(L, unit->GetCurrentSpell(type));
+    return 1;
+}
+
+int LuaUnit::EquipItem(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint16 dest = 0;
+    Item* item = sEluna->CHECK_ITEM(L, 1);
+    uint32 slot = luaL_checkunsigned(L, 2);
+
+    if (slot >= EQUIPMENT_SLOT_END)
+        return 0;
+
+    if (!item)
+    {
+        uint32 entry = luaL_checkunsigned(L, 1);
+        item = Item::CreateItem(entry, 1, player);
+        if (!item)
+            return 0;
+
+        InventoryResult result = player->CanEquipItem(slot, dest, item, false);
+        if (result != EQUIP_ERR_OK)
+        {
+            delete item;
+            return 0;
+        }
+        player->ItemAddedQuestCheck(entry, 1);
+        player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, entry, 1);
+    }
+    else
+    {
+        InventoryResult result = player->CanEquipItem(slot, dest, item, false);
+        if (result != EQUIP_ERR_OK)
+            return 0;
+        player->RemoveItem(item->GetBagSlot(), item->GetSlot(), true);
+    }
+
+    sEluna->PushItem(L, player->EquipItem(dest, item, true));
+    return 1;
+}
+
+int LuaUnit::CanEquipItem(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    Item* item = sEluna->CHECK_ITEM(L, 1);
+    uint32 slot = luaL_checkunsigned(L, 2);
+    if (slot >= EQUIPMENT_SLOT_END)
+    {
+        sEluna->PushBoolean(L, false);
+        return 1;
+    }
+
+    if (!item)
+    {
+        uint32 entry = luaL_checkunsigned(L, 1);
+        uint16 dest;
+        InventoryResult msg = player->CanEquipNewItem(slot, dest, entry, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+    }
+    else
+    {
+        uint16 dest;
+        InventoryResult msg = player->CanEquipItem(slot, dest, item, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            sEluna->PushBoolean(L, false);
+            return 1;
+        }
+    }
+    sEluna->PushBoolean(L, true);
+    return 1;
+}
+
+int LuaUnit::GetInventoryItem(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint8 slot = luaL_checkunsigned(L, 1);
+    if (slot >= INVENTORY_SLOT_ITEM_END)
+        return 0;
+
+    Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+    sEluna->PushItem(L, item);
+    return 1;
+}
+
+int LuaUnit::GetBagItem(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint8 bagslot = luaL_checkunsigned(L, 1);
+    uint8 slot = luaL_checkunsigned(L, 2);
+
+    if (bagslot < INVENTORY_SLOT_BAG_START && bagslot >= INVENTORY_SLOT_BAG_END)
+        return 0;
+
+    Bag* bag = player->GetBagByPos(bagslot);
+    if (!bag || slot >= bag->GetBagSize())
+        return 0;
+
+    Item* item = player->GetItemByPos(bagslot, slot);
+    sEluna->PushItem(L, item);
+    return 1;
+}
+
+int LuaUnit::SummonGameObject(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+    float x = luaL_checknumber(L, 2);
+    float y = luaL_checknumber(L, 3);
+    float z = luaL_checknumber(L, 4);
+    float o = luaL_checknumber(L, 5);
+    uint32 respawnDelay = luaL_optunsigned(L, 6, 30);
+    sEluna->PushGO(L, unit->SummonGameObject(entry, x, y, z, o, 0, 0, 0, 0, respawnDelay));
+    return 1;
+}
+
+int LuaUnit::SpawnCreature(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+    float x = luaL_checknumber(L, 2);
+    float y = luaL_checknumber(L, 3);
+    float z = luaL_checknumber(L, 4);
+    float o = luaL_checknumber(L, 5);
+    uint32 desp = luaL_optunsigned(L, 6, 0);
+    sEluna->PushUnit(L, unit->SummonCreature(entry, x, y, z, o, desp ? TEMPSUMMON_TIMED_OR_DEAD_DESPAWN : TEMPSUMMON_MANUAL_DESPAWN, desp));
+    return 1;
+}
+
+int LuaUnit::DealDamage(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    Unit* target = sEluna->CHECK_UNIT(L, 1);
+    uint32 amount = luaL_checkunsigned(L, 2);
+
+    if (!target)
+        unit->DealDamage(unit, amount);
+    else
+        unit->DealDamage(target, amount);
+    return 0;
+}
+
+int LuaUnit::Despawn(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    uint32 time = luaL_optunsigned(L, 1, 0);
+    creature->DespawnOrUnsummon(time);
+    return 0;
+}
+
+int LuaUnit::GetArenaPoints(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetArenaPoints());
+    return 1;
+}
+
+int LuaUnit::KnockbackFrom(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float x = luaL_checknumber(L, 1);
+    float y = luaL_checknumber(L, 2);
+    float speedXY = luaL_checknumber(L, 3);
+    float speedZ = luaL_checknumber(L, 4);
+    unit->KnockbackFrom(x, y, speedXY, speedZ);
+    return 0;
+}
+
+int LuaUnit::JumpTo(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    WorldObject* obj = sEluna->CHECK_WORLDOBJECT(L, 1);
+    float speedZ = luaL_checknumber(L, 2);
+    if (!obj)
+        return 0;
+
+    unit->JumpTo(obj, speedZ);
+    return 0;
+}
+
+int LuaUnit::Jump(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float speedXY = luaL_checknumber(L, 1);
+    float speedZ = luaL_checknumber(L, 2);
+    bool forward = luaL_optbool(L, 3, true);
+    unit->JumpTo(speedXY, speedZ, forward);
+    return 0;
+}
+
+int LuaUnit::JumpToCoords(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float x = luaL_checknumber(L, 1);
+    float y = luaL_checknumber(L, 2);
+    float z = luaL_checknumber(L, 3);
+    float speedXY = luaL_checknumber(L, 4);
+    float speedZ = luaL_checknumber(L, 5);
+    unit->GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
+    return 0;
+}
+
+int LuaUnit::MoveCharge(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float x = luaL_checknumber(L, 1);
+    float y = luaL_checknumber(L, 2);
+    float z = luaL_checknumber(L, 3);
+    float speed = luaL_checknumber(L, 4);
+    unit->GetMotionMaster()->MoveCharge(x, y, z, speed);
+    return 0;
+}
+
+int LuaUnit::MoveChase(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    Unit* target = sEluna->CHECK_UNIT(L, 1);
+    float dist = luaL_optnumber(L, 2, 0.0f);
+    float angle = luaL_optnumber(L, 3, 0.0f);
+    unit->GetMotionMaster()->MoveChase(target, dist, angle);
+    return 0;
+}
+
+int LuaUnit::SetStunned(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    bool apply = luaL_optbool(L, 1, true);
+    unit->SetControlled(apply, UNIT_STATE_STUNNED);
+    return 0;
+}
+
+int LuaUnit::SetRooted(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    bool apply = luaL_optbool(L, 1, true);
+    unit->SetControlled(apply, UNIT_STATE_ROOT);
+    return 0;
+}
+
+int LuaUnit::SetConfused(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    bool apply = luaL_optbool(L, 1, true);
+    unit->SetControlled(apply, UNIT_STATE_CONFUSED);
+    return 0;
+}
+
+int LuaUnit::SetFeared(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    bool apply = luaL_optbool(L, 1, true);
+    unit->SetControlled(apply, UNIT_STATE_FLEEING);
+    return 0;
+}
+
+int LuaUnit::SetGender(lua_State * L, Unit * unit)
+{
+    TO_PLAYER();
+
+    Gender gender;
+    uint32 _gender = luaL_checkint(L, 1);
+
+    switch (_gender)
+    {
+    case 0:
+        gender = GENDER_MALE;
+        break;
+    case 1:
+        gender = GENDER_FEMALE;
+        break;
+    default:
+        luaL_error(L, "Invalid gender (%d)", _gender);
+        return 0;
+    }
+
+    player->SetByteValue(UNIT_FIELD_BYTES_0, 2, gender);
+    player->SetByteValue(PLAYER_BYTES_3, 0, gender);
+    player->InitDisplayIds();
+    return 0;
+}
+
+int LuaUnit::MoveTo(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float id = luaL_checknumber(L, 1);
+    float x = luaL_checknumber(L, 2);
+    float y = luaL_checknumber(L, 3);
+    float z = luaL_checknumber(L, 4);
+    bool generatePath = luaL_optbool(L, 5, true);
+    unit->GetMotionMaster()->MovePoint(id, x, y, z, generatePath);
+    return 0;
+}
+
+int LuaUnit::MoveFollow(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    Unit* target = sEluna->CHECK_UNIT(L, 1);
+    float dist = luaL_checknumber(L, 2);
+    float angle = luaL_checknumber(L, 3);
+    unit->GetMotionMaster()->MoveFollow(target, dist, angle);
+    return 0;
+}
+
+int LuaUnit::MoveClear(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    unit->GetMotionMaster()->Clear();
+    return 0;
+}
+
+int LuaUnit::MoveRandom(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float radius = luaL_checknumber(L, 1);
+    unit->GetMotionMaster()->MoveRandom(radius);
+    return 0;
+}
+
+int LuaUnit::MoveRotate(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 time = luaL_checkunsigned(L, 1);
+    bool left = luaL_optbool(L, 2, true);
+    unit->GetMotionMaster()->MoveRotate(time, left ? ROTATE_DIRECTION_LEFT : ROTATE_DIRECTION_RIGHT);
+    return 0;
+}
+
+int LuaUnit::SetWalk(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    bool enable = luaL_optbool(L, 1, true);
+    if (Creature* creature = unit->ToCreature())
+        sEluna->PushBoolean(L, creature->SetWalk(enable));
+    else
+        sEluna->PushBoolean(L, unit->SetWalk(enable));
+    return 1;
+}
+
+int LuaUnit::SetSpeed(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 type = luaL_checkunsigned(L, 1);
+    float rate = luaL_checknumber(L, 2);
+    bool forced = luaL_optbool(L, 3, false);
+    if (type >= MAX_MOVE_TYPE)
+        luaL_error(L, "Invalid movement type (%d)", type);
+    else
+        unit->SetSpeed((UnitMoveType)type, rate, forced);
+    return 0;
+}
+
+int LuaUnit::GetHonorPoints(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetHonorPoints());
+    return 1;
+}
+
+int LuaUnit::GetSelection(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnit(L, player->GetSelectedUnit());
+    return 1;
+}
+
+int LuaUnit::GetGMRank(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushInteger(L, player->GetSession()->GetSecurity());
+    return 1;
+}
+
+int LuaUnit::GetCoinage(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetMoney());
+    return 1;
+}
+
+int LuaUnit::GetDisplayId(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetDisplayId());
+    return 1;
+}
+
+int LuaUnit::GetNativeDisplayId(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetNativeDisplayId());
+    return 1;
+}
+
+int LuaUnit::GetName(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushString(L, unit->GetName().c_str());
+    return 1;
+}
+
+int LuaUnit::GetLevel(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->getLevel());
+    return 1;
+}
+
+int LuaUnit::GetHealth(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetHealth());
+    return 1;
+}
+
+int LuaUnit::GetGuildId(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetGuildId());
+    return 1;
+}
+
+int LuaUnit::GetX(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushFloat(L, unit->GetPositionX());
+    return 1;
+}
+
+int LuaUnit::GetY(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushFloat(L, unit->GetPositionY());
+    return 1;
+}
+
+int LuaUnit::GetZ(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushFloat(L, unit->GetPositionZ());
+    return 1;
+}
+
+int LuaUnit::GetO(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushFloat(L, unit->GetOrientation());
+    return 1;
+}
+
+int LuaUnit::GetLocation(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushFloat(L, unit->GetPositionX());
+    sEluna->PushFloat(L, unit->GetPositionY());
+    sEluna->PushFloat(L, unit->GetPositionZ());
+    sEluna->PushFloat(L, unit->GetOrientation());
+    return 4;
+}
+
+int LuaUnit::GetZoneId(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetZoneId());
+    return 1;
+}
+
+int LuaUnit::GetInstanceId(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetInstanceId());
+    return 1;
+}
+
+int LuaUnit::GetPhaseMask(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetPhaseMask());
+    return 1;
+}
+
+int LuaUnit::GetAreaId(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetAreaId());
+    return 1;
+}
+
+int LuaUnit::GetTeam(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushInteger(L, player->GetTeamId());
+    return 1;
+}
+
+int LuaUnit::GetGUID(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushULong(L, unit->GetGUID());
+    return 1;
+}
+
+int LuaUnit::GetGUIDLow(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetGUIDLow());
+    return 1;
+}
+
+int LuaUnit::GetPower(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    int type = luaL_optint(L, 1, -1);
+    if (type == -1)
+    {
+
+        switch (unit->getClass())
+        {
+        case 1:
+            type = POWER_RAGE;
+            break;
+        case 4:
+            type = POWER_ENERGY;
+            break;
+        case 6:
+            type = POWER_RUNIC_POWER;
+            break;
+        case 2:
+        case 3:
+        case 5:
+        case 7:
+        case 8:
+        case 9:
+        case 11:
+            type = POWER_MANA;
+            break;
+        default:
+            type = POWER_MANA;
+        }
+    }
+    else if (type >= POWER_ALL)
+    {
+        luaL_error(L, "Invalid power type (%d)", type);
+        return 0;
+    }
+
+    sEluna->PushUnsigned(L, unit->GetPower((Powers) type));
+    return 1;
+}
+
+int LuaUnit::GetMaxPower(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    int type = luaL_optint(L, 1, -1);
+    if (type == -1)
+    {
+
+        switch (unit->getClass())
+        {
+        case 1:
+            type = POWER_RAGE;
+            break;
+        case 4:
+            type = POWER_ENERGY;
+            break;
+        case 6:
+            type = POWER_RUNIC_POWER;
+            break;
+        case 2:
+        case 3:
+        case 5:
+        case 7:
+        case 8:
+        case 9:
+        case 11:
+            type = POWER_MANA;
+            break;
+        default:
+            type = POWER_MANA;
+        }
+    }
+    else if (type < 0 || type >= POWER_ALL)
+    {
+        luaL_error(L, "Invalid index (%d)", type);
+        return 0;
+    }
+
+    sEluna->PushUnsigned(L, unit->GetMaxPower((Powers) type));
+    return 1;
+}
+
+int LuaUnit::GetPowerType(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushInteger(L, unit->getPowerType());
+    return 1;
+}
+
+int LuaUnit::GetMaxHealth(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetMaxHealth());
+    return 1;
+}
+
+int LuaUnit::GetHealthPct(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushFloat(L, unit->GetHealthPct());
+    return 1;
+}
+
+int LuaUnit::GetPowerPct(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float percent = (unit->GetPower(unit->getPowerType()) / unit->GetMaxPower(unit->getPowerType())) * 100;
+    sEluna->PushFloat(L, percent);
+    return 1;
+}
+
+int LuaUnit::GetGender(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+    sEluna->PushUnsigned(L, unit->getGender());
+    return 1;
+}
+
+int LuaUnit::GetRace(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->getRace());
+    return 1;
+}
+
+int LuaUnit::GetClass(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->getClass());
+    return 1;
+}
+
+int LuaUnit::GetCreatureType(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetCreatureType());
+    return 1;
+}
+
+int LuaUnit::GetClassAsString(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    const char* str = NULL;
+    switch (unit->getClass())
+    {
+    case 1:
+        str = "Warrior";
+        break;
+    case 2:
+        str = "Paladin";
+        break;
+    case 3:
+        str = "Hunter";
+        break;
+    case 4:
+        str = "Rogue";
+        break;
+    case 5:
+        str = "Priest";
+        break;
+    case 6:
+        str = "Death Knight";
+        break;
+    case 7:
+        str = "Shaman";
+        break;
+    case 8:
+        str = "Mage";
+        break;
+    case 9:
+        str = "Warlock";
+        break;
+    case 11:
+        str = "Druid";
+        break;
+    default:
+        str = "NULL";
+        break;
+    }
+
+    sEluna->PushString(L, str);
+    return 1;
+}
+
+int LuaUnit::GetItemCount(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    int id = luaL_checknumber(L, 1);
+    bool checkinBank = luaL_optbool(L, 2, false);
+    sEluna->PushUnsigned(L, player->GetItemCount(id, checkinBank));
+    return 1;
+}
+
+int LuaUnit::GetLifetimeKills(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 currentKills = player->GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS);
+    sEluna->PushUnsigned(L, currentKills);
+    return 1;
+}
+
+int LuaUnit::GetPlayerIP(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushString(L, player->GetSession()->GetRemoteAddress().c_str());
+    return 1;
+}
+
+int LuaUnit::GetLevelPlayedTime(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetLevelPlayedTime());
+    return 1;
+}
+
+int LuaUnit::GetTotalPlayedTime(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetTotalPlayedTime());
+    return 1;
+}
+
+int LuaUnit::GetUnitType(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    if (unit->ToPlayer())
+        sEluna->PushString(L, "Player");
+    else if (unit->ToCreature())
+        sEluna->PushString(L, "Creature");
+    else
+        sEluna->PushString(L, "Unknown");
+    return 1;
+}
+
+int LuaUnit::GetGuild(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushGuild(L, player->GetGuild());
+    return 1;
+}
+
+int LuaUnit::GetGroup(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushGroup(L, player->GetGroup());
+    return 1;
+}
+
+int LuaUnit::GetGearLevel(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushFloat(L, player->GetAverageItemLevel());
+    return 1;
+}
+
+int LuaUnit::GetEntry(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetEntry());
+    return 1;
+}
+
+int LuaUnit::GetFaction(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->getFaction());
+    return 1;
+}
+
+int LuaUnit::SetFaction(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 factionId = luaL_checkunsigned(L, 1);
+    unit->setFaction(factionId);
+    return 0;
+}
+
+int LuaUnit::SetLevel(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 newLevel = luaL_checkunsigned(L, 1);
+    unit->SetLevel(newLevel);
+    return 0;
+}
+
+int LuaUnit::SetPhaseMask(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+    uint32 phaseMask = luaL_checkunsigned(L, 1);
+    bool Update = luaL_optbool(L, 2, true);
+    unit->SetPhaseMask(phaseMask, Update);
+    return 0;
+}
+
+int LuaUnit::SetArenaPoints(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 arenaP = luaL_checkunsigned(L, 1);
+    player->SetArenaPoints(arenaP);
+    return 0;
+}
+
+int LuaUnit::SetHonorPoints(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 honorP = luaL_checkunsigned(L, 1);
+    player->SetHonorPoints(honorP);
+    return 0;
+}
+
+int LuaUnit::SetLifetimeKills(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 val = luaL_checkunsigned(L, 1);
+    player->SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, val);
+    return 0;
+}
+
+int LuaUnit::SetHealth(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 amt = luaL_checkunsigned(L, 1);
+    unit->SetHealth(amt);
+    return 0;
+}
+
+int LuaUnit::SetMaxHealth(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 amt = luaL_checkunsigned(L, 1);
+    unit->SetMaxHealth(amt);
+    return 0;
+}
+
+int LuaUnit::SetPower(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    int type = luaL_checkinteger(L, 1);
+    uint32 amt = luaL_checkunsigned(L, 2);
+
+    switch (type)
+    {
+    case POWER_MANA:
+        unit->SetPower(POWER_MANA, amt);
+        break;
+    case POWER_RAGE:
+        unit->SetPower(POWER_RAGE, amt);
+        break;
+    case POWER_ENERGY:
+        unit->SetPower(POWER_ENERGY, amt);
+        break;
+    case POWER_RUNIC_POWER:
+        unit->SetPower(POWER_RUNIC_POWER, amt);
+        break;
+    default:
+        luaL_error(L, "Invalid power type (%d)", type);
+        break;
+    }
+    return 0;
+}
+
+int LuaUnit::SetMaxPower(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    int type = luaL_checkinteger(L, 1);
+    int amt = luaL_checkunsigned(L, 2);
+
+    switch (type)
+    {
+    case POWER_MANA:
+        unit->SetMaxPower(POWER_MANA, amt);
+        break;
+    case POWER_RAGE:
+        unit->SetMaxPower(POWER_RAGE, amt);
+        break;
+    case POWER_ENERGY:
+        unit->SetMaxPower(POWER_ENERGY, amt);
+        break;
+    case POWER_RUNIC_POWER:
+        unit->SetMaxPower(POWER_RUNIC_POWER, amt);
+        break;
+    default:
+        luaL_error(L, "Invalid power type (%d)", type);
+        break;
+    }
+    return 0;
+}
+
+int LuaUnit::SetDisplayId(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 model = luaL_checkunsigned(L, 1);
+    unit->SetDisplayId(model);
+    return 0;
+}
+
+int LuaUnit::SetNativeDisplayId(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 model = luaL_checkunsigned(L, 1);
+    unit->SetNativeDisplayId(model);
+    return 0;
+}
+
+int LuaUnit::SetFacing(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float o = luaL_checknumber(L, 1);
+    unit->SetFacingTo(o);
+    return 0;
+}
+
+int LuaUnit::SetCoinage(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 amt = luaL_checkunsigned(L, 1);
+    player->SetMoney(amt);
+    return 0;
+}
+
+int LuaUnit::SetBindPoint(lua_State * L, Unit* unit)
+{
+    TO_PLAYER();
+
+    float x = luaL_checknumber(L, 1);
+    float y = luaL_checknumber(L, 2);
+    float z = luaL_checknumber(L, 3);
+    uint32 mapId = luaL_checkunsigned(L, 4);
+    uint32 areaId = luaL_checkunsigned(L, 5);
+
+    WorldLocation loc(mapId, x, y, z);
+    player->SetHomebind(loc, areaId);
+    return 0;
+}
+
+int LuaUnit::SetBindPointAtPlayerLoc(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    WorldLocation loc;
+    player->GetPosition(&loc);
+    loc.m_mapId = player->GetMapId();
+    player->SetHomebind(loc, player->GetAreaId());
+    return 0;
+}
+
+int LuaUnit::SetKnownTitle(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 id = luaL_checkunsigned(L, 1);
+    CharTitlesEntry const* t = sCharTitlesStore.LookupEntry(id);
+    if (t)
+        player->SetTitle(t, false);
+    return 0;
+}
+
+int LuaUnit::UnsetKnownTitle(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 id = luaL_checkunsigned(L, 1);
+    CharTitlesEntry const* t = sCharTitlesStore.LookupEntry(id);
+    if (t)
+        player->SetTitle(t, true);
+    return 0;
+}
+
+int LuaUnit::AdvanceSkillsToMax(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->UpdateSkillsToMaxSkillsForLevel();
+    return 0;
+}
+
+int LuaUnit::AdvanceAllSkills(lua_State* L, Unit * unit)
+{
+    TO_PLAYER();
+
+    uint32 step = luaL_checkunsigned(L, 1);
+
+    if (!step)
+        return 0;
+
+    static const uint32 skillsArray[] = { SKILL_BOWS, SKILL_CROSSBOWS, SKILL_DAGGERS, SKILL_DEFENSE, SKILL_UNARMED, SKILL_GUNS, SKILL_AXES, SKILL_MACES, SKILL_SWORDS, SKILL_POLEARMS,
+        SKILL_STAVES, SKILL_2H_AXES, SKILL_2H_MACES, SKILL_2H_SWORDS, SKILL_WANDS, SKILL_SHIELD, SKILL_FISHING, SKILL_MINING, SKILL_ENCHANTING, SKILL_BLACKSMITHING,
+        SKILL_ALCHEMY, SKILL_HERBALISM, SKILL_ENGINEERING, SKILL_JEWELCRAFTING, SKILL_LEATHERWORKING, SKILL_LOCKPICKING, SKILL_INSCRIPTION, SKILL_SKINNING, SKILL_TAILORING };
+    static const uint32 skillsSize = sizeof(skillsArray)/sizeof(*skillsArray);
+
+    for (int i = 0; i < skillsSize; ++i)
+    {
+        if (player->HasSkill(skillsArray[i]))
+            player->UpdateSkill(skillsArray[i], step);
+    }
+    return 0;
+}
+
+int LuaUnit::AdvanceSkill(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 _skillId = luaL_checkunsigned(L, 1);
+    uint32 _step = luaL_checkunsigned(L, 2);
+    if (_skillId && _step)
+    {
+        if (player->HasSkill(_skillId))
+            player->UpdateSkill(_skillId, _step);
+    }
+    return 0;
+}
+
+int LuaUnit::IsInGroup(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, (player->GetGroup() != NULL));
+    return 1;
+}
+
+int LuaUnit::IsInGuild(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, (player->GetGuildId() != 0));
+    return 1;
+}
+
+int LuaUnit::IsGM(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, player->IsGameMaster());
+    return 1;
+}
+
+int LuaUnit::IsAlive(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsAlive());
+    return 1;
+}
+
+int LuaUnit::IsDead(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->isDead());
+    return 1;
+}
+
+int LuaUnit::IsDying(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->isDying());
+    return 1;
+}
+
+int LuaUnit::IsBanker(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsBanker());
+    return 1;
+}
+
+int LuaUnit::IsBattleMaster(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsBattleMaster());
+    return 1;
+}
+
+int LuaUnit::IsCharmed(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsCharmed());
+    return 1;
+}
+
+int LuaUnit::IsArmorer(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsArmorer());
+    return 1;
+}
+
+int LuaUnit::IsAttackingPlayer(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->isAttackingPlayer());
+    return 1;
+}
+
+int LuaUnit::IsInArenaTeam(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 type = luaL_checkunsigned(L, 1);
+    if (type < MAX_ARENA_SLOT && player->GetArenaTeamId(type))
+        sEluna->PushBoolean(L, true);
+    else
+        sEluna->PushBoolean(L, false);
+    return 1;
+}
+
+int LuaUnit::IsInWorld(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsInWorld());
+    return 1;
+}
+
+int LuaUnit::IsPvPFlagged(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsPvP());
+    return 1;
+}
+
+int LuaUnit::HasQuest(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    uint32 questId = luaL_checkunsigned(L, 1);
+
+    if (Player* player = unit->ToPlayer())
+        sEluna->PushBoolean(L, player->hasQuest(questId));
+    else if (Creature* creature = unit->ToCreature())
+        sEluna->PushBoolean(L, creature->hasQuest(questId));
+    else
+        sEluna->PushBoolean(L, unit->hasQuest(questId));
+    return 1;
+}
+
+int LuaUnit::IsHorde(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, (player->GetTeam() == HORDE));
+    return 1;
+}
+
+int LuaUnit::IsAlliance(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    sEluna->PushBoolean(L, (player->GetTeam() == ALLIANCE));
+    return 1;
+}
+
+int LuaUnit::IsInCombat(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsInCombat());
+    return 1;
+}
+
+int LuaUnit::HasTitle(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 id = luaL_checkunsigned(L, 1);
+    CharTitlesEntry const* titleInfo = sCharTitlesStore.LookupEntry(id);
+    if (titleInfo)
+        sEluna->PushBoolean(L, player->HasTitle(titleInfo));
+    else
+        sEluna->PushBoolean(L, false);
+    return 1;
+}
+
+int LuaUnit::HasSpell(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    uint32 id = luaL_checkunsigned(L, 1);
+    if (Player* player = unit->ToPlayer())
+        sEluna->PushBoolean(L, player->HasSpell(id));
+    else if (Creature* creature = unit->ToCreature())
+        sEluna->PushBoolean(L, creature->HasSpell(id));
+    else
+        sEluna->PushBoolean(L, unit->HasSpell(id));
+    return 1;
+}
+
+int LuaUnit::HasItem(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 itemId = luaL_checkunsigned(L, 1);
+    uint32 count = luaL_optunsigned(L, 2, 1);
+    bool check_bank = luaL_optbool(L, 3, false);
+    sEluna->PushBoolean(L, player->HasItemCount(itemId, count, check_bank));
+    return 1;
+}
+
+int LuaUnit::Teleport(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 mapId = luaL_checkunsigned(L, 1);
+    float X = luaL_checknumber(L, 2);
+    float Y = luaL_checknumber(L, 3);
+    float Z = luaL_checknumber(L, 4);
+    float O = luaL_checknumber(L, 5);
+    if (player->IsInFlight())
+    {
+        player->GetMotionMaster()->MovementExpired();
+        player->CleanupAfterTaxiFlight();
+    }
+    sEluna->PushBoolean(L, player->TeleportTo(mapId, X, Y, Z, O));
+    return 1;
+}
+
+int LuaUnit::AddLifetimeKills(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 val = luaL_checkunsigned(L, 1);
+    uint32 currentKills = player->GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS);
+    player->SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, currentKills + val);
+    return 0;
+}
+
+int LuaUnit::AddItem(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    uint32 itemId = luaL_checkunsigned(L, 1);
+    uint32 itemCount = luaL_checkunsigned(L, 2);
+    sEluna->PushBoolean(L, player->AddItem(itemId, itemCount));
+    return 0;
+}
+
+int LuaUnit::RemoveItem(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    Item* item = sEluna->CHECK_ITEM(L, 1);
+    uint32 itemCount = luaL_checkunsigned(L, 2);
+    if (!item)
+    {
+        uint32 itemId = luaL_checkunsigned(L, 1);
+        player->DestroyItemCount(itemId, itemCount, true);
+    }
+    else
+        player->DestroyItemCount(item, itemCount, true);
+    return 0;
+}
+
+int LuaUnit::RemoveLifetimeKills(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 val = luaL_checkunsigned(L, 1);
+    uint32 currentKills = player->GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS);
+    if (val > currentKills)
+        val = currentKills;
+    player->SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, currentKills - val);
+    return 0;
+}
+
+int LuaUnit::ResetSpellCooldown(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 spellId = luaL_checkunsigned(L, 1);
+    bool update = luaL_optbool(L, 2, true);
+    player->RemoveSpellCooldown(spellId, update);
+    return 0;
+}
+
+int LuaUnit::ResetTypeCooldowns(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 category = luaL_checkunsigned(L, 1);
+    bool update = luaL_optbool(L, 2, true);
+    player->RemoveSpellCategoryCooldown(category, update);
+    return 0;
+}
+
+int LuaUnit::ResetAllCooldowns(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->RemoveAllSpellCooldown();
+    return 0;
+}
+
+int LuaUnit::SendClearCooldowns(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 spellId = luaL_checkunsigned(L, 1);
+    Unit* target = sEluna->CHECK_UNIT(L, 2);
+    if (!target)
+        return 0;
+
+    player->SendClearCooldown(spellId, target);
+    return 0;
+}
+
+int LuaUnit::SendBroadcastMessage(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    const char* message = luaL_checkstring(L, 1);
+    if (std::string(message).length() > 0)
+        ChatHandler(player->GetSession()).SendSysMessage(message);
+    return 0;
+}
+
+int LuaUnit::SendAreaTriggerMessage(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    const char* msg = luaL_checkstring(L, 1);
+    if (std::string(msg).length() > 0)
+        player->GetSession()->SendAreaTriggerMessage(msg);
+    return 0;
+}
+
+int LuaUnit::SendNotification(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    const char* msg = luaL_checkstring(L, 1);
+    if (std::string(msg).length() > 0)
+        player->GetSession()->SendNotification(msg);
+    return 0;
+}
+
+int LuaUnit::SendUnitWhisper(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    const char* msg = luaL_checkstring(L, 1);
+    Unit* receiver = sEluna->CHECK_UNIT(L, 2);
+    bool bossWhisper = luaL_optbool(L, 3, false);
+    if (receiver && std::string(msg).length() > 0)
+        unit->MonsterWhisper(msg, receiver->GetGUID(), bossWhisper);
+    return 0;
+}
+
+int LuaUnit::SendUnitEmote(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    const char* msg = luaL_checkstring(L, 1);
+    Unit* receiver = sEluna->CHECK_UNIT(L, 2);
+    bool bossEmote = luaL_optbool(L, 3, false);
+    if (std::string(msg).length() > 0)
+        unit->MonsterTextEmote(msg, receiver ? receiver->GetGUID() : 0, bossEmote);
+    return 0;
+}
+
+int LuaUnit::SendUnitSay(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    const char* msg = luaL_checkstring(L, 1);
+    uint32 language = luaL_checknumber(L, 2);
+    if (std::string(msg).length() > 0)
+        unit->MonsterSay(msg, language, unit->GetGUID());
+    return 0;
+}
+
+int LuaUnit::SendUnitYell(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    const char* msg = luaL_checkstring(L, 1);
+    uint32 language = luaL_checknumber(L, 2);
+    if (std::string(msg).length() > 0)
+        unit->MonsterYell(msg, language, unit->GetGUID());
+    return 0;
+}
+
+int LuaUnit::SendPacketToPlayer(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    WorldPacket* data = sEluna->CHECK_PACKET(L, 1);
+    if (data)
+        player->GetSession()->SendPacket(data);
+    return 0;
+}
+
+int LuaUnit::SendPacket(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    WorldPacket* data = sEluna->CHECK_PACKET(L, 1);
+    if (data)
+        player->SendMessageToSet(data, false);
+    return 0;
+}
+
+int LuaUnit::SendPacketToGroup(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    WorldPacket* data = sEluna->CHECK_PACKET(L, 1);
+    bool ignorePlayersInBg = luaL_optbool(L, 2, false);
+    if (data && player->GetGroup())
+        player->GetGroup()->BroadcastPacket(data, ignorePlayersInBg, -1, player->GetGUID());
+    return 0;
+}
+
+int LuaUnit::SendPacketToGuild(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    WorldPacket* data = sEluna->CHECK_PACKET(L, 1);
+    if (data && player->GetGuild())
+        player->GetGuild()->BroadcastPacket(data);
+    return 0;
+}
+
+int LuaUnit::SendPacketToRankedInGuild(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    WorldPacket* data = sEluna->CHECK_PACKET(L, 1);
+    uint8 ranked = luaL_checkunsigned(L, 2);
+    if (data && player->GetGuild())
+        player->GetGuild()->BroadcastPacketToRank(data, ranked);
+    return 0;
+}
+
+int LuaUnit::SendVendorWindow(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    Unit* sendTo = sEluna->CHECK_UNIT(L, 1);
+    if (!sendTo)
+        return 0;
+    player->GetSession()->SendListInventory(sendTo->GetGUID());
+    return 0;
+}
+
+int LuaUnit::KickPlayer(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->GetSession()->KickPlayer();
+    return 0;
+}
+
+int LuaUnit::ModifyMoney(lua_State* L, Unit* unit)
+{
+    TO_PLAYER_BOOL();
+
+    int32 amt = luaL_checkinteger(L, 1);
+    bool sendError = luaL_optbool(L, 2, true);
+    sEluna->PushBoolean(L, player->ModifyMoney(amt, sendError));
+    return 1;
+}
+
+int LuaUnit::LearnSpell(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 id = luaL_checkunsigned(L, 1);
+    player->learnSpell(id, false);
+    return 0;
+}
+
+int LuaUnit::DeMorph(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    unit->DeMorph();
+    return 0;
+}
+
+int LuaUnit::ResurrectPlayer(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    float percent = luaL_optnumber(L, 1, 100.0f);
+    bool sickness = luaL_optbool(L, 2, false);
+    player->ResurrectPlayer(percent, sickness);
+    player->SpawnCorpseBones();
+    return 0;
+}
+
+int LuaUnit::CastSpell(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    Object* obj = sEluna->CHECK_OBJECT(L, 1);
+    if (!obj)
+        return 0;
+    uint32 spell = luaL_checkunsigned(L, 2);
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell);
+    if (!spellInfo)
+        return 0;
+    bool triggered = luaL_optbool(L, 3, true);
+
+    SpellCastTargets targets;
+    if (Unit* unitTarget = obj->ToUnit())
+        targets.SetUnitTarget(unitTarget);
+    else if (GameObject* goTarget = obj->ToGameObject())
+        targets.SetGOTarget(goTarget);
+    else if (obj->GetTypeId() == TYPEID_ITEM)
+    {
+        if (Item* itemTarget = reinterpret_cast<Item*>(obj))
+            targets.SetItemTarget(itemTarget);
+    }
+    else
+        return 0;
+
+    unit->CastSpell(targets, spellInfo, NULL, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
+    return 0;
+}
+
+int LuaUnit::CastSpellAoF(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float _x = luaL_checknumber(L, 1);
+    float _y = luaL_checknumber(L, 2);
+    float _z = luaL_checknumber(L, 3);
+    uint32 spell = luaL_checkunsigned(L, 4);
+    bool triggered = luaL_optbool(L, 5, true);
+    unit->CastSpell(_x, _y, _z, spell, triggered);
+    return 0;
+}
+
+int LuaUnit::GetAccountId(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    sEluna->PushUnsigned(L, player->GetSession()->GetAccountId());
+    return 1;
+}
+
+int LuaUnit::GetAccountName(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    std::string accName;
+    if (sAccountMgr->GetName(player->GetSession()->GetAccountId(), accName))
+        sEluna->PushString(L, accName.c_str());
+    else
+        return 0;
+    return 1;
+}
+
+int LuaUnit::GetAITarget(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    SelectAggroTarget targetType = (SelectAggroTarget)luaL_checkunsigned(L, 1);
+    bool playerOnly = luaL_optbool(L, 2, false);
+    uint32 position = luaL_optunsigned(L, 3, 0);
+    float dist = luaL_optnumber(L, 4, 0.0f);
+    int32 aura = luaL_optint(L, 5, 0);
+
+    ;
+    ThreatContainer::StorageType const& threatlist = creature->getThreatManager().getThreatList();
+    if (position >= threatlist.size())
+    {
+        sEluna->PushUnit(L, NULL);
+        return 1;
+    }
+
+    std::list<Unit*> targetList;
+    for (ThreatContainer::StorageType::const_iterator itr = threatlist.begin(); itr != threatlist.end(); ++itr)
+    {
+        Unit* target = (*itr)->getTarget();
+        if (!target)
+            continue;
+        if (playerOnly && !target->ToPlayer())
+            continue;
+        if (aura > 0 && !target->HasAura(aura))
+            continue;
+        else if (aura < 0 && target->HasAura(-aura))
+            continue;
+        if (dist > 0.0f && !creature->IsWithinDist(target, dist))
+            continue;
+        targetList.push_back(target);
+    }
+
+    if (position >= targetList.size())
+    {
+        sEluna->PushUnit(L, NULL);
+        return 1;
+    }
+
+    if (targetType == SELECT_TARGET_NEAREST || targetType == SELECT_TARGET_FARTHEST)
+        targetList.sort(Trinity::ObjectDistanceOrderPred(creature));
+
+    switch (targetType)
+    {
+    case SELECT_TARGET_NEAREST:
+    case SELECT_TARGET_TOPAGGRO:
+        {
+            std::list<Unit*>::const_iterator itr = targetList.begin();
+            std::advance(itr, position);
+            sEluna->PushUnit(L, *itr);
+            return 1;
+        }
+    case SELECT_TARGET_FARTHEST:
+    case SELECT_TARGET_BOTTOMAGGRO:
+        {
+            std::list<Unit*>::reverse_iterator ritr = targetList.rbegin();
+            std::advance(ritr, position);
+            sEluna->PushUnit(L, *ritr);
+            return 1;
+        }
+    case SELECT_TARGET_RANDOM:
+        {
+            std::list<Unit*>::const_iterator itr = targetList.begin();
+            std::advance(itr, urand(position, targetList.size() - 1));
+            sEluna->PushUnit(L, *itr);
+            return 1;
+        }
+    default:
+        break;
+    }
+
+    sEluna->PushUnit(L, NULL);
+    return 1;
+}
+
+int LuaUnit::GetAITargets(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    lua_newtable(L);
+    int tbl = lua_gettop(L);
+    uint32 i = 0;
+
+    ThreatContainer::StorageType const &threatList = creature->getThreatManager().getThreatList();
+    ThreatContainer::StorageType::const_iterator itr;
+    for (itr = threatList.begin(); itr != threatList.end(); ++itr)
+    {
+        Unit* target = (*itr)->getTarget();
+        if (!target)
+            continue;
+        ++i;
+        sEluna->PushUnsigned(L, i);
+        sEluna->PushUnit(L, target);
+        lua_settable(L, tbl);
+    }
+
+    lua_settop(L, tbl);
+    return 1;
+}
+
+int LuaUnit::GetAITargetsCount(lua_State* L, Unit* unit)
+{
+    TO_CREATURE();
+
+    sEluna->PushUnsigned(L, creature->getThreatManager().getThreatList().size());
+    return 1;
+}
+
+int LuaUnit::IsDungeonBoss(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->IsDungeonBoss());
+    return 1;
+}
+
+int LuaUnit::IsWorldBoss(lua_State* L, Unit* unit)
+{
+    TO_CREATURE_BOOL();
+
+    sEluna->PushBoolean(L, creature->isWorldBoss());
+    return 1;
+}
+
+int LuaUnit::GetAura(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 spellID = luaL_checkunsigned(L, 1);
+    sEluna->PushAura(L, unit->GetAura(spellID));
+    return 1;
+}
+
+int LuaUnit::GetMapId(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetMapId());
+    return 1;
+}
+
+int LuaUnit::GetCombatTime(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    sEluna->PushUnsigned(L, unit->GetCombatTimer());
+    return 1;
+}
+
+int LuaUnit::ClearInCombat(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    unit->ClearInCombat();
+    return 0;
+}
+
+int LuaUnit::StopSpellCast(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 spellId = luaL_optunsigned(L, 1, 0);
+    unit->CastStop(spellId);
+    return 0;
+}
+
+int LuaUnit::InterruptSpell(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    int spellType = luaL_checkint(L, 1);
+    bool delayed = luaL_optbool(L, 2, true);
+    bool instant = luaL_optbool(L, 3, true);
+    switch (spellType)
+    {
+    case 0:
+        spellType = CURRENT_MELEE_SPELL;
+        break;
+    case 1:
+        spellType = CURRENT_GENERIC_SPELL;
+        break;
+    case 2:
+        spellType = CURRENT_CHANNELED_SPELL;
+        break;
+    case 3:
+        spellType = CURRENT_AUTOREPEAT_SPELL;
+        break;
+    }
+    unit->InterruptSpell((CurrentSpellTypes)spellType, delayed, instant);
+    return 0;
+}
+
+int LuaUnit::AddAura(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 spellId = luaL_checkunsigned(L, 1);
+    Unit* target = sEluna->CHECK_UNIT(L, 2);
+    if (!target)
+        return 0;
+    unit->AddAura(spellId, target);
+    return 0;
+}
+
+int LuaUnit::RemoveAura(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 spellId = luaL_checkunsigned(L, 1);
+    uint64 casterGUID = sEluna->CHECK_ULONG(L, 2);
+    unit->RemoveAurasDueToSpell(spellId, casterGUID);
+    return 0;
+}
+
+int LuaUnit::RemoveAllAuras(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    unit->RemoveAllAuras();
+    return 0;
+}
+
+int LuaUnit::GossipMenuAddItem(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 _icon = luaL_checkunsigned(L, 1);
+    const char* msg = luaL_checkstring(L, 2);
+    uint32 _sender = luaL_checkunsigned(L, 3);
+    uint32 _intid = luaL_checkunsigned(L, 4);
+    bool _code = luaL_optbool(L, 5, false);
+    const char* _promptMsg = luaL_optstring(L, 6, "");
+    uint32 _money = luaL_optunsigned(L, 7, 0);
+    player->ADD_GOSSIP_ITEM_EXTENDED(_icon, msg, _sender, _intid, _promptMsg, _money, _code);
+    return 0;
+}
+
+int LuaUnit::GossipComplete(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->CLOSE_GOSSIP_MENU();
+    return 0;
+}
+
+int LuaUnit::GossipSendMenu(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 _npcText = luaL_checkunsigned(L, 1);
+    WorldObject* sender = sEluna->CHECK_WORLDOBJECT(L, 2);
+    if (sender)
+    {
+        if (sender->ToPlayer())
+        {
+            uint32 menu_id = luaL_checkunsigned(L, 3);
+            player->PlayerTalkClass->GetGossipMenu().SetMenuId(menu_id);
+        }
+        player->SEND_GOSSIP_MENU(_npcText, sender->GetGUID());
+    }
+    return 0;
+}
+
+int LuaUnit::GossipClearMenu(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    player->PlayerTalkClass->ClearMenus();
+    return 0;
+}
+
+int LuaUnit::PlaySoundToPlayer(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 soundId = luaL_checkunsigned(L, 1);
+    SoundEntriesEntry const* soundEntry = sSoundEntriesStore.LookupEntry(soundId);
+    if (!soundEntry)
+        return 0;
+
+    player->PlayDirectSound(soundId, player);
+    return 0;
+}
+
+int LuaUnit::PlayDirectSound(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 soundId = luaL_checkunsigned(L, 1);
+    Player* player = sEluna->CHECK_PLAYER(L, 2);
+    if (!sSoundEntriesStore.LookupEntry(soundId))
+        return 0;
+
+    if (player)
+        unit->PlayDirectSound(soundId, player);
+    else
+        unit->PlayDirectSound(soundId);
+    return 0;
+}
+
+int LuaUnit::PlayDistanceSound(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 soundId = luaL_checkunsigned(L, 1);
+    Player* player = sEluna->CHECK_PLAYER(L, 2);
+    if (!sSoundEntriesStore.LookupEntry(soundId))
+        return 0;
+
+    if (player)
+        unit->PlayDistanceSound(soundId, player);
+    else
+        unit->PlayDistanceSound(soundId);
+    return 0;
+}
+
+int LuaUnit::Kill(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    Unit* target = sEluna->CHECK_UNIT(L, 1);
+    bool durLoss = luaL_optbool(L, 2, true);
+    unit->Kill((target ? target : unit), durLoss);
+    return 0;
+}
+
+int LuaUnit::RegisterEvent(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    luaL_checktype(L, 1, LUA_TFUNCTION);
+    uint32 delay = luaL_checkunsigned(L, 2);
+    uint32 repeats = luaL_checkunsigned(L, 3);
+
+    lua_settop(L, 1);
+    int functionRef = lua_ref(L, true);
+    unit->m_Events.AddEvent(new Eluna::LuaEventData(functionRef, delay, repeats, unit), unit->m_Events.CalculateTime(delay));
+    sEluna->PushInteger(L, functionRef);
+    return 1;
+}
+
+int LuaUnit::RemoveEventById(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    int eventID = luaL_checkinteger(L, 1);
+    Eluna::LuaEventData::Remove(unit->GetGUID(), eventID);
+    return 0;
+}
+
+int LuaUnit::RemoveEvents(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    Eluna::LuaEventData::RemoveAll(unit);
+    return 0;
+}
+
+int LuaUnit::GetInt32Value(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    sEluna->PushInteger(L, unit->GetInt32Value(index));
+    return 1;
+}
+
+int LuaUnit::GetUInt32Value(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    sEluna->PushUnsigned(L, unit->GetUInt32Value(index));
+    return 1;
+}
+
+int LuaUnit::GetFloatValue(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    sEluna->PushFloat(L, unit->GetFloatValue(index));
+    return 1;
+}
+
+int LuaUnit::GetByteValue(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint8 offset = luaL_checkunsigned(L, 2);
+    sEluna->PushUnsigned(L, unit->GetByteValue(index, offset));
+    return 1;
+}
+
+int LuaUnit::GetUInt16Value(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint8 offset = luaL_checkunsigned(L, 2);
+    sEluna->PushUnsigned(L, unit->GetUInt16Value(index, offset));
+    return 1;
+}
+
+int LuaUnit::SetInt32Value(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    int32 value = luaL_checkinteger(L, 2);
+    unit->SetInt32Value(index, value);
+    return 0;
+}
+
+int LuaUnit::SetUInt32Value(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint32 value = luaL_checkunsigned(L, 2);
+    unit->SetUInt32Value(index, value);
+    return 0;
+}
+
+int LuaUnit::UpdateUInt32Value(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint32 value = luaL_checkunsigned(L, 2);
+    unit->UpdateUInt32Value(index, value);
+    return 0;
+}
+
+int LuaUnit::SetFloatValue(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    float value = luaL_checknumber(L, 2);
+
+    unit->SetFloatValue(index, value);
+    return 0;
+}
+
+int LuaUnit::SetByteValue(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint8 offset = luaL_checkunsigned(L, 2);
+    uint8 value = luaL_checkunsigned(L, 3);
+    unit->SetByteValue(index, offset, value);
+    return 0;
+}
+
+int LuaUnit::SetUInt16Value(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint8 offset = luaL_checkunsigned(L, 2);
+    uint16 value = luaL_checkunsigned(L, 3);
+    unit->SetUInt16Value(index, offset, value);
+    return 0;
+}
+
+int LuaUnit::SetInt16Value(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint16 index = luaL_checkunsigned(L, 1);
+    uint8 offset = luaL_checkunsigned(L, 2);
+    int16 value = luaL_checkinteger(L, 3);
+    unit->SetInt16Value(index, offset, value);
+    return 0;
+}
+
+/* Vehicle */
+
+int LuaUnit::IsOnVehicle(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    if (unit->GetVehicle() || (unit->ToPlayer() && unit->IsVehicle()))
+        sEluna->PushBoolean(L, true);
+    else
+        sEluna->PushBoolean(L, false);
+    return 1;
+}
+
+int LuaUnit::DismissVehicle(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    if (Creature* vehicle = unit->GetVehicleCreatureBase())
+        vehicle->DespawnOrUnsummon();
+    return 0;
+}
+
+int LuaUnit::AddVehiclePassenger(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    Unit* passenger = sEluna->CHECK_UNIT(L, 1);
+    int8 seatId = luaL_checkunsigned(L, 2);
+    Vehicle* _vehicle = unit->GetVehicle();
+    if (!_vehicle)
+        return 0;
+
+    _vehicle->AddPassenger(passenger, seatId);
+    return 0;
+}
+
+/* Not coded in core
+int LuaUnit::EjectPassenger(lua_State* L, Unit* unit)
+{
+TO_UNIT();
+
+Unit* passenger = sEluna->CHECK_UNIT(L, 1);
+Vehicle* _vehicle = unit->GetVehicle();
+if (!_vehicle)
+return 0;
+
+_vehicle->EjectPassenger(passenger, unit);
+return 0;
+}
+*/
+
+int LuaUnit::RemovePassenger(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    Unit* passenger = sEluna->CHECK_UNIT(L, 1);
+    Vehicle* _vehicle = unit->GetVehicle();
+    if (!_vehicle)
+        return 0;
+
+    _vehicle->RemovePassenger(passenger);
+    return 0;
+}
+
+int LuaUnit::RemoveAllPassengers(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    Unit* _unit = unit->GetVehicleBase();
+    if (!_unit)
+        return 0;
+
+    _unit->GetVehicle()->RemoveAllPassengers();
+    return 0;
+}
+
+int LuaUnit::GetPassenger(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    int8 seatId = luaL_checkunsigned(L, 1);
+    Unit* _unit = unit->GetVehicleBase();
+    if (!_unit)
+        return 0;
+
+    sEluna->PushUnit(L, _unit->GetVehicle()->GetPassenger(seatId));
+    return 1;
+}
+
+int LuaUnit::GetNextEmptySeat(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    int8 seatId = luaL_checkunsigned(L, 1);
+    Unit* _unit = unit->GetVehicleBase();
+    if (!_unit)
+        return 0;
+
+    return 0;
+}
+
+int LuaUnit::GetAvailableSeats(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    Unit* _unit = unit->GetVehicleBase();
+    if (!_unit)
+        return 0;
+
+    sEluna->PushUnsigned(L, _unit->GetVehicle()->GetAvailableSeatCount());
+    return 1;
+}
+
+int LuaUnit::GetVehicleBase(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    Unit* _unit = unit->GetVehicleBase();
+    if (_unit)
+        sEluna->PushUnit(L, _unit);
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+int LuaUnit::HasEmptySeat(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    int8 seatId = luaL_checkunsigned(L, 1);
+    Unit* _unit = unit->GetVehicleBase();
+    if (!_unit)
+        return 0;
+
+    sEluna->PushBoolean(L, _unit->GetVehicle()->HasEmptySeat(seatId));
+    return 1;
+}
+
+int LuaUnit::StartTaxi(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 pathId = luaL_checkunsigned(L, 1);
+
+    LuaTaxiMgr::StartTaxi(player, pathId);
+    return 0;
+}
+
+int LuaUnit::SetPlayerLock(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    bool apply = luaL_optbool(L, 1, true);
+
+    if (apply)
+    {
+        player->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED | UNIT_FLAG_SILENCED);
+        player->SetClientControl(player, 0);
+    }
+    else
+    {
+        player->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED | UNIT_FLAG_SILENCED);
+        player->SetClientControl(player, 1);
+    }
+    return 0;
+}
+
+int LuaUnit::GetNearestPlayer(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    float distance = luaL_optnumber(L, 1, SIZE_OF_GRIDS);
+
+    Player* target = NULL;
+    Eluna::NearestTypeWithEntryInRangeCheck checker(unit, distance, TYPEID_PLAYER);
+    Trinity::PlayerLastSearcher<Eluna::NearestTypeWithEntryInRangeCheck> searcher(unit, target, checker);
+    unit->VisitNearbyWorldObject(distance, searcher);
+
+    sEluna->PushUnit(L, target);
+    return 1;
+}
+
+int LuaUnit::GetNearestGameObject(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 entry = luaL_optunsigned(L, 1, 0);
+    float range = luaL_optnumber(L, 2, SIZE_OF_GRIDS);
+
+    GameObject* target = NULL;
+    Eluna::NearestTypeWithEntryInRangeCheck checker(unit, range, TYPEID_GAMEOBJECT, entry);
+    Trinity::GameObjectLastSearcher<Eluna::NearestTypeWithEntryInRangeCheck> searcher(unit, target, checker);
+    unit->VisitNearbyGridObject(range, searcher);
+
+    sEluna->PushGO(L, target);
+    return 1;
+}
+
+int LuaUnit::GetNearestCreature(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 entry = luaL_optunsigned(L, 1, 0);
+    float range = luaL_optnumber(L, 2, SIZE_OF_GRIDS);
+
+    Creature* target = NULL;
+    Eluna::NearestTypeWithEntryInRangeCheck checker(unit, range, TYPEID_UNIT, entry);
+    Trinity::CreatureLastSearcher<Eluna::NearestTypeWithEntryInRangeCheck> searcher(unit, target, checker);
+    unit->VisitNearbyGridObject(range, searcher);
+
+    sEluna->PushUnit(L, target);
+    return 1;
+}
+
+int LuaUnit::GetFriendlyUnitsInRange(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+    float range = luaL_optnumber(L, 1, SIZE_OF_GRIDS);
+
+    UnitList list;
+    Trinity::AnyFriendlyUnitInObjectRangeCheck checker(unit, unit, range);
+    Trinity::UnitListSearcher<Trinity::AnyFriendlyUnitInObjectRangeCheck> searcher(unit, list, checker);
+    unit->VisitNearbyObject(range, searcher);
+    Trinity::ObjectGUIDCheck guidCheck(unit->GetGUID());
+    list.remove_if (guidCheck);
+
+    lua_newtable(L);
+    int tbl = lua_gettop(L);
+    uint32 i = 0;
+
+    for (UnitList::const_iterator it = list.begin(); it != list.end(); ++it)
+    {
+        sEluna->PushUnsigned(L, ++i);
+        sEluna->PushUnit(L, *it);
+        lua_settable(L, tbl);
+    }
+
+    lua_settop(L, tbl);
+    return 1;
+}
+
+int LuaUnit::GetUnfriendlyUnitsInRange(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+    float range = luaL_optnumber(L, 1, SIZE_OF_GRIDS);
+
+    UnitList list;
+    Trinity::AnyUnfriendlyUnitInObjectRangeCheck checker(unit, unit, range);
+    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(unit, list, checker);
+    unit->VisitNearbyObject(range, searcher);
+    Trinity::ObjectGUIDCheck guidCheck(unit->GetGUID());
+    list.remove_if (guidCheck);
+
+    lua_newtable(L);
+    int tbl = lua_gettop(L);
+    uint32 i = 0;
+
+    for (UnitList::const_iterator it = list.begin(); it != list.end(); ++it)
+    {
+        sEluna->PushUnsigned(L, ++i);
+        sEluna->PushUnit(L, *it);
+        lua_settable(L, tbl);
+    }
+
+    lua_settop(L, tbl);
+    return 1;
+}
+
+int LuaUnit::GossipSendPOI(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    float x = luaL_checknumber(L, 1);
+    float y = luaL_checknumber(L, 2);
+    uint32 icon = luaL_checkunsigned(L, 3);
+    uint32 flags = luaL_checkunsigned(L, 4);
+    uint32 data = luaL_checkunsigned(L, 5);
+    std::string iconText = luaL_checkstring(L, 6);
+
+    WorldPacket packet(SMSG_GOSSIP_POI, 4 + 4 + 4 + 4 + 4 + 10);
+    packet << flags;
+    packet << x;
+    packet << y;
+    packet << icon;
+    packet << data;
+    packet << iconText;
+    player->GetSession()->SendPacket(&packet);
+    return 0;
+}
+
+int LuaUnit::GossipAddQuests(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    WorldObject* source = sEluna->CHECK_WORLDOBJECT(L, 1);
+    if (!source)
+        return 0;
+
+    if (source->GetTypeId() == TYPEID_UNIT)
+    {
+        if (source->GetUInt32Value(UNIT_NPC_FLAGS) & UNIT_NPC_FLAG_QUESTGIVER)
+            player->PrepareQuestMenu(source->GetGUID());
+    }
+    else if (source->GetTypeId() == TYPEID_GAMEOBJECT)
+    {
+        if (source->ToGameObject()->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+            player->PrepareQuestMenu(source->GetGUID());
+    }
+    return 0;
+}
+
+int LuaUnit::AttackStop(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->AttackStop());
+    return 1;
+}
+
+int LuaUnit::SetCanFly(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    bool apply = luaL_optbool(L, 1, true);
+    unit->SetCanFly(apply);
+    return 0;
+}
+
+int LuaUnit::SetVisible(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    bool x = luaL_optbool(L, 1, true);
+    unit->SetVisible(x);
+    return 0;
+}
+
+int LuaUnit::IsVisible(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsVisible());
+    return 1;
+}
+
+int LuaUnit::IsMoving(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->isMoving());
+    return 1;
+}
+
+int LuaUnit::IsFlying(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsFlying());
+    return 1;
+}
+
+int LuaUnit::IsStopped(lua_State* L, Unit* unit)
+{
+    TO_UNIT_BOOL();
+
+    sEluna->PushBoolean(L, unit->IsStopped());
+    return 1;
+}
+
+int LuaUnit::RestoreDisplayId(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    unit->RestoreDisplayId();
+    return 0;
+}
+
+int LuaUnit::RestoreFaction(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    unit->RestoreFaction();
+    return 0;
+}
+
+int LuaUnit::RemoveBindSightAuras(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    unit->RemoveBindSightAuras();
+    return 0;
+}
+
+int LuaUnit::RemoveCharmAuras(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    unit->RemoveCharmAuras();
+    return 0;
+}
+
+int LuaUnit::StopMoving(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    unit->StopMoving();
+    return 0;
+}
+
+int LuaUnit::AddUnitState(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 state = luaL_checkunsigned(L, 1);
+
+    unit->AddUnitState(state);
+    return 0;
+}
+
+int LuaUnit::ClearUnitState(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 state = luaL_checkunsigned(L, 1);
+
+    unit->ClearUnitState(state);
+    return 0;
+}
+
+int LuaUnit::HasUnitState(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 state = luaL_checkunsigned(L, 1);
+
+    sEluna->PushBoolean(L, unit->HasUnitState(state));
+    return 1;
+}
+
+int LuaUnit::DisableMelee(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    bool apply = luaL_optbool(L, 1, true);
+
+    if (apply)
+        unit->AddUnitState(UNIT_STATE_CANNOT_AUTOATTACK);
+    else
+        unit->ClearUnitState(UNIT_STATE_CANNOT_AUTOATTACK);
+    return 0;
+}
+
+int LuaUnit::SummonGuardian(lua_State* L, Unit* unit)
+{
+    TO_UNIT();
+
+    uint32 entry = luaL_checkunsigned(L, 1);
+    float x = luaL_checknumber(L, 2);
+    float y = luaL_checknumber(L, 3);
+    float z = luaL_checknumber(L, 4);
+    float o = luaL_checknumber(L, 5);
+    uint32 desp = luaL_optunsigned(L, 6, 0);
+
+    SummonPropertiesEntry const* properties = sSummonPropertiesStore.LookupEntry(61);
+    if (!properties)
+        return 0;
+    Position pos;
+    pos.Relocate(x,y,z,o);
+    TempSummon* summon = unit->GetMap()->SummonCreature(entry, pos, properties, desp, unit);
+
+    if (!summon)
+        return 0;
+    if (summon->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+        ((Guardian*)summon)->InitStatsForLevel(unit->getLevel());
+    if (properties && properties->Category == SUMMON_CATEGORY_ALLY)
+        summon->setFaction(unit->getFaction());
+    if (summon->GetEntry() == 27893)
+    {
+        if (uint32 weapon = unit->GetUInt32Value(PLAYER_VISIBLE_ITEM_16_ENTRYID))
+        {
+            summon->SetDisplayId(11686);
+            summon->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, weapon);
+        }
+        else
+            summon->SetDisplayId(1126);
+    }
+    summon->AI()->EnterEvadeMode();
+
+    sEluna->PushUnit(L, summon);
+    return 1;
+}
+
+int LuaUnit::SendQuestTemplate(lua_State* L, Unit* unit)
+{
+    TO_PLAYER();
+
+    uint32 questId = luaL_checkunsigned(L, 1);
+    bool activeAccept = luaL_optbool(L, 2, true);
+
+    Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
+    if (!quest)
+        return 0;
+
+    player->PlayerTalkClass->SendQuestGiverQuestDetails(quest, player->GetGUID(), activeAccept);
+    return 0;
+}
diff --git a/src/server/LuaEngine/UnitMethods.h b/src/server/LuaEngine/UnitMethods.h
new file mode 100644
index 0000000..98b7163
--- /dev/null
+++ b/src/server/LuaEngine/UnitMethods.h
@@ -0,0 +1,494 @@
+#ifndef UNITMETHODS_H
+#define UNITMETHODS_H
+
+namespace LuaUnit
+{
+    int Attack(lua_State*, Unit*);
+    int DealDamage(lua_State*, Unit*);
+    int SetFlag(lua_State*, Unit*);
+    int RemoveFlag(lua_State*, Unit*);
+    int HasFlag(lua_State*, Unit*);
+    int ClearThreatList(lua_State*, Unit*);
+    int SetOwnerGUID(lua_State*, Unit*);
+    int GetOwner(lua_State*, Unit*);
+    int GetOwnerGUID(lua_State*, Unit*);
+    int SummonPlayer(lua_State*, Unit*);
+    int Mute(lua_State*, Unit*);
+    int GetHeight(lua_State*, Unit*);
+    int GetRelativePoint(lua_State*, Unit*);
+    int Mount(lua_State*, Unit*);
+    int Dismount(lua_State*, Unit*);
+    int IsMounted(lua_State*, Unit*);
+    int IsWithinLoS(lua_State*, Unit*);
+    int GetScale(lua_State*, Unit*);
+    int SetScale(lua_State*, Unit*);
+    int IsDamageEnoughForLootingAndReward(lua_State*, Unit*);
+    int IsReputationGainDisabled(lua_State*, Unit*);
+    int SetDisableReputationGain(lua_State*, Unit*);
+    int SelectVictim(lua_State*, Unit*);
+    int GetCurrentWaypointId(lua_State*, Unit*);
+    int GetWaypointPath(lua_State*, Unit*);
+    int GetTransportHomePosition(lua_State*, Unit*);
+    int IsRegeneratingHealth(lua_State*, Unit*);
+    int HasInvolvedQuest(lua_State*, Unit*);
+    int SetInCombatWithZone(lua_State*, Unit*);
+    int SetRespawnRadius(lua_State*, Unit*);
+    int GetRespawnRadius(lua_State*, Unit*);
+    int Respawn(lua_State*, Unit*);
+    int SetRespawnDelay(lua_State*, Unit*);
+    int GetRespawnDelay(lua_State*, Unit*);
+    int DespawnOrUnsummon(lua_State*, Unit*);
+    int RemoveCorpse(lua_State*, Unit*);
+    int SetDefaultMovementType(lua_State*, Unit*);
+    int GetDefaultMovementType(lua_State*, Unit*);
+    int IsTargetAcceptable(lua_State*, Unit*);
+    int CanAssistTo(lua_State*, Unit*);
+    int HasSearchedAssistance(lua_State*, Unit*);
+    int SetNoSearchAssistance(lua_State*, Unit*);
+    int SetNoCallAssistance(lua_State*, Unit*);
+    int CallAssistance(lua_State*, Unit*);
+    int CallForHelp(lua_State*, Unit*);
+    int FleeToGetAssistance(lua_State*, Unit*);
+    int GetAggroRange(lua_State*, Unit*);
+    int GetAttackDistance(lua_State*, Unit*);
+    int CanStartAttack(lua_State*, Unit*);
+    int ResetLootMode(lua_State*, Unit*);
+    int RemoveLootMode(lua_State*, Unit*);
+    int AddLootMode(lua_State*, Unit*);
+    int SetLootMode(lua_State*, Unit*);
+    int HasLootMode(lua_State*, Unit*);
+    int GetLootMode(lua_State*, Unit*);
+    int IsTappedBy(lua_State*, Unit*);
+    int HasLootRecipient(lua_State*, Unit*);
+    int GetLootRecipientGroup(lua_State*, Unit*);
+    int GetLootRecipient(lua_State*, Unit*);
+    int SetDeathState(lua_State*, Unit*);
+    int SetReactState(lua_State*, Unit*);
+    int GetReactState(lua_State*, Unit*);
+    int HasReactState(lua_State*, Unit*);
+    int CanFly(lua_State*, Unit*);
+    int CanSwim(lua_State*, Unit*);
+    int CanWalk(lua_State*, Unit*);
+    int SetDisableGravity(lua_State*, Unit*);
+    int SetHover(lua_State*, Unit*);
+    int IsInEvadeMode(lua_State*, Unit*);
+    int IsElite(lua_State*, Unit*);
+    int IsGuard(lua_State*, Unit*);
+    int IsTrigger(lua_State*, Unit*);
+    int IsCivilian(lua_State*, Unit*);
+    int IsRacialLeader(lua_State*, Unit*);
+    int HasCategoryCooldown(lua_State*, Unit*);
+    int GetScriptName(lua_State*, Unit*);
+    int GetAIName(lua_State*, Unit*);
+    int GetScriptId(lua_State*, Unit*);
+    int GetCreatureSpellCooldownDelay(lua_State*, Unit*);
+    int GetShieldBlockValue(lua_State*, Unit*);
+    int GetMountId(lua_State*, Unit*);
+    int GetCorpseDelay(lua_State*, Unit*);
+    int GetHomePosition(lua_State*, Unit*);
+    int RewardQuest(lua_State*, Unit*);
+    int HasAura(lua_State*, Unit*);
+    int IsARecruiter(lua_State*, Unit*);
+    int GetRecruiterId(lua_State*, Unit*);
+    int GetSelectedPlayer(lua_State*, Unit*);
+    int GetSelectedUnit(lua_State*, Unit*);
+    int GetDistance(lua_State*, Unit*);
+    int GetLatency(lua_State*, Unit*);
+    int SendAuctionMenu(lua_State*, Unit*);
+    int SendMailMenu(lua_State*, Unit*);
+    int SendTaxiMenu(lua_State*, Unit*);
+    int SendSpiritResurrect(lua_State*, Unit*);
+    int SendTabardVendorActivate(lua_State*, Unit*);
+    int SendShowBank(lua_State*, Unit*);
+    int SendListInventory(lua_State*, Unit*);
+    int SendTrainerList(lua_State*, Unit*);
+    int LogoutPlayer(lua_State*, Unit*);
+    int GetChampioningFaction(lua_State*, Unit*);
+    int ResetAchievements(lua_State*, Unit*);
+    int HasAchieved(lua_State*, Unit*);
+    int GetOriginalSubGroup(lua_State*, Unit*);
+    int GetOriginalGroup(lua_State*, Unit*);
+    int RemoveFromBattlegroundOrBattlefieldRaid(lua_State*, Unit*);
+    int CanUninviteFromGroup(lua_State*, Unit*);
+    int GetNextRandomRaidMember(lua_State*, Unit*);
+    int GetSubGroup(lua_State*, Unit*);
+    int GetGroupInvite(lua_State*, Unit*);
+    int HasPendingBind(lua_State*, Unit*);
+    int UnbindInstance(lua_State*, Unit*);
+    int BindToInstance(lua_State*, Unit*);
+    int SetAtLoginFlag(lua_State*, Unit*);
+    int InRandomLfgDungeon(lua_State*, Unit*);
+    int IsUsingLfg(lua_State*, Unit*);
+    int HasAtLoginFlag(lua_State*, Unit*);
+    int IsVisibleForPlayer(lua_State*, Unit*);
+    int IsNeverVisible(lua_State*, Unit*);
+    int CanFlyInZone(lua_State*, Unit*);
+    int SetRestTime(lua_State*, Unit*);
+    int GetRestTime(lua_State*, Unit*);
+    int GetXPRestBonus(lua_State*, Unit*);
+    int CanSpeak(lua_State*, Unit*);
+    int IsImmuneToEnvironmentalDamage(lua_State*, Unit*);
+    int IsRested(lua_State*, Unit*);
+    int LeaveBattleground(lua_State*, Unit*);
+    int InBattlegroundQueue(lua_State*, Unit*);
+    int GetBattlegroundTypeId(lua_State*, Unit*);
+    int GetBattlegroundId(lua_State*, Unit*);
+    int IsOutdoorPvPActive(lua_State*, Unit*);
+    int InArena(lua_State*, Unit*);
+    int InBattleground(lua_State*, Unit*);
+    int CanTameExoticPets(lua_State*, Unit*);
+    int CanTitanGrip(lua_State*, Unit*);
+    int CanBlock(lua_State*, Unit*);
+    int CanParry(lua_State*, Unit*);
+    int GetDrunkValue(lua_State*, Unit*);
+    int SetDrunkValue(lua_State*, Unit*);
+    int GetSpellCooldowns(lua_State*, Unit*);
+    int ModifyArenaPoints(lua_State*, Unit*);
+    int ModifyHonorPoints(lua_State*, Unit*);
+    int GetReputationRank(lua_State*, Unit*);
+    int IsHonorOrXPTarget(lua_State*, Unit*);
+    int SetFactionForRace(lua_State*, Unit*);
+    int SetSkill(lua_State*, Unit*);
+    int HasSkill(lua_State*, Unit*);
+    int GetSkillTempBonusValue(lua_State*, Unit*);
+    int GetSkillPermBonusValue(lua_State*, Unit*);
+    int GetSkillStep(lua_State*, Unit*);
+    int GetPureSkillValue(lua_State*, Unit*);
+    int GetBaseSkillValue(lua_State*, Unit*);
+    int GetSkillValue(lua_State*, Unit*);
+    int GetPureMaxSkillValue(lua_State*, Unit*);
+    int GetMaxSkillValue(lua_State*, Unit*);
+    int SetMovement(lua_State*, Unit*);
+    int DurabilityRepair(lua_State*, Unit*);
+    int DurabilityRepairAll(lua_State*, Unit*);
+    int DurabilityPointLossForEquipSlot(lua_State*, Unit*);
+    int DurabilityPointsLossAll(lua_State*, Unit*);
+    int DurabilityPointsLoss(lua_State*, Unit*);
+    int DurabilityLoss(lua_State*, Unit*);
+    int DurabilityLossAll(lua_State*, Unit*);
+    int KillPlayer(lua_State*, Unit*);
+    int GetManaBonusFromIntellect(lua_State*, Unit*);
+    int GetHealthBonusFromStamina(lua_State*, Unit*);
+    int GetDifficulty(lua_State*, Unit*);
+    int GetGuildRank(lua_State*, Unit*);
+    int SetGuildRank(lua_State*, Unit*);
+    int RemoveFromGroup(lua_State*, Unit*);
+    int IsGroupVisibleFor(lua_State*, Unit*);
+    int IsInSameRaidWith(lua_State*, Unit*);
+    int IsInSameGroupWith(lua_State*, Unit*);
+    int SetPvP(lua_State*, Unit*);
+    int SetFFA(lua_State*, Unit*);
+    int SetSanctuary(lua_State*, Unit*);
+    int GetSpellCooldownDelay(lua_State*, Unit*);
+    int HasSpellCooldown(lua_State*, Unit*);
+    int IsAuctioneer(lua_State*, Unit*);
+    int HealthBelowPct(lua_State*, Unit*);
+    int HealthAbovePct(lua_State*, Unit*);
+    int GetSpecsCount(lua_State*, Unit*);
+    int GetActiveSpec(lua_State*, Unit*);
+    int HasTalent(lua_State*, Unit*);
+    int AddTalent(lua_State*, Unit*);
+    int ResetTalentsCost(lua_State*, Unit*);
+    int ResetTalents(lua_State*, Unit*);
+    int SetFreeTalentPoints(lua_State*, Unit*);
+    int GetFreeTalentPoints(lua_State*, Unit*);
+    int GetGuildName(lua_State*, Unit*);
+    int GetReputation(lua_State*, Unit*);
+    int SetReputation(lua_State*, Unit*);
+    int RemoveSpell(lua_State*, Unit*);
+    int ClearComboPoints(lua_State*, Unit*);
+    int GainSpellComboPoints(lua_State*, Unit*);
+    int AddComboPoints(lua_State*, Unit*);
+    int GetComboTarget(lua_State*, Unit*);
+    int GetComboPoints(lua_State*, Unit*);
+    int HasReceivedQuestReward(lua_State*, Unit*);
+    int RegenerateHealth(lua_State*, Unit*);
+    int Regenerate(lua_State*, Unit*);
+    int RegenerateAll(lua_State*, Unit*);
+    int ResetPetTalents(lua_State*, Unit*);
+    int SaveToDB(lua_State*, Unit*);
+    int Emote(lua_State*, Unit*);
+    int CountPctFromCurHealth(lua_State*, Unit*);
+    int CountPctFromMaxHealth(lua_State*, Unit*);
+    int GetInGameTime(lua_State*, Unit*);
+    int TalkedToCreature(lua_State*, Unit*);
+    int CastedCreatureOrGO(lua_State*, Unit*);
+    int KilledPlayerCredit(lua_State*, Unit*);
+    int KilledMonsterCredit(lua_State*, Unit*);
+    int GroupEventHappens(lua_State*, Unit*);
+    int AreaExploredOrEventHappens(lua_State*, Unit*);
+    int CanShareQuest(lua_State*, Unit*);
+    int HasQuestForGO(lua_State*, Unit*);
+    int HasQuestForItem(lua_State*, Unit*);
+    int GetReqKillOrCastCurrentCount(lua_State*, Unit*);
+    int RemoveRewardedQuest(lua_State*, Unit*);
+    int RemoveActiveQuest(lua_State*, Unit*);
+    int SetQuestStatus(lua_State*, Unit*);
+    int GetQuestStatus(lua_State*, Unit*);
+    int FailQuest(lua_State*, Unit*);
+    int IncompleteQuest(lua_State*, Unit*);
+    int CompleteQuest(lua_State*, Unit*);
+    int IsActiveQuest(lua_State*, Unit*);
+    int GetQuestLevel(lua_State*, Unit*);
+    int GetItemByEntry(lua_State*, Unit*);
+    int SetSheath(lua_State*, Unit*);
+    int Whisper(lua_State*, Unit*);
+    int TextEmote(lua_State*, Unit*);
+    int Yell(lua_State*, Unit*);
+    int Say(lua_State*, Unit*);
+    int GetPhaseMaskForSpawn(lua_State*, Unit*);
+    int SummonPet(lua_State*, Unit*);
+    int RemovePet(lua_State*, Unit*);
+    int GetRestType(lua_State*, Unit*);
+    int SetRestType(lua_State*, Unit*);
+    int SetRestBonus(lua_State*, Unit*);
+    int GetRestBonus(lua_State*, Unit*);
+    int GiveLevel(lua_State*, Unit*);
+    int GiveXP(lua_State*, Unit*);
+    int IsGMVisible(lua_State*, Unit*);
+    int IsTaxiCheater(lua_State*, Unit*);
+    int IsGMChat(lua_State*, Unit*);
+    int IsAcceptingWhispers(lua_State*, Unit*);
+    int SetAcceptWhispers(lua_State*, Unit*);
+    int SetPvPDeath(lua_State*, Unit*);
+    int SetGMVisible(lua_State*, Unit*);
+    int SetTaxiCheat(lua_State*, Unit*);
+    int SetGMChat(lua_State*, Unit*);
+    int SetGameMaster(lua_State*, Unit*);
+    int GetChatTag(lua_State*, Unit*);
+    int IsDND(lua_State*, Unit*);
+    int IsAFK(lua_State*, Unit*);
+    int ToggleDND(lua_State*, Unit*);
+    int ToggleAFK(lua_State*, Unit*);
+    int IsFalling(lua_State*, Unit*);
+    int IsUnderWater(lua_State*, Unit*);
+    int IsInWater(lua_State*, Unit*);
+    int GetVictim(lua_State*, Unit*);
+    int GetNearestTargetInAttackDistance(lua_State*, Unit*);
+    int GetNearestTarget(lua_State*, Unit*);
+    int GetNearestHostileTargetInAggroRange(lua_State*, Unit*);
+    int GetNearbyTarget(lua_State*, Unit*);
+    int GetObjectGlobally(lua_State*, Unit*);
+    int GetNearbyGameObject(lua_State*, Unit*);
+    int SendChatMessageToPlayer(lua_State*, Unit*);
+    int GetCurrentSpell(lua_State*, Unit*);
+    int EquipItem(lua_State*, Unit*);
+    int CanEquipItem(lua_State*, Unit*);
+    int GetInventoryItem(lua_State*, Unit*);
+    int GetBagItem(lua_State*, Unit*);
+    int SummonGameObject(lua_State*, Unit*);
+    int SpawnCreature(lua_State*, Unit*);
+    int Despawn(lua_State*, Unit*);
+    int GetArenaPoints(lua_State*, Unit*);
+    int KnockbackFrom(lua_State*, Unit*);
+    int JumpTo(lua_State*, Unit*);
+    int Jump(lua_State*, Unit*);
+    int JumpToCoords(lua_State*, Unit*);
+    int MoveCharge(lua_State*, Unit*);
+    int MoveChase(lua_State*, Unit*);
+    int SetStunned(lua_State*, Unit*);
+    int SetRooted(lua_State*, Unit*);
+    int SetConfused(lua_State*, Unit*);
+    int SetFeared(lua_State*, Unit*);
+    int SetGender(lua_State*, Unit*);
+    int MoveTo(lua_State*, Unit*);
+    int MoveFollow(lua_State*, Unit*);
+    int MoveClear(lua_State*, Unit*);
+    int MoveRandom(lua_State*, Unit*);
+    int MoveRotate(lua_State*, Unit*);
+    int SetWalk(lua_State*, Unit*);
+    int SetSpeed(lua_State*, Unit*);
+    int GetHonorPoints(lua_State*, Unit*);
+    int GetSelection(lua_State*, Unit*);
+    int GetGMRank(lua_State*, Unit*);
+    int GetCoinage(lua_State*, Unit*);
+    int GetDisplayId(lua_State*, Unit*);
+    int GetNativeDisplayId(lua_State*, Unit*);
+    int GetName(lua_State*, Unit*);
+    int GetLevel(lua_State*, Unit*);
+    int GetHealth(lua_State*, Unit*);
+    int GetGuildId(lua_State*, Unit*);
+    int GetX(lua_State*, Unit*);
+    int GetY(lua_State*, Unit*);
+    int GetZ(lua_State*, Unit*);
+    int GetO(lua_State*, Unit*);
+    int GetLocation(lua_State*, Unit*);
+    int GetZoneId(lua_State*, Unit*);
+    int GetInstanceId(lua_State*, Unit*);
+    int GetPhaseMask(lua_State*, Unit*);
+    int GetAreaId(lua_State*, Unit*);
+    int GetTeam(lua_State*, Unit*);
+    int GetGUID(lua_State*, Unit*);
+    int GetGUIDLow(lua_State*, Unit*);
+    int GetPower(lua_State*, Unit*);
+    int GetMaxPower(lua_State*, Unit*);
+    int GetPowerType(lua_State*, Unit*);
+    int GetMaxHealth(lua_State*, Unit*);
+    int GetHealthPct(lua_State*, Unit*);
+    int GetPowerPct(lua_State*, Unit*);
+    int GetGender(lua_State*, Unit*);
+    int GetRace(lua_State*, Unit*);
+    int GetClass(lua_State*, Unit*);
+    int GetCreatureType(lua_State*, Unit*);
+    int GetClassAsString(lua_State*, Unit*);
+    int GetItemCount(lua_State*, Unit*);
+    int GetLifetimeKills(lua_State*, Unit*);
+    int GetPlayerIP(lua_State*, Unit*);
+    int GetLevelPlayedTime(lua_State*, Unit*);
+    int GetTotalPlayedTime(lua_State*, Unit*);
+    int GetUnitType(lua_State*, Unit*);
+    int GetGuild(lua_State*, Unit*);
+    int GetGroup(lua_State*, Unit*);
+    int GetGearLevel(lua_State*, Unit*);
+    int GetEntry(lua_State*, Unit*);
+    int GetFaction(lua_State*, Unit*);
+    int SetFaction(lua_State*, Unit*);
+    int SetLevel(lua_State*, Unit*);
+    int SetPhaseMask(lua_State*, Unit*);
+    int SetArenaPoints(lua_State*, Unit*);
+    int SetHonorPoints(lua_State*, Unit*);
+    int SetLifetimeKills(lua_State*, Unit*);
+    int SetHealth(lua_State*, Unit*);
+    int SetMaxHealth(lua_State*, Unit*);
+    int SetPower(lua_State*, Unit*);
+    int SetMaxPower(lua_State*, Unit*);
+    int SetDisplayId(lua_State*, Unit*);
+    int SetNativeDisplayId(lua_State*, Unit*);
+    int SetFacing(lua_State*, Unit*);
+    int SetCoinage(lua_State*, Unit*);
+    int SetBindPoint(lua_State*, Unit*);
+    int SetBindPointAtPlayerLoc(lua_State*, Unit*);
+    int SetKnownTitle(lua_State*, Unit*);
+    int UnsetKnownTitle(lua_State*, Unit*);
+    int AdvanceSkillsToMax(lua_State*, Unit*);
+    int AdvanceAllSkills(lua_State*, Unit*);
+    int AdvanceSkill(lua_State*, Unit*);
+    int IsInGroup(lua_State*, Unit*);
+    int IsInGuild(lua_State*, Unit*);
+    int IsGM(lua_State*, Unit*);
+    int IsAlive(lua_State*, Unit*);
+    int IsDead(lua_State*, Unit*);
+    int IsDying(lua_State*, Unit*);
+    int IsBanker(lua_State*, Unit*);
+    int IsBattleMaster(lua_State*, Unit*);
+    int IsCharmed(lua_State*, Unit*);
+    int IsArmorer(lua_State*, Unit*);
+    int IsAttackingPlayer(lua_State*, Unit*);
+    int IsInArenaTeam(lua_State*, Unit*);
+    int IsInWorld(lua_State*, Unit*);
+    int IsPvPFlagged(lua_State*, Unit*);
+    int HasQuest(lua_State*, Unit*);
+    int IsHorde(lua_State*, Unit*);
+    int IsAlliance(lua_State*, Unit*);
+    int IsInCombat(lua_State*, Unit*);
+    int HasTitle(lua_State*, Unit*);
+    int HasSpell(lua_State*, Unit*);
+    int HasItem(lua_State*, Unit*);
+    int Teleport(lua_State*, Unit*);
+    int AddLifetimeKills(lua_State*, Unit*);
+    int AddItem(lua_State*, Unit*);
+    int RemoveItem(lua_State*, Unit*);
+    int RemoveLifetimeKills(lua_State*, Unit*);
+    int ResetSpellCooldown(lua_State*, Unit*);
+    int ResetTypeCooldowns(lua_State*, Unit*);
+    int ResetAllCooldowns(lua_State*, Unit*);
+    int SendClearCooldowns(lua_State*, Unit*);
+    int SendBroadcastMessage(lua_State*, Unit*);
+    int SendAreaTriggerMessage(lua_State*, Unit*);
+    int SendNotification(lua_State*, Unit*);
+    int SendUnitWhisper(lua_State*, Unit*);
+    int SendUnitEmote(lua_State*, Unit*);
+    int SendUnitSay(lua_State*, Unit*);
+    int SendUnitYell(lua_State*, Unit*);
+    int SendPacketToPlayer(lua_State*, Unit*);
+    int SendPacket(lua_State*, Unit*);
+    int SendPacketToGroup(lua_State*, Unit*);
+    int SendPacketToGuild(lua_State*, Unit*);
+    int SendPacketToRankedInGuild(lua_State*, Unit*);
+    int SendVendorWindow(lua_State*, Unit*);
+    int KickPlayer(lua_State*, Unit*);
+    int ModifyMoney(lua_State*, Unit*);
+    int LearnSpell(lua_State*, Unit*);
+    int DeMorph(lua_State*, Unit*);
+    int ResurrectPlayer(lua_State*, Unit*);
+    int CastSpell(lua_State*, Unit*);
+    int CastSpellAoF(lua_State*, Unit*);
+    int GetAccountId(lua_State*, Unit*);
+    int GetAccountName(lua_State*, Unit*);
+    int GetAITarget(lua_State*, Unit*);
+    int GetAITargets(lua_State*, Unit*);
+    int GetAITargetsCount(lua_State*, Unit*);
+    int IsDungeonBoss(lua_State*, Unit*);
+    int IsWorldBoss(lua_State*, Unit*);
+    int GetAura(lua_State*, Unit*);
+    int GetMapId(lua_State*, Unit*);
+    int GetCombatTime(lua_State*, Unit*);
+    int ClearInCombat(lua_State*, Unit*);
+    int StopSpellCast(lua_State*, Unit*);
+    int InterruptSpell(lua_State*, Unit*);
+    int AddAura(lua_State*, Unit*);
+    int RemoveAura(lua_State*, Unit*);
+    int RemoveAllAuras(lua_State*, Unit*);
+    int GossipMenuAddItem(lua_State*, Unit*);
+    int GossipComplete(lua_State*, Unit*);
+    int GossipSendMenu(lua_State*, Unit*);
+    int GossipClearMenu(lua_State*, Unit*);
+    int PlaySoundToPlayer(lua_State*, Unit*);
+    int PlayDirectSound(lua_State*, Unit*);
+    int PlayDistanceSound(lua_State*, Unit*);
+    int Kill(lua_State*, Unit*);
+    int RegisterEvent(lua_State*, Unit*);
+    int RemoveEventById(lua_State*, Unit*);
+    int RemoveEvents(lua_State*, Unit*);
+    int GetInt32Value(lua_State*, Unit*);
+    int GetUInt32Value(lua_State*, Unit*);
+    int GetFloatValue(lua_State*, Unit*);
+    int GetByteValue(lua_State*, Unit*);
+    int GetUInt16Value(lua_State*, Unit*);
+    int SetInt32Value(lua_State*, Unit*);
+    int SetUInt32Value(lua_State*, Unit*);
+    int UpdateUInt32Value(lua_State*, Unit*);
+    int SetFloatValue(lua_State*, Unit*);
+    int SetByteValue(lua_State*, Unit*);
+    int SetUInt16Value(lua_State*, Unit*);
+    int SetInt16Value(lua_State*, Unit*);
+    int IsOnVehicle(lua_State*, Unit*);
+    int DismissVehicle(lua_State*, Unit*);
+    int AddVehiclePassenger(lua_State*, Unit*);
+    int EjectPassenger(lua_State*, Unit*);
+    int RemovePassenger(lua_State*, Unit*);
+    int RemoveAllPassengers(lua_State*, Unit*);
+    int GetPassenger(lua_State*, Unit*);
+    int GetNextEmptySeat(lua_State*, Unit*);
+    int GetAvailableSeats(lua_State*, Unit*);
+    int GetVehicleBase(lua_State*, Unit*);
+    int HasEmptySeat(lua_State*, Unit*);
+    int StartTaxi(lua_State*, Unit*);
+    int SetPlayerLock(lua_State*, Unit*);
+    int GetNearestPlayer(lua_State*, Unit*);
+    int GetNearestGameObject(lua_State*, Unit*);
+    int GetNearestCreature(lua_State*, Unit*);
+    int GossipSendPOI(lua_State*, Unit*);
+    int GossipAddQuests(lua_State*, Unit*);
+    int AttackStop(lua_State*, Unit*);
+    int SetCanFly(lua_State*, Unit*);
+    int SetVisible(lua_State*, Unit*);
+    int IsVisible(lua_State*, Unit*);
+    int IsMoving(lua_State*, Unit*);
+    int IsFlying(lua_State*, Unit*);
+    int IsStopped(lua_State*, Unit*);
+    int RestoreDisplayId(lua_State*, Unit*);
+    int RestoreFaction(lua_State*, Unit*);
+    int RemoveBindSightAuras(lua_State*, Unit*);
+    int RemoveCharmAuras(lua_State*, Unit*);
+    int StopMoving(lua_State*, Unit*);
+    int AddUnitState(lua_State*, Unit*);
+    int ClearUnitState(lua_State*, Unit*);
+    int HasUnitState(lua_State*, Unit*);
+    int DisableMelee(lua_State*, Unit*);
+    int GetFriendlyUnitsInRange(lua_State*, Unit*);
+    int GetUnfriendlyUnitsInRange(lua_State*, Unit*);
+    int SummonGuardian(lua_State*, Unit*);
+    int SendQuestTemplate(lua_State*, Unit*);
+};
+#endif
diff --git a/src/server/LuaEngine/WorldPacketMethods.h b/src/server/LuaEngine/WorldPacketMethods.h
new file mode 100644
index 0000000..16b3b6c
--- /dev/null
+++ b/src/server/LuaEngine/WorldPacketMethods.h
@@ -0,0 +1,283 @@
+#ifndef WORLDPACKETMETHODS_H
+#define WORLDPACKETMETHODS_H
+
+class LuaPacket
+{
+public:
+    // GetUnitType()
+    static int GetUnitType(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        lua_pushstring(L, "Packet");
+        return 1;
+    }
+
+    // GetOpcode()
+    static int GetOpcode(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        sEluna->PushUnsigned(L, packet->GetOpcode());
+        return 1;
+    }
+
+    // GetSize()
+    static int GetSize(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        sEluna->PushUnsigned(L, packet->size());
+        return 1;
+    }
+
+    // SetOpcode(opcode)
+    static int SetOpcode(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint16 opcode = luaL_checkunsigned(L, 1);
+        if (opcode >= NUM_MSG_TYPES)
+            luaL_error(L, "Invalid opcode type (%d)", opcode);
+        else
+            packet->SetOpcode(opcode);
+        return 0;
+    }
+
+    // ReadByte()
+    static int ReadByte(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        int8 byte;
+        (*packet) >> byte;
+        sEluna->PushInteger(L, byte);
+        return 1;
+    }
+
+    // ReadUByte()
+    static int ReadUByte(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint8 byte;
+        (*packet) >> byte;
+        sEluna->PushUnsigned(L, byte);
+        return 1;
+    }
+
+    // ReadShort()
+    static int ReadShort(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        int16 _short;
+        (*packet) >> _short;
+        sEluna->PushInteger(L, _short);
+        return 1;
+    }
+
+    // ReadUShort()
+    static int ReadUShort(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint16 _ushort;
+        (*packet) >> _ushort;
+        sEluna->PushUnsigned(L, _ushort);
+        return 1;
+    }
+
+    // ReadLong()
+    static int ReadLong(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        int32 _long;
+        (*packet) >> _long;
+        sEluna->PushInteger(L, _long);
+        return 1;
+    }
+
+    // ReadULong()
+    static int ReadULong(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint32 _ulong;
+        (*packet) >> _ulong;
+        sEluna->PushUnsigned(L, _ulong);
+        return 1;
+    }
+
+    // ReadFloat()
+    static int ReadFloat(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        float _val;
+        (*packet) >> _val;
+        sEluna->PushFloat(L, _val);
+        return 1;
+    }
+
+    // ReadDouble()
+    static int ReadDouble(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        double _val;
+        (*packet) >> _val;
+        sEluna->PushDouble(L, _val);
+        return 1;
+    }
+
+    // ReadGUID()
+    static int ReadGUID(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint64 guid;
+        (*packet) >> guid;
+        sEluna->PushULong(L, guid);
+        return 1;
+    }
+
+    // ReadString()
+    static int ReadString(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        std::string _val;
+        (*packet) >> _val;
+        sEluna->PushString(L, _val.c_str());
+        return 1;
+    }
+
+    // WriteGUID(guid)
+    static int WriteGUID(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint64 guid = sEluna->CHECK_ULONG(L, 1);
+
+        (*packet) << guid;
+        return 0;
+    }
+
+    // WriteString(string)
+    static int WriteString(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        std::string _val = std::string(luaL_checkstring(L, 1));
+        (*packet) << _val;
+        return 0;
+    }
+
+    // WriteBye(byte)
+    static int WriteByte(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        int8 byte = luaL_checkinteger(L, 1);
+        (*packet) << byte;
+        return 0;
+    }
+
+    // WriteUByte(byte)
+    static int WriteUByte(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint8 byte = luaL_checkunsigned(L, 1);
+        (*packet) << byte;
+        return 0;
+    }
+
+    // WriteUShort(short)
+    static int WriteUShort(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint16 _ushort = luaL_checkunsigned(L, 1);
+        (*packet) << _ushort;
+        return 0;
+    }
+
+    // WriteShort(short)
+    static int WriteShort(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        int16 _short = luaL_checkinteger(L, 1);
+        (*packet) << _short;
+        return 0;
+    }
+
+    // WriteLong(long)
+    static int WriteLong(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        int32 _long = luaL_checkinteger(L, 1);
+        (*packet) << _long;
+        return 0;
+    }
+
+    // WriteULong(long)
+    static int WriteULong(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint32 _ulong = luaL_checkunsigned(L, 1);
+        (*packet) << _ulong;
+        return 0;
+    }
+
+    // WriteFloat(float)
+    static int WriteFloat(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        float _val = luaL_checknumber(L, 1);
+        (*packet) << _val;
+        return 0;
+    }
+
+    // WriteDouble(double)
+    static int WriteDouble(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        double _val = luaL_checknumber(L, 1);
+        (*packet) << _val;
+        return 0;
+    }
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/authserver/Main.cpp b/src/server/authserver/Main.cpp
index 9a80abe..ee46e17 100644
--- a/src/server/authserver/Main.cpp
+++ b/src/server/authserver/Main.cpp
@@ -96,7 +96,7 @@ extern int main(int argc, char **argv)
         ++c;
     }
 
-    if (!sConfigMgr->LoadInitial(cfg_file))
+    if (!ConfigMgr::Load(cfg_file))
     {
         printf("Invalid or missing configuration file : %s\n", cfg_file);
         printf("Verify that the file exists and has \'[authserver]\' written in the top of the file!\n");
@@ -118,7 +118,7 @@ extern int main(int argc, char **argv)
     TC_LOG_DEBUG(LOG_FILTER_AUTHSERVER, "Max allowed open files is %d", ACE::max_handles());
 
     // authserver PID file creation
-    std::string pidfile = sConfigMgr->GetStringDefault("PidFile", "");
+    std::string pidfile = ConfigMgr::GetStringDefault("PidFile", "");
     if (!pidfile.empty())
     {
         uint32 pid = CreatePIDFile(pidfile);
@@ -135,7 +135,7 @@ extern int main(int argc, char **argv)
         return 1;
 
     // Get the list of realms for the server
-    sRealmList->Initialize(sConfigMgr->GetIntDefault("RealmsStateUpdateDelay", 20));
+    sRealmList->Initialize(ConfigMgr::GetIntDefault("RealmsStateUpdateDelay", 20));
     if (sRealmList->size() == 0)
     {
         TC_LOG_ERROR(LOG_FILTER_AUTHSERVER, "No valid realms specified.");
@@ -145,14 +145,14 @@ extern int main(int argc, char **argv)
     // Launch the listening network socket
     RealmAcceptor acceptor;
 
-    int32 rmport = sConfigMgr->GetIntDefault("RealmServerPort", 3724);
+    int32 rmport = ConfigMgr::GetIntDefault("RealmServerPort", 3724);
     if (rmport < 0 || rmport > 0xFFFF)
     {
         TC_LOG_ERROR(LOG_FILTER_AUTHSERVER, "Specified port out of allowed range (1-65535)");
         return 1;
     }
 
-    std::string bind_ip = sConfigMgr->GetStringDefault("BindIP", "0.0.0.0");
+    std::string bind_ip = ConfigMgr::GetStringDefault("BindIP", "0.0.0.0");
 
     ACE_INET_Addr bind_addr(uint16(rmport), bind_ip.c_str());
 
@@ -175,7 +175,7 @@ extern int main(int argc, char **argv)
     {
         HANDLE hProcess = GetCurrentProcess();
 
-        uint32 Aff = sConfigMgr->GetIntDefault("UseProcessors", 0);
+        uint32 Aff = ConfigMgr::GetIntDefault("UseProcessors", 0);
         if (Aff > 0)
         {
             ULONG_PTR appAff;
@@ -195,7 +195,7 @@ extern int main(int argc, char **argv)
 
         }
 
-        bool Prio = sConfigMgr->GetBoolDefault("ProcessPriority", false);
+        bool Prio = ConfigMgr::GetBoolDefault("ProcessPriority", false);
 
         if (Prio)
         {
@@ -209,7 +209,7 @@ extern int main(int argc, char **argv)
 #endif
 
     // maximum counter for next ping
-    uint32 numLoops = (sConfigMgr->GetIntDefault("MaxPingTime", 30) * (MINUTE * 1000000 / 100000));
+    uint32 numLoops = (ConfigMgr::GetIntDefault("MaxPingTime", 30) * (MINUTE * 1000000 / 100000));
     uint32 loopCounter = 0;
 
     // Wait for termination signal
@@ -241,21 +241,21 @@ bool StartDB()
 {
     MySQL::Library_Init();
 
-    std::string dbstring = sConfigMgr->GetStringDefault("LoginDatabaseInfo", "");
+    std::string dbstring = ConfigMgr::GetStringDefault("LoginDatabaseInfo", "");
     if (dbstring.empty())
     {
         TC_LOG_ERROR(LOG_FILTER_AUTHSERVER, "Database not specified");
         return false;
     }
 
-    int32 worker_threads = sConfigMgr->GetIntDefault("LoginDatabase.WorkerThreads", 1);
+    int32 worker_threads = ConfigMgr::GetIntDefault("LoginDatabase.WorkerThreads", 1);
     if (worker_threads < 1 || worker_threads > 32)
     {
         TC_LOG_ERROR(LOG_FILTER_AUTHSERVER, "Improper value specified for LoginDatabase.WorkerThreads, defaulting to 1.");
         worker_threads = 1;
     }
 
-    int32 synch_threads = sConfigMgr->GetIntDefault("LoginDatabase.SynchThreads", 1);
+    int32 synch_threads = ConfigMgr::GetIntDefault("LoginDatabase.SynchThreads", 1);
     if (synch_threads < 1 || synch_threads > 32)
     {
         TC_LOG_ERROR(LOG_FILTER_AUTHSERVER, "Improper value specified for LoginDatabase.SynchThreads, defaulting to 1.");
diff --git a/src/server/authserver/Server/AuthSocket.cpp b/src/server/authserver/Server/AuthSocket.cpp
index 6bfe918..792e1bf 100644
--- a/src/server/authserver/Server/AuthSocket.cpp
+++ b/src/server/authserver/Server/AuthSocket.cpp
@@ -682,7 +682,7 @@ bool AuthSocket::_HandleLogonProof()
 
         TC_LOG_DEBUG(LOG_FILTER_AUTHSERVER, "'%s:%d' [AuthChallenge] account %s tried to login with invalid password!", socket().getRemoteAddress().c_str(), socket().getRemotePort(), _login.c_str ());
 
-        uint32 MaxWrongPassCount = sConfigMgr->GetIntDefault("WrongPass.MaxCount", 0);
+        uint32 MaxWrongPassCount = ConfigMgr::GetIntDefault("WrongPass.MaxCount", 0);
         if (MaxWrongPassCount > 0)
         {
             //Increment number of failed logins by one and if it reaches the limit temporarily ban that account or IP
@@ -699,8 +699,8 @@ bool AuthSocket::_HandleLogonProof()
 
                 if (failed_logins >= MaxWrongPassCount)
                 {
-                    uint32 WrongPassBanTime = sConfigMgr->GetIntDefault("WrongPass.BanTime", 600);
-                    bool WrongPassBanType = sConfigMgr->GetBoolDefault("WrongPass.BanType", false);
+                    uint32 WrongPassBanTime = ConfigMgr::GetIntDefault("WrongPass.BanTime", 600);
+                    bool WrongPassBanType = ConfigMgr::GetBoolDefault("WrongPass.BanType", false);
 
                     if (WrongPassBanType)
                     {
diff --git a/src/server/game/Accounts/AccountMgr.cpp b/src/server/game/Accounts/AccountMgr.cpp
index 4075ffa..ea6d87b 100644
--- a/src/server/game/Accounts/AccountMgr.cpp
+++ b/src/server/game/Accounts/AccountMgr.cpp
@@ -439,7 +439,7 @@ void AccountMgr::LoadRBAC()
 
     TC_LOG_DEBUG(LOG_FILTER_RBAC, "AccountMgr::LoadRBAC: Loading default groups");
     // Load default groups to be added to any RBAC Object.
-    std::string defaultGroups = sConfigMgr->GetStringDefault("RBAC.DefaultGroups", "");
+    std::string defaultGroups = ConfigMgr::GetStringDefault("RBAC.DefaultGroups", "");
     Tokenizer tokens(defaultGroups, ',');
     for (Tokenizer::const_iterator itr = tokens.begin(); itr != tokens.end(); ++itr)
         if (uint32 groupId = atoi(*itr))
@@ -448,7 +448,7 @@ void AccountMgr::LoadRBAC()
 
 void AccountMgr::UpdateAccountAccess(RBACData* rbac, uint32 accountId, uint8 securityLevel, int32 realmId)
 {
-    int32 serverRealmId = realmId != -1 ? realmId : sConfigMgr->GetIntDefault("RealmID", 0);
+    int32 serverRealmId = realmId != -1 ? realmId : ConfigMgr::GetIntDefault("RealmID", 0);
     bool needDelete = false;
     if (!rbac)
     {
diff --git a/src/server/game/Battlefield/Zones/BattlefieldWG.h b/src/server/game/Battlefield/Zones/BattlefieldWG.h
index 8bf68cb..0b7999f 100644
--- a/src/server/game/Battlefield/Zones/BattlefieldWG.h
+++ b/src/server/game/Battlefield/Zones/BattlefieldWG.h
@@ -1630,7 +1630,7 @@ struct WintergraspWorkshopData
 
                 // Found associate graveyard and update it
                 if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
-                    if (m_WG->GetGraveyardById(m_Type))
+                    if (m_WG && m_WG->GetGraveyardById(m_Type))
                         m_WG->GetGraveyardById(m_Type)->GiveControlTo(TEAM_ALLIANCE);
 
                 m_TeamControl = team;
@@ -1668,7 +1668,7 @@ struct WintergraspWorkshopData
 
                 // Update graveyard control
                 if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
-                    if (m_WG->GetGraveyardById(m_Type))
+                    if (m_WG && m_WG->GetGraveyardById(m_Type))
                         m_WG->GetGraveyardById(m_Type)->GiveControlTo(TEAM_HORDE);
 
                 m_TeamControl = team;
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index f455610..ff273d7 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -107,6 +107,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
   ${CMAKE_SOURCE_DIR}/dep/SFMT
   ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/dep/lualib
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
   ${CMAKE_SOURCE_DIR}/src/server/collision/Models
@@ -124,6 +125,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
   ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
   ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
+  ${CMAKE_SOURCE_DIR}/src/server/LuaEngine
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}/Accounts
   ${CMAKE_CURRENT_SOURCE_DIR}/Achievements
@@ -204,9 +206,17 @@ include_directories(
 add_library(game STATIC
   ${game_STAT_SRCS}
   ${game_STAT_PCH_SRC}
+  ${lua_STAT_SRCS}
+  ${LuaEngine_STAT_SRCS}
 )
 
 add_dependencies(game revision.h)
+add_dependencies(game lua)
+
+target_link_libraries(game
+ lua
+ LuaEngine
+)
 
 # Generate precompiled header
 if (USE_COREPCH)
diff --git a/src/server/game/Conditions/ConditionMgr.cpp b/src/server/game/Conditions/ConditionMgr.cpp
index 8007590..dd3804c 100644
--- a/src/server/game/Conditions/ConditionMgr.cpp
+++ b/src/server/game/Conditions/ConditionMgr.cpp
@@ -1624,7 +1624,7 @@ bool ConditionMgr::isConditionTypeValid(Condition* cond)
 
             if (cond->ConditionValue2 < 1 || cond->ConditionValue2 > sWorld->GetConfigMaxSkillValue())
             {
-                TC_LOG_ERROR(LOG_FILTER_SQL, "Skill condition specifies skill (%u) with invalid value (%u), skipped", cond->ConditionValue1, cond->ConditionValue2);
+                TC_LOG_ERROR(LOG_FILTER_SQL, "Skill condition specifies invalid skill value (%u), skipped", cond->ConditionValue2);
                 return false;
             }
             if (cond->ConditionValue3)
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 358f941..b540b60 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -78,6 +78,7 @@
 #include "World.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
+#include "HookMgr.h"
 
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
@@ -1208,7 +1209,7 @@ bool Player::StoreNewItemInBestSlots(uint32 titem_id, uint32 titem_amount)
         if (msg != EQUIP_ERR_OK)
             break;
 
-        EquipNewItem(eDest, titem_id, true);
+        Item* item = EquipNewItem(eDest, titem_id, true);
         AutoUnequipOffhandIfNeed();
         --titem_amount;
     }
@@ -2130,7 +2131,7 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         ExitVehicle();
 
     // reset movement flags at teleport, because player will continue move with these flags after teleport
-    SetUnitMovementFlags(GetUnitMovementFlags() & MOVEMENTFLAG_MASK_HAS_PLAYER_STATUS_OPCODE);
+    SetUnitMovementFlags(0);
     DisableSpline();
 
     if (m_transport)
@@ -11650,6 +11651,7 @@ InventoryResult Player::CanEquipItem(uint8 slot, uint16 &dest, Item* pItem, bool
                 }
             }
             dest = ((INVENTORY_SLOT_BAG_0 << 8) | eslot);
+
             return EQUIP_ERR_OK;
         }
     }
@@ -11977,7 +11979,7 @@ InventoryResult Player::CanUseItem(ItemTemplate const* proto) const
         if (proto->HolidayId && !IsHolidayActive((HolidayIds)proto->HolidayId))
             return EQUIP_ERR_CANT_DO_RIGHT_NOW;
 
-        return EQUIP_ERR_OK;
+        return sHookMgr->OnCanUseItem(this, proto->ItemId);
     }
 
     return EQUIP_ERR_ITEM_NOT_FOUND;
@@ -12412,13 +12414,15 @@ Item* Player::EquipItem(uint16 pos, Item* pItem, bool update)
 
         ApplyEquipCooldown(pItem2);
 
+        sHookMgr->OnEquip(this, pItem2, bag, slot);
         return pItem2;
     }
 
     // only for full equip instead adding to stack
     UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_ITEM, pItem->GetEntry());
     UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_EPIC_ITEM, pItem->GetEntry(), slot);
-
+    
+    sHookMgr->OnEquip(this, pItem, bag, slot);
     return pItem;
 }
 
@@ -22106,10 +22110,10 @@ bool Player::IsAlwaysDetectableFor(WorldObject const* seer) const
 
     if (const Player* seerPlayer = seer->ToPlayer())
         if (IsGroupVisibleFor(seerPlayer))
-            return !(seerPlayer->duel && seerPlayer->duel->startTime != 0 && seerPlayer->duel->opponent == this);
+            return true;
 
-    return false;
-}
+     return false;
+ }
 
 bool Player::IsVisibleGloballyFor(Player const* u) const
 {
@@ -24506,6 +24510,7 @@ void Player::StoreLootItem(uint8 lootSlot, Loot* loot)
         if (loot->containerID > 0)
             loot->DeleteLootItemFromContainerItemDB(item->itemid);
 
+        sHookMgr->OnLootItem(this, newitem, item->count, this->GetLootGUID());
     }
     else
         SendEquipError(msg, NULL, NULL, item->itemid);
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 021b86d..0bb1e9b 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -11742,6 +11742,8 @@ void Unit::SetInCombatState(bool PvP, Unit* enemy)
         if (!(creature->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_MOUNTED_COMBAT))
             Dismount();
     }
+    else if(Player* player = ToPlayer())
+        sScriptMgr->OnPlayerEnterCombat(player, enemy);
 
     for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
     {
@@ -11775,8 +11777,11 @@ void Unit::ClearInCombat()
         else if (!IsCharmed())
             return;
     }
-    else
-        ToPlayer()->UpdatePotionCooldown();
+    else if(Player* player = ToPlayer())
+    {
+        player->UpdatePotionCooldown();
+        sScriptMgr->OnPlayerLeaveCombat(player);
+    }
 
     RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);
 }
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index 8a1eb78..5474e33 100644
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -735,13 +735,8 @@ enum MovementFlags
 
     /// @todo if needed: add more flags to this masks that are exclusive to players
     MOVEMENTFLAG_MASK_PLAYER_ONLY =
-        MOVEMENTFLAG_FLYING,
-
-    /// Movement flags that have change status opcodes associated for players
-    MOVEMENTFLAG_MASK_HAS_PLAYER_STATUS_OPCODE = MOVEMENTFLAG_DISABLE_GRAVITY | MOVEMENTFLAG_ROOT |
-        MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_WATERWALKING | MOVEMENTFLAG_FALLING_SLOW | MOVEMENTFLAG_HOVER
+        MOVEMENTFLAG_FLYING
 };
-
 enum MovementFlags2
 {
     MOVEMENTFLAG2_NONE                     = 0x00000000,
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index ae389dd..6a4bbcc 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -2000,7 +2000,7 @@ uint64 ObjectMgr::GetPlayerGUIDByName(std::string const& name) const
     return guid;
 }
 
-bool ObjectMgr::GetPlayerNameByGUID(uint64 guid, std::string& name) const
+bool ObjectMgr::GetPlayerNameByGUID(uint64 guid, std::string &name) const
 {
     // prevent DB access for online player
     if (Player* player = ObjectAccessor::FindPlayer(guid))
@@ -2179,7 +2179,7 @@ void ObjectMgr::LoadItemTemplates()
         itemTemplate.Name1                     = fields[4].GetString();
         itemTemplate.DisplayInfoID             = fields[5].GetUInt32();
         itemTemplate.Quality                   = uint32(fields[6].GetUInt8());
-        itemTemplate.Flags                     = uint32(fields[7].GetUInt32());
+        itemTemplate.Flags                     = uint32(fields[7].GetInt64());
         itemTemplate.Flags2                    = fields[8].GetUInt32();
         itemTemplate.BuyCount                  = uint32(fields[9].GetUInt8());
         itemTemplate.BuyPrice                  = int32(fields[10].GetInt64());
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index 1c986e2..266fe8e 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -716,19 +716,7 @@ class ObjectMgr
         void GetPlayerLevelInfo(uint32 race, uint32 class_, uint8 level, PlayerLevelInfo* info) const;
 
         uint64 GetPlayerGUIDByName(std::string const& name) const;
-
-        /**
-        * Retrieves the player name by guid.
-        *
-        * If the player is online, the name is retrieved immediately otherwise
-        * a database query is done.
-        *
-        * @param guid player full guid
-        * @param name returned name
-        *
-        * @return true if player was found, false otherwise
-        */
-        bool GetPlayerNameByGUID(uint64 guid, std::string& name) const;
+        bool GetPlayerNameByGUID(uint64 guid, std::string &name) const;
         uint32 GetPlayerTeamByGUID(uint64 guid) const;
         uint32 GetPlayerAccountIdByGUID(uint64 guid) const;
         uint32 GetPlayerAccountIdByPlayerName(std::string const& name) const;
diff --git a/src/server/game/Guilds/Guild.cpp b/src/server/game/Guilds/Guild.cpp
index d31b4b7..0369615 100644
--- a/src/server/game/Guilds/Guild.cpp
+++ b/src/server/game/Guilds/Guild.cpp
@@ -2123,7 +2123,7 @@ bool Guild::Validate()
         _SetLeaderGUID(pLeader);
 
     // Check config if multiple guildmasters are allowed
-    if (!sConfigMgr->GetBoolDefault("Guild.AllowMultipleGuildMaster", 0))
+    if (!ConfigMgr::GetBoolDefault("Guild.AllowMultipleGuildMaster", 0))
         for (Members::iterator itr = m_members.begin(); itr != m_members.end(); ++itr)
             if (itr->second->GetRankId() == GR_GUILDMASTER && !itr->second->IsSamePlayer(m_leaderGuid))
                 itr->second->ChangeRank(GR_OFFICER);
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index 415b674..708b16f 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -46,6 +46,7 @@
 #include "World.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
+#include "HookMgr.h"
 
 
 class LoginQueryHolder : public SQLQueryHolder
@@ -998,6 +999,9 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
     }
 
     if (pCurrChar->HasAtLoginFlag(AT_LOGIN_FIRST))
+        sHookMgr->OnFirstLogin(pCurrChar);
+
+    if (pCurrChar->HasAtLoginFlag(AT_LOGIN_FIRST))
         pCurrChar->RemoveAtLoginFlag(AT_LOGIN_FIRST);
 
     // show time before shutdown if shutdown planned.
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index 4ebccc5..c62241f 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -39,6 +39,7 @@
 #include "Util.h"
 #include "ScriptMgr.h"
 #include "AccountMgr.h"
+#include "HookMgr.h"
 
 void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
 {
@@ -248,6 +249,9 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
             }
 
+            if(!sHookMgr->OnChat(sender, type, lang, msg))
+                return;
+
             if (type == CHAT_MSG_SAY)
                 sender->Say(msg, lang);
             else if (type == CHAT_MSG_EMOTE)
@@ -311,6 +315,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
+            if(!sHookMgr->OnChat(sender, type, lang, msg, group))
+                return;
 
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, uint8(type), lang, NULL, 0, msg.c_str(), NULL);
@@ -323,6 +329,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 if (Guild* guild = sGuildMgr->GetGuildById(GetPlayer()->GetGuildId()))
                 {
                     sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, guild);
+                    if(!sHookMgr->OnChat(sender, type, lang, msg, guild))
+                        return;
 
                     guild->BroadcastToGuild(this, false, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
                 }
@@ -335,6 +343,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 if (Guild* guild = sGuildMgr->GetGuildById(GetPlayer()->GetGuildId()))
                 {
                     sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, guild);
+                    if(!sHookMgr->OnChat(sender, type, lang, msg, guild))
+                        return;
 
                     guild->BroadcastToGuild(this, true, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
                 }
@@ -352,6 +362,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             }
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
+            if(!sHookMgr->OnChat(sender, type, lang, msg, group))
+                return;
 
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_RAID, lang, "", 0, msg.c_str(), NULL);
@@ -369,6 +381,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             }
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
+            if(!sHookMgr->OnChat(sender, type, lang, msg, group))
+                return;
 
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_RAID_LEADER, lang, "", 0, msg.c_str(), NULL);
@@ -381,6 +395,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
+            if(!sHookMgr->OnChat(sender, type, lang, msg, group))
+                return;
 
             WorldPacket data;
             //in battleground, raid warning is sent only to players in battleground - code is ok
@@ -395,6 +411,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
+            if(!sHookMgr->OnChat(sender, type, lang, msg, group))
+                return;
 
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_BATTLEGROUND, lang, "", 0, msg.c_str(), NULL);
@@ -408,6 +426,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
+            if(!sHookMgr->OnChat(sender, type, lang, msg, group))
+                return;
 
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_BATTLEGROUND_LEADER, lang, "", 0, msg.c_str(), NULL);
@@ -429,6 +449,9 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 if (Channel* chn = cMgr->GetChannel(channel, _player))
                 {
                     sScriptMgr->OnPlayerChat(_player, type, lang, msg, chn);
+                    if(!sHookMgr->OnChat(sender, type, lang, msg, chn))
+                        return;
+
                     chn->Say(_player->GetGUID(), msg.c_str(), lang);
                 }
             }
@@ -455,6 +478,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 }
 
                 sScriptMgr->OnPlayerChat(_player, type, lang, msg);
+                if(!sHookMgr->OnChat(sender, type, lang, msg))
+                    return;
             }
             break;
         }
@@ -478,6 +503,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             }
 
             sScriptMgr->OnPlayerChat(_player, type, lang, msg);
+            if(!sHookMgr->OnChat(sender, type, lang, msg))
+                return;
             break;
         }
         default:
diff --git a/src/server/game/Handlers/ItemHandler.cpp b/src/server/game/Handlers/ItemHandler.cpp
index 90c1bc4..bd7c5f1 100644
--- a/src/server/game/Handlers/ItemHandler.cpp
+++ b/src/server/game/Handlers/ItemHandler.cpp
@@ -27,6 +27,7 @@
 #include "UpdateData.h"
 #include "ObjectAccessor.h"
 #include "SpellInfo.h"
+#include "HookMgr.h"
 
 void WorldSession::HandleSplitItemOpcode(WorldPacket& recvData)
 {
diff --git a/src/server/game/Handlers/LootHandler.cpp b/src/server/game/Handlers/LootHandler.cpp
index cdcf4c5..0a091dd 100644
--- a/src/server/game/Handlers/LootHandler.cpp
+++ b/src/server/game/Handlers/LootHandler.cpp
@@ -30,6 +30,7 @@
 #include "World.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
+#include "HookMgr.h"
 
 void WorldSession::HandleAutostoreLootItemOpcode(WorldPacket& recvData)
 {
@@ -471,6 +472,7 @@ void WorldSession::HandleLootMasterGiveOpcode(WorldPacket& recvData)
     target->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item.itemid, item.count);
     target->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_TYPE, loot->loot_type, item.count);
     target->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_EPIC_ITEM, item.itemid, item.count);
+    sHookMgr->OnLootItem(target, newitem, item.count, lootguid);
 
     // mark as looted
     item.count=0;
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index e8d781a..c6954f5 100644
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -55,6 +55,7 @@
 #include "BattlegroundMgr.h"
 #include "Battlefield.h"
 #include "BattlefieldMgr.h"
+#include "HookMgr.h"
 
 void WorldSession::HandleRepopRequestOpcode(WorldPacket& recvData)
 {
@@ -100,6 +101,12 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
     if (_player->PlayerTalkClass->IsGossipOptionCoded(gossipListId))
         recvData >> code;
 
+    if (IS_ITEM_GUID(guid) || IS_PLAYER_GUID(guid))
+    {
+        sHookMgr->HandleGossipSelectOption(GetPlayer(), guid, GetPlayer()->PlayerTalkClass->GetGossipOptionSender(gossipListId), GetPlayer()->PlayerTalkClass->GetGossipOptionAction(gossipListId), code, menuId);
+        return;
+    }
+
     Creature* unit = NULL;
     GameObject* go = NULL;
     if (IS_CRE_OR_VEH_GUID(guid))
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index 0dc96b3..6c1cdf9 100644
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -32,6 +32,8 @@
 #include "CreatureAI.h"
 #include "Player.h"
 #include "WorldPacket.h"
+#include "LuaEngine.h"
+#include "HookMgr.h"
 
 // This is the global static registry of scripts.
 template<class TScript>
@@ -181,6 +183,8 @@ void ScriptMgr::Initialize()
 
     FillSpellSummary();
     AddScripts();
+	/* Eluna [Lua Engine] */
+    sEluna->StartEluna(false);
 
     TC_LOG_INFO(LOG_FILTER_SERVER_LOADING, ">> Loaded %u C++ scripts in %u ms", GetScriptCount(), GetMSTimeDiffToNow(oldMSTime));
 }
@@ -646,6 +650,9 @@ bool ScriptMgr::OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effInd
     ASSERT(caster);
     ASSERT(target);
 
+    if(sHookMgr->OnDummyEffect(caster, spellId, effIndex, target))
+        return true;
+
     GET_SCRIPT_RET(ItemScript, target->GetScriptId(), tmpscript, false);
     return tmpscript->OnDummyEffect(caster, spellId, effIndex, target);
 }
@@ -656,6 +663,9 @@ bool ScriptMgr::OnQuestAccept(Player* player, Item* item, Quest const* quest)
     ASSERT(item);
     ASSERT(quest);
 
+    if(sHookMgr->OnQuestAccept(player, item, quest))
+        return true;
+
     GET_SCRIPT_RET(ItemScript, item->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestAccept(player, item, quest);
@@ -666,6 +676,9 @@ bool ScriptMgr::OnItemUse(Player* player, Item* item, SpellCastTargets const& ta
     ASSERT(player);
     ASSERT(item);
 
+    if(sHookMgr->OnUse(player, item, targets))
+        return true;
+
     GET_SCRIPT_RET(ItemScript, item->GetScriptId(), tmpscript, false);
     return tmpscript->OnUse(player, item, targets);
 }
@@ -675,6 +688,9 @@ bool ScriptMgr::OnItemExpire(Player* player, ItemTemplate const* proto)
     ASSERT(player);
     ASSERT(proto);
 
+    if(sHookMgr->OnExpire(player, proto))
+        return true;
+
     GET_SCRIPT_RET(ItemScript, proto->ScriptId, tmpscript, false);
     return tmpscript->OnExpire(player, proto);
 }
@@ -684,6 +700,9 @@ bool ScriptMgr::OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effInd
     ASSERT(caster);
     ASSERT(target);
 
+    if(sHookMgr->OnDummyEffect(caster, spellId, effIndex, target))
+        return true;
+
     GET_SCRIPT_RET(CreatureScript, target->GetScriptId(), tmpscript, false);
     return tmpscript->OnDummyEffect(caster, spellId, effIndex, target);
 }
@@ -693,6 +712,9 @@ bool ScriptMgr::OnGossipHello(Player* player, Creature* creature)
     ASSERT(player);
     ASSERT(creature);
 
+    if(sHookMgr->OnGossipHello(player, creature))
+        return true;
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnGossipHello(player, creature);
@@ -703,6 +725,9 @@ bool ScriptMgr::OnGossipSelect(Player* player, Creature* creature, uint32 sender
     ASSERT(player);
     ASSERT(creature);
 
+    if(sHookMgr->OnGossipSelect(player, creature, sender, action))
+        return true;
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     return tmpscript->OnGossipSelect(player, creature, sender, action);
 }
@@ -713,6 +738,9 @@ bool ScriptMgr::OnGossipSelectCode(Player* player, Creature* creature, uint32 se
     ASSERT(creature);
     ASSERT(code);
 
+    if(sHookMgr->OnGossipSelectCode(player, creature, sender, action, code))
+        return true;
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     return tmpscript->OnGossipSelectCode(player, creature, sender, action, code);
 }
@@ -723,6 +751,12 @@ bool ScriptMgr::OnQuestAccept(Player* player, Creature* creature, Quest const* q
     ASSERT(creature);
     ASSERT(quest);
 
+    if(sHookMgr->OnQuestAccept(player, creature, quest))
+    {
+        player->PlayerTalkClass->ClearMenus();
+        return true;
+    }
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestAccept(player, creature, quest);
@@ -734,6 +768,12 @@ bool ScriptMgr::OnQuestSelect(Player* player, Creature* creature, Quest const* q
     ASSERT(creature);
     ASSERT(quest);
 
+    if(sHookMgr->OnQuestSelect(player, creature, quest))
+    {
+        player->PlayerTalkClass->ClearMenus();
+        return true;
+    }
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestSelect(player, creature, quest);
@@ -745,6 +785,12 @@ bool ScriptMgr::OnQuestComplete(Player* player, Creature* creature, Quest const*
     ASSERT(creature);
     ASSERT(quest);
 
+    if(sHookMgr->OnQuestComplete(player, creature, quest))
+    {
+        player->PlayerTalkClass->ClearMenus();
+        return true;
+    }
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestComplete(player, creature, quest);
@@ -756,6 +802,12 @@ bool ScriptMgr::OnQuestReward(Player* player, Creature* creature, Quest const* q
     ASSERT(creature);
     ASSERT(quest);
 
+    if(sHookMgr->OnQuestReward(player, creature, quest, opt))
+    {
+        player->PlayerTalkClass->ClearMenus();
+        return true;
+    }
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestReward(player, creature, quest, opt);
@@ -766,7 +818,12 @@ uint32 ScriptMgr::GetDialogStatus(Player* player, Creature* creature)
     ASSERT(player);
     ASSERT(creature);
 
-    /// @todo 100 is a funny magic number to have hanging around here...
+    if(uint32 dialogid = sHookMgr->GetDialogStatus(player, creature))
+    {
+        player->PlayerTalkClass->ClearMenus();
+        return dialogid;
+    }
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, 100);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->GetDialogStatus(player, creature);
@@ -776,6 +833,9 @@ CreatureAI* ScriptMgr::GetCreatureAI(Creature* creature)
 {
     ASSERT(creature);
 
+    if(CreatureAI* luaAI = sEluna->LuaCreatureAI->GetAI(creature))
+        return luaAI;
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, NULL);
     return tmpscript->GetAI(creature);
 }
@@ -784,6 +844,9 @@ GameObjectAI* ScriptMgr::GetGameObjectAI(GameObject* gameobject)
 {
     ASSERT(gameobject);
 
+    if(GameObjectAI* luaAI = sEluna->LuaGameObjectAI->GetAI(gameobject))
+        return luaAI;
+
     GET_SCRIPT_RET(GameObjectScript, gameobject->GetScriptId(), tmpscript, NULL);
     return tmpscript->GetAI(gameobject);
 }
@@ -801,6 +864,9 @@ bool ScriptMgr::OnGossipHello(Player* player, GameObject* go)
     ASSERT(player);
     ASSERT(go);
 
+    if(sHookMgr->OnGossipHello(player, go))
+        return true;
+
     GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnGossipHello(player, go);
@@ -811,6 +877,9 @@ bool ScriptMgr::OnGossipSelect(Player* player, GameObject* go, uint32 sender, ui
     ASSERT(player);
     ASSERT(go);
 
+    if(sHookMgr->OnGossipSelect(player, go, sender, action))
+        return true;
+
     GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);
     return tmpscript->OnGossipSelect(player, go, sender, action);
 }
@@ -821,6 +890,9 @@ bool ScriptMgr::OnGossipSelectCode(Player* player, GameObject* go, uint32 sender
     ASSERT(go);
     ASSERT(code);
 
+    if(sHookMgr->OnGossipSelectCode(player, go, sender, action, code))
+        return true;
+
     GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);
     return tmpscript->OnGossipSelectCode(player, go, sender, action, code);
 }
@@ -831,6 +903,9 @@ bool ScriptMgr::OnQuestAccept(Player* player, GameObject* go, Quest const* quest
     ASSERT(go);
     ASSERT(quest);
 
+    if(sHookMgr->OnQuestAccept(player, go, quest))
+        return true;
+
     GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestAccept(player, go, quest);
@@ -842,6 +917,9 @@ bool ScriptMgr::OnQuestReward(Player* player, GameObject* go, Quest const* quest
     ASSERT(go);
     ASSERT(quest);
 
+    if(sHookMgr->OnQuestReward(player, go, quest, opt))
+        return true;
+
     GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestReward(player, go, quest, opt);
@@ -852,7 +930,12 @@ uint32 ScriptMgr::GetDialogStatus(Player* player, GameObject* go)
     ASSERT(player);
     ASSERT(go);
 
-    /// @todo 100 is a funny magic number to have hanging around here...
+    if(uint32 dialogid = sHookMgr->GetDialogStatus(player, go))
+    {
+        player->PlayerTalkClass->ClearMenus();
+        return dialogid;
+    }
+
     GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, 100);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->GetDialogStatus(player, go);
@@ -862,6 +945,8 @@ void ScriptMgr::OnGameObjectDestroyed(GameObject* go, Player* player)
 {
     ASSERT(go);
 
+    sHookMgr->OnDestroyed(go, player);
+
     GET_SCRIPT(GameObjectScript, go->GetScriptId(), tmpscript);
     tmpscript->OnDestroyed(go, player);
 }
@@ -870,6 +955,8 @@ void ScriptMgr::OnGameObjectDamaged(GameObject* go, Player* player)
 {
     ASSERT(go);
 
+    sHookMgr->OnDamaged(go, player);
+
     GET_SCRIPT(GameObjectScript, go->GetScriptId(), tmpscript);
     tmpscript->OnDamaged(go, player);
 }
@@ -878,6 +965,8 @@ void ScriptMgr::OnGameObjectLootStateChanged(GameObject* go, uint32 state, Unit*
 {
     ASSERT(go);
 
+    sHookMgr->OnLootStateChanged(go, state, unit);
+
     GET_SCRIPT(GameObjectScript, go->GetScriptId(), tmpscript);
     tmpscript->OnLootStateChanged(go, state, unit);
 }
@@ -886,6 +975,8 @@ void ScriptMgr::OnGameObjectStateChanged(GameObject* go, uint32 state)
 {
     ASSERT(go);
 
+    sHookMgr->OnGameObjectStateChanged(go, state);
+
     GET_SCRIPT(GameObjectScript, go->GetScriptId(), tmpscript);
     tmpscript->OnGameObjectStateChanged(go, state);
 }
@@ -903,6 +994,9 @@ bool ScriptMgr::OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effInd
     ASSERT(caster);
     ASSERT(target);
 
+    if(sHookMgr->OnDummyEffect(caster, spellId, effIndex, target))
+        return true;
+
     GET_SCRIPT_RET(GameObjectScript, target->GetScriptId(), tmpscript, false);
     return tmpscript->OnDummyEffect(caster, spellId, effIndex, target);
 }
@@ -912,6 +1006,9 @@ bool ScriptMgr::OnAreaTrigger(Player* player, AreaTriggerEntry const* trigger)
     ASSERT(player);
     ASSERT(trigger);
 
+    if(sHookMgr->OnTrigger(player, trigger))
+        return true;
+
     GET_SCRIPT_RET(AreaTriggerScript, sObjectMgr->GetAreaTriggerScriptId(trigger->id), tmpscript, false);
     return tmpscript->OnTrigger(player, trigger);
 }
@@ -945,6 +1042,8 @@ void ScriptMgr::OnWeatherChange(Weather* weather, WeatherState state, float grad
 {
     ASSERT(weather);
 
+    sHookMgr->OnChange(weather, state, grade);
+
     GET_SCRIPT(WeatherScript, weather->GetScriptId(), tmpscript);
     tmpscript->OnChange(weather, state, grade);
 }
@@ -993,6 +1092,9 @@ bool ScriptMgr::OnConditionCheck(Condition* condition, ConditionSourceInfo& sour
 {
     ASSERT(condition);
 
+    if(sHookMgr->OnConditionCheck(condition, sourceInfo))
+        return true;
+
     GET_SCRIPT_RET(ConditionScript, condition->ScriptId, tmpscript, true);
     return tmpscript->OnConditionCheck(condition, sourceInfo);
 }
@@ -1067,6 +1169,8 @@ void ScriptMgr::OnAddPassenger(Transport* transport, Player* player)
     ASSERT(transport);
     ASSERT(player);
 
+    sHookMgr->OnAddPassenger(transport, player);
+
     GET_SCRIPT(TransportScript, transport->GetScriptId(), tmpscript);
     tmpscript->OnAddPassenger(transport, player);
 }
@@ -1076,6 +1180,8 @@ void ScriptMgr::OnAddCreaturePassenger(Transport* transport, Creature* creature)
     ASSERT(transport);
     ASSERT(creature);
 
+    sHookMgr->OnAddCreaturePassenger(transport, creature);
+
     GET_SCRIPT(TransportScript, transport->GetScriptId(), tmpscript);
     tmpscript->OnAddCreaturePassenger(transport, creature);
 }
@@ -1085,6 +1191,8 @@ void ScriptMgr::OnRemovePassenger(Transport* transport, Player* player)
     ASSERT(transport);
     ASSERT(player);
 
+    sHookMgr->OnRemovePassenger(transport, player);
+
     GET_SCRIPT(TransportScript, transport->GetScriptId(), tmpscript);
     tmpscript->OnRemovePassenger(transport, player);
 }
@@ -1099,6 +1207,8 @@ void ScriptMgr::OnTransportUpdate(Transport* transport, uint32 diff)
 
 void ScriptMgr::OnRelocate(Transport* transport, uint32 waypointId, uint32 mapId, float x, float y, float z)
 {
+    sHookMgr->OnRelocate(transport, waypointId, mapId, x, y, z);
+
     GET_SCRIPT(TransportScript, transport->GetScriptId(), tmpscript);
     tmpscript->OnRelocate(transport, waypointId, mapId, x, y, z);
 }
@@ -1258,6 +1368,16 @@ void ScriptMgr::OnPlayerUpdateZone(Player* player, uint32 newZone, uint32 newAre
     FOREACH_SCRIPT(PlayerScript)->OnUpdateZone(player, newZone, newArea);
 }
 
+void ScriptMgr::OnPlayerEnterCombat(Player* player, Unit* enemy)
+{
+    FOREACH_SCRIPT(PlayerScript)->OnPlayerEnterCombat(player, enemy);
+}
+
+void ScriptMgr::OnPlayerLeaveCombat(Player* player)
+{
+    FOREACH_SCRIPT(PlayerScript)->OnPlayerLeaveCombat(player);
+}
+
 // Guild
 void ScriptMgr::OnGuildAddMember(Guild* guild, Player* player, uint8& plRank)
 {
diff --git a/src/server/game/Scripting/ScriptMgr.h b/src/server/game/Scripting/ScriptMgr.h
index e794650..2072b5f 100644
--- a/src/server/game/Scripting/ScriptMgr.h
+++ b/src/server/game/Scripting/ScriptMgr.h
@@ -754,6 +754,12 @@ class PlayerScript : public UnitScript
 
         // Called when a player changes to a new map (after moving to new map)
         virtual void OnMapChanged(Player* /*player*/) { }
+
+        // Called when a player enters combat
+        virtual void OnPlayerEnterCombat(Player* /*player*/, Unit* /*enemy*/) { }
+
+        // Called when a player leaves combat
+        virtual void OnPlayerLeaveCombat(Player* /*player*/) { }
 };
 
 class GuildScript : public ScriptObject
@@ -1028,6 +1034,8 @@ class ScriptMgr
         void OnPlayerSave(Player* player);
         void OnPlayerBindToInstance(Player* player, Difficulty difficulty, uint32 mapid, bool permanent);
         void OnPlayerUpdateZone(Player* player, uint32 newZone, uint32 newArea);
+        void OnPlayerEnterCombat(Player* player, Unit* enemy);
+        void OnPlayerLeaveCombat(Player* player);
 
     public: /* GuildScript */
 
diff --git a/src/server/game/Server/Protocol/PacketLog.cpp b/src/server/game/Server/Protocol/PacketLog.cpp
index aeeb0a2..fe8b680 100644
--- a/src/server/game/Server/Protocol/PacketLog.cpp
+++ b/src/server/game/Server/Protocol/PacketLog.cpp
@@ -35,13 +35,13 @@ PacketLog::~PacketLog()
 
 void PacketLog::Initialize()
 {
-    std::string logsDir = sConfigMgr->GetStringDefault("LogsDir", "");
+    std::string logsDir = ConfigMgr::GetStringDefault("LogsDir", "");
 
     if (!logsDir.empty())
         if ((logsDir.at(logsDir.length()-1) != '/') && (logsDir.at(logsDir.length()-1) != '\\'))
             logsDir.push_back('/');
 
-    std::string logname = sConfigMgr->GetStringDefault("PacketLogFile", "");
+    std::string logname = ConfigMgr::GetStringDefault("PacketLogFile", "");
     if (!logname.empty())
         _file = fopen((logsDir + logname).c_str(), "wb");
 }
diff --git a/src/server/game/Server/WorldSocketMgr.cpp b/src/server/game/Server/WorldSocketMgr.cpp
index 57a7777..ce89243 100644
--- a/src/server/game/Server/WorldSocketMgr.cpp
+++ b/src/server/game/Server/WorldSocketMgr.cpp
@@ -230,9 +230,9 @@ WorldSocketMgr::~WorldSocketMgr()
 int
 WorldSocketMgr::StartReactiveIO (ACE_UINT16 port, const char* address)
 {
-    m_UseNoDelay = sConfigMgr->GetBoolDefault ("Network.TcpNodelay", true);
+    m_UseNoDelay = ConfigMgr::GetBoolDefault ("Network.TcpNodelay", true);
 
-    int num_threads = sConfigMgr->GetIntDefault ("Network.Threads", 1);
+    int num_threads = ConfigMgr::GetIntDefault ("Network.Threads", 1);
 
     if (num_threads <= 0)
     {
@@ -247,9 +247,9 @@ WorldSocketMgr::StartReactiveIO (ACE_UINT16 port, const char* address)
     TC_LOG_DEBUG(LOG_FILTER_GENERAL, "Max allowed socket connections %d", ACE::max_handles());
 
     // -1 means use default
-    m_SockOutKBuff = sConfigMgr->GetIntDefault ("Network.OutKBuff", -1);
+    m_SockOutKBuff = ConfigMgr::GetIntDefault ("Network.OutKBuff", -1);
 
-    m_SockOutUBuff = sConfigMgr->GetIntDefault ("Network.OutUBuff", 65536);
+    m_SockOutUBuff = ConfigMgr::GetIntDefault ("Network.OutUBuff", 65536);
 
     if (m_SockOutUBuff <= 0)
     {
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index 22940c3..4af1723 100644
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -65,6 +65,7 @@
 #include "InstanceScript.h"
 #include "PathGenerator.h"
 #include "ReputationMgr.h"
+#include "HookMgr.h"
 
 pEffect SpellEffects[TOTAL_SPELL_EFFECTS]=
 {
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 56f9ec6..645c14b 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -397,123 +397,123 @@ void World::LoadConfigSettings(bool reload)
 {
     if (reload)
     {
-        if (!sConfigMgr->Reload())
+        if (!ConfigMgr::Load())
         {
-            TC_LOG_ERROR(LOG_FILTER_GENERAL, "World settings reload fail: can't read settings from %s.", sConfigMgr->GetFilename().c_str());
+            TC_LOG_ERROR(LOG_FILTER_GENERAL, "World settings reload fail: can't read settings from %s.", ConfigMgr::GetFilename().c_str());
             return;
         }
         sLog->LoadFromConfig();
     }
 
     ///- Read the player limit and the Message of the day from the config file
-    SetPlayerAmountLimit(sConfigMgr->GetIntDefault("PlayerLimit", 100));
-    SetMotd(sConfigMgr->GetStringDefault("Motd", "Welcome to a Trinity Core Server."));
+    SetPlayerAmountLimit(ConfigMgr::GetIntDefault("PlayerLimit", 100));
+    SetMotd(ConfigMgr::GetStringDefault("Motd", "Welcome to a Trinity Core Server."));
 
     ///- Read ticket system setting from the config file
-    m_bool_configs[CONFIG_ALLOW_TICKETS] = sConfigMgr->GetBoolDefault("AllowTickets", true);
+    m_bool_configs[CONFIG_ALLOW_TICKETS] = ConfigMgr::GetBoolDefault("AllowTickets", true);
 
     ///- Get string for new logins (newly created characters)
-    SetNewCharString(sConfigMgr->GetStringDefault("PlayerStart.String", ""));
+    SetNewCharString(ConfigMgr::GetStringDefault("PlayerStart.String", ""));
 
     ///- Send server info on login?
-    m_int_configs[CONFIG_ENABLE_SINFO_LOGIN] = sConfigMgr->GetIntDefault("Server.LoginInfo", 0);
+    m_int_configs[CONFIG_ENABLE_SINFO_LOGIN] = ConfigMgr::GetIntDefault("Server.LoginInfo", 0);
 
     ///- Read all rates from the config file
-    rate_values[RATE_HEALTH]      = sConfigMgr->GetFloatDefault("Rate.Health", 1);
+    rate_values[RATE_HEALTH]      = ConfigMgr::GetFloatDefault("Rate.Health", 1);
     if (rate_values[RATE_HEALTH] < 0)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Rate.Health (%f) must be > 0. Using 1 instead.", rate_values[RATE_HEALTH]);
         rate_values[RATE_HEALTH] = 1;
     }
-    rate_values[RATE_POWER_MANA]  = sConfigMgr->GetFloatDefault("Rate.Mana", 1);
+    rate_values[RATE_POWER_MANA]  = ConfigMgr::GetFloatDefault("Rate.Mana", 1);
     if (rate_values[RATE_POWER_MANA] < 0)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Rate.Mana (%f) must be > 0. Using 1 instead.", rate_values[RATE_POWER_MANA]);
         rate_values[RATE_POWER_MANA] = 1;
     }
-    rate_values[RATE_POWER_RAGE_INCOME] = sConfigMgr->GetFloatDefault("Rate.Rage.Income", 1);
-    rate_values[RATE_POWER_RAGE_LOSS]   = sConfigMgr->GetFloatDefault("Rate.Rage.Loss", 1);
+    rate_values[RATE_POWER_RAGE_INCOME] = ConfigMgr::GetFloatDefault("Rate.Rage.Income", 1);
+    rate_values[RATE_POWER_RAGE_LOSS]   = ConfigMgr::GetFloatDefault("Rate.Rage.Loss", 1);
     if (rate_values[RATE_POWER_RAGE_LOSS] < 0)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Rate.Rage.Loss (%f) must be > 0. Using 1 instead.", rate_values[RATE_POWER_RAGE_LOSS]);
         rate_values[RATE_POWER_RAGE_LOSS] = 1;
     }
-    rate_values[RATE_POWER_RUNICPOWER_INCOME] = sConfigMgr->GetFloatDefault("Rate.RunicPower.Income", 1);
-    rate_values[RATE_POWER_RUNICPOWER_LOSS]   = sConfigMgr->GetFloatDefault("Rate.RunicPower.Loss", 1);
+    rate_values[RATE_POWER_RUNICPOWER_INCOME] = ConfigMgr::GetFloatDefault("Rate.RunicPower.Income", 1);
+    rate_values[RATE_POWER_RUNICPOWER_LOSS]   = ConfigMgr::GetFloatDefault("Rate.RunicPower.Loss", 1);
     if (rate_values[RATE_POWER_RUNICPOWER_LOSS] < 0)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Rate.RunicPower.Loss (%f) must be > 0. Using 1 instead.", rate_values[RATE_POWER_RUNICPOWER_LOSS]);
         rate_values[RATE_POWER_RUNICPOWER_LOSS] = 1;
     }
-    rate_values[RATE_POWER_FOCUS]  = sConfigMgr->GetFloatDefault("Rate.Focus", 1.0f);
-    rate_values[RATE_POWER_ENERGY] = sConfigMgr->GetFloatDefault("Rate.Energy", 1.0f);
-
-    rate_values[RATE_SKILL_DISCOVERY]      = sConfigMgr->GetFloatDefault("Rate.Skill.Discovery", 1.0f);
-
-    rate_values[RATE_DROP_ITEM_POOR]       = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Poor", 1.0f);
-    rate_values[RATE_DROP_ITEM_NORMAL]     = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Normal", 1.0f);
-    rate_values[RATE_DROP_ITEM_UNCOMMON]   = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Uncommon", 1.0f);
-    rate_values[RATE_DROP_ITEM_RARE]       = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Rare", 1.0f);
-    rate_values[RATE_DROP_ITEM_EPIC]       = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Epic", 1.0f);
-    rate_values[RATE_DROP_ITEM_LEGENDARY]  = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Legendary", 1.0f);
-    rate_values[RATE_DROP_ITEM_ARTIFACT]   = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Artifact", 1.0f);
-    rate_values[RATE_DROP_ITEM_REFERENCED] = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Referenced", 1.0f);
-    rate_values[RATE_DROP_ITEM_REFERENCED_AMOUNT] = sConfigMgr->GetFloatDefault("Rate.Drop.Item.ReferencedAmount", 1.0f);
-    rate_values[RATE_DROP_MONEY]  = sConfigMgr->GetFloatDefault("Rate.Drop.Money", 1.0f);
-    rate_values[RATE_XP_KILL]     = sConfigMgr->GetFloatDefault("Rate.XP.Kill", 1.0f);
-    rate_values[RATE_XP_QUEST]    = sConfigMgr->GetFloatDefault("Rate.XP.Quest", 1.0f);
-    rate_values[RATE_XP_EXPLORE]  = sConfigMgr->GetFloatDefault("Rate.XP.Explore", 1.0f);
-    rate_values[RATE_REPAIRCOST]  = sConfigMgr->GetFloatDefault("Rate.RepairCost", 1.0f);
+    rate_values[RATE_POWER_FOCUS]  = ConfigMgr::GetFloatDefault("Rate.Focus", 1.0f);
+    rate_values[RATE_POWER_ENERGY] = ConfigMgr::GetFloatDefault("Rate.Energy", 1.0f);
+
+    rate_values[RATE_SKILL_DISCOVERY]      = ConfigMgr::GetFloatDefault("Rate.Skill.Discovery", 1.0f);
+
+    rate_values[RATE_DROP_ITEM_POOR]       = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Poor", 1.0f);
+    rate_values[RATE_DROP_ITEM_NORMAL]     = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Normal", 1.0f);
+    rate_values[RATE_DROP_ITEM_UNCOMMON]   = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Uncommon", 1.0f);
+    rate_values[RATE_DROP_ITEM_RARE]       = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Rare", 1.0f);
+    rate_values[RATE_DROP_ITEM_EPIC]       = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Epic", 1.0f);
+    rate_values[RATE_DROP_ITEM_LEGENDARY]  = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Legendary", 1.0f);
+    rate_values[RATE_DROP_ITEM_ARTIFACT]   = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Artifact", 1.0f);
+    rate_values[RATE_DROP_ITEM_REFERENCED] = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Referenced", 1.0f);
+    rate_values[RATE_DROP_ITEM_REFERENCED_AMOUNT] = ConfigMgr::GetFloatDefault("Rate.Drop.Item.ReferencedAmount", 1.0f);
+    rate_values[RATE_DROP_MONEY]  = ConfigMgr::GetFloatDefault("Rate.Drop.Money", 1.0f);
+    rate_values[RATE_XP_KILL]     = ConfigMgr::GetFloatDefault("Rate.XP.Kill", 1.0f);
+    rate_values[RATE_XP_QUEST]    = ConfigMgr::GetFloatDefault("Rate.XP.Quest", 1.0f);
+    rate_values[RATE_XP_EXPLORE]  = ConfigMgr::GetFloatDefault("Rate.XP.Explore", 1.0f);
+    rate_values[RATE_REPAIRCOST]  = ConfigMgr::GetFloatDefault("Rate.RepairCost", 1.0f);
     if (rate_values[RATE_REPAIRCOST] < 0.0f)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Rate.RepairCost (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_REPAIRCOST]);
         rate_values[RATE_REPAIRCOST] = 0.0f;
     }
-    rate_values[RATE_REPUTATION_GAIN]  = sConfigMgr->GetFloatDefault("Rate.Reputation.Gain", 1.0f);
-    rate_values[RATE_REPUTATION_LOWLEVEL_KILL]  = sConfigMgr->GetFloatDefault("Rate.Reputation.LowLevel.Kill", 1.0f);
-    rate_values[RATE_REPUTATION_LOWLEVEL_QUEST]  = sConfigMgr->GetFloatDefault("Rate.Reputation.LowLevel.Quest", 1.0f);
-    rate_values[RATE_REPUTATION_RECRUIT_A_FRIEND_BONUS] = sConfigMgr->GetFloatDefault("Rate.Reputation.RecruitAFriendBonus", 0.1f);
-    rate_values[RATE_CREATURE_NORMAL_DAMAGE]          = sConfigMgr->GetFloatDefault("Rate.Creature.Normal.Damage", 1.0f);
-    rate_values[RATE_CREATURE_ELITE_ELITE_DAMAGE]     = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.Elite.Damage", 1.0f);
-    rate_values[RATE_CREATURE_ELITE_RAREELITE_DAMAGE] = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.RAREELITE.Damage", 1.0f);
-    rate_values[RATE_CREATURE_ELITE_WORLDBOSS_DAMAGE] = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.WORLDBOSS.Damage", 1.0f);
-    rate_values[RATE_CREATURE_ELITE_RARE_DAMAGE]      = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.RARE.Damage", 1.0f);
-    rate_values[RATE_CREATURE_NORMAL_HP]          = sConfigMgr->GetFloatDefault("Rate.Creature.Normal.HP", 1.0f);
-    rate_values[RATE_CREATURE_ELITE_ELITE_HP]     = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.Elite.HP", 1.0f);
-    rate_values[RATE_CREATURE_ELITE_RAREELITE_HP] = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.RAREELITE.HP", 1.0f);
-    rate_values[RATE_CREATURE_ELITE_WORLDBOSS_HP] = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.WORLDBOSS.HP", 1.0f);
-    rate_values[RATE_CREATURE_ELITE_RARE_HP]      = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.RARE.HP", 1.0f);
-    rate_values[RATE_CREATURE_NORMAL_SPELLDAMAGE]          = sConfigMgr->GetFloatDefault("Rate.Creature.Normal.SpellDamage", 1.0f);
-    rate_values[RATE_CREATURE_ELITE_ELITE_SPELLDAMAGE]     = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.Elite.SpellDamage", 1.0f);
-    rate_values[RATE_CREATURE_ELITE_RAREELITE_SPELLDAMAGE] = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.RAREELITE.SpellDamage", 1.0f);
-    rate_values[RATE_CREATURE_ELITE_WORLDBOSS_SPELLDAMAGE] = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.WORLDBOSS.SpellDamage", 1.0f);
-    rate_values[RATE_CREATURE_ELITE_RARE_SPELLDAMAGE]      = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.RARE.SpellDamage", 1.0f);
-    rate_values[RATE_CREATURE_AGGRO]  = sConfigMgr->GetFloatDefault("Rate.Creature.Aggro", 1.0f);
-    rate_values[RATE_REST_INGAME]                    = sConfigMgr->GetFloatDefault("Rate.Rest.InGame", 1.0f);
-    rate_values[RATE_REST_OFFLINE_IN_TAVERN_OR_CITY] = sConfigMgr->GetFloatDefault("Rate.Rest.Offline.InTavernOrCity", 1.0f);
-    rate_values[RATE_REST_OFFLINE_IN_WILDERNESS]     = sConfigMgr->GetFloatDefault("Rate.Rest.Offline.InWilderness", 1.0f);
-    rate_values[RATE_DAMAGE_FALL]  = sConfigMgr->GetFloatDefault("Rate.Damage.Fall", 1.0f);
-    rate_values[RATE_AUCTION_TIME]  = sConfigMgr->GetFloatDefault("Rate.Auction.Time", 1.0f);
-    rate_values[RATE_AUCTION_DEPOSIT] = sConfigMgr->GetFloatDefault("Rate.Auction.Deposit", 1.0f);
-    rate_values[RATE_AUCTION_CUT] = sConfigMgr->GetFloatDefault("Rate.Auction.Cut", 1.0f);
-    rate_values[RATE_HONOR] = sConfigMgr->GetFloatDefault("Rate.Honor", 1.0f);
-    rate_values[RATE_INSTANCE_RESET_TIME] = sConfigMgr->GetFloatDefault("Rate.InstanceResetTime", 1.0f);
-    rate_values[RATE_TALENT] = sConfigMgr->GetFloatDefault("Rate.Talent", 1.0f);
+    rate_values[RATE_REPUTATION_GAIN]  = ConfigMgr::GetFloatDefault("Rate.Reputation.Gain", 1.0f);
+    rate_values[RATE_REPUTATION_LOWLEVEL_KILL]  = ConfigMgr::GetFloatDefault("Rate.Reputation.LowLevel.Kill", 1.0f);
+    rate_values[RATE_REPUTATION_LOWLEVEL_QUEST]  = ConfigMgr::GetFloatDefault("Rate.Reputation.LowLevel.Quest", 1.0f);
+    rate_values[RATE_REPUTATION_RECRUIT_A_FRIEND_BONUS] = ConfigMgr::GetFloatDefault("Rate.Reputation.RecruitAFriendBonus", 0.1f);
+    rate_values[RATE_CREATURE_NORMAL_DAMAGE]          = ConfigMgr::GetFloatDefault("Rate.Creature.Normal.Damage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_ELITE_DAMAGE]     = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.Elite.Damage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RAREELITE_DAMAGE] = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.RAREELITE.Damage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_WORLDBOSS_DAMAGE] = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.WORLDBOSS.Damage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RARE_DAMAGE]      = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.RARE.Damage", 1.0f);
+    rate_values[RATE_CREATURE_NORMAL_HP]          = ConfigMgr::GetFloatDefault("Rate.Creature.Normal.HP", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_ELITE_HP]     = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.Elite.HP", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RAREELITE_HP] = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.RAREELITE.HP", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_WORLDBOSS_HP] = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.WORLDBOSS.HP", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RARE_HP]      = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.RARE.HP", 1.0f);
+    rate_values[RATE_CREATURE_NORMAL_SPELLDAMAGE]          = ConfigMgr::GetFloatDefault("Rate.Creature.Normal.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_ELITE_SPELLDAMAGE]     = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.Elite.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RAREELITE_SPELLDAMAGE] = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.RAREELITE.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_WORLDBOSS_SPELLDAMAGE] = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.WORLDBOSS.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RARE_SPELLDAMAGE]      = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.RARE.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_AGGRO]  = ConfigMgr::GetFloatDefault("Rate.Creature.Aggro", 1.0f);
+    rate_values[RATE_REST_INGAME]                    = ConfigMgr::GetFloatDefault("Rate.Rest.InGame", 1.0f);
+    rate_values[RATE_REST_OFFLINE_IN_TAVERN_OR_CITY] = ConfigMgr::GetFloatDefault("Rate.Rest.Offline.InTavernOrCity", 1.0f);
+    rate_values[RATE_REST_OFFLINE_IN_WILDERNESS]     = ConfigMgr::GetFloatDefault("Rate.Rest.Offline.InWilderness", 1.0f);
+    rate_values[RATE_DAMAGE_FALL]  = ConfigMgr::GetFloatDefault("Rate.Damage.Fall", 1.0f);
+    rate_values[RATE_AUCTION_TIME]  = ConfigMgr::GetFloatDefault("Rate.Auction.Time", 1.0f);
+    rate_values[RATE_AUCTION_DEPOSIT] = ConfigMgr::GetFloatDefault("Rate.Auction.Deposit", 1.0f);
+    rate_values[RATE_AUCTION_CUT] = ConfigMgr::GetFloatDefault("Rate.Auction.Cut", 1.0f);
+    rate_values[RATE_HONOR] = ConfigMgr::GetFloatDefault("Rate.Honor", 1.0f);
+    rate_values[RATE_INSTANCE_RESET_TIME] = ConfigMgr::GetFloatDefault("Rate.InstanceResetTime", 1.0f);
+    rate_values[RATE_TALENT] = ConfigMgr::GetFloatDefault("Rate.Talent", 1.0f);
     if (rate_values[RATE_TALENT] < 0.0f)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Rate.Talent (%f) must be > 0. Using 1 instead.", rate_values[RATE_TALENT]);
         rate_values[RATE_TALENT] = 1.0f;
     }
-    rate_values[RATE_MOVESPEED] = sConfigMgr->GetFloatDefault("Rate.MoveSpeed", 1.0f);
+    rate_values[RATE_MOVESPEED] = ConfigMgr::GetFloatDefault("Rate.MoveSpeed", 1.0f);
     if (rate_values[RATE_MOVESPEED] < 0)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Rate.MoveSpeed (%f) must be > 0. Using 1 instead.", rate_values[RATE_MOVESPEED]);
         rate_values[RATE_MOVESPEED] = 1.0f;
     }
     for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i) playerBaseMoveSpeed[i] = baseMoveSpeed[i] * rate_values[RATE_MOVESPEED];
-    rate_values[RATE_CORPSE_DECAY_LOOTED] = sConfigMgr->GetFloatDefault("Rate.Corpse.Decay.Looted", 0.5f);
+    rate_values[RATE_CORPSE_DECAY_LOOTED] = ConfigMgr::GetFloatDefault("Rate.Corpse.Decay.Looted", 0.5f);
 
-    rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] = sConfigMgr->GetFloatDefault("TargetPosRecalculateRange", 1.5f);
+    rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] = ConfigMgr::GetFloatDefault("TargetPosRecalculateRange", 1.5f);
     if (rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] < CONTACT_DISTANCE)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "TargetPosRecalculateRange (%f) must be >= %f. Using %f instead.", rate_values[RATE_TARGET_POS_RECALCULATION_RANGE], CONTACT_DISTANCE, CONTACT_DISTANCE);
@@ -526,7 +526,7 @@ void World::LoadConfigSettings(bool reload)
         rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] = NOMINAL_MELEE_RANGE;
     }
 
-    rate_values[RATE_DURABILITY_LOSS_ON_DEATH]  = sConfigMgr->GetFloatDefault("DurabilityLoss.OnDeath", 10.0f);
+    rate_values[RATE_DURABILITY_LOSS_ON_DEATH]  = ConfigMgr::GetFloatDefault("DurabilityLoss.OnDeath", 10.0f);
     if (rate_values[RATE_DURABILITY_LOSS_ON_DEATH] < 0.0f)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "DurabilityLoss.OnDeath (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_ON_DEATH]);
@@ -539,25 +539,25 @@ void World::LoadConfigSettings(bool reload)
     }
     rate_values[RATE_DURABILITY_LOSS_ON_DEATH] = rate_values[RATE_DURABILITY_LOSS_ON_DEATH] / 100.0f;
 
-    rate_values[RATE_DURABILITY_LOSS_DAMAGE] = sConfigMgr->GetFloatDefault("DurabilityLossChance.Damage", 0.5f);
+    rate_values[RATE_DURABILITY_LOSS_DAMAGE] = ConfigMgr::GetFloatDefault("DurabilityLossChance.Damage", 0.5f);
     if (rate_values[RATE_DURABILITY_LOSS_DAMAGE] < 0.0f)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "DurabilityLossChance.Damage (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_DAMAGE]);
         rate_values[RATE_DURABILITY_LOSS_DAMAGE] = 0.0f;
     }
-    rate_values[RATE_DURABILITY_LOSS_ABSORB] = sConfigMgr->GetFloatDefault("DurabilityLossChance.Absorb", 0.5f);
+    rate_values[RATE_DURABILITY_LOSS_ABSORB] = ConfigMgr::GetFloatDefault("DurabilityLossChance.Absorb", 0.5f);
     if (rate_values[RATE_DURABILITY_LOSS_ABSORB] < 0.0f)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "DurabilityLossChance.Absorb (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_ABSORB]);
         rate_values[RATE_DURABILITY_LOSS_ABSORB] = 0.0f;
     }
-    rate_values[RATE_DURABILITY_LOSS_PARRY] = sConfigMgr->GetFloatDefault("DurabilityLossChance.Parry", 0.05f);
+    rate_values[RATE_DURABILITY_LOSS_PARRY] = ConfigMgr::GetFloatDefault("DurabilityLossChance.Parry", 0.05f);
     if (rate_values[RATE_DURABILITY_LOSS_PARRY] < 0.0f)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "DurabilityLossChance.Parry (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_PARRY]);
         rate_values[RATE_DURABILITY_LOSS_PARRY] = 0.0f;
     }
-    rate_values[RATE_DURABILITY_LOSS_BLOCK] = sConfigMgr->GetFloatDefault("DurabilityLossChance.Block", 0.05f);
+    rate_values[RATE_DURABILITY_LOSS_BLOCK] = ConfigMgr::GetFloatDefault("DurabilityLossChance.Block", 0.05f);
     if (rate_values[RATE_DURABILITY_LOSS_BLOCK] < 0.0f)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "DurabilityLossChance.Block (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_BLOCK]);
@@ -565,39 +565,39 @@ void World::LoadConfigSettings(bool reload)
     }
     ///- Read other configuration items from the config file
 
-    m_bool_configs[CONFIG_DURABILITY_LOSS_IN_PVP] = sConfigMgr->GetBoolDefault("DurabilityLoss.InPvP", false);
+    m_bool_configs[CONFIG_DURABILITY_LOSS_IN_PVP] = ConfigMgr::GetBoolDefault("DurabilityLoss.InPvP", false);
 
-    m_int_configs[CONFIG_COMPRESSION] = sConfigMgr->GetIntDefault("Compression", 1);
+    m_int_configs[CONFIG_COMPRESSION] = ConfigMgr::GetIntDefault("Compression", 1);
     if (m_int_configs[CONFIG_COMPRESSION] < 1 || m_int_configs[CONFIG_COMPRESSION] > 9)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Compression level (%i) must be in range 1..9. Using default compression level (1).", m_int_configs[CONFIG_COMPRESSION]);
         m_int_configs[CONFIG_COMPRESSION] = 1;
     }
-    m_bool_configs[CONFIG_ADDON_CHANNEL] = sConfigMgr->GetBoolDefault("AddonChannel", true);
-    m_bool_configs[CONFIG_CLEAN_CHARACTER_DB] = sConfigMgr->GetBoolDefault("CleanCharacterDB", false);
-    m_int_configs[CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS] = sConfigMgr->GetIntDefault("PersistentCharacterCleanFlags", 0);
-    m_int_configs[CONFIG_CHAT_CHANNEL_LEVEL_REQ] = sConfigMgr->GetIntDefault("ChatLevelReq.Channel", 1);
-    m_int_configs[CONFIG_CHAT_WHISPER_LEVEL_REQ] = sConfigMgr->GetIntDefault("ChatLevelReq.Whisper", 1);
-    m_int_configs[CONFIG_CHAT_SAY_LEVEL_REQ] = sConfigMgr->GetIntDefault("ChatLevelReq.Say", 1);
-    m_int_configs[CONFIG_TRADE_LEVEL_REQ] = sConfigMgr->GetIntDefault("LevelReq.Trade", 1);
-    m_int_configs[CONFIG_TICKET_LEVEL_REQ] = sConfigMgr->GetIntDefault("LevelReq.Ticket", 1);
-    m_int_configs[CONFIG_AUCTION_LEVEL_REQ] = sConfigMgr->GetIntDefault("LevelReq.Auction", 1);
-    m_int_configs[CONFIG_MAIL_LEVEL_REQ] = sConfigMgr->GetIntDefault("LevelReq.Mail", 1);
-    m_bool_configs[CONFIG_PRESERVE_CUSTOM_CHANNELS] = sConfigMgr->GetBoolDefault("PreserveCustomChannels", false);
-    m_int_configs[CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION] = sConfigMgr->GetIntDefault("PreserveCustomChannelDuration", 14);
-    m_bool_configs[CONFIG_GRID_UNLOAD] = sConfigMgr->GetBoolDefault("GridUnload", true);
-    m_int_configs[CONFIG_INTERVAL_SAVE] = sConfigMgr->GetIntDefault("PlayerSaveInterval", 15 * MINUTE * IN_MILLISECONDS);
-    m_int_configs[CONFIG_INTERVAL_DISCONNECT_TOLERANCE] = sConfigMgr->GetIntDefault("DisconnectToleranceInterval", 0);
-    m_bool_configs[CONFIG_STATS_SAVE_ONLY_ON_LOGOUT] = sConfigMgr->GetBoolDefault("PlayerSave.Stats.SaveOnlyOnLogout", true);
-
-    m_int_configs[CONFIG_MIN_LEVEL_STAT_SAVE] = sConfigMgr->GetIntDefault("PlayerSave.Stats.MinLevel", 0);
+    m_bool_configs[CONFIG_ADDON_CHANNEL] = ConfigMgr::GetBoolDefault("AddonChannel", true);
+    m_bool_configs[CONFIG_CLEAN_CHARACTER_DB] = ConfigMgr::GetBoolDefault("CleanCharacterDB", false);
+    m_int_configs[CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS] = ConfigMgr::GetIntDefault("PersistentCharacterCleanFlags", 0);
+    m_int_configs[CONFIG_CHAT_CHANNEL_LEVEL_REQ] = ConfigMgr::GetIntDefault("ChatLevelReq.Channel", 1);
+    m_int_configs[CONFIG_CHAT_WHISPER_LEVEL_REQ] = ConfigMgr::GetIntDefault("ChatLevelReq.Whisper", 1);
+    m_int_configs[CONFIG_CHAT_SAY_LEVEL_REQ] = ConfigMgr::GetIntDefault("ChatLevelReq.Say", 1);
+    m_int_configs[CONFIG_TRADE_LEVEL_REQ] = ConfigMgr::GetIntDefault("LevelReq.Trade", 1);
+    m_int_configs[CONFIG_TICKET_LEVEL_REQ] = ConfigMgr::GetIntDefault("LevelReq.Ticket", 1);
+    m_int_configs[CONFIG_AUCTION_LEVEL_REQ] = ConfigMgr::GetIntDefault("LevelReq.Auction", 1);
+    m_int_configs[CONFIG_MAIL_LEVEL_REQ] = ConfigMgr::GetIntDefault("LevelReq.Mail", 1);
+    m_bool_configs[CONFIG_PRESERVE_CUSTOM_CHANNELS] = ConfigMgr::GetBoolDefault("PreserveCustomChannels", false);
+    m_int_configs[CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION] = ConfigMgr::GetIntDefault("PreserveCustomChannelDuration", 14);
+    m_bool_configs[CONFIG_GRID_UNLOAD] = ConfigMgr::GetBoolDefault("GridUnload", true);
+    m_int_configs[CONFIG_INTERVAL_SAVE] = ConfigMgr::GetIntDefault("PlayerSaveInterval", 15 * MINUTE * IN_MILLISECONDS);
+    m_int_configs[CONFIG_INTERVAL_DISCONNECT_TOLERANCE] = ConfigMgr::GetIntDefault("DisconnectToleranceInterval", 0);
+    m_bool_configs[CONFIG_STATS_SAVE_ONLY_ON_LOGOUT] = ConfigMgr::GetBoolDefault("PlayerSave.Stats.SaveOnlyOnLogout", true);
+
+    m_int_configs[CONFIG_MIN_LEVEL_STAT_SAVE] = ConfigMgr::GetIntDefault("PlayerSave.Stats.MinLevel", 0);
     if (m_int_configs[CONFIG_MIN_LEVEL_STAT_SAVE] > MAX_LEVEL)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "PlayerSave.Stats.MinLevel (%i) must be in range 0..80. Using default, do not save character stats (0).", m_int_configs[CONFIG_MIN_LEVEL_STAT_SAVE]);
         m_int_configs[CONFIG_MIN_LEVEL_STAT_SAVE] = 0;
     }
 
-    m_int_configs[CONFIG_INTERVAL_GRIDCLEAN] = sConfigMgr->GetIntDefault("GridCleanUpDelay", 5 * MINUTE * IN_MILLISECONDS);
+    m_int_configs[CONFIG_INTERVAL_GRIDCLEAN] = ConfigMgr::GetIntDefault("GridCleanUpDelay", 5 * MINUTE * IN_MILLISECONDS);
     if (m_int_configs[CONFIG_INTERVAL_GRIDCLEAN] < MIN_GRID_DELAY)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "GridCleanUpDelay (%i) must be greater %u. Use this minimal value.", m_int_configs[CONFIG_INTERVAL_GRIDCLEAN], MIN_GRID_DELAY);
@@ -606,7 +606,7 @@ void World::LoadConfigSettings(bool reload)
     if (reload)
         sMapMgr->SetGridCleanUpDelay(m_int_configs[CONFIG_INTERVAL_GRIDCLEAN]);
 
-    m_int_configs[CONFIG_INTERVAL_MAPUPDATE] = sConfigMgr->GetIntDefault("MapUpdateInterval", 100);
+    m_int_configs[CONFIG_INTERVAL_MAPUPDATE] = ConfigMgr::GetIntDefault("MapUpdateInterval", 100);
     if (m_int_configs[CONFIG_INTERVAL_MAPUPDATE] < MIN_MAP_UPDATE_DELAY)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "MapUpdateInterval (%i) must be greater %u. Use this minimal value.", m_int_configs[CONFIG_INTERVAL_MAPUPDATE], MIN_MAP_UPDATE_DELAY);
@@ -615,81 +615,81 @@ void World::LoadConfigSettings(bool reload)
     if (reload)
         sMapMgr->SetMapUpdateInterval(m_int_configs[CONFIG_INTERVAL_MAPUPDATE]);
 
-    m_int_configs[CONFIG_INTERVAL_CHANGEWEATHER] = sConfigMgr->GetIntDefault("ChangeWeatherInterval", 10 * MINUTE * IN_MILLISECONDS);
+    m_int_configs[CONFIG_INTERVAL_CHANGEWEATHER] = ConfigMgr::GetIntDefault("ChangeWeatherInterval", 10 * MINUTE * IN_MILLISECONDS);
 
     if (reload)
     {
-        uint32 val = sConfigMgr->GetIntDefault("WorldServerPort", 8085);
+        uint32 val = ConfigMgr::GetIntDefault("WorldServerPort", 8085);
         if (val != m_int_configs[CONFIG_PORT_WORLD])
             TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "WorldServerPort option can't be changed at worldserver.conf reload, using current value (%u).", m_int_configs[CONFIG_PORT_WORLD]);
     }
     else
-        m_int_configs[CONFIG_PORT_WORLD] = sConfigMgr->GetIntDefault("WorldServerPort", 8085);
+        m_int_configs[CONFIG_PORT_WORLD] = ConfigMgr::GetIntDefault("WorldServerPort", 8085);
 
-    m_int_configs[CONFIG_SOCKET_TIMEOUTTIME] = sConfigMgr->GetIntDefault("SocketTimeOutTime", 900000);
-    m_int_configs[CONFIG_SESSION_ADD_DELAY] = sConfigMgr->GetIntDefault("SessionAddDelay", 10000);
+    m_int_configs[CONFIG_SOCKET_TIMEOUTTIME] = ConfigMgr::GetIntDefault("SocketTimeOutTime", 900000);
+    m_int_configs[CONFIG_SESSION_ADD_DELAY] = ConfigMgr::GetIntDefault("SessionAddDelay", 10000);
 
-    m_float_configs[CONFIG_GROUP_XP_DISTANCE] = sConfigMgr->GetFloatDefault("MaxGroupXPDistance", 74.0f);
-    m_float_configs[CONFIG_MAX_RECRUIT_A_FRIEND_DISTANCE] = sConfigMgr->GetFloatDefault("MaxRecruitAFriendBonusDistance", 100.0f);
+    m_float_configs[CONFIG_GROUP_XP_DISTANCE] = ConfigMgr::GetFloatDefault("MaxGroupXPDistance", 74.0f);
+    m_float_configs[CONFIG_MAX_RECRUIT_A_FRIEND_DISTANCE] = ConfigMgr::GetFloatDefault("MaxRecruitAFriendBonusDistance", 100.0f);
 
     /// @todo Add MonsterSight and GuarderSight (with meaning) in worldserver.conf or put them as define
-    m_float_configs[CONFIG_SIGHT_MONSTER] = sConfigMgr->GetFloatDefault("MonsterSight", 50);
-    m_float_configs[CONFIG_SIGHT_GUARDER] = sConfigMgr->GetFloatDefault("GuarderSight", 50);
+    m_float_configs[CONFIG_SIGHT_MONSTER] = ConfigMgr::GetFloatDefault("MonsterSight", 50);
+    m_float_configs[CONFIG_SIGHT_GUARDER] = ConfigMgr::GetFloatDefault("GuarderSight", 50);
 
     if (reload)
     {
-        uint32 val = sConfigMgr->GetIntDefault("GameType", 0);
+        uint32 val = ConfigMgr::GetIntDefault("GameType", 0);
         if (val != m_int_configs[CONFIG_GAME_TYPE])
             TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "GameType option can't be changed at worldserver.conf reload, using current value (%u).", m_int_configs[CONFIG_GAME_TYPE]);
     }
     else
-        m_int_configs[CONFIG_GAME_TYPE] = sConfigMgr->GetIntDefault("GameType", 0);
+        m_int_configs[CONFIG_GAME_TYPE] = ConfigMgr::GetIntDefault("GameType", 0);
 
     if (reload)
     {
-        uint32 val = sConfigMgr->GetIntDefault("RealmZone", REALM_ZONE_DEVELOPMENT);
+        uint32 val = ConfigMgr::GetIntDefault("RealmZone", REALM_ZONE_DEVELOPMENT);
         if (val != m_int_configs[CONFIG_REALM_ZONE])
             TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "RealmZone option can't be changed at worldserver.conf reload, using current value (%u).", m_int_configs[CONFIG_REALM_ZONE]);
     }
     else
-        m_int_configs[CONFIG_REALM_ZONE] = sConfigMgr->GetIntDefault("RealmZone", REALM_ZONE_DEVELOPMENT);
-
-    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_CALENDAR]= sConfigMgr->GetBoolDefault("AllowTwoSide.Interaction.Calendar", false);
-    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHANNEL] = sConfigMgr->GetBoolDefault("AllowTwoSide.Interaction.Channel", false);
-    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP]   = sConfigMgr->GetBoolDefault("AllowTwoSide.Interaction.Group", false);
-    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD]   = sConfigMgr->GetBoolDefault("AllowTwoSide.Interaction.Guild", false);
-    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION] = sConfigMgr->GetBoolDefault("AllowTwoSide.Interaction.Auction", false);
-    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_TRADE]               = sConfigMgr->GetBoolDefault("AllowTwoSide.trade", false);
-    m_int_configs[CONFIG_STRICT_PLAYER_NAMES]                 = sConfigMgr->GetIntDefault ("StrictPlayerNames",  0);
-    m_int_configs[CONFIG_STRICT_CHARTER_NAMES]                = sConfigMgr->GetIntDefault ("StrictCharterNames", 0);
-    m_int_configs[CONFIG_STRICT_PET_NAMES]                    = sConfigMgr->GetIntDefault ("StrictPetNames",     0);
-
-    m_int_configs[CONFIG_MIN_PLAYER_NAME]                     = sConfigMgr->GetIntDefault ("MinPlayerName",  2);
+        m_int_configs[CONFIG_REALM_ZONE] = ConfigMgr::GetIntDefault("RealmZone", REALM_ZONE_DEVELOPMENT);
+
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_CALENDAR]= ConfigMgr::GetBoolDefault("AllowTwoSide.Interaction.Calendar", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHANNEL] = ConfigMgr::GetBoolDefault("AllowTwoSide.Interaction.Channel", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP]   = ConfigMgr::GetBoolDefault("AllowTwoSide.Interaction.Group", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD]   = ConfigMgr::GetBoolDefault("AllowTwoSide.Interaction.Guild", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION] = ConfigMgr::GetBoolDefault("AllowTwoSide.Interaction.Auction", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_TRADE]               = ConfigMgr::GetBoolDefault("AllowTwoSide.trade", false);
+    m_int_configs[CONFIG_STRICT_PLAYER_NAMES]                 = ConfigMgr::GetIntDefault ("StrictPlayerNames",  0);
+    m_int_configs[CONFIG_STRICT_CHARTER_NAMES]                = ConfigMgr::GetIntDefault ("StrictCharterNames", 0);
+    m_int_configs[CONFIG_STRICT_PET_NAMES]                    = ConfigMgr::GetIntDefault ("StrictPetNames",     0);
+
+    m_int_configs[CONFIG_MIN_PLAYER_NAME]                     = ConfigMgr::GetIntDefault ("MinPlayerName",  2);
     if (m_int_configs[CONFIG_MIN_PLAYER_NAME] < 1 || m_int_configs[CONFIG_MIN_PLAYER_NAME] > MAX_PLAYER_NAME)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "MinPlayerName (%i) must be in range 1..%u. Set to 2.", m_int_configs[CONFIG_MIN_PLAYER_NAME], MAX_PLAYER_NAME);
         m_int_configs[CONFIG_MIN_PLAYER_NAME] = 2;
     }
 
-    m_int_configs[CONFIG_MIN_CHARTER_NAME]                    = sConfigMgr->GetIntDefault ("MinCharterName", 2);
+    m_int_configs[CONFIG_MIN_CHARTER_NAME]                    = ConfigMgr::GetIntDefault ("MinCharterName", 2);
     if (m_int_configs[CONFIG_MIN_CHARTER_NAME] < 1 || m_int_configs[CONFIG_MIN_CHARTER_NAME] > MAX_CHARTER_NAME)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "MinCharterName (%i) must be in range 1..%u. Set to 2.", m_int_configs[CONFIG_MIN_CHARTER_NAME], MAX_CHARTER_NAME);
         m_int_configs[CONFIG_MIN_CHARTER_NAME] = 2;
     }
 
-    m_int_configs[CONFIG_MIN_PET_NAME]                        = sConfigMgr->GetIntDefault ("MinPetName",     2);
+    m_int_configs[CONFIG_MIN_PET_NAME]                        = ConfigMgr::GetIntDefault ("MinPetName",     2);
     if (m_int_configs[CONFIG_MIN_PET_NAME] < 1 || m_int_configs[CONFIG_MIN_PET_NAME] > MAX_PET_NAME)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "MinPetName (%i) must be in range 1..%u. Set to 2.", m_int_configs[CONFIG_MIN_PET_NAME], MAX_PET_NAME);
         m_int_configs[CONFIG_MIN_PET_NAME] = 2;
     }
 
-    m_int_configs[CONFIG_CHARACTER_CREATING_DISABLED] = sConfigMgr->GetIntDefault("CharacterCreating.Disabled", 0);
-    m_int_configs[CONFIG_CHARACTER_CREATING_DISABLED_RACEMASK] = sConfigMgr->GetIntDefault("CharacterCreating.Disabled.RaceMask", 0);
-    m_int_configs[CONFIG_CHARACTER_CREATING_DISABLED_CLASSMASK] = sConfigMgr->GetIntDefault("CharacterCreating.Disabled.ClassMask", 0);
+    m_int_configs[CONFIG_CHARACTER_CREATING_DISABLED] = ConfigMgr::GetIntDefault("CharacterCreating.Disabled", 0);
+    m_int_configs[CONFIG_CHARACTER_CREATING_DISABLED_RACEMASK] = ConfigMgr::GetIntDefault("CharacterCreating.Disabled.RaceMask", 0);
+    m_int_configs[CONFIG_CHARACTER_CREATING_DISABLED_CLASSMASK] = ConfigMgr::GetIntDefault("CharacterCreating.Disabled.ClassMask", 0);
 
-    m_int_configs[CONFIG_CHARACTERS_PER_REALM] = sConfigMgr->GetIntDefault("CharactersPerRealm", 10);
+    m_int_configs[CONFIG_CHARACTERS_PER_REALM] = ConfigMgr::GetIntDefault("CharactersPerRealm", 10);
     if (m_int_configs[CONFIG_CHARACTERS_PER_REALM] < 1 || m_int_configs[CONFIG_CHARACTERS_PER_REALM] > 10)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "CharactersPerRealm (%i) must be in range 1..10. Set to 10.", m_int_configs[CONFIG_CHARACTERS_PER_REALM]);
@@ -697,23 +697,23 @@ void World::LoadConfigSettings(bool reload)
     }
 
     // must be after CONFIG_CHARACTERS_PER_REALM
-    m_int_configs[CONFIG_CHARACTERS_PER_ACCOUNT] = sConfigMgr->GetIntDefault("CharactersPerAccount", 50);
+    m_int_configs[CONFIG_CHARACTERS_PER_ACCOUNT] = ConfigMgr::GetIntDefault("CharactersPerAccount", 50);
     if (m_int_configs[CONFIG_CHARACTERS_PER_ACCOUNT] < m_int_configs[CONFIG_CHARACTERS_PER_REALM])
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "CharactersPerAccount (%i) can't be less than CharactersPerRealm (%i).", m_int_configs[CONFIG_CHARACTERS_PER_ACCOUNT], m_int_configs[CONFIG_CHARACTERS_PER_REALM]);
         m_int_configs[CONFIG_CHARACTERS_PER_ACCOUNT] = m_int_configs[CONFIG_CHARACTERS_PER_REALM];
     }
 
-    m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM] = sConfigMgr->GetIntDefault("HeroicCharactersPerRealm", 1);
+    m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM] = ConfigMgr::GetIntDefault("HeroicCharactersPerRealm", 1);
     if (int32(m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM]) < 0 || m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM] > 10)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "HeroicCharactersPerRealm (%i) must be in range 0..10. Set to 1.", m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM]);
         m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM] = 1;
     }
 
-    m_int_configs[CONFIG_CHARACTER_CREATING_MIN_LEVEL_FOR_HEROIC_CHARACTER] = sConfigMgr->GetIntDefault("CharacterCreating.MinLevelForHeroicCharacter", 55);
+    m_int_configs[CONFIG_CHARACTER_CREATING_MIN_LEVEL_FOR_HEROIC_CHARACTER] = ConfigMgr::GetIntDefault("CharacterCreating.MinLevelForHeroicCharacter", 55);
 
-    m_int_configs[CONFIG_SKIP_CINEMATICS] = sConfigMgr->GetIntDefault("SkipCinematics", 0);
+    m_int_configs[CONFIG_SKIP_CINEMATICS] = ConfigMgr::GetIntDefault("SkipCinematics", 0);
     if (int32(m_int_configs[CONFIG_SKIP_CINEMATICS]) < 0 || m_int_configs[CONFIG_SKIP_CINEMATICS] > 2)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "SkipCinematics (%i) must be in range 0..2. Set to 0.", m_int_configs[CONFIG_SKIP_CINEMATICS]);
@@ -722,12 +722,12 @@ void World::LoadConfigSettings(bool reload)
 
     if (reload)
     {
-        uint32 val = sConfigMgr->GetIntDefault("MaxPlayerLevel", DEFAULT_MAX_LEVEL);
+        uint32 val = ConfigMgr::GetIntDefault("MaxPlayerLevel", DEFAULT_MAX_LEVEL);
         if (val != m_int_configs[CONFIG_MAX_PLAYER_LEVEL])
             TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "MaxPlayerLevel option can't be changed at config reload, using current value (%u).", m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
     }
     else
-        m_int_configs[CONFIG_MAX_PLAYER_LEVEL] = sConfigMgr->GetIntDefault("MaxPlayerLevel", DEFAULT_MAX_LEVEL);
+        m_int_configs[CONFIG_MAX_PLAYER_LEVEL] = ConfigMgr::GetIntDefault("MaxPlayerLevel", DEFAULT_MAX_LEVEL);
 
     if (m_int_configs[CONFIG_MAX_PLAYER_LEVEL] > MAX_LEVEL)
     {
@@ -735,9 +735,9 @@ void World::LoadConfigSettings(bool reload)
         m_int_configs[CONFIG_MAX_PLAYER_LEVEL] = MAX_LEVEL;
     }
 
-    m_int_configs[CONFIG_MIN_DUALSPEC_LEVEL] = sConfigMgr->GetIntDefault("MinDualSpecLevel", 40);
+    m_int_configs[CONFIG_MIN_DUALSPEC_LEVEL] = ConfigMgr::GetIntDefault("MinDualSpecLevel", 40);
 
-    m_int_configs[CONFIG_START_PLAYER_LEVEL] = sConfigMgr->GetIntDefault("StartPlayerLevel", 1);
+    m_int_configs[CONFIG_START_PLAYER_LEVEL] = ConfigMgr::GetIntDefault("StartPlayerLevel", 1);
     if (m_int_configs[CONFIG_START_PLAYER_LEVEL] < 1)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "StartPlayerLevel (%i) must be in range 1..MaxPlayerLevel(%u). Set to 1.", m_int_configs[CONFIG_START_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
@@ -749,7 +749,7 @@ void World::LoadConfigSettings(bool reload)
         m_int_configs[CONFIG_START_PLAYER_LEVEL] = m_int_configs[CONFIG_MAX_PLAYER_LEVEL];
     }
 
-    m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] = sConfigMgr->GetIntDefault("StartHeroicPlayerLevel", 55);
+    m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] = ConfigMgr::GetIntDefault("StartHeroicPlayerLevel", 55);
     if (m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] < 1)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "StartHeroicPlayerLevel (%i) must be in range 1..MaxPlayerLevel(%u). Set to 55.",
@@ -763,7 +763,7 @@ void World::LoadConfigSettings(bool reload)
         m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] = m_int_configs[CONFIG_MAX_PLAYER_LEVEL];
     }
 
-    m_int_configs[CONFIG_START_PLAYER_MONEY] = sConfigMgr->GetIntDefault("StartPlayerMoney", 0);
+    m_int_configs[CONFIG_START_PLAYER_MONEY] = ConfigMgr::GetIntDefault("StartPlayerMoney", 0);
     if (int32(m_int_configs[CONFIG_START_PLAYER_MONEY]) < 0)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "StartPlayerMoney (%i) must be in range 0..%u. Set to %u.", m_int_configs[CONFIG_START_PLAYER_MONEY], MAX_MONEY_AMOUNT, 0);
@@ -776,14 +776,14 @@ void World::LoadConfigSettings(bool reload)
         m_int_configs[CONFIG_START_PLAYER_MONEY] = MAX_MONEY_AMOUNT;
     }
 
-    m_int_configs[CONFIG_MAX_HONOR_POINTS] = sConfigMgr->GetIntDefault("MaxHonorPoints", 75000);
+    m_int_configs[CONFIG_MAX_HONOR_POINTS] = ConfigMgr::GetIntDefault("MaxHonorPoints", 75000);
     if (int32(m_int_configs[CONFIG_MAX_HONOR_POINTS]) < 0)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "MaxHonorPoints (%i) can't be negative. Set to 0.", m_int_configs[CONFIG_MAX_HONOR_POINTS]);
         m_int_configs[CONFIG_MAX_HONOR_POINTS] = 0;
     }
 
-    m_int_configs[CONFIG_START_HONOR_POINTS] = sConfigMgr->GetIntDefault("StartHonorPoints", 0);
+    m_int_configs[CONFIG_START_HONOR_POINTS] = ConfigMgr::GetIntDefault("StartHonorPoints", 0);
     if (int32(m_int_configs[CONFIG_START_HONOR_POINTS]) < 0)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "StartHonorPoints (%i) must be in range 0..MaxHonorPoints(%u). Set to %u.",
@@ -797,14 +797,14 @@ void World::LoadConfigSettings(bool reload)
         m_int_configs[CONFIG_START_HONOR_POINTS] = m_int_configs[CONFIG_MAX_HONOR_POINTS];
     }
 
-    m_int_configs[CONFIG_MAX_ARENA_POINTS] = sConfigMgr->GetIntDefault("MaxArenaPoints", 10000);
+    m_int_configs[CONFIG_MAX_ARENA_POINTS] = ConfigMgr::GetIntDefault("MaxArenaPoints", 10000);
     if (int32(m_int_configs[CONFIG_MAX_ARENA_POINTS]) < 0)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "MaxArenaPoints (%i) can't be negative. Set to 0.", m_int_configs[CONFIG_MAX_ARENA_POINTS]);
         m_int_configs[CONFIG_MAX_ARENA_POINTS] = 0;
     }
 
-    m_int_configs[CONFIG_START_ARENA_POINTS] = sConfigMgr->GetIntDefault("StartArenaPoints", 0);
+    m_int_configs[CONFIG_START_ARENA_POINTS] = ConfigMgr::GetIntDefault("StartArenaPoints", 0);
     if (int32(m_int_configs[CONFIG_START_ARENA_POINTS]) < 0)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "StartArenaPoints (%i) must be in range 0..MaxArenaPoints(%u). Set to %u.",
@@ -818,7 +818,7 @@ void World::LoadConfigSettings(bool reload)
         m_int_configs[CONFIG_START_ARENA_POINTS] = m_int_configs[CONFIG_MAX_ARENA_POINTS];
     }
 
-    m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL] = sConfigMgr->GetIntDefault("RecruitAFriend.MaxLevel", 60);
+    m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL] = ConfigMgr::GetIntDefault("RecruitAFriend.MaxLevel", 60);
     if (m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL] > m_int_configs[CONFIG_MAX_PLAYER_LEVEL])
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "RecruitAFriend.MaxLevel (%i) must be in the range 0..MaxLevel(%u). Set to %u.",
@@ -826,33 +826,33 @@ void World::LoadConfigSettings(bool reload)
         m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL] = 60;
     }
 
-    m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL_DIFFERENCE] = sConfigMgr->GetIntDefault("RecruitAFriend.MaxDifference", 4);
-    m_bool_configs[CONFIG_ALL_TAXI_PATHS] = sConfigMgr->GetBoolDefault("AllFlightPaths", false);
-    m_bool_configs[CONFIG_INSTANT_TAXI] = sConfigMgr->GetBoolDefault("InstantFlightPaths", false);
+    m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL_DIFFERENCE] = ConfigMgr::GetIntDefault("RecruitAFriend.MaxDifference", 4);
+    m_bool_configs[CONFIG_ALL_TAXI_PATHS] = ConfigMgr::GetBoolDefault("AllFlightPaths", false);
+    m_bool_configs[CONFIG_INSTANT_TAXI] = ConfigMgr::GetBoolDefault("InstantFlightPaths", false);
 
-    m_bool_configs[CONFIG_INSTANCE_IGNORE_LEVEL] = sConfigMgr->GetBoolDefault("Instance.IgnoreLevel", false);
-    m_bool_configs[CONFIG_INSTANCE_IGNORE_RAID]  = sConfigMgr->GetBoolDefault("Instance.IgnoreRaid", false);
+    m_bool_configs[CONFIG_INSTANCE_IGNORE_LEVEL] = ConfigMgr::GetBoolDefault("Instance.IgnoreLevel", false);
+    m_bool_configs[CONFIG_INSTANCE_IGNORE_RAID]  = ConfigMgr::GetBoolDefault("Instance.IgnoreRaid", false);
 
-    m_bool_configs[CONFIG_CAST_UNSTUCK] = sConfigMgr->GetBoolDefault("CastUnstuck", true);
-    m_int_configs[CONFIG_INSTANCE_RESET_TIME_HOUR]  = sConfigMgr->GetIntDefault("Instance.ResetTimeHour", 4);
-    m_int_configs[CONFIG_INSTANCE_UNLOAD_DELAY] = sConfigMgr->GetIntDefault("Instance.UnloadDelay", 30 * MINUTE * IN_MILLISECONDS);
+    m_bool_configs[CONFIG_CAST_UNSTUCK] = ConfigMgr::GetBoolDefault("CastUnstuck", true);
+    m_int_configs[CONFIG_INSTANCE_RESET_TIME_HOUR]  = ConfigMgr::GetIntDefault("Instance.ResetTimeHour", 4);
+    m_int_configs[CONFIG_INSTANCE_UNLOAD_DELAY] = ConfigMgr::GetIntDefault("Instance.UnloadDelay", 30 * MINUTE * IN_MILLISECONDS);
 
-    m_int_configs[CONFIG_MAX_PRIMARY_TRADE_SKILL] = sConfigMgr->GetIntDefault("MaxPrimaryTradeSkill", 2);
-    m_int_configs[CONFIG_MIN_PETITION_SIGNS] = sConfigMgr->GetIntDefault("MinPetitionSigns", 9);
+    m_int_configs[CONFIG_MAX_PRIMARY_TRADE_SKILL] = ConfigMgr::GetIntDefault("MaxPrimaryTradeSkill", 2);
+    m_int_configs[CONFIG_MIN_PETITION_SIGNS] = ConfigMgr::GetIntDefault("MinPetitionSigns", 9);
     if (m_int_configs[CONFIG_MIN_PETITION_SIGNS] > 9)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "MinPetitionSigns (%i) must be in range 0..9. Set to 9.", m_int_configs[CONFIG_MIN_PETITION_SIGNS]);
         m_int_configs[CONFIG_MIN_PETITION_SIGNS] = 9;
     }
 
-    m_int_configs[CONFIG_GM_LOGIN_STATE]        = sConfigMgr->GetIntDefault("GM.LoginState", 2);
-    m_int_configs[CONFIG_GM_VISIBLE_STATE]      = sConfigMgr->GetIntDefault("GM.Visible", 2);
-    m_int_configs[CONFIG_GM_CHAT]               = sConfigMgr->GetIntDefault("GM.Chat", 2);
-    m_int_configs[CONFIG_GM_WHISPERING_TO]      = sConfigMgr->GetIntDefault("GM.WhisperingTo", 2);
+    m_int_configs[CONFIG_GM_LOGIN_STATE]        = ConfigMgr::GetIntDefault("GM.LoginState", 2);
+    m_int_configs[CONFIG_GM_VISIBLE_STATE]      = ConfigMgr::GetIntDefault("GM.Visible", 2);
+    m_int_configs[CONFIG_GM_CHAT]               = ConfigMgr::GetIntDefault("GM.Chat", 2);
+    m_int_configs[CONFIG_GM_WHISPERING_TO]      = ConfigMgr::GetIntDefault("GM.WhisperingTo", 2);
 
-    m_int_configs[CONFIG_GM_LEVEL_IN_GM_LIST]   = sConfigMgr->GetIntDefault("GM.InGMList.Level", SEC_ADMINISTRATOR);
-    m_int_configs[CONFIG_GM_LEVEL_IN_WHO_LIST]  = sConfigMgr->GetIntDefault("GM.InWhoList.Level", SEC_ADMINISTRATOR);
-    m_int_configs[CONFIG_START_GM_LEVEL]        = sConfigMgr->GetIntDefault("GM.StartLevel", 1);
+    m_int_configs[CONFIG_GM_LEVEL_IN_GM_LIST]   = ConfigMgr::GetIntDefault("GM.InGMList.Level", SEC_ADMINISTRATOR);
+    m_int_configs[CONFIG_GM_LEVEL_IN_WHO_LIST]  = ConfigMgr::GetIntDefault("GM.InWhoList.Level", SEC_ADMINISTRATOR);
+    m_int_configs[CONFIG_START_GM_LEVEL]        = ConfigMgr::GetIntDefault("GM.StartLevel", 1);
     if (m_int_configs[CONFIG_START_GM_LEVEL] < m_int_configs[CONFIG_START_PLAYER_LEVEL])
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "GM.StartLevel (%i) must be in range StartPlayerLevel(%u)..%u. Set to %u.",
@@ -864,15 +864,15 @@ void World::LoadConfigSettings(bool reload)
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "GM.StartLevel (%i) must be in range 1..%u. Set to %u.", m_int_configs[CONFIG_START_GM_LEVEL], MAX_LEVEL, MAX_LEVEL);
         m_int_configs[CONFIG_START_GM_LEVEL] = MAX_LEVEL;
     }
-    m_bool_configs[CONFIG_ALLOW_GM_GROUP]       = sConfigMgr->GetBoolDefault("GM.AllowInvite", false);
-    m_bool_configs[CONFIG_GM_LOWER_SECURITY] = sConfigMgr->GetBoolDefault("GM.LowerSecurity", false);
-    m_float_configs[CONFIG_CHANCE_OF_GM_SURVEY] = sConfigMgr->GetFloatDefault("GM.TicketSystem.ChanceOfGMSurvey", 50.0f);
+    m_bool_configs[CONFIG_ALLOW_GM_GROUP]       = ConfigMgr::GetBoolDefault("GM.AllowInvite", false);
+    m_bool_configs[CONFIG_GM_LOWER_SECURITY] = ConfigMgr::GetBoolDefault("GM.LowerSecurity", false);
+    m_float_configs[CONFIG_CHANCE_OF_GM_SURVEY] = ConfigMgr::GetFloatDefault("GM.TicketSystem.ChanceOfGMSurvey", 50.0f);
 
-    m_int_configs[CONFIG_GROUP_VISIBILITY] = sConfigMgr->GetIntDefault("Visibility.GroupMode", 1);
+    m_int_configs[CONFIG_GROUP_VISIBILITY] = ConfigMgr::GetIntDefault("Visibility.GroupMode", 1);
 
-    m_int_configs[CONFIG_MAIL_DELIVERY_DELAY] = sConfigMgr->GetIntDefault("MailDeliveryDelay", HOUR);
+    m_int_configs[CONFIG_MAIL_DELIVERY_DELAY] = ConfigMgr::GetIntDefault("MailDeliveryDelay", HOUR);
 
-    m_int_configs[CONFIG_UPTIME_UPDATE] = sConfigMgr->GetIntDefault("UpdateUptimeInterval", 10);
+    m_int_configs[CONFIG_UPTIME_UPDATE] = ConfigMgr::GetIntDefault("UpdateUptimeInterval", 10);
     if (int32(m_int_configs[CONFIG_UPTIME_UPDATE]) <= 0)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "UpdateUptimeInterval (%i) must be > 0, set to default 10.", m_int_configs[CONFIG_UPTIME_UPDATE]);
@@ -885,7 +885,7 @@ void World::LoadConfigSettings(bool reload)
     }
 
     // log db cleanup interval
-    m_int_configs[CONFIG_LOGDB_CLEARINTERVAL] = sConfigMgr->GetIntDefault("LogDB.Opt.ClearInterval", 10);
+    m_int_configs[CONFIG_LOGDB_CLEARINTERVAL] = ConfigMgr::GetIntDefault("LogDB.Opt.ClearInterval", 10);
     if (int32(m_int_configs[CONFIG_LOGDB_CLEARINTERVAL]) <= 0)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "LogDB.Opt.ClearInterval (%i) must be > 0, set to default 10.", m_int_configs[CONFIG_LOGDB_CLEARINTERVAL]);
@@ -896,146 +896,146 @@ void World::LoadConfigSettings(bool reload)
         m_timers[WUPDATE_CLEANDB].SetInterval(m_int_configs[CONFIG_LOGDB_CLEARINTERVAL] * MINUTE * IN_MILLISECONDS);
         m_timers[WUPDATE_CLEANDB].Reset();
     }
-    m_int_configs[CONFIG_LOGDB_CLEARTIME] = sConfigMgr->GetIntDefault("LogDB.Opt.ClearTime", 1209600); // 14 days default
+    m_int_configs[CONFIG_LOGDB_CLEARTIME] = ConfigMgr::GetIntDefault("LogDB.Opt.ClearTime", 1209600); // 14 days default
     TC_LOG_INFO(LOG_FILTER_SERVER_LOADING, "Will clear `logs` table of entries older than %i seconds every %u minutes.",
         m_int_configs[CONFIG_LOGDB_CLEARTIME], m_int_configs[CONFIG_LOGDB_CLEARINTERVAL]);
 
-    m_int_configs[CONFIG_SKILL_CHANCE_ORANGE] = sConfigMgr->GetIntDefault("SkillChance.Orange", 100);
-    m_int_configs[CONFIG_SKILL_CHANCE_YELLOW] = sConfigMgr->GetIntDefault("SkillChance.Yellow", 75);
-    m_int_configs[CONFIG_SKILL_CHANCE_GREEN]  = sConfigMgr->GetIntDefault("SkillChance.Green", 25);
-    m_int_configs[CONFIG_SKILL_CHANCE_GREY]   = sConfigMgr->GetIntDefault("SkillChance.Grey", 0);
+    m_int_configs[CONFIG_SKILL_CHANCE_ORANGE] = ConfigMgr::GetIntDefault("SkillChance.Orange", 100);
+    m_int_configs[CONFIG_SKILL_CHANCE_YELLOW] = ConfigMgr::GetIntDefault("SkillChance.Yellow", 75);
+    m_int_configs[CONFIG_SKILL_CHANCE_GREEN]  = ConfigMgr::GetIntDefault("SkillChance.Green", 25);
+    m_int_configs[CONFIG_SKILL_CHANCE_GREY]   = ConfigMgr::GetIntDefault("SkillChance.Grey", 0);
 
-    m_int_configs[CONFIG_SKILL_CHANCE_MINING_STEPS]  = sConfigMgr->GetIntDefault("SkillChance.MiningSteps", 75);
-    m_int_configs[CONFIG_SKILL_CHANCE_SKINNING_STEPS]   = sConfigMgr->GetIntDefault("SkillChance.SkinningSteps", 75);
+    m_int_configs[CONFIG_SKILL_CHANCE_MINING_STEPS]  = ConfigMgr::GetIntDefault("SkillChance.MiningSteps", 75);
+    m_int_configs[CONFIG_SKILL_CHANCE_SKINNING_STEPS]   = ConfigMgr::GetIntDefault("SkillChance.SkinningSteps", 75);
 
-    m_bool_configs[CONFIG_SKILL_PROSPECTING] = sConfigMgr->GetBoolDefault("SkillChance.Prospecting", false);
-    m_bool_configs[CONFIG_SKILL_MILLING] = sConfigMgr->GetBoolDefault("SkillChance.Milling", false);
+    m_bool_configs[CONFIG_SKILL_PROSPECTING] = ConfigMgr::GetBoolDefault("SkillChance.Prospecting", false);
+    m_bool_configs[CONFIG_SKILL_MILLING] = ConfigMgr::GetBoolDefault("SkillChance.Milling", false);
 
-    m_int_configs[CONFIG_SKILL_GAIN_CRAFTING]  = sConfigMgr->GetIntDefault("SkillGain.Crafting", 1);
+    m_int_configs[CONFIG_SKILL_GAIN_CRAFTING]  = ConfigMgr::GetIntDefault("SkillGain.Crafting", 1);
 
-    m_int_configs[CONFIG_SKILL_GAIN_DEFENSE]  = sConfigMgr->GetIntDefault("SkillGain.Defense", 1);
+    m_int_configs[CONFIG_SKILL_GAIN_DEFENSE]  = ConfigMgr::GetIntDefault("SkillGain.Defense", 1);
 
-    m_int_configs[CONFIG_SKILL_GAIN_GATHERING]  = sConfigMgr->GetIntDefault("SkillGain.Gathering", 1);
+    m_int_configs[CONFIG_SKILL_GAIN_GATHERING]  = ConfigMgr::GetIntDefault("SkillGain.Gathering", 1);
 
-    m_int_configs[CONFIG_SKILL_GAIN_WEAPON]  = sConfigMgr->GetIntDefault("SkillGain.Weapon", 1);
+    m_int_configs[CONFIG_SKILL_GAIN_WEAPON]  = ConfigMgr::GetIntDefault("SkillGain.Weapon", 1);
 
-    m_int_configs[CONFIG_MAX_OVERSPEED_PINGS] = sConfigMgr->GetIntDefault("MaxOverspeedPings", 2);
+    m_int_configs[CONFIG_MAX_OVERSPEED_PINGS] = ConfigMgr::GetIntDefault("MaxOverspeedPings", 2);
     if (m_int_configs[CONFIG_MAX_OVERSPEED_PINGS] != 0 && m_int_configs[CONFIG_MAX_OVERSPEED_PINGS] < 2)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "MaxOverspeedPings (%i) must be in range 2..infinity (or 0 to disable check). Set to 2.", m_int_configs[CONFIG_MAX_OVERSPEED_PINGS]);
         m_int_configs[CONFIG_MAX_OVERSPEED_PINGS] = 2;
     }
 
-    m_bool_configs[CONFIG_SAVE_RESPAWN_TIME_IMMEDIATELY] = sConfigMgr->GetBoolDefault("SaveRespawnTimeImmediately", true);
-    m_bool_configs[CONFIG_WEATHER] = sConfigMgr->GetBoolDefault("ActivateWeather", true);
+    m_bool_configs[CONFIG_SAVE_RESPAWN_TIME_IMMEDIATELY] = ConfigMgr::GetBoolDefault("SaveRespawnTimeImmediately", true);
+    m_bool_configs[CONFIG_WEATHER] = ConfigMgr::GetBoolDefault("ActivateWeather", true);
 
-    m_int_configs[CONFIG_DISABLE_BREATHING] = sConfigMgr->GetIntDefault("DisableWaterBreath", SEC_CONSOLE);
+    m_int_configs[CONFIG_DISABLE_BREATHING] = ConfigMgr::GetIntDefault("DisableWaterBreath", SEC_CONSOLE);
 
-    m_bool_configs[CONFIG_ALWAYS_MAX_SKILL_FOR_LEVEL] = sConfigMgr->GetBoolDefault("AlwaysMaxSkillForLevel", false);
+    m_bool_configs[CONFIG_ALWAYS_MAX_SKILL_FOR_LEVEL] = ConfigMgr::GetBoolDefault("AlwaysMaxSkillForLevel", false);
 
     if (reload)
     {
-        uint32 val = sConfigMgr->GetIntDefault("Expansion", 1);
+        uint32 val = ConfigMgr::GetIntDefault("Expansion", 1);
         if (val != m_int_configs[CONFIG_EXPANSION])
             TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Expansion option can't be changed at worldserver.conf reload, using current value (%u).", m_int_configs[CONFIG_EXPANSION]);
     }
     else
-        m_int_configs[CONFIG_EXPANSION] = sConfigMgr->GetIntDefault("Expansion", 1);
+        m_int_configs[CONFIG_EXPANSION] = ConfigMgr::GetIntDefault("Expansion", 1);
 
-    m_int_configs[CONFIG_CHATFLOOD_MESSAGE_COUNT] = sConfigMgr->GetIntDefault("ChatFlood.MessageCount", 10);
-    m_int_configs[CONFIG_CHATFLOOD_MESSAGE_DELAY] = sConfigMgr->GetIntDefault("ChatFlood.MessageDelay", 1);
-    m_int_configs[CONFIG_CHATFLOOD_MUTE_TIME]     = sConfigMgr->GetIntDefault("ChatFlood.MuteTime", 10);
+    m_int_configs[CONFIG_CHATFLOOD_MESSAGE_COUNT] = ConfigMgr::GetIntDefault("ChatFlood.MessageCount", 10);
+    m_int_configs[CONFIG_CHATFLOOD_MESSAGE_DELAY] = ConfigMgr::GetIntDefault("ChatFlood.MessageDelay", 1);
+    m_int_configs[CONFIG_CHATFLOOD_MUTE_TIME]     = ConfigMgr::GetIntDefault("ChatFlood.MuteTime", 10);
 
-    m_bool_configs[CONFIG_EVENT_ANNOUNCE] = sConfigMgr->GetIntDefault("Event.Announce", false);
+    m_bool_configs[CONFIG_EVENT_ANNOUNCE] = ConfigMgr::GetIntDefault("Event.Announce", false);
 
-    m_float_configs[CONFIG_CREATURE_FAMILY_FLEE_ASSISTANCE_RADIUS] = sConfigMgr->GetFloatDefault("CreatureFamilyFleeAssistanceRadius", 30.0f);
-    m_float_configs[CONFIG_CREATURE_FAMILY_ASSISTANCE_RADIUS] = sConfigMgr->GetFloatDefault("CreatureFamilyAssistanceRadius", 10.0f);
-    m_int_configs[CONFIG_CREATURE_FAMILY_ASSISTANCE_DELAY]  = sConfigMgr->GetIntDefault("CreatureFamilyAssistanceDelay", 1500);
-    m_int_configs[CONFIG_CREATURE_FAMILY_FLEE_DELAY]        = sConfigMgr->GetIntDefault("CreatureFamilyFleeDelay", 7000);
+    m_float_configs[CONFIG_CREATURE_FAMILY_FLEE_ASSISTANCE_RADIUS] = ConfigMgr::GetFloatDefault("CreatureFamilyFleeAssistanceRadius", 30.0f);
+    m_float_configs[CONFIG_CREATURE_FAMILY_ASSISTANCE_RADIUS] = ConfigMgr::GetFloatDefault("CreatureFamilyAssistanceRadius", 10.0f);
+    m_int_configs[CONFIG_CREATURE_FAMILY_ASSISTANCE_DELAY]  = ConfigMgr::GetIntDefault("CreatureFamilyAssistanceDelay", 1500);
+    m_int_configs[CONFIG_CREATURE_FAMILY_FLEE_DELAY]        = ConfigMgr::GetIntDefault("CreatureFamilyFleeDelay", 7000);
 
-    m_int_configs[CONFIG_WORLD_BOSS_LEVEL_DIFF] = sConfigMgr->GetIntDefault("WorldBossLevelDiff", 3);
+    m_int_configs[CONFIG_WORLD_BOSS_LEVEL_DIFF] = ConfigMgr::GetIntDefault("WorldBossLevelDiff", 3);
 
     // note: disable value (-1) will assigned as 0xFFFFFFF, to prevent overflow at calculations limit it to max possible player level MAX_LEVEL(100)
-    m_int_configs[CONFIG_QUEST_LOW_LEVEL_HIDE_DIFF] = sConfigMgr->GetIntDefault("Quests.LowLevelHideDiff", 4);
+    m_int_configs[CONFIG_QUEST_LOW_LEVEL_HIDE_DIFF] = ConfigMgr::GetIntDefault("Quests.LowLevelHideDiff", 4);
     if (m_int_configs[CONFIG_QUEST_LOW_LEVEL_HIDE_DIFF] > MAX_LEVEL)
         m_int_configs[CONFIG_QUEST_LOW_LEVEL_HIDE_DIFF] = MAX_LEVEL;
-    m_int_configs[CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF] = sConfigMgr->GetIntDefault("Quests.HighLevelHideDiff", 7);
+    m_int_configs[CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF] = ConfigMgr::GetIntDefault("Quests.HighLevelHideDiff", 7);
     if (m_int_configs[CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF] > MAX_LEVEL)
         m_int_configs[CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF] = MAX_LEVEL;
-    m_bool_configs[CONFIG_QUEST_IGNORE_RAID] = sConfigMgr->GetBoolDefault("Quests.IgnoreRaid", false);
-    m_bool_configs[CONFIG_QUEST_IGNORE_AUTO_ACCEPT] = sConfigMgr->GetBoolDefault("Quests.IgnoreAutoAccept", false);
-    m_bool_configs[CONFIG_QUEST_IGNORE_AUTO_COMPLETE] = sConfigMgr->GetBoolDefault("Quests.IgnoreAutoComplete", false);
+    m_bool_configs[CONFIG_QUEST_IGNORE_RAID] = ConfigMgr::GetBoolDefault("Quests.IgnoreRaid", false);
+    m_bool_configs[CONFIG_QUEST_IGNORE_AUTO_ACCEPT] = ConfigMgr::GetBoolDefault("Quests.IgnoreAutoAccept", false);
+    m_bool_configs[CONFIG_QUEST_IGNORE_AUTO_COMPLETE] = ConfigMgr::GetBoolDefault("Quests.IgnoreAutoComplete", false);
 
-    m_int_configs[CONFIG_RANDOM_BG_RESET_HOUR] = sConfigMgr->GetIntDefault("Battleground.Random.ResetHour", 6);
+    m_int_configs[CONFIG_RANDOM_BG_RESET_HOUR] = ConfigMgr::GetIntDefault("Battleground.Random.ResetHour", 6);
     if (m_int_configs[CONFIG_RANDOM_BG_RESET_HOUR] > 23)
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Battleground.Random.ResetHour (%i) can't be load. Set to 6.", m_int_configs[CONFIG_RANDOM_BG_RESET_HOUR]);
         m_int_configs[CONFIG_RANDOM_BG_RESET_HOUR] = 6;
     }
 
-    m_int_configs[CONFIG_GUILD_RESET_HOUR] = sConfigMgr->GetIntDefault("Guild.ResetHour", 6);
+    m_int_configs[CONFIG_GUILD_RESET_HOUR] = ConfigMgr::GetIntDefault("Guild.ResetHour", 6);
     if (m_int_configs[CONFIG_GUILD_RESET_HOUR] > 23)
     {
         TC_LOG_ERROR(LOG_FILTER_GENERAL, "Guild.ResetHour (%i) can't be load. Set to 6.", m_int_configs[CONFIG_GUILD_RESET_HOUR]);
         m_int_configs[CONFIG_GUILD_RESET_HOUR] = 6;
     }
 
-    m_bool_configs[CONFIG_DETECT_POS_COLLISION] = sConfigMgr->GetBoolDefault("DetectPosCollision", true);
+    m_bool_configs[CONFIG_DETECT_POS_COLLISION] = ConfigMgr::GetBoolDefault("DetectPosCollision", true);
 
-    m_bool_configs[CONFIG_RESTRICTED_LFG_CHANNEL]      = sConfigMgr->GetBoolDefault("Channel.RestrictedLfg", true);
-    m_bool_configs[CONFIG_TALENTS_INSPECTING]           = sConfigMgr->GetBoolDefault("TalentsInspecting", true);
-    m_bool_configs[CONFIG_CHAT_FAKE_MESSAGE_PREVENTING] = sConfigMgr->GetBoolDefault("ChatFakeMessagePreventing", false);
-    m_int_configs[CONFIG_CHAT_STRICT_LINK_CHECKING_SEVERITY] = sConfigMgr->GetIntDefault("ChatStrictLinkChecking.Severity", 0);
-    m_int_configs[CONFIG_CHAT_STRICT_LINK_CHECKING_KICK] = sConfigMgr->GetIntDefault("ChatStrictLinkChecking.Kick", 0);
+    m_bool_configs[CONFIG_RESTRICTED_LFG_CHANNEL]      = ConfigMgr::GetBoolDefault("Channel.RestrictedLfg", true);
+    m_bool_configs[CONFIG_TALENTS_INSPECTING]           = ConfigMgr::GetBoolDefault("TalentsInspecting", true);
+    m_bool_configs[CONFIG_CHAT_FAKE_MESSAGE_PREVENTING] = ConfigMgr::GetBoolDefault("ChatFakeMessagePreventing", false);
+    m_int_configs[CONFIG_CHAT_STRICT_LINK_CHECKING_SEVERITY] = ConfigMgr::GetIntDefault("ChatStrictLinkChecking.Severity", 0);
+    m_int_configs[CONFIG_CHAT_STRICT_LINK_CHECKING_KICK] = ConfigMgr::GetIntDefault("ChatStrictLinkChecking.Kick", 0);
 
-    m_int_configs[CONFIG_CORPSE_DECAY_NORMAL]    = sConfigMgr->GetIntDefault("Corpse.Decay.NORMAL", 60);
-    m_int_configs[CONFIG_CORPSE_DECAY_RARE]      = sConfigMgr->GetIntDefault("Corpse.Decay.RARE", 300);
-    m_int_configs[CONFIG_CORPSE_DECAY_ELITE]     = sConfigMgr->GetIntDefault("Corpse.Decay.ELITE", 300);
-    m_int_configs[CONFIG_CORPSE_DECAY_RAREELITE] = sConfigMgr->GetIntDefault("Corpse.Decay.RAREELITE", 300);
-    m_int_configs[CONFIG_CORPSE_DECAY_WORLDBOSS] = sConfigMgr->GetIntDefault("Corpse.Decay.WORLDBOSS", 3600);
+    m_int_configs[CONFIG_CORPSE_DECAY_NORMAL]    = ConfigMgr::GetIntDefault("Corpse.Decay.NORMAL", 60);
+    m_int_configs[CONFIG_CORPSE_DECAY_RARE]      = ConfigMgr::GetIntDefault("Corpse.Decay.RARE", 300);
+    m_int_configs[CONFIG_CORPSE_DECAY_ELITE]     = ConfigMgr::GetIntDefault("Corpse.Decay.ELITE", 300);
+    m_int_configs[CONFIG_CORPSE_DECAY_RAREELITE] = ConfigMgr::GetIntDefault("Corpse.Decay.RAREELITE", 300);
+    m_int_configs[CONFIG_CORPSE_DECAY_WORLDBOSS] = ConfigMgr::GetIntDefault("Corpse.Decay.WORLDBOSS", 3600);
 
-    m_int_configs[CONFIG_DEATH_SICKNESS_LEVEL]           = sConfigMgr->GetIntDefault ("Death.SicknessLevel", 11);
-    m_bool_configs[CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP] = sConfigMgr->GetBoolDefault("Death.CorpseReclaimDelay.PvP", true);
-    m_bool_configs[CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE] = sConfigMgr->GetBoolDefault("Death.CorpseReclaimDelay.PvE", true);
-    m_bool_configs[CONFIG_DEATH_BONES_WORLD]              = sConfigMgr->GetBoolDefault("Death.Bones.World", true);
-    m_bool_configs[CONFIG_DEATH_BONES_BG_OR_ARENA]        = sConfigMgr->GetBoolDefault("Death.Bones.BattlegroundOrArena", true);
+    m_int_configs[CONFIG_DEATH_SICKNESS_LEVEL]           = ConfigMgr::GetIntDefault ("Death.SicknessLevel", 11);
+    m_bool_configs[CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP] = ConfigMgr::GetBoolDefault("Death.CorpseReclaimDelay.PvP", true);
+    m_bool_configs[CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE] = ConfigMgr::GetBoolDefault("Death.CorpseReclaimDelay.PvE", true);
+    m_bool_configs[CONFIG_DEATH_BONES_WORLD]              = ConfigMgr::GetBoolDefault("Death.Bones.World", true);
+    m_bool_configs[CONFIG_DEATH_BONES_BG_OR_ARENA]        = ConfigMgr::GetBoolDefault("Death.Bones.BattlegroundOrArena", true);
 
-    m_bool_configs[CONFIG_DIE_COMMAND_MODE] = sConfigMgr->GetBoolDefault("Die.Command.Mode", true);
+    m_bool_configs[CONFIG_DIE_COMMAND_MODE] = ConfigMgr::GetBoolDefault("Die.Command.Mode", true);
 
-    m_float_configs[CONFIG_THREAT_RADIUS] = sConfigMgr->GetFloatDefault("ThreatRadius", 60.0f);
+    m_float_configs[CONFIG_THREAT_RADIUS] = ConfigMgr::GetFloatDefault("ThreatRadius", 60.0f);
 
     // always use declined names in the russian client
     m_bool_configs[CONFIG_DECLINED_NAMES_USED] =
-        (m_int_configs[CONFIG_REALM_ZONE] == REALM_ZONE_RUSSIAN) ? true : sConfigMgr->GetBoolDefault("DeclinedNames", false);
-
-    m_float_configs[CONFIG_LISTEN_RANGE_SAY]       = sConfigMgr->GetFloatDefault("ListenRange.Say", 25.0f);
-    m_float_configs[CONFIG_LISTEN_RANGE_TEXTEMOTE] = sConfigMgr->GetFloatDefault("ListenRange.TextEmote", 25.0f);
-    m_float_configs[CONFIG_LISTEN_RANGE_YELL]      = sConfigMgr->GetFloatDefault("ListenRange.Yell", 300.0f);
-
-    m_bool_configs[CONFIG_BATTLEGROUND_CAST_DESERTER]                = sConfigMgr->GetBoolDefault("Battleground.CastDeserter", true);
-    m_bool_configs[CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_ENABLE]       = sConfigMgr->GetBoolDefault("Battleground.QueueAnnouncer.Enable", false);
-    m_bool_configs[CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY]   = sConfigMgr->GetBoolDefault("Battleground.QueueAnnouncer.PlayerOnly", false);
-    m_int_configs[CONFIG_BATTLEGROUND_INVITATION_TYPE]               = sConfigMgr->GetIntDefault ("Battleground.InvitationType", 0);
-    m_int_configs[CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER]        = sConfigMgr->GetIntDefault ("Battleground.PrematureFinishTimer", 5 * MINUTE * IN_MILLISECONDS);
-    m_int_configs[CONFIG_BATTLEGROUND_PREMADE_GROUP_WAIT_FOR_MATCH]  = sConfigMgr->GetIntDefault ("Battleground.PremadeGroupWaitForMatch", 30 * MINUTE * IN_MILLISECONDS);
-    m_bool_configs[CONFIG_BG_XP_FOR_KILL]                            = sConfigMgr->GetBoolDefault("Battleground.GiveXPForKills", false);
-    m_int_configs[CONFIG_ARENA_MAX_RATING_DIFFERENCE]                = sConfigMgr->GetIntDefault ("Arena.MaxRatingDifference", 150);
-    m_int_configs[CONFIG_ARENA_RATING_DISCARD_TIMER]                 = sConfigMgr->GetIntDefault ("Arena.RatingDiscardTimer", 10 * MINUTE * IN_MILLISECONDS);
-    m_int_configs[CONFIG_ARENA_RATED_UPDATE_TIMER]                   = sConfigMgr->GetIntDefault ("Arena.RatedUpdateTimer", 5 * IN_MILLISECONDS);
-    m_bool_configs[CONFIG_ARENA_AUTO_DISTRIBUTE_POINTS]              = sConfigMgr->GetBoolDefault("Arena.AutoDistributePoints", false);
-    m_int_configs[CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS]        = sConfigMgr->GetIntDefault ("Arena.AutoDistributeInterval", 7);
-    m_bool_configs[CONFIG_ARENA_QUEUE_ANNOUNCER_ENABLE]              = sConfigMgr->GetBoolDefault("Arena.QueueAnnouncer.Enable", false);
-    m_bool_configs[CONFIG_ARENA_QUEUE_ANNOUNCER_PLAYERONLY]          = sConfigMgr->GetBoolDefault("Arena.QueueAnnouncer.PlayerOnly", false);
-    m_int_configs[CONFIG_ARENA_SEASON_ID]                            = sConfigMgr->GetIntDefault ("Arena.ArenaSeason.ID", 1);
-    m_int_configs[CONFIG_ARENA_START_RATING]                         = sConfigMgr->GetIntDefault ("Arena.ArenaStartRating", 0);
-    m_int_configs[CONFIG_ARENA_START_PERSONAL_RATING]                = sConfigMgr->GetIntDefault ("Arena.ArenaStartPersonalRating", 1000);
-    m_int_configs[CONFIG_ARENA_START_MATCHMAKER_RATING]              = sConfigMgr->GetIntDefault ("Arena.ArenaStartMatchmakerRating", 1500);
-    m_bool_configs[CONFIG_ARENA_SEASON_IN_PROGRESS]                  = sConfigMgr->GetBoolDefault("Arena.ArenaSeason.InProgress", true);
-    m_bool_configs[CONFIG_ARENA_LOG_EXTENDED_INFO]                   = sConfigMgr->GetBoolDefault("ArenaLog.ExtendedInfo", false);
-
-    m_bool_configs[CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN]            = sConfigMgr->GetBoolDefault("OffhandCheckAtSpellUnlearn", true);
-
-    if (int32 clientCacheId = sConfigMgr->GetIntDefault("ClientCacheVersion", 0))
+        (m_int_configs[CONFIG_REALM_ZONE] == REALM_ZONE_RUSSIAN) ? true : ConfigMgr::GetBoolDefault("DeclinedNames", false);
+
+    m_float_configs[CONFIG_LISTEN_RANGE_SAY]       = ConfigMgr::GetFloatDefault("ListenRange.Say", 25.0f);
+    m_float_configs[CONFIG_LISTEN_RANGE_TEXTEMOTE] = ConfigMgr::GetFloatDefault("ListenRange.TextEmote", 25.0f);
+    m_float_configs[CONFIG_LISTEN_RANGE_YELL]      = ConfigMgr::GetFloatDefault("ListenRange.Yell", 300.0f);
+
+    m_bool_configs[CONFIG_BATTLEGROUND_CAST_DESERTER]                = ConfigMgr::GetBoolDefault("Battleground.CastDeserter", true);
+    m_bool_configs[CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_ENABLE]       = ConfigMgr::GetBoolDefault("Battleground.QueueAnnouncer.Enable", false);
+    m_bool_configs[CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY]   = ConfigMgr::GetBoolDefault("Battleground.QueueAnnouncer.PlayerOnly", false);
+    m_int_configs[CONFIG_BATTLEGROUND_INVITATION_TYPE]               = ConfigMgr::GetIntDefault ("Battleground.InvitationType", 0);
+    m_int_configs[CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER]        = ConfigMgr::GetIntDefault ("Battleground.PrematureFinishTimer", 5 * MINUTE * IN_MILLISECONDS);
+    m_int_configs[CONFIG_BATTLEGROUND_PREMADE_GROUP_WAIT_FOR_MATCH]  = ConfigMgr::GetIntDefault ("Battleground.PremadeGroupWaitForMatch", 30 * MINUTE * IN_MILLISECONDS);
+    m_bool_configs[CONFIG_BG_XP_FOR_KILL]                            = ConfigMgr::GetBoolDefault("Battleground.GiveXPForKills", false);
+    m_int_configs[CONFIG_ARENA_MAX_RATING_DIFFERENCE]                = ConfigMgr::GetIntDefault ("Arena.MaxRatingDifference", 150);
+    m_int_configs[CONFIG_ARENA_RATING_DISCARD_TIMER]                 = ConfigMgr::GetIntDefault ("Arena.RatingDiscardTimer", 10 * MINUTE * IN_MILLISECONDS);
+    m_int_configs[CONFIG_ARENA_RATED_UPDATE_TIMER]                   = ConfigMgr::GetIntDefault ("Arena.RatedUpdateTimer", 5 * IN_MILLISECONDS);
+    m_bool_configs[CONFIG_ARENA_AUTO_DISTRIBUTE_POINTS]              = ConfigMgr::GetBoolDefault("Arena.AutoDistributePoints", false);
+    m_int_configs[CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS]        = ConfigMgr::GetIntDefault ("Arena.AutoDistributeInterval", 7);
+    m_bool_configs[CONFIG_ARENA_QUEUE_ANNOUNCER_ENABLE]              = ConfigMgr::GetBoolDefault("Arena.QueueAnnouncer.Enable", false);
+    m_bool_configs[CONFIG_ARENA_QUEUE_ANNOUNCER_PLAYERONLY]          = ConfigMgr::GetBoolDefault("Arena.QueueAnnouncer.PlayerOnly", false);
+    m_int_configs[CONFIG_ARENA_SEASON_ID]                            = ConfigMgr::GetIntDefault ("Arena.ArenaSeason.ID", 1);
+    m_int_configs[CONFIG_ARENA_START_RATING]                         = ConfigMgr::GetIntDefault ("Arena.ArenaStartRating", 0);
+    m_int_configs[CONFIG_ARENA_START_PERSONAL_RATING]                = ConfigMgr::GetIntDefault ("Arena.ArenaStartPersonalRating", 1000);
+    m_int_configs[CONFIG_ARENA_START_MATCHMAKER_RATING]              = ConfigMgr::GetIntDefault ("Arena.ArenaStartMatchmakerRating", 1500);
+    m_bool_configs[CONFIG_ARENA_SEASON_IN_PROGRESS]                  = ConfigMgr::GetBoolDefault("Arena.ArenaSeason.InProgress", true);
+    m_bool_configs[CONFIG_ARENA_LOG_EXTENDED_INFO]                   = ConfigMgr::GetBoolDefault("ArenaLog.ExtendedInfo", false);
+
+    m_bool_configs[CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN]            = ConfigMgr::GetBoolDefault("OffhandCheckAtSpellUnlearn", true);
+
+    if (int32 clientCacheId = ConfigMgr::GetIntDefault("ClientCacheVersion", 0))
     {
         // overwrite DB/old value
         if (clientCacheId > 0)
@@ -1047,15 +1047,15 @@ void World::LoadConfigSettings(bool reload)
             TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "ClientCacheVersion can't be negative %d, ignored.", clientCacheId);
     }
 
-    m_int_configs[CONFIG_GUILD_EVENT_LOG_COUNT] = sConfigMgr->GetIntDefault("Guild.EventLogRecordsCount", GUILD_EVENTLOG_MAX_RECORDS);
+    m_int_configs[CONFIG_GUILD_EVENT_LOG_COUNT] = ConfigMgr::GetIntDefault("Guild.EventLogRecordsCount", GUILD_EVENTLOG_MAX_RECORDS);
     if (m_int_configs[CONFIG_GUILD_EVENT_LOG_COUNT] > GUILD_EVENTLOG_MAX_RECORDS)
         m_int_configs[CONFIG_GUILD_EVENT_LOG_COUNT] = GUILD_EVENTLOG_MAX_RECORDS;
-    m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] = sConfigMgr->GetIntDefault("Guild.BankEventLogRecordsCount", GUILD_BANKLOG_MAX_RECORDS);
+    m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] = ConfigMgr::GetIntDefault("Guild.BankEventLogRecordsCount", GUILD_BANKLOG_MAX_RECORDS);
     if (m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] > GUILD_BANKLOG_MAX_RECORDS)
         m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] = GUILD_BANKLOG_MAX_RECORDS;
 
     //visibility on continents
-    m_MaxVisibleDistanceOnContinents = sConfigMgr->GetFloatDefault("Visibility.Distance.Continents", DEFAULT_VISIBILITY_DISTANCE);
+    m_MaxVisibleDistanceOnContinents = ConfigMgr::GetFloatDefault("Visibility.Distance.Continents", DEFAULT_VISIBILITY_DISTANCE);
     if (m_MaxVisibleDistanceOnContinents < 45*sWorld->getRate(RATE_CREATURE_AGGRO))
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Visibility.Distance.Continents can't be less max aggro radius %f", 45*sWorld->getRate(RATE_CREATURE_AGGRO));
@@ -1068,7 +1068,7 @@ void World::LoadConfigSettings(bool reload)
     }
 
     //visibility in instances
-    m_MaxVisibleDistanceInInstances = sConfigMgr->GetFloatDefault("Visibility.Distance.Instances", DEFAULT_VISIBILITY_INSTANCE);
+    m_MaxVisibleDistanceInInstances = ConfigMgr::GetFloatDefault("Visibility.Distance.Instances", DEFAULT_VISIBILITY_INSTANCE);
     if (m_MaxVisibleDistanceInInstances < 45*sWorld->getRate(RATE_CREATURE_AGGRO))
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Visibility.Distance.Instances can't be less max aggro radius %f", 45*sWorld->getRate(RATE_CREATURE_AGGRO));
@@ -1081,7 +1081,7 @@ void World::LoadConfigSettings(bool reload)
     }
 
     //visibility in BG/Arenas
-    m_MaxVisibleDistanceInBGArenas = sConfigMgr->GetFloatDefault("Visibility.Distance.BGArenas", DEFAULT_VISIBILITY_BGARENAS);
+    m_MaxVisibleDistanceInBGArenas = ConfigMgr::GetFloatDefault("Visibility.Distance.BGArenas", DEFAULT_VISIBILITY_BGARENAS);
     if (m_MaxVisibleDistanceInBGArenas < 45*sWorld->getRate(RATE_CREATURE_AGGRO))
     {
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "Visibility.Distance.BGArenas can't be less max aggro radius %f", 45*sWorld->getRate(RATE_CREATURE_AGGRO));
@@ -1093,18 +1093,18 @@ void World::LoadConfigSettings(bool reload)
         m_MaxVisibleDistanceInBGArenas = MAX_VISIBILITY_DISTANCE;
     }
 
-    m_visibility_notify_periodOnContinents = sConfigMgr->GetIntDefault("Visibility.Notify.Period.OnContinents", DEFAULT_VISIBILITY_NOTIFY_PERIOD);
-    m_visibility_notify_periodInInstances = sConfigMgr->GetIntDefault("Visibility.Notify.Period.InInstances",   DEFAULT_VISIBILITY_NOTIFY_PERIOD);
-    m_visibility_notify_periodInBGArenas = sConfigMgr->GetIntDefault("Visibility.Notify.Period.InBGArenas",    DEFAULT_VISIBILITY_NOTIFY_PERIOD);
+    m_visibility_notify_periodOnContinents = ConfigMgr::GetIntDefault("Visibility.Notify.Period.OnContinents", DEFAULT_VISIBILITY_NOTIFY_PERIOD);
+    m_visibility_notify_periodInInstances = ConfigMgr::GetIntDefault("Visibility.Notify.Period.InInstances",   DEFAULT_VISIBILITY_NOTIFY_PERIOD);
+    m_visibility_notify_periodInBGArenas = ConfigMgr::GetIntDefault("Visibility.Notify.Period.InBGArenas",    DEFAULT_VISIBILITY_NOTIFY_PERIOD);
 
     ///- Load the CharDelete related config options
-    m_int_configs[CONFIG_CHARDELETE_METHOD] = sConfigMgr->GetIntDefault("CharDelete.Method", 0);
-    m_int_configs[CONFIG_CHARDELETE_MIN_LEVEL] = sConfigMgr->GetIntDefault("CharDelete.MinLevel", 0);
-    m_int_configs[CONFIG_CHARDELETE_HEROIC_MIN_LEVEL] = sConfigMgr->GetIntDefault("CharDelete.Heroic.MinLevel", 0);
-    m_int_configs[CONFIG_CHARDELETE_KEEP_DAYS] = sConfigMgr->GetIntDefault("CharDelete.KeepDays", 30);
+    m_int_configs[CONFIG_CHARDELETE_METHOD] = ConfigMgr::GetIntDefault("CharDelete.Method", 0);
+    m_int_configs[CONFIG_CHARDELETE_MIN_LEVEL] = ConfigMgr::GetIntDefault("CharDelete.MinLevel", 0);
+    m_int_configs[CONFIG_CHARDELETE_HEROIC_MIN_LEVEL] = ConfigMgr::GetIntDefault("CharDelete.Heroic.MinLevel", 0);
+    m_int_configs[CONFIG_CHARDELETE_KEEP_DAYS] = ConfigMgr::GetIntDefault("CharDelete.KeepDays", 30);
 
     ///- Read the "Data" directory from the config file
-    std::string dataPath = sConfigMgr->GetStringDefault("DataDir", "./");
+    std::string dataPath = ConfigMgr::GetStringDefault("DataDir", "./");
     if (dataPath.at(dataPath.length()-1) != '/' && dataPath.at(dataPath.length()-1) != '\\')
         dataPath.push_back('/');
 
@@ -1128,13 +1128,13 @@ void World::LoadConfigSettings(bool reload)
         TC_LOG_INFO(LOG_FILTER_SERVER_LOADING, "Using DataDir %s", m_dataPath.c_str());
     }
 
-    m_bool_configs[CONFIG_ENABLE_MMAPS] = sConfigMgr->GetBoolDefault("mmap.enablePathFinding", false);
+    m_bool_configs[CONFIG_ENABLE_MMAPS] = ConfigMgr::GetBoolDefault("mmap.enablePathFinding", false);
     TC_LOG_INFO(LOG_FILTER_SERVER_LOADING, "WORLD: MMap data directory is: %smmaps", m_dataPath.c_str());
 
-    m_bool_configs[CONFIG_VMAP_INDOOR_CHECK] = sConfigMgr->GetBoolDefault("vmap.enableIndoorCheck", 0);
-    bool enableIndoor = sConfigMgr->GetBoolDefault("vmap.enableIndoorCheck", true);
-    bool enableLOS = sConfigMgr->GetBoolDefault("vmap.enableLOS", true);
-    bool enableHeight = sConfigMgr->GetBoolDefault("vmap.enableHeight", true);
+    m_bool_configs[CONFIG_VMAP_INDOOR_CHECK] = ConfigMgr::GetBoolDefault("vmap.enableIndoorCheck", 0);
+    bool enableIndoor = ConfigMgr::GetBoolDefault("vmap.enableIndoorCheck", true);
+    bool enableLOS = ConfigMgr::GetBoolDefault("vmap.enableLOS", true);
+    bool enableHeight = ConfigMgr::GetBoolDefault("vmap.enableHeight", true);
 
     if (!enableHeight)
         TC_LOG_ERROR(LOG_FILTER_SERVER_LOADING, "VMap height checking disabled! Creatures movements and other various things WILL be broken! Expect no support.");
@@ -1144,61 +1144,61 @@ void World::LoadConfigSettings(bool reload)
     TC_LOG_INFO(LOG_FILTER_SERVER_LOADING, "VMap support included. LineOfSight: %i, getHeight: %i, indoorCheck: %i", enableLOS, enableHeight, enableIndoor);
     TC_LOG_INFO(LOG_FILTER_SERVER_LOADING, "VMap data directory is: %svmaps", m_dataPath.c_str());
 
-    m_int_configs[CONFIG_MAX_WHO] = sConfigMgr->GetIntDefault("MaxWhoListReturns", 49);
-    m_bool_configs[CONFIG_START_ALL_SPELLS] = sConfigMgr->GetBoolDefault("PlayerStart.AllSpells", false);
+    m_int_configs[CONFIG_MAX_WHO] = ConfigMgr::GetIntDefault("MaxWhoListReturns", 49);
+    m_bool_configs[CONFIG_START_ALL_SPELLS] = ConfigMgr::GetBoolDefault("PlayerStart.AllSpells", false);
     if (m_bool_configs[CONFIG_START_ALL_SPELLS])
         TC_LOG_WARN(LOG_FILTER_SERVER_LOADING, "PlayerStart.AllSpells enabled - may not function as intended!");
-    m_int_configs[CONFIG_HONOR_AFTER_DUEL] = sConfigMgr->GetIntDefault("HonorPointsAfterDuel", 0);
-    m_bool_configs[CONFIG_START_ALL_EXPLORED] = sConfigMgr->GetBoolDefault("PlayerStart.MapsExplored", false);
-    m_bool_configs[CONFIG_START_ALL_REP] = sConfigMgr->GetBoolDefault("PlayerStart.AllReputation", false);
-    m_bool_configs[CONFIG_ALWAYS_MAXSKILL] = sConfigMgr->GetBoolDefault("AlwaysMaxWeaponSkill", false);
-    m_bool_configs[CONFIG_PVP_TOKEN_ENABLE] = sConfigMgr->GetBoolDefault("PvPToken.Enable", false);
-    m_int_configs[CONFIG_PVP_TOKEN_MAP_TYPE] = sConfigMgr->GetIntDefault("PvPToken.MapAllowType", 4);
-    m_int_configs[CONFIG_PVP_TOKEN_ID] = sConfigMgr->GetIntDefault("PvPToken.ItemID", 29434);
-    m_int_configs[CONFIG_PVP_TOKEN_COUNT] = sConfigMgr->GetIntDefault("PvPToken.ItemCount", 1);
+    m_int_configs[CONFIG_HONOR_AFTER_DUEL] = ConfigMgr::GetIntDefault("HonorPointsAfterDuel", 0);
+    m_bool_configs[CONFIG_START_ALL_EXPLORED] = ConfigMgr::GetBoolDefault("PlayerStart.MapsExplored", false);
+    m_bool_configs[CONFIG_START_ALL_REP] = ConfigMgr::GetBoolDefault("PlayerStart.AllReputation", false);
+    m_bool_configs[CONFIG_ALWAYS_MAXSKILL] = ConfigMgr::GetBoolDefault("AlwaysMaxWeaponSkill", false);
+    m_bool_configs[CONFIG_PVP_TOKEN_ENABLE] = ConfigMgr::GetBoolDefault("PvPToken.Enable", false);
+    m_int_configs[CONFIG_PVP_TOKEN_MAP_TYPE] = ConfigMgr::GetIntDefault("PvPToken.MapAllowType", 4);
+    m_int_configs[CONFIG_PVP_TOKEN_ID] = ConfigMgr::GetIntDefault("PvPToken.ItemID", 29434);
+    m_int_configs[CONFIG_PVP_TOKEN_COUNT] = ConfigMgr::GetIntDefault("PvPToken.ItemCount", 1);
     if (m_int_configs[CONFIG_PVP_TOKEN_COUNT] < 1)
         m_int_configs[CONFIG_PVP_TOKEN_COUNT] = 1;
 
-    m_bool_configs[CONFIG_NO_RESET_TALENT_COST] = sConfigMgr->GetBoolDefault("NoResetTalentsCost", false);
-    m_bool_configs[CONFIG_SHOW_KICK_IN_WORLD] = sConfigMgr->GetBoolDefault("ShowKickInWorld", false);
-    m_int_configs[CONFIG_INTERVAL_LOG_UPDATE] = sConfigMgr->GetIntDefault("RecordUpdateTimeDiffInterval", 60000);
-    m_int_configs[CONFIG_MIN_LOG_UPDATE] = sConfigMgr->GetIntDefault("MinRecordUpdateTimeDiff", 100);
-    m_int_configs[CONFIG_NUMTHREADS] = sConfigMgr->GetIntDefault("MapUpdate.Threads", 1);
-    m_int_configs[CONFIG_MAX_RESULTS_LOOKUP_COMMANDS] = sConfigMgr->GetIntDefault("Command.LookupMaxResults", 0);
+    m_bool_configs[CONFIG_NO_RESET_TALENT_COST] = ConfigMgr::GetBoolDefault("NoResetTalentsCost", false);
+    m_bool_configs[CONFIG_SHOW_KICK_IN_WORLD] = ConfigMgr::GetBoolDefault("ShowKickInWorld", false);
+    m_int_configs[CONFIG_INTERVAL_LOG_UPDATE] = ConfigMgr::GetIntDefault("RecordUpdateTimeDiffInterval", 60000);
+    m_int_configs[CONFIG_MIN_LOG_UPDATE] = ConfigMgr::GetIntDefault("MinRecordUpdateTimeDiff", 100);
+    m_int_configs[CONFIG_NUMTHREADS] = ConfigMgr::GetIntDefault("MapUpdate.Threads", 1);
+    m_int_configs[CONFIG_MAX_RESULTS_LOOKUP_COMMANDS] = ConfigMgr::GetIntDefault("Command.LookupMaxResults", 0);
 
     // chat logging
-    m_bool_configs[CONFIG_CHATLOG_CHANNEL] = sConfigMgr->GetBoolDefault("ChatLogs.Channel", false);
-    m_bool_configs[CONFIG_CHATLOG_WHISPER] = sConfigMgr->GetBoolDefault("ChatLogs.Whisper", false);
-    m_bool_configs[CONFIG_CHATLOG_SYSCHAN] = sConfigMgr->GetBoolDefault("ChatLogs.SysChan", false);
-    m_bool_configs[CONFIG_CHATLOG_PARTY] = sConfigMgr->GetBoolDefault("ChatLogs.Party", false);
-    m_bool_configs[CONFIG_CHATLOG_RAID] = sConfigMgr->GetBoolDefault("ChatLogs.Raid", false);
-    m_bool_configs[CONFIG_CHATLOG_GUILD] = sConfigMgr->GetBoolDefault("ChatLogs.Guild", false);
-    m_bool_configs[CONFIG_CHATLOG_PUBLIC] = sConfigMgr->GetBoolDefault("ChatLogs.Public", false);
-    m_bool_configs[CONFIG_CHATLOG_ADDON] = sConfigMgr->GetBoolDefault("ChatLogs.Addon", false);
-    m_bool_configs[CONFIG_CHATLOG_BGROUND] = sConfigMgr->GetBoolDefault("ChatLogs.Battleground", false);
+    m_bool_configs[CONFIG_CHATLOG_CHANNEL] = ConfigMgr::GetBoolDefault("ChatLogs.Channel", false);
+    m_bool_configs[CONFIG_CHATLOG_WHISPER] = ConfigMgr::GetBoolDefault("ChatLogs.Whisper", false);
+    m_bool_configs[CONFIG_CHATLOG_SYSCHAN] = ConfigMgr::GetBoolDefault("ChatLogs.SysChan", false);
+    m_bool_configs[CONFIG_CHATLOG_PARTY] = ConfigMgr::GetBoolDefault("ChatLogs.Party", false);
+    m_bool_configs[CONFIG_CHATLOG_RAID] = ConfigMgr::GetBoolDefault("ChatLogs.Raid", false);
+    m_bool_configs[CONFIG_CHATLOG_GUILD] = ConfigMgr::GetBoolDefault("ChatLogs.Guild", false);
+    m_bool_configs[CONFIG_CHATLOG_PUBLIC] = ConfigMgr::GetBoolDefault("ChatLogs.Public", false);
+    m_bool_configs[CONFIG_CHATLOG_ADDON] = ConfigMgr::GetBoolDefault("ChatLogs.Addon", false);
+    m_bool_configs[CONFIG_CHATLOG_BGROUND] = ConfigMgr::GetBoolDefault("ChatLogs.Battleground", false);
 
     // Warden
-    m_bool_configs[CONFIG_WARDEN_ENABLED]              = sConfigMgr->GetBoolDefault("Warden.Enabled", false);
-    m_int_configs[CONFIG_WARDEN_NUM_MEM_CHECKS]        = sConfigMgr->GetIntDefault("Warden.NumMemChecks", 3);
-    m_int_configs[CONFIG_WARDEN_NUM_OTHER_CHECKS]      = sConfigMgr->GetIntDefault("Warden.NumOtherChecks", 7);
-    m_int_configs[CONFIG_WARDEN_CLIENT_BAN_DURATION]   = sConfigMgr->GetIntDefault("Warden.BanDuration", 86400);
-    m_int_configs[CONFIG_WARDEN_CLIENT_CHECK_HOLDOFF]  = sConfigMgr->GetIntDefault("Warden.ClientCheckHoldOff", 30);
-    m_int_configs[CONFIG_WARDEN_CLIENT_FAIL_ACTION]    = sConfigMgr->GetIntDefault("Warden.ClientCheckFailAction", 0);
-    m_int_configs[CONFIG_WARDEN_CLIENT_RESPONSE_DELAY] = sConfigMgr->GetIntDefault("Warden.ClientResponseDelay", 600);
+    m_bool_configs[CONFIG_WARDEN_ENABLED]              = ConfigMgr::GetBoolDefault("Warden.Enabled", false);
+    m_int_configs[CONFIG_WARDEN_NUM_MEM_CHECKS]        = ConfigMgr::GetIntDefault("Warden.NumMemChecks", 3);
+    m_int_configs[CONFIG_WARDEN_NUM_OTHER_CHECKS]      = ConfigMgr::GetIntDefault("Warden.NumOtherChecks", 7);
+    m_int_configs[CONFIG_WARDEN_CLIENT_BAN_DURATION]   = ConfigMgr::GetIntDefault("Warden.BanDuration", 86400);
+    m_int_configs[CONFIG_WARDEN_CLIENT_CHECK_HOLDOFF]  = ConfigMgr::GetIntDefault("Warden.ClientCheckHoldOff", 30);
+    m_int_configs[CONFIG_WARDEN_CLIENT_FAIL_ACTION]    = ConfigMgr::GetIntDefault("Warden.ClientCheckFailAction", 0);
+    m_int_configs[CONFIG_WARDEN_CLIENT_RESPONSE_DELAY] = ConfigMgr::GetIntDefault("Warden.ClientResponseDelay", 600);
 
     // Dungeon finder
-    m_int_configs[CONFIG_LFG_OPTIONSMASK] = sConfigMgr->GetIntDefault("DungeonFinder.OptionsMask", 1);
+    m_int_configs[CONFIG_LFG_OPTIONSMASK] = ConfigMgr::GetIntDefault("DungeonFinder.OptionsMask", 1);
 
     // DBC_ItemAttributes
-    m_bool_configs[CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES] = sConfigMgr->GetBoolDefault("DBC.EnforceItemAttributes", true);
+    m_bool_configs[CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES] = ConfigMgr::GetBoolDefault("DBC.EnforceItemAttributes", true);
 
     // Max instances per hour
-    m_int_configs[CONFIG_MAX_INSTANCES_PER_HOUR] = sConfigMgr->GetIntDefault("AccountInstancesPerHour", 5);
+    m_int_configs[CONFIG_MAX_INSTANCES_PER_HOUR] = ConfigMgr::GetIntDefault("AccountInstancesPerHour", 5);
 
     // AutoBroadcast
-    m_bool_configs[CONFIG_AUTOBROADCAST] = sConfigMgr->GetBoolDefault("AutoBroadcast.On", false);
-    m_int_configs[CONFIG_AUTOBROADCAST_CENTER] = sConfigMgr->GetIntDefault("AutoBroadcast.Center", 0);
-    m_int_configs[CONFIG_AUTOBROADCAST_INTERVAL] = sConfigMgr->GetIntDefault("AutoBroadcast.Timer", 60000);
+    m_bool_configs[CONFIG_AUTOBROADCAST] = ConfigMgr::GetBoolDefault("AutoBroadcast.On", false);
+    m_int_configs[CONFIG_AUTOBROADCAST_CENTER] = ConfigMgr::GetIntDefault("AutoBroadcast.Center", 0);
+    m_int_configs[CONFIG_AUTOBROADCAST_INTERVAL] = ConfigMgr::GetIntDefault("AutoBroadcast.Timer", 60000);
     if (reload)
     {
         m_timers[WUPDATE_AUTOBROADCAST].SetInterval(m_int_configs[CONFIG_AUTOBROADCAST_INTERVAL]);
@@ -1206,28 +1206,28 @@ void World::LoadConfigSettings(bool reload)
     }
 
     // MySQL ping time interval
-    m_int_configs[CONFIG_DB_PING_INTERVAL] = sConfigMgr->GetIntDefault("MaxPingTime", 30);
+    m_int_configs[CONFIG_DB_PING_INTERVAL] = ConfigMgr::GetIntDefault("MaxPingTime", 30);
 
     // misc
-    m_bool_configs[CONFIG_PDUMP_NO_PATHS] = sConfigMgr->GetBoolDefault("PlayerDump.DisallowPaths", true);
-    m_bool_configs[CONFIG_PDUMP_NO_OVERWRITE] = sConfigMgr->GetBoolDefault("PlayerDump.DisallowOverwrite", true);
-    m_bool_configs[CONFIG_UI_QUESTLEVELS_IN_DIALOGS] = sConfigMgr->GetBoolDefault("UI.ShowQuestLevelsInDialogs", false);
+    m_bool_configs[CONFIG_PDUMP_NO_PATHS] = ConfigMgr::GetBoolDefault("PlayerDump.DisallowPaths", true);
+    m_bool_configs[CONFIG_PDUMP_NO_OVERWRITE] = ConfigMgr::GetBoolDefault("PlayerDump.DisallowOverwrite", true);
+    m_bool_configs[CONFIG_UI_QUESTLEVELS_IN_DIALOGS] = ConfigMgr::GetBoolDefault("UI.ShowQuestLevelsInDialogs", false);
 
     // Wintergrasp battlefield
-    m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = sConfigMgr->GetBoolDefault("Wintergrasp.Enable", false);
-    m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = sConfigMgr->GetIntDefault("Wintergrasp.PlayerMax", 100);
-    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN] = sConfigMgr->GetIntDefault("Wintergrasp.PlayerMin", 0);
-    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN_LVL] = sConfigMgr->GetIntDefault("Wintergrasp.PlayerMinLvl", 77);
-    m_int_configs[CONFIG_WINTERGRASP_BATTLETIME] = sConfigMgr->GetIntDefault("Wintergrasp.BattleTimer", 30);
-    m_int_configs[CONFIG_WINTERGRASP_NOBATTLETIME] = sConfigMgr->GetIntDefault("Wintergrasp.NoBattleTimer", 150);
-    m_int_configs[CONFIG_WINTERGRASP_RESTART_AFTER_CRASH] = sConfigMgr->GetIntDefault("Wintergrasp.CrashRestartTimer", 10);
+    m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = ConfigMgr::GetBoolDefault("Wintergrasp.Enable", false);
+    m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = ConfigMgr::GetIntDefault("Wintergrasp.PlayerMax", 100);
+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN] = ConfigMgr::GetIntDefault("Wintergrasp.PlayerMin", 0);
+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN_LVL] = ConfigMgr::GetIntDefault("Wintergrasp.PlayerMinLvl", 77);
+    m_int_configs[CONFIG_WINTERGRASP_BATTLETIME] = ConfigMgr::GetIntDefault("Wintergrasp.BattleTimer", 30);
+    m_int_configs[CONFIG_WINTERGRASP_NOBATTLETIME] = ConfigMgr::GetIntDefault("Wintergrasp.NoBattleTimer", 150);
+    m_int_configs[CONFIG_WINTERGRASP_RESTART_AFTER_CRASH] = ConfigMgr::GetIntDefault("Wintergrasp.CrashRestartTimer", 10);
 
     // Stats limits
-    m_bool_configs[CONFIG_STATS_LIMITS_ENABLE] = sConfigMgr->GetBoolDefault("Stats.Limits.Enable", false);
-    m_float_configs[CONFIG_STATS_LIMITS_DODGE] = sConfigMgr->GetFloatDefault("Stats.Limits.Dodge", 95.0f);
-    m_float_configs[CONFIG_STATS_LIMITS_PARRY] = sConfigMgr->GetFloatDefault("Stats.Limits.Parry", 95.0f);
-    m_float_configs[CONFIG_STATS_LIMITS_BLOCK] = sConfigMgr->GetFloatDefault("Stats.Limits.Block", 95.0f);
-    m_float_configs[CONFIG_STATS_LIMITS_CRIT] = sConfigMgr->GetFloatDefault("Stats.Limits.Crit", 95.0f);
+    m_bool_configs[CONFIG_STATS_LIMITS_ENABLE] = ConfigMgr::GetBoolDefault("Stats.Limits.Enable", false);
+    m_float_configs[CONFIG_STATS_LIMITS_DODGE] = ConfigMgr::GetFloatDefault("Stats.Limits.Dodge", 95.0f);
+    m_float_configs[CONFIG_STATS_LIMITS_PARRY] = ConfigMgr::GetFloatDefault("Stats.Limits.Parry", 95.0f);
+    m_float_configs[CONFIG_STATS_LIMITS_BLOCK] = ConfigMgr::GetFloatDefault("Stats.Limits.Block", 95.0f);
+    m_float_configs[CONFIG_STATS_LIMITS_CRIT] = ConfigMgr::GetFloatDefault("Stats.Limits.Crit", 95.0f);
 
     // call ScriptMgr if we're reloading the configuration
     if (reload)
@@ -1796,13 +1796,13 @@ void World::SetInitialWorldSettings()
 
     TC_LOG_INFO(LOG_FILTER_WORLDSERVER, "World initialized in %u minutes %u seconds", (startupDuration / 60000), ((startupDuration % 60000) / 1000));
 
-    if (uint32 realmId = sConfigMgr->GetIntDefault("RealmID", 0)) // 0 reserved for auth
+    if (uint32 realmId = ConfigMgr::GetIntDefault("RealmID", 0)) // 0 reserved for auth
         sLog->SetRealmId(realmId);
 }
 
 void World::DetectDBCLang()
 {
-    uint8 m_lang_confid = sConfigMgr->GetIntDefault("DBC.Locale", 255);
+    uint8 m_lang_confid = ConfigMgr::GetIntDefault("DBC.Locale", 255);
 
     if (m_lang_confid != 255 && m_lang_confid >= TOTAL_LOCALES)
     {
@@ -1876,7 +1876,7 @@ void World::LoadAutobroadcasts()
     m_Autobroadcasts.clear();
     m_AutobroadcastsWeights.clear();
 
-    uint32 realmId = sConfigMgr->GetIntDefault("RealmID", 0);
+    uint32 realmId = ConfigMgr::GetIntDefault("RealmID", 0);
     PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_AUTOBROADCAST);
     stmt->setInt32(0, realmId);
     PreparedQueryResult result = LoginDatabase.Query(stmt);
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index cf46180..d505589 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -65,6 +65,8 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
   ${CMAKE_SOURCE_DIR}/src/server/collision/Models
+  ${CMAKE_SOURCE_DIR}/src/server/LuaEngine
+  ${CMAKE_SOURCE_DIR}/dep/lualib
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Database
   ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
diff --git a/src/server/scripts/Commands/cs_arena.cpp b/src/server/scripts/Commands/cs_arena.cpp
index b6a1b27..b631bab 100644
--- a/src/server/scripts/Commands/cs_arena.cpp
+++ b/src/server/scripts/Commands/cs_arena.cpp
@@ -228,9 +228,9 @@ public:
         if (!handler->extractPlayerTarget(nameStr, &target, &targetGuid))
             return false;
 
-        ArenaTeam* arena = sArenaTeamMgr->GetArenaTeamById(teamId);
+        ArenaTeam* Arena = sArenaTeamMgr->GetArenaTeamById(teamId);
 
-        if (!arena)
+        if (!Arena)
         {
             handler->PSendSysMessage(LANG_ARENA_ERROR_NOT_FOUND, teamId);
             handler->SetSentErrorMessage(true);
@@ -244,38 +244,36 @@ public:
             return false;
         }
 
-        if (arena->IsFighting())
+        if (Arena->IsFighting())
         {
             handler->SendSysMessage(LANG_ARENA_ERROR_COMBAT);
             handler->SetSentErrorMessage(true);
             return false;
         }
 
-        if (!arena->IsMember(targetGuid))
+        if (!Arena->IsMember(targetGuid))
         {
-            handler->PSendSysMessage(LANG_ARENA_ERROR_NOT_MEMBER, nameStr, arena->GetName().c_str());
+            handler->PSendSysMessage(LANG_ARENA_ERROR_NOT_MEMBER, nameStr, Arena->GetName().c_str());
             handler->SetSentErrorMessage(true);
             return false;
         }
 
-        if (arena->GetCaptain() == targetGuid)
+        if (Arena->GetCaptain() == targetGuid)
         {
-            handler->PSendSysMessage(LANG_ARENA_ERROR_CAPTAIN, nameStr, arena->GetName().c_str());
+            handler->PSendSysMessage(LANG_ARENA_ERROR_CAPTAIN, nameStr, Arena->GetName().c_str());
             handler->SetSentErrorMessage(true);
             return false;
         }
 
-        std::string oldCaptainName;
-        sObjectMgr->GetPlayerNameByGUID(arena->GetCaptain(), oldCaptainName);
-        arena->SetCaptain(targetGuid);
-
-        handler->PSendSysMessage(LANG_ARENA_CAPTAIN, arena->GetName().c_str(), arena->GetId(), oldCaptainName.c_str(), target->GetName().c_str());
+        Player* oldCaptain = sObjectMgr->GetPlayerByLowGUID(Arena->GetCaptain());
+        Arena->SetCaptain(targetGuid);
+        handler->PSendSysMessage(LANG_ARENA_CAPTAIN, Arena->GetName().c_str(), Arena->GetId(), oldCaptain->GetName().c_str(), target->GetName().c_str());
         if (handler->GetSession())
             TC_LOG_DEBUG(LOG_FILTER_ARENAS, "GameMaster: %s [GUID: %u] promoted player: %s [GUID: %u] to leader of arena team \"%s\"[Id: %u]",
-                handler->GetSession()->GetPlayer()->GetName().c_str(), handler->GetSession()->GetPlayer()->GetGUIDLow(), target->GetName().c_str(), target->GetGUIDLow(), arena->GetName().c_str(), arena->GetId());
+                handler->GetSession()->GetPlayer()->GetName().c_str(), handler->GetSession()->GetPlayer()->GetGUIDLow(), target->GetName().c_str(), target->GetGUIDLow(), Arena->GetName().c_str(), Arena->GetId());
         else
             TC_LOG_DEBUG(LOG_FILTER_ARENAS, "Console: promoted player: %s [GUID: %u] to leader of arena team \"%s\"[Id: %u]",
-                target->GetName().c_str(), target->GetGUIDLow(), arena->GetName().c_str(), arena->GetId());
+                target->GetName().c_str(), target->GetGUIDLow(), Arena->GetName().c_str(), Arena->GetId());
         return true;
     }
 
diff --git a/src/server/scripts/Commands/cs_character.cpp b/src/server/scripts/Commands/cs_character.cpp
index 7a49fc2..8bcf13c 100644
--- a/src/server/scripts/Commands/cs_character.cpp
+++ b/src/server/scripts/Commands/cs_character.cpp
@@ -281,7 +281,7 @@ public:
                 if (name.empty())
                     continue;
 
-                char const* activeStr = target->GetUInt32Value(PLAYER_CHOSEN_TITLE) == titleInfo->bit_index
+                char const* activeStr = target && target->GetUInt32Value(PLAYER_CHOSEN_TITLE) == titleInfo->bit_index
                 ? handler->GetTrinityString(LANG_ACTIVE)
                 : "";
 
diff --git a/src/server/scripts/Commands/cs_reload.cpp b/src/server/scripts/Commands/cs_reload.cpp
index 5351f3e..cab69e5 100644
--- a/src/server/scripts/Commands/cs_reload.cpp
+++ b/src/server/scripts/Commands/cs_reload.cpp
@@ -41,6 +41,7 @@ EndScriptData */
 #include "TicketMgr.h"
 #include "WardenCheckMgr.h"
 #include "WaypointManager.h"
+#include "LuaEngine.h"
 
 class reload_commandscript : public CommandScript
 {
@@ -159,6 +160,7 @@ public:
             { "waypoint_data",                SEC_ADMINISTRATOR, true,  &HandleReloadWpCommand,                         "", NULL },
             { "vehicle_accessory",            SEC_ADMINISTRATOR, true,  &HandleReloadVehicleAccessoryCommand,           "", NULL },
             { "vehicle_template_accessory",   SEC_ADMINISTRATOR, true,  &HandleReloadVehicleTemplateAccessoryCommand,   "", NULL },
+            { "eluna",                        SEC_ADMINISTRATOR, true,  &HandleReloadElunaLuaEngine,                    "", NULL },
             { NULL,                           0,                 false, NULL,                                           "", NULL }
         };
         static ChatCommand commandTable[] =
@@ -1245,6 +1247,13 @@ public:
         return true;
     }
 
+    static bool HandleReloadElunaLuaEngine(ChatHandler* handler, const char* /*args*/)
+    {
+        sEluna->StartEluna(true);
+        handler->SendSysMessage("Reloaded Eluna Nova Engine");
+        return true;
+    }
+
     static bool HandleReloadRBACCommand(ChatHandler* handler, const char* /*args*/)
     {
         TC_LOG_INFO(LOG_FILTER_GENERAL, "Reloading RBAC tables...");
diff --git a/src/server/scripts/Commands/cs_server.cpp b/src/server/scripts/Commands/cs_server.cpp
index ec8771c..2d4fa27 100644
--- a/src/server/scripts/Commands/cs_server.cpp
+++ b/src/server/scripts/Commands/cs_server.cpp
@@ -153,7 +153,7 @@ public:
                 sWorld->SetPlayerSecurityLimit(SEC_ADMINISTRATOR);
             else if (strncmp(paramStr, "reset", limit) == 0)
             {
-                sWorld->SetPlayerAmountLimit(sConfigMgr->GetIntDefault("PlayerLimit", 100));
+                sWorld->SetPlayerAmountLimit(ConfigMgr::GetIntDefault("PlayerLimit", 100));
                 sWorld->LoadDBAllowedSecurityLevel();
             }
             else
diff --git a/src/server/scripts/EasternKingdoms/Stratholme/instance_stratholme.cpp b/src/server/scripts/EasternKingdoms/Stratholme/instance_stratholme.cpp
index b0d5b05..383b930 100644
--- a/src/server/scripts/EasternKingdoms/Stratholme/instance_stratholme.cpp
+++ b/src/server/scripts/EasternKingdoms/Stratholme/instance_stratholme.cpp
@@ -246,29 +246,23 @@ class instance_stratholme : public InstanceMapScript
                     case TYPE_BARONESS:
                         EncounterState[1] = data;
                         if (data == IN_PROGRESS)
-                        {
                             HandleGameObject(ziggurat1GUID, true);
-                            //change to DONE when crystals implemented
+                        if (data == IN_PROGRESS)                    //change to DONE when crystals implemented
                             StartSlaugtherSquare();
-                        }
                         break;
                     case TYPE_NERUB:
                         EncounterState[2] = data;
                         if (data == IN_PROGRESS)
-                        {
                             HandleGameObject(ziggurat2GUID, true);
-                            //change to DONE when crystals implemented
+                        if (data == IN_PROGRESS)                    //change to DONE when crystals implemented
                             StartSlaugtherSquare();
-                        }
                         break;
                     case TYPE_PALLID:
                         EncounterState[3] = data;
                         if (data == IN_PROGRESS)
-                        {
                             HandleGameObject(ziggurat3GUID, true);
-                            //change to DONE when crystals implemented
+                        if (data == IN_PROGRESS)                    //change to DONE when crystals implemented
                             StartSlaugtherSquare();
-                        }
                         break;
                     case TYPE_RAMSTEIN:
                         if (data == IN_PROGRESS)
diff --git a/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_kalecgos.cpp b/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_kalecgos.cpp
index ddcd4c7..820f1e7 100644
--- a/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_kalecgos.cpp
+++ b/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_kalecgos.cpp
@@ -556,8 +556,8 @@ public:
             if (i->GetSource() && i->GetSource()->GetPositionZ() < DEMON_REALM_Z + 5)
                 ++SpectralPlayers;
         }
-
-        if (player->HasAura(AURA_SPECTRAL_EXHAUSTION) || SpectralPlayers >= MAX_PLAYERS_IN_SPECTRAL_REALM)
+        uint8 MaxSpectralPlayers =  MAX_PLAYERS_IN_SPECTRAL_REALM;
+        if (player->HasAura(AURA_SPECTRAL_EXHAUSTION) || (MaxSpectralPlayers && SpectralPlayers >= MaxSpectralPlayers))
             player->GetSession()->SendNotification(GO_FAILED);
         else
             player->CastSpell(player, SPELL_TELEPORT_SPECTRAL, true);
diff --git a/src/server/scripts/EasternKingdoms/ZulAman/boss_akilzon.cpp b/src/server/scripts/EasternKingdoms/ZulAman/boss_akilzon.cpp
index 380293d..92caaa0 100644
--- a/src/server/scripts/EasternKingdoms/ZulAman/boss_akilzon.cpp
+++ b/src/server/scripts/EasternKingdoms/ZulAman/boss_akilzon.cpp
@@ -174,7 +174,7 @@ class boss_akilzon : public CreatureScript
                     {
                         if (Unit* target = (*i))
                         {
-                            if (Cloud && !Cloud->IsWithinDist(target, 6, false))
+                            if (!Cloud->IsWithinDist(target, 6, false))
                                 Cloud->CastCustomSpell(target, SPELL_ZAP, &bp0, NULL, NULL, true, 0, 0, me->GetGUID());
                         }
                     }
diff --git a/src/server/scripts/EasternKingdoms/ZulAman/zulaman.cpp b/src/server/scripts/EasternKingdoms/ZulAman/zulaman.cpp
index 7dbed4e..de9dd90 100644
--- a/src/server/scripts/EasternKingdoms/ZulAman/zulaman.cpp
+++ b/src/server/scripts/EasternKingdoms/ZulAman/zulaman.cpp
@@ -333,9 +333,6 @@ class npc_harrison_jones : public CreatureScript
                 {
                     if (_gongTimer <= diff)
                     {
-                        if (!instance)
-                            return;
-
                         switch (_gongEvent)
                         {
                             case GONG_EVENT_1:
@@ -365,7 +362,8 @@ class npc_harrison_jones : public CreatureScript
 
                                 // trigger or gong will need to be scripted to set IN_PROGRESS after enough hits.
                                 // This is temp workaround.
-                                instance->SetData(DATA_GONGEVENT, IN_PROGRESS); // to be removed.
+                                if (instance)
+                                    instance->SetData(DATA_GONGEVENT, IN_PROGRESS); // to be removed.
 
                                 if (instance->GetData(DATA_GONGEVENT) == IN_PROGRESS)
                                 {
@@ -439,16 +437,16 @@ class npc_harrison_jones : public CreatureScript
                                 _gongEvent = GONG_EVENT_10;
                                 break;
                             case GONG_EVENT_10:
-                                me->SetFacingTo(1.59044f);
-                                _gongEvent = 11;
-                                _gongTimer = 6000;
+                                    me->SetFacingTo(1.59044f);
+                                    _gongEvent = 11;
+                                    _gongTimer = 6000;
                                 break;
                             case GONG_EVENT_11:
-                                me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
-
-                                instance->SetData(DATA_GONGEVENT, NOT_STARTED);
-                                _gongEvent = 0;
-                                _gongTimer = 1000;
+                                    me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                                    if (instance)
+                                        instance->SetData(DATA_GONGEVENT, NOT_STARTED);
+                                    _gongEvent = 0;
+                                    _gongTimer = 1000;
                                 break;
                         }
                     }
diff --git a/src/server/scripts/Kalimdor/BlackfathomDeeps/blackfathom_deeps.cpp b/src/server/scripts/Kalimdor/BlackfathomDeeps/blackfathom_deeps.cpp
index e74ed93..b64c7c1 100644
--- a/src/server/scripts/Kalimdor/BlackfathomDeeps/blackfathom_deeps.cpp
+++ b/src/server/scripts/Kalimdor/BlackfathomDeeps/blackfathom_deeps.cpp
@@ -31,6 +31,8 @@ enum Spells
     SPELL_TELEPORT_DARNASSUS                                = 9268
 };
 
+#define GOSSIP_ITEM_MORRIDUNE "Please port me to Darnassus"
+
 const Position HomePosition = {-815.817f, -145.299f, -25.870f, 0};
 
 class go_blackfathom_altar : public GameObjectScript
@@ -199,6 +201,32 @@ class npc_morridune : public CreatureScript
 public:
     npc_morridune() : CreatureScript("npc_morridune") { }
 
+    bool OnGossipSelect(Player* player, Creature* /*creature*/, uint32 /*sender*/, uint32 action) OVERRIDE
+    {
+        player->PlayerTalkClass->ClearMenus();
+        switch (action)
+        {
+            case GOSSIP_ACTION_INFO_DEF + 1:
+                player->TeleportTo(1, 9952.239f, 2284.277f, 1341.394f, 1.595f);
+                player->CLOSE_GOSSIP_MENU();
+                break;
+        }
+        return true;
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature) OVERRIDE
+    {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_ITEM_MORRIDUNE, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+
+        player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
+        return true;
+    }
+
+    CreatureAI* GetAI(Creature* creature) const OVERRIDE
+    {
+        return new npc_morriduneAI(creature);
+    }
+
     struct npc_morriduneAI : public npc_escortAI
     {
         npc_morriduneAI(Creature* creature) : npc_escortAI(creature)
@@ -220,17 +248,7 @@ public:
                     break;
             }
         }
-
-        void sGossipSelect(Player* player, uint32 /*sender*/, uint32 /*action*/) OVERRIDE
-        {
-            DoCast(player, SPELL_TELEPORT_DARNASSUS);
-        }
     };
-
-    CreatureAI* GetAI(Creature* creature) const OVERRIDE
-    {
-        return new npc_morriduneAI(creature);
-    }
 };
 
 void AddSC_blackfathom_deeps()
diff --git a/src/server/scripts/Kalimdor/RazorfenDowns/razorfen_downs.cpp b/src/server/scripts/Kalimdor/RazorfenDowns/razorfen_downs.cpp
index 320c997..516cd6a 100644
--- a/src/server/scripts/Kalimdor/RazorfenDowns/razorfen_downs.cpp
+++ b/src/server/scripts/Kalimdor/RazorfenDowns/razorfen_downs.cpp
@@ -39,64 +39,54 @@ EndContentData */
 
 enum Spells
 {
+    SPELL_GOLDTHORN_TEA                         = 13028,
     SPELL_TEACHING_GOLDTHORN_TEA                = 13029,
-    SPELL_TEACHING_MIGHTY_TROLLS_BLOOD_POTION   = 13030
+    SPELL_MIGHT_TROLLS_BLOOD_POTION             = 3451,
+    SPELL_TEACHING_MIGHTY_TROLLS_BLOOD_POTION   = 13030,
 };
 
 enum Gossips
 {
-    GOSSIP_COOKING_SKILL_HIGH                   = 1444,
-    GOSSIP_COOKING_SKILL_LOW                    = 1501,
-    GOSSIP_ALCHEMY_SKILL_HIGH                   = 1442,
-    GOSSIP_ALCHEMY_SKILL_LOW                    = 1502
+    GOSSIP_TEXT_TEA_ANSWER                      = 2114,
+    GOSSIP_TEXT_POTION_ANSWER                   = 2115,
 };
 
+#define GOSSIP_ITEM_TEA     "Teach me the cooking recipe"
+#define GOSSIP_ITEM_POTION  "Teach me the alchemy recipe"
+
 class npc_henry_stern : public CreatureScript
 {
 public:
     npc_henry_stern() : CreatureScript("npc_henry_stern") { }
 
-    struct npc_henry_sternAI : public ScriptedAI
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 /*sender*/, uint32 action) OVERRIDE
     {
-        npc_henry_sternAI(Creature* creature) : ScriptedAI(creature) { }
-
-        void sGossipSelect(Player* player, uint32 /*sender*/, uint32 action) OVERRIDE
+        player->PlayerTalkClass->ClearMenus();
+        if (action == GOSSIP_ACTION_INFO_DEF + 1)
         {
-            if (action == 0)
-            {
-                if (player->GetBaseSkillValue(SKILL_COOKING) >= 175)
-                {
-                    player->PrepareGossipMenu(me, GOSSIP_COOKING_SKILL_HIGH);
-                    player->SendPreparedGossip(me);
-                    DoCast(player, SPELL_TEACHING_GOLDTHORN_TEA);
-                }
-                else
-                {
-                    player->PrepareGossipMenu(me, GOSSIP_COOKING_SKILL_LOW);
-                    player->SendPreparedGossip(me);
-                }
-            }
+            player->CastSpell(player, SPELL_TEACHING_GOLDTHORN_TEA, true);
+            player->SEND_GOSSIP_MENU(GOSSIP_TEXT_TEA_ANSWER, creature->GetGUID());
+        }
 
-            if (action == 1)
-            {
-                if (player->GetBaseSkillValue(SKILL_ALCHEMY) >= 180)
-                {
-                    player->PrepareGossipMenu(me, GOSSIP_ALCHEMY_SKILL_HIGH);
-                    player->SendPreparedGossip(me);
-                    DoCast(player, SPELL_TEACHING_MIGHTY_TROLLS_BLOOD_POTION);
-                }
-                else
-                {
-                    player->PrepareGossipMenu(me, GOSSIP_ALCHEMY_SKILL_LOW);
-                    player->SendPreparedGossip(me);
-                }
-            }
+        if (action == GOSSIP_ACTION_INFO_DEF + 2)
+        {
+            player->CastSpell(player, SPELL_TEACHING_MIGHTY_TROLLS_BLOOD_POTION, true);
+            player->SEND_GOSSIP_MENU(GOSSIP_TEXT_POTION_ANSWER, creature->GetGUID());
         }
-    };
 
-    CreatureAI* GetAI(Creature* creature) const OVERRIDE
+        return true;
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature) OVERRIDE
     {
-        return new npc_henry_sternAI(creature);
+        if (player->GetBaseSkillValue(SKILL_COOKING) >= 175 && !player->HasSpell(SPELL_GOLDTHORN_TEA))
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_ITEM_TEA, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+
+        if (player->GetBaseSkillValue(SKILL_ALCHEMY) >= 180 && !player->HasSpell(SPELL_MIGHT_TROLLS_BLOOD_POTION))
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_ITEM_POTION, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 2);
+
+        player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
+        return true;
     }
 };
 
diff --git a/src/server/scripts/Kalimdor/zone_the_barrens.cpp b/src/server/scripts/Kalimdor/zone_the_barrens.cpp
index 62867c4..b1f6114 100644
--- a/src/server/scripts/Kalimdor/zone_the_barrens.cpp
+++ b/src/server/scripts/Kalimdor/zone_the_barrens.cpp
@@ -176,6 +176,42 @@ public:
 };
 
 /*######
+## npc_sputtervalve
+######*/
+
+#define GOSSIP_SPUTTERVALVE "Can you tell me about this shard?"
+
+class npc_sputtervalve : public CreatureScript
+{
+public:
+    npc_sputtervalve() : CreatureScript("npc_sputtervalve") { }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 /*sender*/, uint32 action) OVERRIDE
+    {
+        player->PlayerTalkClass->ClearMenus();
+        if (action == GOSSIP_ACTION_INFO_DEF)
+        {
+            player->SEND_GOSSIP_MENU(2013, creature->GetGUID());
+            player->AreaExploredOrEventHappens(6981);
+        }
+        return true;
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature) OVERRIDE
+    {
+        if (creature->IsQuestGiver())
+            player->PrepareQuestMenu(creature->GetGUID());
+
+        if (player->GetQuestStatus(6981) == QUEST_STATUS_INCOMPLETE)
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_SPUTTERVALVE, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+
+        player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
+        return true;
+    }
+
+};
+
+/*######
 ## npc_taskmaster_fizzule
 ######*/
 
@@ -655,6 +691,7 @@ void AddSC_the_barrens()
 {
     new npc_beaten_corpse();
     new npc_gilthares();
+    new npc_sputtervalve();
     new npc_taskmaster_fizzule();
     new npc_twiggy_flathead();
     new npc_wizzlecrank_shredder();
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/trial_of_the_crusader.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/trial_of_the_crusader.cpp
index b590b96..24cbbee 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/trial_of_the_crusader.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/trial_of_the_crusader.cpp
@@ -318,8 +318,7 @@ class boss_lich_king_toc : public CreatureScript
                             _instance->SetData(TYPE_EVENT, 5080);
                             break;
                         case 5080:
-                        {
-                            if (GameObject* go = GameObject::GetGameObject(*me, _instance->GetData64(GO_ARGENT_COLISEUM_FLOOR)))
+                            if (GameObject* go = _instance->instance->GetGameObject(_instance->GetData64(GO_ARGENT_COLISEUM_FLOOR)))
                             {
                                 go->SetDisplayId(DISPLAYID_DESTROYED_FLOOR);
                                 go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED | GO_FLAG_NODESPAWN);
@@ -329,17 +328,18 @@ class boss_lich_king_toc : public CreatureScript
                             me->CastSpell(me, SPELL_CORPSE_TELEPORT, false);
                             me->CastSpell(me, SPELL_DESTROY_FLOOR_KNOCKUP, false);
 
-                            _instance->SetBossState(BOSS_LICH_KING, DONE);
-                            Creature* temp = Unit::GetCreature(*me, _instance->GetData64(NPC_ANUBARAK));
-                            if (!temp || !temp->IsAlive())
-                                temp = me->SummonCreature(NPC_ANUBARAK, AnubarakLoc[0].GetPositionX(), AnubarakLoc[0].GetPositionY(), AnubarakLoc[0].GetPositionZ(), 3, TEMPSUMMON_CORPSE_TIMED_DESPAWN, DESPAWN_TIME);
-
-                            _instance->SetData(TYPE_EVENT, 0);
+                            if (_instance)
+                            {
+                                _instance->SetBossState(BOSS_LICH_KING, DONE);
+                                Creature* temp = Unit::GetCreature(*me, _instance->GetData64(NPC_ANUBARAK));
+                                if (!temp || !temp->IsAlive())
+                                    temp = me->SummonCreature(NPC_ANUBARAK, AnubarakLoc[0].GetPositionX(), AnubarakLoc[0].GetPositionY(), AnubarakLoc[0].GetPositionZ(), 3, TEMPSUMMON_CORPSE_TIMED_DESPAWN, DESPAWN_TIME);
 
+                                _instance->SetData(TYPE_EVENT, 0);
+                            }
                             me->DespawnOrUnsummon();
                             _updateTimer = 20*IN_MILLISECONDS;
                             break;
-                        }
                         default:
                             break;
                     }
diff --git a/src/server/scripts/Northrend/Nexus/Oculus/oculus.cpp b/src/server/scripts/Northrend/Nexus/Oculus/oculus.cpp
index e5f8cce..52ffc12 100644
--- a/src/server/scripts/Northrend/Nexus/Oculus/oculus.cpp
+++ b/src/server/scripts/Northrend/Nexus/Oculus/oculus.cpp
@@ -354,7 +354,9 @@ public:
         void MovementInform(uint32 type, uint32 id) OVERRIDE
         {
             if (type == POINT_MOTION_TYPE && id == 0)
+            {
                 me->SetDisableGravity(false); // Needed this for proper animation after spawn, the summon in air fall to ground bug leave no other option for now, if this isn't used the drake will only walk on move.
+            }
         }
 
         void UpdateAI(uint32 diff) OVERRIDE
@@ -386,7 +388,9 @@ public:
                     }
                     else WelcomeSequelTimer -= diff;
                 }
-
+            }
+            if (me->HasAuraType(SPELL_AURA_CONTROL_VEHICLE))
+            {
                 if (instance->GetBossState(DATA_UROM_EVENT) == DONE)
                 {
                     if (!(SpecialOff))
@@ -399,7 +403,9 @@ public:
                         else SpecialTimer -= diff;
                     }
                 }
-
+            }
+            if (me->HasAuraType(SPELL_AURA_CONTROL_VEHICLE))
+            {
                 if (!(HealthWarningOff))
                 {
                     if (me->GetHealthPct() <= 40.0f)
@@ -408,7 +414,9 @@ public:
                         HealthWarningOff = true;
                     }
                 }
-
+            }
+            if (me->HasAuraType(SPELL_AURA_CONTROL_VEHICLE))
+            {
                 if (HealthWarningOff)
                 {
                     if (WarningTimer <= diff)
@@ -419,7 +427,6 @@ public:
                     else WarningTimer -= diff;
                 }
             }
-
             if (!(me->HasAuraType(SPELL_AURA_CONTROL_VEHICLE)))
             {
                 if (!(DisableTakeOff))
diff --git a/src/server/scripts/Northrend/UtgardeKeep/UtgardePinnacle/boss_palehoof.cpp b/src/server/scripts/Northrend/UtgardeKeep/UtgardePinnacle/boss_palehoof.cpp
index b70bda7..0cf7636 100644
--- a/src/server/scripts/Northrend/UtgardeKeep/UtgardePinnacle/boss_palehoof.cpp
+++ b/src/server/scripts/Northrend/UtgardeKeep/UtgardePinnacle/boss_palehoof.cpp
@@ -234,9 +234,7 @@ public:
         {
             if (currentPhase == PHASE_NONE)
             {
-                if (instance)
-                    instance->SetData(DATA_GORTOK_PALEHOOF_EVENT, IN_PROGRESS);
-
+                instance->SetData(DATA_GORTOK_PALEHOOF_EVENT, IN_PROGRESS);
                 me->SummonCreature(NPC_STASIS_CONTROLLER, moveLocs[5].x, moveLocs[5].y, moveLocs[5].z, 0, TEMPSUMMON_CORPSE_DESPAWN);
             }
             Phase move = PHASE_NONE;
diff --git a/src/server/scripts/Outland/BlackTemple/black_temple.cpp b/src/server/scripts/Outland/BlackTemple/black_temple.cpp
index a44c5f5..3d4e729 100644
--- a/src/server/scripts/Outland/BlackTemple/black_temple.cpp
+++ b/src/server/scripts/Outland/BlackTemple/black_temple.cpp
@@ -21,41 +21,25 @@ Complete: 100%
 Comment:  Spirit of Olum: Player Teleporter to Seer Kanai Teleport after defeating Naj'entus and Supremus.
 */
 
+/* Content
+npc_spirit_of_olum
+*/
+
 #include "ScriptMgr.h"
 #include "ScriptedCreature.h"
 #include "ScriptedGossip.h"
 #include "black_temple.h"
 #include "Player.h"
 
-enum Spells
-{
-    // Spirit of Olum
-    SPELL_TELEPORT                   = 41566,
-    // Wrathbone Flayer
-    SPELL_CLEAVE                     = 15496,
-    SPELL_IGNORED                    = 39544,
-    SPELL_SUMMON_CHANNEL             = 40094
-};
+/*###
+# npc_spirit_of_olum
+####*/
 
-enum Creatures
-{
-    NPC_BLOOD_MAGE                   = 22945,
-    NPC_DEATHSHAPER                  = 22882
-};
-
-enum Events
+enum Spells
 {
-    // Wrathbone Flayer
-    EVENT_GET_CHANNELERS             = 1,
-    EVENT_SET_CHANNELERS             = 2,
-    EVENT_CLEAVE                     = 3,
-    EVENT_IGNORED                    = 4,
+    SPELL_TELEPORT              = 41566
 };
 
-// ########################################################
-// Spirit of Olum
-// ########################################################
-
 class npc_spirit_of_olum : public CreatureScript
 {
 public:
@@ -82,137 +66,7 @@ public:
     }
 };
 
-// ########################################################
-// Wrathbone Flayer
-// ########################################################
-
-class npc_wrathbone_flayer : public CreatureScript
-{
-public:
-    npc_wrathbone_flayer() : CreatureScript("npc_wrathbone_flayer") { }
-
-    struct npc_wrathbone_flayerAI : public ScriptedAI
-    {
-        npc_wrathbone_flayerAI(Creature* creature) : ScriptedAI(creature)
-        {
-            instance = creature->GetInstanceScript();
-        }
-
-        void Reset() OVERRIDE
-        {
-            events.ScheduleEvent(EVENT_GET_CHANNELERS, 3000);
-            enteredCombat = false;
-        }
-
-        void JustDied(Unit* /*killer*/) OVERRIDE { }
-
-        void EnterCombat(Unit* /*who*/) OVERRIDE
-        {
-            events.ScheduleEvent(EVENT_CLEAVE, 5000);
-            events.ScheduleEvent(EVENT_IGNORED, 7000);
-            enteredCombat = true;
-        }
-
-        void UpdateAI(uint32 diff) OVERRIDE
-        {
-
-            if (!enteredCombat)
-            {
-                events.Update(diff);
-
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch (eventId)
-                    {
-                        case EVENT_GET_CHANNELERS:
-                        {
-                            std::list<Creature*> BloodMageList;
-                            me->GetCreatureListWithEntryInGrid(BloodMageList, NPC_BLOOD_MAGE, 15.0f);
-
-                            if (!BloodMageList.empty())
-                                for (std::list<Creature*>::const_iterator itr = BloodMageList.begin(); itr != BloodMageList.end(); ++itr)
-                                {
-                                    bloodmage.push_back((*itr)->GetGUID());
-                                    if ((*itr)->isDead())
-                                        (*itr)->Respawn();
-                                }
-
-                            std::list<Creature*> DeathShaperList;
-                            me->GetCreatureListWithEntryInGrid(DeathShaperList, NPC_DEATHSHAPER, 15.0f);
-
-                            if (!DeathShaperList.empty())
-                                for (std::list<Creature*>::const_iterator itr = DeathShaperList.begin(); itr != DeathShaperList.end(); ++itr)
-                                {
-                                    deathshaper.push_back((*itr)->GetGUID());
-                                    if ((*itr)->isDead())
-                                        (*itr)->Respawn();
-                                }
-
-                            events.ScheduleEvent(EVENT_SET_CHANNELERS, 3000);
-
-                            break;
-                        }
-                        case EVENT_SET_CHANNELERS:
-                        {
-                            for (std::list<uint64>::const_iterator itr = bloodmage.begin(); itr != bloodmage.end(); ++itr)
-                                if (Creature* bloodmage = (Unit::GetCreature(*me, *itr)))
-                                    bloodmage->AI()->DoCast(SPELL_SUMMON_CHANNEL);
-
-                            for (std::list<uint64>::const_iterator itr = deathshaper.begin(); itr != deathshaper.end(); ++itr)
-                                if (Creature* deathshaper = (Unit::GetCreature(*me, *itr)))
-                                    deathshaper->AI()->DoCast(SPELL_SUMMON_CHANNEL);
-
-                            events.ScheduleEvent(EVENT_SET_CHANNELERS, 12000);
-
-                            break;
-                        }
-                        default:
-                            break;
-                    }
-                }
-            }
-
-            if (!UpdateVictim())
-                return;
-
-            events.Update(diff);
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch (eventId)
-                {
-                    case EVENT_CLEAVE:
-                        DoCastVictim(SPELL_CLEAVE);
-                        events.ScheduleEvent(EVENT_CLEAVE, urand (1000, 2000));
-                        break;
-                    case EVENT_IGNORED:
-                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0))
-                            DoCast(target, SPELL_IGNORED);
-                        events.ScheduleEvent(EVENT_IGNORED, 10000);
-                        break;
-                    default:
-                        break;
-                }
-            }
-            DoMeleeAttackIfReady();
-        }
-
-        private:
-            InstanceScript* instance;
-            EventMap events;
-            std::list<uint64> bloodmage;
-            std::list<uint64> deathshaper;
-            bool enteredCombat;
-    };
-
-    CreatureAI* GetAI(Creature* creature) const OVERRIDE
-    {
-        return new npc_wrathbone_flayerAI(creature);
-    }
-};
-
 void AddSC_black_temple()
 {
     new npc_spirit_of_olum();
-    new npc_wrathbone_flayer();
 }
diff --git a/src/server/scripts/Outland/BlackTemple/boss_shade_of_akama.cpp b/src/server/scripts/Outland/BlackTemple/boss_shade_of_akama.cpp
index 4a4304b..d86c9a2 100644
--- a/src/server/scripts/Outland/BlackTemple/boss_shade_of_akama.cpp
+++ b/src/server/scripts/Outland/BlackTemple/boss_shade_of_akama.cpp
@@ -72,7 +72,7 @@ enum Spells
     // Ashtongue Spiritbinder
     SPELL_SPIRIT_MEND                = 42025,
     SPELL_CHAIN_HEAL                 = 42027,
-    SPELL_SPIRITBINDER_SPIRIT_HEAL   = 42317
+    SPELL_SPIRIT_HEAL                = 42317
 };
 
 enum Creatures
@@ -1189,7 +1189,7 @@ public:
                 switch (eventId)
                 {
                     case EVENT_SPIRIT_HEAL:
-                        DoCast(me, SPELL_SPIRITBINDER_SPIRIT_HEAL);
+                        DoCast(me, SPELL_SPIRIT_HEAL);
                         events.ScheduleEvent(EVENT_SPIRIT_HEAL, urand (13000, 16000));
                         break;
                     default:
diff --git a/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_nethekurse.cpp b/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_nethekurse.cpp
index 0dbd21f..1d50be9 100644
--- a/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_nethekurse.cpp
+++ b/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_nethekurse.cpp
@@ -105,7 +105,7 @@ class boss_grand_warlock_nethekurse : public CreatureScript
                 Cleave_Timer = 5000;
             }
 
-            void JustDied(Unit* /*killer*/) OVERRIDE
+            void JustDied(Unit* /*killer*/)
             {
                 Talk(SAY_DIE);
 
@@ -113,7 +113,7 @@ class boss_grand_warlock_nethekurse : public CreatureScript
                     instance->SetBossState(DATA_NETHEKURSE, DONE);
             }
 
-            void SetData(uint32 data, uint32 value) OVERRIDE
+            void SetData(uint32 data, uint32 value)
             {
                 if (data != SETDATA_DATA)
                     return;
@@ -340,9 +340,9 @@ class npc_fel_orc_convert : public CreatureScript
                 {
                     if (instance->GetBossState(DATA_NETHEKURSE) != IN_PROGRESS)
                         return;
-
-                    if (Creature* Kurse = Unit::GetCreature(*me, instance->GetData64(NPC_GRAND_WARLOCK_NETHEKURSE)))
-                        Kurse->AI()->SetData(SETDATA_DATA, SETDATA_PEON_DEATH);
+                    if (instance->GetData64(NPC_GRAND_WARLOCK_NETHEKURSE))
+                        if (Creature* Kurse = Unit::GetCreature(*me, instance->GetData64(NPC_GRAND_WARLOCK_NETHEKURSE)))
+                            Kurse->AI()->SetData(SETDATA_DATA, SETDATA_PEON_DEATH);
                 }
             }
 
@@ -404,3 +404,4 @@ void AddSC_boss_grand_warlock_nethekurse()
     new npc_fel_orc_convert();
     new npc_lesser_shadow_fissure();
 }
+
diff --git a/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warbringer_omrogg.cpp b/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warbringer_omrogg.cpp
index 9c4be7c..9c32e45 100644
--- a/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warbringer_omrogg.cpp
+++ b/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warbringer_omrogg.cpp
@@ -447,3 +447,4 @@ void AddSC_boss_warbringer_omrogg()
     new boss_warbringer_omrogg();
     new npc_omrogg_heads();
 }
+
diff --git a/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warchief_kargath_bladefist.cpp b/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warchief_kargath_bladefist.cpp
index f9ec3ed..87b94de 100644
--- a/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warchief_kargath_bladefist.cpp
+++ b/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warchief_kargath_bladefist.cpp
@@ -319,3 +319,4 @@ void AddSC_boss_warchief_kargath_bladefist()
 {
     new boss_warchief_kargath_bladefist();
 }
+
diff --git a/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/instance_shattered_halls.cpp b/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/instance_shattered_halls.cpp
index 362b8e7..3328d5c 100644
--- a/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/instance_shattered_halls.cpp
+++ b/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/instance_shattered_halls.cpp
@@ -49,7 +49,7 @@ class instance_shattered_halls : public InstanceMapScript
                 nethekurseDoor2GUID = 0;
             }
 
-            void OnGameObjectCreate(GameObject* go) OVERRIDE
+            void OnGameObjectCreate(GameObject* go)
             {
                 switch (go->GetEntry())
                 {
@@ -62,7 +62,7 @@ class instance_shattered_halls : public InstanceMapScript
                 }
             }
 
-            void OnCreatureCreate(Creature* creature) OVERRIDE
+            void OnCreatureCreate(Creature* creature)
             {
                 switch (creature->GetEntry())
                 {
@@ -72,7 +72,7 @@ class instance_shattered_halls : public InstanceMapScript
                 }
             }
 
-            bool SetBossState(uint32 type, EncounterState state) OVERRIDE
+            bool SetBossState(uint32 type, EncounterState state)
             {
                 if (!InstanceScript::SetBossState(type, state))
                     return false;
@@ -168,3 +168,4 @@ void AddSC_instance_shattered_halls()
 {
     new instance_shattered_halls();
 }
+
diff --git a/src/server/scripts/Outland/TempestKeep/Eye/boss_alar.cpp b/src/server/scripts/Outland/TempestKeep/Eye/boss_alar.cpp
index 09fb235..389634a 100644
--- a/src/server/scripts/Outland/TempestKeep/Eye/boss_alar.cpp
+++ b/src/server/scripts/Outland/TempestKeep/Eye/boss_alar.cpp
@@ -75,8 +75,11 @@ enum WaitEventType
 class boss_alar : public CreatureScript
 {
     public:
-        boss_alar() : CreatureScript("boss_alar") { }
 
+        boss_alar()
+            : CreatureScript("boss_alar")
+        {
+        }
         struct boss_alarAI : public ScriptedAI
         {
             boss_alarAI(Creature* creature) : ScriptedAI(creature)
@@ -159,6 +162,7 @@ class boss_alar : public CreatureScript
 
             void MoveInLineOfSight(Unit* /*who*/) OVERRIDE {}
 
+
             void AttackStart(Unit* who) OVERRIDE
             {
                 if (Phase1)
@@ -458,7 +462,11 @@ class boss_alar : public CreatureScript
 class npc_ember_of_alar : public CreatureScript
 {
     public:
-        npc_ember_of_alar() : CreatureScript("npc_ember_of_alar") { }
+
+        npc_ember_of_alar()
+            : CreatureScript("npc_ember_of_alar")
+        {
+        }
 
         struct npc_ember_of_alarAI : public ScriptedAI
         {
@@ -476,12 +484,10 @@ class npc_ember_of_alar : public CreatureScript
             {
                 toDie = false;
             }
-
             void EnterCombat(Unit* /*who*/) OVERRIDE
             {
                 DoZoneInCombat();
             }
-
             void EnterEvadeMode() OVERRIDE
             {
                 me->setDeathState(JUST_DIED);
@@ -535,7 +541,11 @@ class npc_ember_of_alar : public CreatureScript
 class npc_flame_patch_alar : public CreatureScript
 {
     public:
-        npc_flame_patch_alar() : CreatureScript("npc_flame_patch_alar") { }
+
+        npc_flame_patch_alar()
+            : CreatureScript("npc_flame_patch_alar")
+        {
+        }
 
         struct npc_flame_patch_alarAI : public ScriptedAI
         {
@@ -560,3 +570,4 @@ void AddSC_boss_alar()
     new npc_ember_of_alar();
     new npc_flame_patch_alar();
 }
+
diff --git a/src/server/shared/Configuration/Config.cpp b/src/server/shared/Configuration/Config.cpp
index 47d59a5..5d5cc02 100644
--- a/src/server/shared/Configuration/Config.cpp
+++ b/src/server/shared/Configuration/Config.cpp
@@ -17,79 +17,72 @@
  */
 
 #include "Config.h"
-#include "Errors.h"
+#include <ace/Auto_Ptr.h>
+#include <ace/Configuration_Import_Export.h>
+#include <ace/Thread_Mutex.h>
 
-// Defined here as it must not be exposed to end-users.
-bool ConfigMgr::GetValueHelper(const char* name, ACE_TString &result)
+namespace ConfigMgr
 {
-    GuardType guard(_configLock);
 
-    if (_config.get() == 0)
-        return false;
+namespace
+{
+    typedef ACE_Thread_Mutex LockType;
+    typedef ACE_Guard<LockType> GuardType;
 
-    ACE_TString section_name;
-    ACE_Configuration_Section_Key section_key;
-    const ACE_Configuration_Section_Key &root_key = _config->root_section();
+    std::string _filename;
+    ACE_Auto_Ptr<ACE_Configuration_Heap> _config;
+    LockType m_configLock;
 
-    int i = 0;
-    while (_config->enumerate_sections(root_key, i, section_name) == 0)
+    // Defined here as it must not be exposed to end-users.
+    bool GetValueHelper(const char* name, ACE_TString &result)
     {
-        _config->open_section(root_key, section_name.c_str(), 0, section_key);
-        if (_config->get_string_value(section_key, name, result) == 0)
-            return true;
-        ++i;
-    }
-
-    return false;
-}
+        GuardType guard(m_configLock);
 
-bool ConfigMgr::LoadInitial(char const* file)
-{
-    ASSERT(file);
-
-    GuardType guard(_configLock);
+        if (_config.get() == 0)
+            return false;
 
-    _filename = file;
-    _config.reset(new ACE_Configuration_Heap());
-    if (_config->open() == 0)
-        if (LoadData(_filename.c_str()))
-            return true;
+        ACE_TString section_name;
+        ACE_Configuration_Section_Key section_key;
+        const ACE_Configuration_Section_Key &root_key = _config->root_section();
 
-    _config.reset();
-    return false;
-}
+        int i = 0;
+        while (_config->enumerate_sections(root_key, i, section_name) == 0)
+        {
+            _config->open_section(root_key, section_name.c_str(), 0, section_key);
+            if (_config->get_string_value(section_key, name, result) == 0)
+                return true;
+            ++i;
+        }
 
-bool ConfigMgr::LoadMore(char const* file)
-{
-    ASSERT(file);
-    ASSERT(_config);
-
-    GuardType guard(_configLock);
-
-    return LoadData(file);
+        return false;
+    }
 }
 
-bool ConfigMgr::Reload()
+bool Load(const char* file)
 {
-    return LoadInitial(_filename.c_str());
-}
+    GuardType guard(m_configLock);
 
-bool ConfigMgr::LoadData(char const* file)
-{
-    ACE_Ini_ImpExp config_importer(*_config.get());
-    if (config_importer.import_config(file) == 0)
-        return true;
+    if (file)
+        _filename = file;
 
+    _config.reset(new ACE_Configuration_Heap);
+    if (_config->open() == 0)
+    {
+        ACE_Ini_ImpExp config_importer(*_config.get());
+        if (config_importer.import_config(_filename.c_str()) == 0)
+            return true;
+    }
+    _config.reset();
     return false;
 }
 
-std::string ConfigMgr::GetStringDefault(const char* name, const std::string &def)
+std::string GetStringDefault(const char* name, const std::string &def)
 {
     ACE_TString val;
     return GetValueHelper(name, val) ? val.c_str() : def;
 }
 
-bool ConfigMgr::GetBoolDefault(const char* name, bool def)
+bool GetBoolDefault(const char* name, bool def)
 {
     ACE_TString val;
 
@@ -100,20 +93,22 @@ bool ConfigMgr::GetBoolDefault(const char* name, bool def)
         val == "1");
 }
 
-int ConfigMgr::GetIntDefault(const char* name, int def)
+int GetIntDefault(const char* name, int def)
 {
     ACE_TString val;
     return GetValueHelper(name, val) ? atoi(val.c_str()) : def;
 }
 
-float ConfigMgr::GetFloatDefault(const char* name, float def)
+float GetFloatDefault(const char* name, float def)
 {
     ACE_TString val;
     return GetValueHelper(name, val) ? (float)atof(val.c_str()) : def;
 }
 
-std::string const& ConfigMgr::GetFilename()
+const std::string & GetFilename()
 {
-    GuardType guard(_configLock);
+    GuardType guard(m_configLock);
     return _filename;
 }
+
+} // namespace
diff --git a/src/server/shared/Configuration/Config.h b/src/server/shared/Configuration/Config.h
index d633e37..778c25f 100644
--- a/src/server/shared/Configuration/Config.h
+++ b/src/server/shared/Configuration/Config.h
@@ -20,58 +20,17 @@
 #define CONFIG_H
 
 #include <string>
-#include <map>
-#include <ace/Singleton.h>
-#include <ace/Configuration_Import_Export.h>
-#include <ace/Thread_Mutex.h>
-#include <AutoPtr.h>
 
-typedef Trinity::AutoPtr<ACE_Configuration_Heap, ACE_Null_Mutex> Config;
-
-class ConfigMgr
+namespace ConfigMgr
 {
-    friend class ACE_Singleton<ConfigMgr, ACE_Null_Mutex>;
-    friend class ConfigLoader;
-
-    ConfigMgr() { }
-    ~ConfigMgr() { }
-
-public:
-    /// Method used only for loading main configuration files (authserver.conf and worldserver.conf)
-    bool LoadInitial(char const* file);
-
-    /**
-     * This method loads additional configuration files
-     * It is recommended to use this method in WorldScript::OnConfigLoad hooks
-     *
-     * @return true if loading was successful
-     */
-    bool LoadMore(char const* file);
-
-    bool Reload();
+    bool Load(const char *file = NULL);
 
     std::string GetStringDefault(const char* name, const std::string& def);
     bool GetBoolDefault(const char* name, bool def);
     int GetIntDefault(const char* name, int def);
     float GetFloatDefault(const char* name, float def);
 
-    std::string const& GetFilename();
-
-private:
-    bool GetValueHelper(const char* name, ACE_TString &result);
-    bool LoadData(char const* file);
-
-    typedef ACE_Thread_Mutex LockType;
-    typedef ACE_Guard<LockType> GuardType;
-
-    std::string _filename;
-    Config _config;
-    LockType _configLock;
-
-    ConfigMgr(ConfigMgr const&);
-    ConfigMgr& operator=(ConfigMgr const&);
-};
-
-#define sConfigMgr ACE_Singleton<ConfigMgr, ACE_Null_Mutex>::instance()
+    const std::string & GetFilename();
+}
 
 #endif
diff --git a/src/server/shared/DataStores/DBCStore.h b/src/server/shared/DataStores/DBCStore.h
index fdbf0f2..9015197 100644
--- a/src/server/shared/DataStores/DBCStore.h
+++ b/src/server/shared/DataStores/DBCStore.h
@@ -71,7 +71,7 @@ class DBCStorage
     typedef std::list<char*> StringPoolList;
     public:
         explicit DBCStorage(char const* f)
-            : fmt(f), nCount(0), fieldCount(0), dataTable(NULL)
+            : fmt(f), nCount(0), fieldCount(0), dataTable(NULL), loaded(false)
         {
             indexTable.asT = NULL;
         }
@@ -80,9 +80,34 @@ class DBCStorage
 
         T const* LookupEntry(uint32 id) const
         {
+            if(loaded)
+            {
+                typename std::map<uint32, T const*>::const_iterator it = data.find(id);
+                if (it == data.end())
+                    return NULL;
+                return it->second;
+            }
             return (id >= nCount) ? NULL : indexTable.asT[id];
         }
 
+        void SetEntry(uint32 id, T* t) // Cryptic they say..
+        {
+            if(!loaded)
+            {
+                for (uint32 i = 0; i < GetNumRows(); ++i)
+                {
+                    T const* node = LookupEntry(i);
+                    if (!node)
+                        continue;
+                    data[i] = node;
+                }
+                loaded = true;
+            }
+            if (id > nCount)
+                nCount = id+1;
+            data[id] = t;
+        }
+
         uint32  GetNumRows() const { return nCount; }
         char const* GetFormat() const { return fmt; }
         uint32 GetFieldCount() const { return fieldCount; }
@@ -260,6 +285,12 @@ class DBCStorage
 
         void Clear()
         {
+            if (loaded)
+            {
+                data.clear();
+                loaded = false;
+            }
+
             if (!indexTable.asT)
                 return;
 
@@ -290,6 +321,8 @@ class DBCStorage
         indexTable;
 
         T* dataTable;
+        std::map<uint32, T const*> data;
+        bool loaded;
         StringPoolList stringPoolList;
 };
 
diff --git a/src/server/shared/Logging/Log.cpp b/src/server/shared/Logging/Log.cpp
index be7aab9..312a346 100644
--- a/src/server/shared/Logging/Log.cpp
+++ b/src/server/shared/Logging/Log.cpp
@@ -48,13 +48,13 @@ uint8 Log::NextAppenderId()
 int32 GetConfigIntDefault(std::string base, const char* name, int32 value)
 {
     base.append(name);
-    return sConfigMgr->GetIntDefault(base.c_str(), value);
+    return ConfigMgr::GetIntDefault(base.c_str(), value);
 }
 
 std::string GetConfigStringDefault(std::string base, const char* name, const char* value)
 {
     base.append(name);
-    return sConfigMgr->GetStringDefault(base.c_str(), value);
+    return ConfigMgr::GetStringDefault(base.c_str(), value);
 }
 
 // Returns default logger if the requested logger is not found
@@ -83,7 +83,7 @@ void Log::CreateAppenderFromConfig(const char* name)
     // if type = Console. optional1 = Color
     std::string options = "Appender.";
     options.append(name);
-    options = sConfigMgr->GetStringDefault(options.c_str(), "");
+    options = ConfigMgr::GetStringDefault(options.c_str(), "");
     Tokenizer tokens(options, ',');
     Tokenizer::const_iterator iter = tokens.begin();
     uint8 size = tokens.size();
@@ -173,7 +173,7 @@ void Log::CreateLoggerFromConfig(const char* name)
 
     std::string options = "Logger.";
     options.append(name);
-    options = sConfigMgr->GetStringDefault(options.c_str(), "");
+    options = ConfigMgr::GetStringDefault(options.c_str(), "");
 
     if (options.empty())
     {
@@ -235,7 +235,7 @@ void Log::CreateLoggerFromConfig(const char* name)
 
 void Log::ReadAppendersFromConfig()
 {
-    std::istringstream ss(sConfigMgr->GetStringDefault("Appenders", ""));
+    std::istringstream ss(ConfigMgr::GetStringDefault("Appenders", ""));
     std::string name;
 
     do
@@ -249,7 +249,7 @@ void Log::ReadAppendersFromConfig()
 
 void Log::ReadLoggersFromConfig()
 {
-    std::istringstream ss(sConfigMgr->GetStringDefault("Loggers", ""));
+    std::istringstream ss(ConfigMgr::GetStringDefault("Loggers", ""));
     std::string name;
 
     do
@@ -457,11 +457,11 @@ void Log::LoadFromConfig()
 {
     Close();
 
-    if (sConfigMgr->GetBoolDefault("Log.Async.Enable", false))
+    if (ConfigMgr::GetBoolDefault("Log.Async.Enable", false))
         worker = new LogWorker();
 
     AppenderId = 0;
-    m_logsDir = sConfigMgr->GetStringDefault("LogsDir", "");
+    m_logsDir = ConfigMgr::GetStringDefault("LogsDir", "");
     if (!m_logsDir.empty())
         if ((m_logsDir.at(m_logsDir.length() - 1) != '/') && (m_logsDir.at(m_logsDir.length() - 1) != '\\'))
             m_logsDir.push_back('/');
diff --git a/src/server/worldserver/CommandLine/CliRunnable.cpp b/src/server/worldserver/CommandLine/CliRunnable.cpp
index 361af45..9cdfe0a 100644
--- a/src/server/worldserver/CommandLine/CliRunnable.cpp
+++ b/src/server/worldserver/CommandLine/CliRunnable.cpp
@@ -141,7 +141,7 @@ void CliRunnable::run()
     rl_event_hook = cli_hook_func;
 #endif
 
-    if (sConfigMgr->GetBoolDefault("BeepAtStart", true))
+    if (ConfigMgr::GetBoolDefault("BeepAtStart", true))
         printf("\a");                                       // \a = Alert
 
     // print this here the first time
diff --git a/src/server/worldserver/Main.cpp b/src/server/worldserver/Main.cpp
index 33ece81..f9c672b 100644
--- a/src/server/worldserver/Main.cpp
+++ b/src/server/worldserver/Main.cpp
@@ -129,7 +129,7 @@ extern int main(int argc, char **argv)
         ++c;
     }
 
-    if (!sConfigMgr->LoadInitial(cfg_file))
+    if (!ConfigMgr::Load(cfg_file))
     {
         printf("Invalid or missing configuration file : %s\n", cfg_file);
         printf("Verify that the file exists and has \'[worldserver]' written in the top of the file!\n");
diff --git a/src/server/worldserver/Master.cpp b/src/server/worldserver/Master.cpp
index 69b163b..8816581 100644
--- a/src/server/worldserver/Master.cpp
+++ b/src/server/worldserver/Master.cpp
@@ -138,7 +138,7 @@ int Master::Run()
     TC_LOG_INFO(LOG_FILTER_WORLDSERVER, "http://TrinityCore.org                    \\/__/\n");
 
     /// worldserver PID file creation
-    std::string pidfile = sConfigMgr->GetStringDefault("PidFile", "");
+    std::string pidfile = ConfigMgr::GetStringDefault("PidFile", "");
     if (!pidfile.empty())
     {
         uint32 pid = CreatePIDFile(pidfile);
@@ -182,9 +182,9 @@ int Master::Run()
     ACE_Based::Thread* cliThread = NULL;
 
 #ifdef _WIN32
-    if (sConfigMgr->GetBoolDefault("Console.Enable", true) && (m_ServiceStatus == -1)/* need disable console in service mode*/)
+    if (ConfigMgr::GetBoolDefault("Console.Enable", true) && (m_ServiceStatus == -1)/* need disable console in service mode*/)
 #else
-    if (sConfigMgr->GetBoolDefault("Console.Enable", true))
+    if (ConfigMgr::GetBoolDefault("Console.Enable", true))
 #endif
     {
         ///- Launch CliRunnable thread
@@ -198,7 +198,7 @@ int Master::Run()
     {
         HANDLE hProcess = GetCurrentProcess();
 
-        uint32 Aff = sConfigMgr->GetIntDefault("UseProcessors", 0);
+        uint32 Aff = ConfigMgr::GetIntDefault("UseProcessors", 0);
         if (Aff > 0)
         {
             ULONG_PTR appAff;
@@ -222,7 +222,7 @@ int Master::Run()
             }
         }
 
-        bool Prio = sConfigMgr->GetBoolDefault("ProcessPriority", false);
+        bool Prio = ConfigMgr::GetBoolDefault("ProcessPriority", false);
 
         //if (Prio && (m_ServiceStatus == -1)  /* need set to default process priority class in service mode*/)
         if (Prio)
@@ -237,15 +237,15 @@ int Master::Run()
     //Start soap serving thread
     ACE_Based::Thread* soap_thread = NULL;
 
-    if (sConfigMgr->GetBoolDefault("SOAP.Enabled", false))
+    if (ConfigMgr::GetBoolDefault("SOAP.Enabled", false))
     {
         TCSoapRunnable* runnable = new TCSoapRunnable();
-        runnable->setListenArguments(sConfigMgr->GetStringDefault("SOAP.IP", "127.0.0.1"), uint16(sConfigMgr->GetIntDefault("SOAP.Port", 7878)));
+        runnable->setListenArguments(ConfigMgr::GetStringDefault("SOAP.IP", "127.0.0.1"), uint16(ConfigMgr::GetIntDefault("SOAP.Port", 7878)));
         soap_thread = new ACE_Based::Thread(runnable);
     }
 
     ///- Start up freeze catcher thread
-    if (uint32 freeze_delay = sConfigMgr->GetIntDefault("MaxCoreStuckTime", 0))
+    if (uint32 freeze_delay = ConfigMgr::GetIntDefault("MaxCoreStuckTime", 0))
     {
         FreezeDetectorRunnable* fdr = new FreezeDetectorRunnable();
         fdr->SetDelayTime(freeze_delay * 1000);
@@ -255,7 +255,7 @@ int Master::Run()
 
     ///- Launch the world listener socket
     uint16 wsport = uint16(sWorld->getIntConfig(CONFIG_PORT_WORLD));
-    std::string bind_ip = sConfigMgr->GetStringDefault("BindIP", "0.0.0.0");
+    std::string bind_ip = ConfigMgr::GetStringDefault("BindIP", "0.0.0.0");
 
     if (sWorldSocketMgr->StartNetwork(wsport, bind_ip.c_str()) == -1)
     {
@@ -357,14 +357,14 @@ bool Master::_StartDB()
     std::string dbstring;
     uint8 async_threads, synch_threads;
 
-    dbstring = sConfigMgr->GetStringDefault("WorldDatabaseInfo", "");
+    dbstring = ConfigMgr::GetStringDefault("WorldDatabaseInfo", "");
     if (dbstring.empty())
     {
         TC_LOG_ERROR(LOG_FILTER_WORLDSERVER, "World database not specified in configuration file");
         return false;
     }
 
-    async_threads = uint8(sConfigMgr->GetIntDefault("WorldDatabase.WorkerThreads", 1));
+    async_threads = uint8(ConfigMgr::GetIntDefault("WorldDatabase.WorkerThreads", 1));
     if (async_threads < 1 || async_threads > 32)
     {
         TC_LOG_ERROR(LOG_FILTER_WORLDSERVER, "World database: invalid number of worker threads specified. "
@@ -372,7 +372,7 @@ bool Master::_StartDB()
         return false;
     }
 
-    synch_threads = uint8(sConfigMgr->GetIntDefault("WorldDatabase.SynchThreads", 1));
+    synch_threads = uint8(ConfigMgr::GetIntDefault("WorldDatabase.SynchThreads", 1));
     ///- Initialise the world database
     if (!WorldDatabase.Open(dbstring, async_threads, synch_threads))
     {
@@ -381,14 +381,14 @@ bool Master::_StartDB()
     }
 
     ///- Get character database info from configuration file
-    dbstring = sConfigMgr->GetStringDefault("CharacterDatabaseInfo", "");
+    dbstring = ConfigMgr::GetStringDefault("CharacterDatabaseInfo", "");
     if (dbstring.empty())
     {
         TC_LOG_ERROR(LOG_FILTER_WORLDSERVER, "Character database not specified in configuration file");
         return false;
     }
 
-    async_threads = uint8(sConfigMgr->GetIntDefault("CharacterDatabase.WorkerThreads", 1));
+    async_threads = uint8(ConfigMgr::GetIntDefault("CharacterDatabase.WorkerThreads", 1));
     if (async_threads < 1 || async_threads > 32)
     {
         TC_LOG_ERROR(LOG_FILTER_WORLDSERVER, "Character database: invalid number of worker threads specified. "
@@ -396,7 +396,7 @@ bool Master::_StartDB()
         return false;
     }
 
-    synch_threads = uint8(sConfigMgr->GetIntDefault("CharacterDatabase.SynchThreads", 2));
+    synch_threads = uint8(ConfigMgr::GetIntDefault("CharacterDatabase.SynchThreads", 2));
 
     ///- Initialise the Character database
     if (!CharacterDatabase.Open(dbstring, async_threads, synch_threads))
@@ -406,14 +406,14 @@ bool Master::_StartDB()
     }
 
     ///- Get login database info from configuration file
-    dbstring = sConfigMgr->GetStringDefault("LoginDatabaseInfo", "");
+    dbstring = ConfigMgr::GetStringDefault("LoginDatabaseInfo", "");
     if (dbstring.empty())
     {
         TC_LOG_ERROR(LOG_FILTER_WORLDSERVER, "Login database not specified in configuration file");
         return false;
     }
 
-    async_threads = uint8(sConfigMgr->GetIntDefault("LoginDatabase.WorkerThreads", 1));
+    async_threads = uint8(ConfigMgr::GetIntDefault("LoginDatabase.WorkerThreads", 1));
     if (async_threads < 1 || async_threads > 32)
     {
         TC_LOG_ERROR(LOG_FILTER_WORLDSERVER, "Login database: invalid number of worker threads specified. "
@@ -421,7 +421,7 @@ bool Master::_StartDB()
         return false;
     }
 
-    synch_threads = uint8(sConfigMgr->GetIntDefault("LoginDatabase.SynchThreads", 1));
+    synch_threads = uint8(ConfigMgr::GetIntDefault("LoginDatabase.SynchThreads", 1));
     ///- Initialise the login database
     if (!LoginDatabase.Open(dbstring, async_threads, synch_threads))
     {
@@ -430,7 +430,7 @@ bool Master::_StartDB()
     }
 
     ///- Get the realm Id from the configuration file
-    realmID = sConfigMgr->GetIntDefault("RealmID", 0);
+    realmID = ConfigMgr::GetIntDefault("RealmID", 0);
     if (!realmID)
     {
         TC_LOG_ERROR(LOG_FILTER_WORLDSERVER, "Realm ID not defined in configuration file");
diff --git a/src/server/worldserver/RemoteAccess/RARunnable.cpp b/src/server/worldserver/RemoteAccess/RARunnable.cpp
index 465e605..edb7e04 100644
--- a/src/server/worldserver/RemoteAccess/RARunnable.cpp
+++ b/src/server/worldserver/RemoteAccess/RARunnable.cpp
@@ -56,13 +56,13 @@ RARunnable::~RARunnable()
 
 void RARunnable::run()
 {
-    if (!sConfigMgr->GetBoolDefault("Ra.Enable", false))
+    if (!ConfigMgr::GetBoolDefault("Ra.Enable", false))
         return;
 
     ACE_Acceptor<RASocket, ACE_SOCK_ACCEPTOR> acceptor;
 
-    uint16 raport = uint16(sConfigMgr->GetIntDefault("Ra.Port", 3443));
-    std::string stringip = sConfigMgr->GetStringDefault("Ra.IP", "0.0.0.0");
+    uint16 raport = uint16(ConfigMgr::GetIntDefault("Ra.Port", 3443));
+    std::string stringip = ConfigMgr::GetStringDefault("Ra.IP", "0.0.0.0");
     ACE_INET_Addr listen_addr(raport, stringip.c_str());
 
     if (acceptor.open(listen_addr, m_Reactor) == -1)
diff --git a/src/server/worldserver/RemoteAccess/RASocket.cpp b/src/server/worldserver/RemoteAccess/RASocket.cpp
index 3fd4e34..fa5fdfd 100644
--- a/src/server/worldserver/RemoteAccess/RASocket.cpp
+++ b/src/server/worldserver/RemoteAccess/RASocket.cpp
@@ -32,7 +32,7 @@
 
 RASocket::RASocket()
 {
-    _minLevel = uint8(sConfigMgr->GetIntDefault("RA.MinLevel", 3));
+    _minLevel = uint8(ConfigMgr::GetIntDefault("RA.MinLevel", 3));
     _commandExecuting = false;
 }
 
-- 
1.8.1.msysgit.1

