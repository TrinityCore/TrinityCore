/*
 * This file is part of the TrinityCore Project. See AUTHORS file for Copyright information
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "UpdateFields.h"
#include "AreaTrigger.h"
#include "ByteBuffer.h"
#include "Corpse.h"
#include "DynamicObject.h"
#include "Player.h"
#include "ViewerDependentValues.h"

// This file is automatically generated, DO NOT EDIT

#if TRINITY_COMPILER == TRINITY_COMPILER_GNU
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#else
#pragma warning(push)
#pragma warning(disable: 4100)
#endif

namespace UF
{
void ObjectData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Object const* owner, Player const* receiver) const
{
    data << int32(ViewerDependentValue<EntryIDTag>::GetValue(this, owner, receiver));
    data << uint32(ViewerDependentValue<DynamicFlagsTag>::GetValue(this, owner, receiver));
    data << float(Scale);
}

void ObjectData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Object const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void ObjectData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Object const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlock(0), 4);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(ViewerDependentValue<EntryIDTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[2])
        {
            data << uint32(ViewerDependentValue<DynamicFlagsTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[3])
        {
            data << float(Scale);
        }
    }
}

void ObjectData::ClearChangesMask()
{
    Base::ClearChangesMask(EntryID);
    Base::ClearChangesMask(DynamicFlags);
    Base::ClearChangesMask(Scale);
    _changesMask.ResetAll();
}

void ItemEnchantment::WriteCreate(ByteBuffer& data, Item const* owner, Player const* receiver) const
{
    data << int32(ID);
    data << uint32(Duration);
    data << int16(Charges);
    data << uint16(Inactive);
}

void ItemEnchantment::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Item const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 5);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(ID);
        }
        if (changesMask[2])
        {
            data << uint32(Duration);
        }
        if (changesMask[3])
        {
            data << int16(Charges);
        }
        if (changesMask[4])
        {
            data << uint16(Inactive);
        }
    }
}

void ItemEnchantment::ClearChangesMask()
{
    Base::ClearChangesMask(ID);
    Base::ClearChangesMask(Duration);
    Base::ClearChangesMask(Charges);
    Base::ClearChangesMask(Inactive);
    _changesMask.ResetAll();
}

void ItemMod::WriteCreate(ByteBuffer& data, Item const* owner, Player const* receiver) const
{
    data << int32(Value);
    data << uint8(Type);
}

void ItemMod::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Item const* owner, Player const* receiver) const
{
    data << int32(Value);
    data << uint8(Type);
}

bool ItemMod::operator==(ItemMod const& right) const
{
    return Value == right.Value
        && Type == right.Type;
}

void ItemModList::WriteCreate(ByteBuffer& data, Item const* owner, Player const* receiver) const
{
    data.WriteBits(Values.size(), 6);
    for (uint32 i = 0; i < Values.size(); ++i)
    {
        Values[i].WriteCreate(data, owner, receiver);
    }
    data.FlushBits();
}

void ItemModList::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Item const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 1);

    if (changesMask[0])
    {
        if (!ignoreChangesMask)
            Values.WriteUpdateMask(data, 6);
        else
            WriteCompleteDynamicFieldUpdateMask(Values.size(), data, 6);
    }
    data.FlushBits();
    if (changesMask[0])
    {
        for (uint32 i = 0; i < Values.size(); ++i)
        {
            if (Values.HasChanged(i) || ignoreChangesMask)
            {
                Values[i].WriteUpdate(data, ignoreChangesMask, owner, receiver);
            }
        }
    }
    data.FlushBits();
}

void ItemModList::ClearChangesMask()
{
    Base::ClearChangesMask(Values);
    _changesMask.ResetAll();
}

void ArtifactPower::WriteCreate(ByteBuffer& data, Item const* owner, Player const* receiver) const
{
    data << int16(ArtifactPowerID);
    data << uint8(PurchasedRank);
    data << uint8(CurrentRankWithBonus);
}

void ArtifactPower::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Item const* owner, Player const* receiver) const
{
    data << int16(ArtifactPowerID);
    data << uint8(PurchasedRank);
    data << uint8(CurrentRankWithBonus);
}

bool ArtifactPower::operator==(ArtifactPower const& right) const
{
    return ArtifactPowerID == right.ArtifactPowerID
        && PurchasedRank == right.PurchasedRank
        && CurrentRankWithBonus == right.CurrentRankWithBonus;
}

void SocketedGem::WriteCreate(ByteBuffer& data, Item const* owner, Player const* receiver) const
{
    data << int32(ItemID);
    for (uint32 i = 0; i < 16; ++i)
    {
        data << uint16(BonusListIDs[i]);
    }
    data << uint8(Context);
}

void SocketedGem::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Item const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlocksMask(0), 1);
    if (changesMask.GetBlock(0))
        data.WriteBits(changesMask.GetBlock(0), 32);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(ItemID);
        }
        if (changesMask[2])
        {
            data << uint8(Context);
        }
    }
    if (changesMask[3])
    {
        for (uint32 i = 0; i < 16; ++i)
        {
            if (changesMask[4 + i])
            {
                data << uint16(BonusListIDs[i]);
            }
        }
    }
}

void SocketedGem::ClearChangesMask()
{
    Base::ClearChangesMask(ItemID);
    Base::ClearChangesMask(Context);
    Base::ClearChangesMask(BonusListIDs);
    _changesMask.ResetAll();
}

void ItemData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Item const* owner, Player const* receiver) const
{
    data << Owner;
    data << ContainedIn;
    data << Creator;
    data << GiftCreator;
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << uint32(StackCount);
        data << uint32(Expiration);
        for (uint32 i = 0; i < 5; ++i)
        {
            data << int32(SpellCharges[i]);
        }
    }
    data << uint32(DynamicFlags);
    for (uint32 i = 0; i < 13; ++i)
    {
        Enchantment[i].WriteCreate(data, owner, receiver);
    }
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << uint32(Durability);
        data << uint32(MaxDurability);
    }
    data << uint32(CreatePlayedTime);
    data << int32(Context);
    data << int64(CreateTime);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << uint64(ArtifactXP);
        data << uint8(ItemAppearanceModID);
    }
    data << uint32(ArtifactPowers.size());
    data << uint32(Gems.size());
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << uint32(DynamicFlags2);
    }
    data << ItemBonusKey;
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << uint16(DEBUGItemLevel);
    }
    for (uint32 i = 0; i < ArtifactPowers.size(); ++i)
    {
        ArtifactPowers[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < Gems.size(); ++i)
    {
        Gems[i].WriteCreate(data, owner, receiver);
    }
    Modifiers->WriteCreate(data, owner, receiver);
}

void ItemData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Item const* owner, Player const* receiver) const
{
    Mask allowedMaskForTarget({ 0xF80A727Fu, 0x000001FFu });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    WriteUpdate(data, _changesMask & allowedMaskForTarget, false, owner, receiver);
}

void ItemData::AppendAllowedFieldsMaskForFlag(Mask& allowedMaskForTarget, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags)
{
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
        allowedMaskForTarget |= std::array<uint32, 2>{ 0x07F58D80u, 0x00000000u };
}

void ItemData::FilterDisallowedFieldsMaskForFlag(Mask& changesMask, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags)
{
    Mask allowedMaskForTarget({ 0xF80A727Fu, 0x000001FFu });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    changesMask &= allowedMaskForTarget;
}

void ItemData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Item const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlocksMask(0), 2);
    for (uint32 i = 0; i < 2; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            if (!ignoreNestedChangesMask)
                ArtifactPowers.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(ArtifactPowers.size(), data);
        }
        if (changesMask[2])
        {
            if (!ignoreNestedChangesMask)
                Gems.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Gems.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            for (uint32 i = 0; i < ArtifactPowers.size(); ++i)
            {
                if (ArtifactPowers.HasChanged(i) || ignoreNestedChangesMask)
                {
                    ArtifactPowers[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[2])
        {
            for (uint32 i = 0; i < Gems.size(); ++i)
            {
                if (Gems.HasChanged(i) || ignoreNestedChangesMask)
                {
                    Gems[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[3])
        {
            data << Owner;
        }
        if (changesMask[4])
        {
            data << ContainedIn;
        }
        if (changesMask[5])
        {
            data << Creator;
        }
        if (changesMask[6])
        {
            data << GiftCreator;
        }
        if (changesMask[7])
        {
            data << uint32(StackCount);
        }
        if (changesMask[8])
        {
            data << uint32(Expiration);
        }
        if (changesMask[9])
        {
            data << uint32(DynamicFlags);
        }
        if (changesMask[10])
        {
            data << uint32(Durability);
        }
        if (changesMask[11])
        {
            data << uint32(MaxDurability);
        }
        if (changesMask[12])
        {
            data << uint32(CreatePlayedTime);
        }
        if (changesMask[13])
        {
            data << int32(Context);
        }
        if (changesMask[14])
        {
            data << int64(CreateTime);
        }
        if (changesMask[15])
        {
            data << uint64(ArtifactXP);
        }
        if (changesMask[16])
        {
            data << uint8(ItemAppearanceModID);
        }
        if (changesMask[18])
        {
            data << uint32(DynamicFlags2);
        }
        if (changesMask[19])
        {
            data << ItemBonusKey;
        }
        if (changesMask[20])
        {
            data << uint16(DEBUGItemLevel);
        }
        if (changesMask[17])
        {
            Modifiers->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
    }
    if (changesMask[21])
    {
        for (uint32 i = 0; i < 5; ++i)
        {
            if (changesMask[22 + i])
            {
                data << int32(SpellCharges[i]);
            }
        }
    }
    if (changesMask[27])
    {
        for (uint32 i = 0; i < 13; ++i)
        {
            if (changesMask[28 + i])
            {
                Enchantment[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
}

void ItemData::ClearChangesMask()
{
    Base::ClearChangesMask(ArtifactPowers);
    Base::ClearChangesMask(Gems);
    Base::ClearChangesMask(Owner);
    Base::ClearChangesMask(ContainedIn);
    Base::ClearChangesMask(Creator);
    Base::ClearChangesMask(GiftCreator);
    Base::ClearChangesMask(StackCount);
    Base::ClearChangesMask(Expiration);
    Base::ClearChangesMask(DynamicFlags);
    Base::ClearChangesMask(Durability);
    Base::ClearChangesMask(MaxDurability);
    Base::ClearChangesMask(CreatePlayedTime);
    Base::ClearChangesMask(Context);
    Base::ClearChangesMask(CreateTime);
    Base::ClearChangesMask(ArtifactXP);
    Base::ClearChangesMask(ItemAppearanceModID);
    Base::ClearChangesMask(Modifiers);
    Base::ClearChangesMask(DynamicFlags2);
    Base::ClearChangesMask(ItemBonusKey);
    Base::ClearChangesMask(DEBUGItemLevel);
    Base::ClearChangesMask(SpellCharges);
    Base::ClearChangesMask(Enchantment);
    _changesMask.ResetAll();
}

void ContainerData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Bag const* owner, Player const* receiver) const
{
    for (uint32 i = 0; i < 36; ++i)
    {
        data << Slots[i];
    }
    data << uint32(NumSlots);
}

void ContainerData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Bag const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void ContainerData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Bag const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlocksMask(0), 2);
    for (uint32 i = 0; i < 2; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << uint32(NumSlots);
        }
    }
    if (changesMask[2])
    {
        for (uint32 i = 0; i < 36; ++i)
        {
            if (changesMask[3 + i])
            {
                data << Slots[i];
            }
        }
    }
}

void ContainerData::ClearChangesMask()
{
    Base::ClearChangesMask(NumSlots);
    Base::ClearChangesMask(Slots);
    _changesMask.ResetAll();
}

void AzeriteEmpoweredItemData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, AzeriteEmpoweredItem const* owner, Player const* receiver) const
{
    for (uint32 i = 0; i < 5; ++i)
    {
        data << int32(Selections[i]);
    }
}

void AzeriteEmpoweredItemData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, AzeriteEmpoweredItem const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void AzeriteEmpoweredItemData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, AzeriteEmpoweredItem const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlocksMask(0), 1);
    if (changesMask.GetBlock(0))
        data.WriteBits(changesMask.GetBlock(0), 32);

    data.FlushBits();
    if (changesMask[0])
    {
        for (uint32 i = 0; i < 5; ++i)
        {
            if (changesMask[1 + i])
            {
                data << int32(Selections[i]);
            }
        }
    }
}

void AzeriteEmpoweredItemData::ClearChangesMask()
{
    Base::ClearChangesMask(Selections);
    _changesMask.ResetAll();
}

void UnlockedAzeriteEssence::WriteCreate(ByteBuffer& data, AzeriteItem const* owner, Player const* receiver) const
{
    data << uint32(AzeriteEssenceID);
    data << uint32(Rank);
}

void UnlockedAzeriteEssence::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, AzeriteItem const* owner, Player const* receiver) const
{
    data << uint32(AzeriteEssenceID);
    data << uint32(Rank);
}

bool UnlockedAzeriteEssence::operator==(UnlockedAzeriteEssence const& right) const
{
    return AzeriteEssenceID == right.AzeriteEssenceID
        && Rank == right.Rank;
}

void SelectedAzeriteEssences::WriteCreate(ByteBuffer& data, AzeriteItem const* owner, Player const* receiver) const
{
    for (uint32 i = 0; i < 4; ++i)
    {
        data << uint32(AzeriteEssenceID[i]);
    }
    data << uint32(SpecializationID);
    data.WriteBit(Enabled);
    data.FlushBits();
}

void SelectedAzeriteEssences::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, AzeriteItem const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlocksMask(0), 1);
    if (changesMask.GetBlock(0))
        data.WriteBits(changesMask.GetBlock(0), 32);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBit(Enabled);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            data << uint32(SpecializationID);
        }
    }
    if (changesMask[3])
    {
        for (uint32 i = 0; i < 4; ++i)
        {
            if (changesMask[4 + i])
            {
                data << uint32(AzeriteEssenceID[i]);
            }
        }
    }
    data.FlushBits();
}

void SelectedAzeriteEssences::ClearChangesMask()
{
    Base::ClearChangesMask(Enabled);
    Base::ClearChangesMask(SpecializationID);
    Base::ClearChangesMask(AzeriteEssenceID);
    _changesMask.ResetAll();
}

void AzeriteItemData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, AzeriteItem const* owner, Player const* receiver) const
{
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << uint64(Xp);
        data << uint32(Level);
        data << uint32(AuraLevel);
        data << uint32(KnowledgeLevel);
        data << int32(DEBUGknowledgeWeek);
    }
    data << uint32(UnlockedEssences.size());
    data << uint32(SelectedEssences.size());
    data << uint32(UnlockedEssenceMilestones.size());
    for (uint32 i = 0; i < UnlockedEssences.size(); ++i)
    {
        UnlockedEssences[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < UnlockedEssenceMilestones.size(); ++i)
    {
        data << uint32(UnlockedEssenceMilestones[i]);
    }
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data.WriteBit(Enabled);
    }
    for (uint32 i = 0; i < SelectedEssences.size(); ++i)
    {
        SelectedEssences[i].WriteCreate(data, owner, receiver);
    }
    data.FlushBits();
}

void AzeriteItemData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, AzeriteItem const* owner, Player const* receiver) const
{
    Mask allowedMaskForTarget({ 0x0000001Du });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    WriteUpdate(data, _changesMask & allowedMaskForTarget, false, owner, receiver);
}

void AzeriteItemData::AppendAllowedFieldsMaskForFlag(Mask& allowedMaskForTarget, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags)
{
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
        allowedMaskForTarget |= std::array<uint32, 1>{ 0x000003E2u };
}

void AzeriteItemData::FilterDisallowedFieldsMaskForFlag(Mask& changesMask, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags)
{
    Mask allowedMaskForTarget({ 0x0000001Du });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    changesMask &= allowedMaskForTarget;
}

void AzeriteItemData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, AzeriteItem const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlock(0), 10);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBit(Enabled);
        }
        if (changesMask[2])
        {
            if (!ignoreNestedChangesMask)
                UnlockedEssences.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(UnlockedEssences.size(), data);
        }
        if (changesMask[3])
        {
            if (!ignoreNestedChangesMask)
                SelectedEssences.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(SelectedEssences.size(), data);
        }
        if (changesMask[4])
        {
            if (!ignoreNestedChangesMask)
                UnlockedEssenceMilestones.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(UnlockedEssenceMilestones.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            for (uint32 i = 0; i < UnlockedEssences.size(); ++i)
            {
                if (UnlockedEssences.HasChanged(i) || ignoreNestedChangesMask)
                {
                    UnlockedEssences[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[4])
        {
            for (uint32 i = 0; i < UnlockedEssenceMilestones.size(); ++i)
            {
                if (UnlockedEssenceMilestones.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << uint32(UnlockedEssenceMilestones[i]);
                }
            }
        }
        if (changesMask[3])
        {
            for (uint32 i = 0; i < SelectedEssences.size(); ++i)
            {
                if (SelectedEssences.HasChanged(i) || ignoreNestedChangesMask)
                {
                    SelectedEssences[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[5])
        {
            data << uint64(Xp);
        }
        if (changesMask[6])
        {
            data << uint32(Level);
        }
        if (changesMask[7])
        {
            data << uint32(AuraLevel);
        }
        if (changesMask[8])
        {
            data << uint32(KnowledgeLevel);
        }
        if (changesMask[9])
        {
            data << int32(DEBUGknowledgeWeek);
        }
    }
    data.FlushBits();
}

void AzeriteItemData::ClearChangesMask()
{
    Base::ClearChangesMask(Enabled);
    Base::ClearChangesMask(UnlockedEssences);
    Base::ClearChangesMask(UnlockedEssenceMilestones);
    Base::ClearChangesMask(SelectedEssences);
    Base::ClearChangesMask(Xp);
    Base::ClearChangesMask(Level);
    Base::ClearChangesMask(AuraLevel);
    Base::ClearChangesMask(KnowledgeLevel);
    Base::ClearChangesMask(DEBUGknowledgeWeek);
    _changesMask.ResetAll();
}

void SpellCastVisual::WriteCreate(ByteBuffer& data, Object const* owner, Player const* receiver) const
{
    data << int32(SpellXSpellVisualID);
    data << int32(ScriptVisualID);
}

void SpellCastVisual::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Object const* owner, Player const* receiver) const
{
    data << int32(SpellXSpellVisualID);
    data << int32(ScriptVisualID);
}

bool SpellCastVisual::operator==(SpellCastVisual const& right) const
{
    return SpellXSpellVisualID == right.SpellXSpellVisualID
        && ScriptVisualID == right.ScriptVisualID;
}

void UnitChannel::WriteCreate(ByteBuffer& data, Unit const* owner, Player const* receiver) const
{
    data << int32(SpellID);
    SpellVisual.WriteCreate(data, owner, receiver);
}

void UnitChannel::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Unit const* owner, Player const* receiver) const
{
    data << int32(SpellID);
    SpellVisual.WriteUpdate(data, ignoreChangesMask, owner, receiver);
}

bool UnitChannel::operator==(UnitChannel const& right) const
{
    return SpellID == right.SpellID
        && SpellVisual == right.SpellVisual;
}

void VisibleItem::WriteCreate(ByteBuffer& data, Unit const* owner, Player const* receiver) const
{
    data << int32(ItemID);
    data << int32(SecondaryItemModifiedAppearanceID);
    data << int32(ConditionalItemAppearanceID);
    data << uint16(ItemAppearanceModID);
    data << uint16(ItemVisual);
}

void VisibleItem::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Unit const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 6);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(ItemID);
        }
        if (changesMask[2])
        {
            data << int32(SecondaryItemModifiedAppearanceID);
        }
        if (changesMask[3])
        {
            data << int32(ConditionalItemAppearanceID);
        }
        if (changesMask[4])
        {
            data << uint16(ItemAppearanceModID);
        }
        if (changesMask[5])
        {
            data << uint16(ItemVisual);
        }
    }
}

void VisibleItem::ClearChangesMask()
{
    Base::ClearChangesMask(ItemID);
    Base::ClearChangesMask(SecondaryItemModifiedAppearanceID);
    Base::ClearChangesMask(ConditionalItemAppearanceID);
    Base::ClearChangesMask(ItemAppearanceModID);
    Base::ClearChangesMask(ItemVisual);
    _changesMask.ResetAll();
}

void PassiveSpellHistory::WriteCreate(ByteBuffer& data, Unit const* owner, Player const* receiver) const
{
    data << int32(SpellID);
    data << int32(AuraSpellID);
}

void PassiveSpellHistory::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Unit const* owner, Player const* receiver) const
{
    data << int32(SpellID);
    data << int32(AuraSpellID);
}

bool PassiveSpellHistory::operator==(PassiveSpellHistory const& right) const
{
    return SpellID == right.SpellID
        && AuraSpellID == right.AuraSpellID;
}

void UnitData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Unit const* owner, Player const* receiver) const
{
    data << int32(ViewerDependentValue<DisplayIDTag>::GetValue(this, owner, receiver));
    for (uint32 i = 0; i < 2; ++i)
    {
        data << uint32(ViewerDependentValue<NpcFlagsTag>::GetValue(this, i, owner, receiver));
    }
    data << uint32(StateSpellVisualID);
    data << uint32(StateAnimID);
    data << uint32(StateAnimKitID);
    data << uint32(StateWorldEffectIDs->size());
    data << uint32(StateWorldEffectsQuestObjectiveID);
    data << int32(SpellOverrideNameID);
    for (uint32 i = 0; i < StateWorldEffectIDs->size(); ++i)
    {
        data << uint32((*StateWorldEffectIDs)[i]);
    }
    data << Charm;
    data << Summon;
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << Critter;
    }
    data << CharmedBy;
    data << SummonedBy;
    data << CreatedBy;
    data << DemonCreator;
    data << LookAtControllerTarget;
    data << Target;
    data << BattlePetCompanionGUID;
    data << uint64(BattlePetDBID);
    ChannelData->WriteCreate(data, owner, receiver);
    data << int8(SpellEmpowerStage);
    data << uint32(SummonedByHomeRealm);
    data << uint8(Race);
    data << uint8(ClassId);
    data << uint8(PlayerClassId);
    data << uint8(Sex);
    data << uint8(DisplayPower);
    data << uint32(OverrideDisplayPowerID);
    data << int64(Health);
    for (uint32 i = 0; i < 10; ++i)
    {
        data << int32(Power[i]);
        data << int32(MaxPower[i]);
    }
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner | UpdateFieldFlag::UnitAll))
    {
        for (uint32 i = 0; i < 10; ++i)
        {
            data << float(PowerRegenFlatModifier[i]);
            data << float(PowerRegenInterruptedFlatModifier[i]);
        }
    }
    data << int64(MaxHealth);
    data << int32(Level);
    data << int32(EffectiveLevel);
    data << int32(ContentTuningID);
    data << int32(ScalingLevelMin);
    data << int32(ScalingLevelMax);
    data << int32(ScalingLevelDelta);
    data << int32(ScalingFactionGroup);
    data << int32(ViewerDependentValue<FactionTemplateTag>::GetValue(this, owner, receiver));
    for (uint32 i = 0; i < 3; ++i)
    {
        VirtualItems[i].WriteCreate(data, owner, receiver);
    }
    data << uint32(ViewerDependentValue<FlagsTag>::GetValue(this, owner, receiver));
    data << uint32(Flags2);
    data << uint32(ViewerDependentValue<Flags3Tag>::GetValue(this, owner, receiver));
    data << uint32(ViewerDependentValue<AuraStateTag>::GetValue(this, owner, receiver));
    for (uint32 i = 0; i < 2; ++i)
    {
        data << uint32(AttackRoundBaseTime[i]);
    }
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << uint32(RangedAttackRoundBaseTime);
    }
    data << float(BoundingRadius);
    data << float(CombatReach);
    data << float(DisplayScale);
    data << int32(CreatureFamily);
    data << int32(CreatureType);
    data << int32(NativeDisplayID);
    data << float(NativeXDisplayScale);
    data << int32(MountDisplayID);
    data << int32(CosmeticMountDisplayID);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner | UpdateFieldFlag::Empath))
    {
        data << float(MinDamage);
        data << float(MaxDamage);
        data << float(MinOffHandDamage);
        data << float(MaxOffHandDamage);
    }
    data << uint8(StandState);
    data << uint8(PetTalentPoints);
    data << uint8(VisFlags);
    data << uint8(AnimTier);
    data << uint32(PetNumber);
    data << uint32(PetNameTimestamp);
    data << uint32(PetExperience);
    data << uint32(PetNextLevelExperience);
    data << float(ModCastingSpeed);
    data << float(ModCastingSpeedNeg);
    data << float(ModSpellHaste);
    data << float(ModHaste);
    data << float(ModRangedHaste);
    data << float(ModHasteRegen);
    data << float(ModTimeRate);
    data << int32(CreatedBySpell);
    data << int32(EmoteState);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        for (uint32 i = 0; i < 4; ++i)
        {
            data << int32(Stats[i]);
            data << int32(StatPosBuff[i]);
            data << int32(StatNegBuff[i]);
            data << int32(StatSupportBuff[i]);
        }
    }
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner | UpdateFieldFlag::Empath))
    {
        for (uint32 i = 0; i < 7; ++i)
        {
            data << int32(Resistances[i]);
        }
    }
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        for (uint32 i = 0; i < 7; ++i)
        {
            data << int32(BonusResistanceMods[i]);
            data << int32(ManaCostModifier[i]);
        }
    }
    data << int32(BaseMana);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << int32(BaseHealth);
    }
    data << uint8(SheatheState);
    data << uint8(ViewerDependentValue<PvpFlagsTag>::GetValue(this, owner, receiver));
    data << uint8(PetFlags);
    data << uint8(ShapeshiftForm);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << int32(AttackPower);
        data << int32(AttackPowerModPos);
        data << int32(AttackPowerModNeg);
        data << float(AttackPowerMultiplier);
        data << int32(AttackPowerModSupport);
        data << int32(RangedAttackPower);
        data << int32(RangedAttackPowerModPos);
        data << int32(RangedAttackPowerModNeg);
        data << float(RangedAttackPowerMultiplier);
        data << int32(RangedAttackPowerModSupport);
        data << int32(MainHandWeaponAttackPower);
        data << int32(OffHandWeaponAttackPower);
        data << int32(RangedWeaponAttackPower);
        data << int32(SetAttackSpeedAura);
        data << float(Lifesteal);
        data << float(MinRangedDamage);
        data << float(MaxRangedDamage);
        data << float(ManaCostMultiplier);
        data << float(MaxHealthModifier);
    }
    data << float(HoverHeight);
    data << int32(MinItemLevelCutoff);
    data << int32(MinItemLevel);
    data << int32(MaxItemLevel);
    data << int32(AzeriteItemLevel);
    data << int32(WildBattlePetLevel);
    data << int32(BattlePetCompanionExperience);
    data << uint32(BattlePetCompanionNameTimestamp);
    data << int32(ViewerDependentValue<InteractSpellIDTag>::GetValue(this, owner, receiver));
    data << int32(ScaleDuration);
    data << int32(LooksLikeMountID);
    data << int32(LooksLikeCreatureID);
    data << int32(LookAtControllerID);
    data << int32(PerksVendorItemID);
    data << int32(TaxiNodesID);
    data << GuildGUID;
    data << uint32(PassiveSpells.size());
    data << uint32(WorldEffects.size());
    data << uint32(ChannelObjects.size());
    data << int32(FlightCapabilityID);
    data << float(GlideEventSpeedDivisor);
    data << uint32(Field_308);
    data << uint32(Field_30C);
    data << uint32(SilencedSchoolMask);
    data << uint32(CurrentAreaID);
    data << NameplateAttachToGUID;
    for (uint32 i = 0; i < PassiveSpells.size(); ++i)
    {
        PassiveSpells[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < WorldEffects.size(); ++i)
    {
        data << int32(WorldEffects[i]);
    }
    for (uint32 i = 0; i < ChannelObjects.size(); ++i)
    {
        data << ChannelObjects[i];
    }
}

void UnitData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Unit const* owner, Player const* receiver) const
{
    Mask allowedMaskForTarget({ 0xFFFFDFFFu, 0xF0FFBFFFu, 0x000F7FFFu, 0xFFFFFF01u, 0x007FFFFFu, 0x0003F800u, 0x00000000u });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    WriteUpdate(data, _changesMask & allowedMaskForTarget, false, owner, receiver);
}

void UnitData::AppendAllowedFieldsMaskForFlag(Mask& allowedMaskForTarget, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags)
{
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
        allowedMaskForTarget |= std::array<uint32, 7>{ 0x00002000u, 0x0F004000u, 0xFFF08000u, 0x000000FEu, 0xFF800004u, 0xFFFC07FFu, 0x01FFFFFFu };
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::UnitAll))
        allowedMaskForTarget |= std::array<uint32, 7>{ 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0xFF800004u, 0x000007FFu, 0x00000000u };
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Empath))
        allowedMaskForTarget |= std::array<uint32, 7>{ 0x00000000u, 0x0F000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x000007F8u };
}

void UnitData::FilterDisallowedFieldsMaskForFlag(Mask& changesMask, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags)
{
    Mask allowedMaskForTarget({ 0xFFFFDFFFu, 0xF0FFBFFFu, 0x000F7FFFu, 0xFFFFFF01u, 0x007FFFFFu, 0x0003F800u, 0x00000000u });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    changesMask &= allowedMaskForTarget;
}

void UnitData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Unit const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlocksMask(0), 7);
    for (uint32 i = 0; i < 7; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBits(StateWorldEffectIDs->size(), 32);
            for (uint32 i = 0; i < StateWorldEffectIDs->size(); ++i)
            {
                data << uint32((*StateWorldEffectIDs)[i]);
            }
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            if (!ignoreNestedChangesMask)
                PassiveSpells.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(PassiveSpells.size(), data);
        }
        if (changesMask[3])
        {
            if (!ignoreNestedChangesMask)
                WorldEffects.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(WorldEffects.size(), data);
        }
        if (changesMask[4])
        {
            if (!ignoreNestedChangesMask)
                ChannelObjects.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(ChannelObjects.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            for (uint32 i = 0; i < PassiveSpells.size(); ++i)
            {
                if (PassiveSpells.HasChanged(i) || ignoreNestedChangesMask)
                {
                    PassiveSpells[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[3])
        {
            for (uint32 i = 0; i < WorldEffects.size(); ++i)
            {
                if (WorldEffects.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(WorldEffects[i]);
                }
            }
        }
        if (changesMask[4])
        {
            for (uint32 i = 0; i < ChannelObjects.size(); ++i)
            {
                if (ChannelObjects.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << ChannelObjects[i];
                }
            }
        }
        if (changesMask[5])
        {
            data << int32(ViewerDependentValue<DisplayIDTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[6])
        {
            data << uint32(StateSpellVisualID);
        }
        if (changesMask[7])
        {
            data << uint32(StateAnimID);
        }
        if (changesMask[8])
        {
            data << uint32(StateAnimKitID);
        }
        if (changesMask[9])
        {
            data << uint32(StateWorldEffectsQuestObjectiveID);
        }
        if (changesMask[10])
        {
            data << int32(SpellOverrideNameID);
        }
        if (changesMask[11])
        {
            data << Charm;
        }
        if (changesMask[12])
        {
            data << Summon;
        }
        if (changesMask[13])
        {
            data << Critter;
        }
        if (changesMask[14])
        {
            data << CharmedBy;
        }
        if (changesMask[15])
        {
            data << SummonedBy;
        }
        if (changesMask[16])
        {
            data << CreatedBy;
        }
        if (changesMask[17])
        {
            data << DemonCreator;
        }
        if (changesMask[18])
        {
            data << LookAtControllerTarget;
        }
        if (changesMask[19])
        {
            data << Target;
        }
        if (changesMask[20])
        {
            data << BattlePetCompanionGUID;
        }
        if (changesMask[21])
        {
            data << uint64(BattlePetDBID);
        }
        if (changesMask[22])
        {
            ChannelData->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[23])
        {
            data << int8(SpellEmpowerStage);
        }
        if (changesMask[24])
        {
            data << uint32(SummonedByHomeRealm);
        }
        if (changesMask[25])
        {
            data << uint8(Race);
        }
        if (changesMask[26])
        {
            data << uint8(ClassId);
        }
        if (changesMask[27])
        {
            data << uint8(PlayerClassId);
        }
        if (changesMask[28])
        {
            data << uint8(Sex);
        }
        if (changesMask[29])
        {
            data << uint8(DisplayPower);
        }
        if (changesMask[30])
        {
            data << uint32(OverrideDisplayPowerID);
        }
        if (changesMask[31])
        {
            data << int64(Health);
        }
    }
    if (changesMask[32])
    {
        if (changesMask[33])
        {
            data << int64(MaxHealth);
        }
        if (changesMask[34])
        {
            data << int32(Level);
        }
        if (changesMask[35])
        {
            data << int32(EffectiveLevel);
        }
        if (changesMask[36])
        {
            data << int32(ContentTuningID);
        }
        if (changesMask[37])
        {
            data << int32(ScalingLevelMin);
        }
        if (changesMask[38])
        {
            data << int32(ScalingLevelMax);
        }
        if (changesMask[39])
        {
            data << int32(ScalingLevelDelta);
        }
        if (changesMask[40])
        {
            data << int32(ScalingFactionGroup);
        }
        if (changesMask[41])
        {
            data << int32(ViewerDependentValue<FactionTemplateTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[42])
        {
            data << uint32(ViewerDependentValue<FlagsTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[43])
        {
            data << uint32(Flags2);
        }
        if (changesMask[44])
        {
            data << uint32(ViewerDependentValue<Flags3Tag>::GetValue(this, owner, receiver));
        }
        if (changesMask[45])
        {
            data << uint32(ViewerDependentValue<AuraStateTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[46])
        {
            data << uint32(RangedAttackRoundBaseTime);
        }
        if (changesMask[47])
        {
            data << float(BoundingRadius);
        }
        if (changesMask[48])
        {
            data << float(CombatReach);
        }
        if (changesMask[49])
        {
            data << float(DisplayScale);
        }
        if (changesMask[50])
        {
            data << int32(CreatureFamily);
        }
        if (changesMask[51])
        {
            data << int32(CreatureType);
        }
        if (changesMask[52])
        {
            data << int32(NativeDisplayID);
        }
        if (changesMask[53])
        {
            data << float(NativeXDisplayScale);
        }
        if (changesMask[54])
        {
            data << int32(MountDisplayID);
        }
        if (changesMask[55])
        {
            data << int32(CosmeticMountDisplayID);
        }
        if (changesMask[56])
        {
            data << float(MinDamage);
        }
        if (changesMask[57])
        {
            data << float(MaxDamage);
        }
        if (changesMask[58])
        {
            data << float(MinOffHandDamage);
        }
        if (changesMask[59])
        {
            data << float(MaxOffHandDamage);
        }
        if (changesMask[60])
        {
            data << uint8(StandState);
        }
        if (changesMask[61])
        {
            data << uint8(PetTalentPoints);
        }
        if (changesMask[62])
        {
            data << uint8(VisFlags);
        }
        if (changesMask[63])
        {
            data << uint8(AnimTier);
        }
    }
    if (changesMask[64])
    {
        if (changesMask[65])
        {
            data << uint32(PetNumber);
        }
        if (changesMask[66])
        {
            data << uint32(PetNameTimestamp);
        }
        if (changesMask[67])
        {
            data << uint32(PetExperience);
        }
        if (changesMask[68])
        {
            data << uint32(PetNextLevelExperience);
        }
        if (changesMask[69])
        {
            data << float(ModCastingSpeed);
        }
        if (changesMask[70])
        {
            data << float(ModCastingSpeedNeg);
        }
        if (changesMask[71])
        {
            data << float(ModSpellHaste);
        }
        if (changesMask[72])
        {
            data << float(ModHaste);
        }
        if (changesMask[73])
        {
            data << float(ModRangedHaste);
        }
        if (changesMask[74])
        {
            data << float(ModHasteRegen);
        }
        if (changesMask[75])
        {
            data << float(ModTimeRate);
        }
        if (changesMask[76])
        {
            data << int32(CreatedBySpell);
        }
        if (changesMask[77])
        {
            data << int32(EmoteState);
        }
        if (changesMask[78])
        {
            data << int32(BaseMana);
        }
        if (changesMask[79])
        {
            data << int32(BaseHealth);
        }
        if (changesMask[80])
        {
            data << uint8(SheatheState);
        }
        if (changesMask[81])
        {
            data << uint8(ViewerDependentValue<PvpFlagsTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[82])
        {
            data << uint8(PetFlags);
        }
        if (changesMask[83])
        {
            data << uint8(ShapeshiftForm);
        }
        if (changesMask[84])
        {
            data << int32(AttackPower);
        }
        if (changesMask[85])
        {
            data << int32(AttackPowerModPos);
        }
        if (changesMask[86])
        {
            data << int32(AttackPowerModNeg);
        }
        if (changesMask[87])
        {
            data << float(AttackPowerMultiplier);
        }
        if (changesMask[88])
        {
            data << int32(AttackPowerModSupport);
        }
        if (changesMask[89])
        {
            data << int32(RangedAttackPower);
        }
        if (changesMask[90])
        {
            data << int32(RangedAttackPowerModPos);
        }
        if (changesMask[91])
        {
            data << int32(RangedAttackPowerModNeg);
        }
        if (changesMask[92])
        {
            data << float(RangedAttackPowerMultiplier);
        }
        if (changesMask[93])
        {
            data << int32(RangedAttackPowerModSupport);
        }
        if (changesMask[94])
        {
            data << int32(MainHandWeaponAttackPower);
        }
        if (changesMask[95])
        {
            data << int32(OffHandWeaponAttackPower);
        }
    }
    if (changesMask[96])
    {
        if (changesMask[97])
        {
            data << int32(RangedWeaponAttackPower);
        }
        if (changesMask[98])
        {
            data << int32(SetAttackSpeedAura);
        }
        if (changesMask[99])
        {
            data << float(Lifesteal);
        }
        if (changesMask[100])
        {
            data << float(MinRangedDamage);
        }
        if (changesMask[101])
        {
            data << float(MaxRangedDamage);
        }
        if (changesMask[102])
        {
            data << float(ManaCostMultiplier);
        }
        if (changesMask[103])
        {
            data << float(MaxHealthModifier);
        }
        if (changesMask[104])
        {
            data << float(HoverHeight);
        }
        if (changesMask[105])
        {
            data << int32(MinItemLevelCutoff);
        }
        if (changesMask[106])
        {
            data << int32(MinItemLevel);
        }
        if (changesMask[107])
        {
            data << int32(MaxItemLevel);
        }
        if (changesMask[108])
        {
            data << int32(AzeriteItemLevel);
        }
        if (changesMask[109])
        {
            data << int32(WildBattlePetLevel);
        }
        if (changesMask[110])
        {
            data << int32(BattlePetCompanionExperience);
        }
        if (changesMask[111])
        {
            data << uint32(BattlePetCompanionNameTimestamp);
        }
        if (changesMask[112])
        {
            data << int32(ViewerDependentValue<InteractSpellIDTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[113])
        {
            data << int32(ScaleDuration);
        }
        if (changesMask[114])
        {
            data << int32(LooksLikeMountID);
        }
        if (changesMask[115])
        {
            data << int32(LooksLikeCreatureID);
        }
        if (changesMask[116])
        {
            data << int32(LookAtControllerID);
        }
        if (changesMask[117])
        {
            data << int32(PerksVendorItemID);
        }
        if (changesMask[118])
        {
            data << int32(TaxiNodesID);
        }
        if (changesMask[119])
        {
            data << GuildGUID;
        }
        if (changesMask[120])
        {
            data << int32(FlightCapabilityID);
        }
        if (changesMask[121])
        {
            data << float(GlideEventSpeedDivisor);
        }
        if (changesMask[122])
        {
            data << uint32(Field_308);
        }
        if (changesMask[123])
        {
            data << uint32(Field_30C);
        }
        if (changesMask[124])
        {
            data << uint32(SilencedSchoolMask);
        }
        if (changesMask[125])
        {
            data << uint32(CurrentAreaID);
        }
        if (changesMask[126])
        {
            data << NameplateAttachToGUID;
        }
    }
    if (changesMask[127])
    {
        for (uint32 i = 0; i < 2; ++i)
        {
            if (changesMask[128 + i])
            {
                data << uint32(ViewerDependentValue<NpcFlagsTag>::GetValue(this, i, owner, receiver));
            }
        }
    }
    if (changesMask[130])
    {
        for (uint32 i = 0; i < 10; ++i)
        {
            if (changesMask[131 + i])
            {
                data << int32(Power[i]);
            }
            if (changesMask[141 + i])
            {
                data << int32(MaxPower[i]);
            }
            if (changesMask[151 + i])
            {
                data << float(PowerRegenFlatModifier[i]);
            }
            if (changesMask[161 + i])
            {
                data << float(PowerRegenInterruptedFlatModifier[i]);
            }
        }
    }
    if (changesMask[171])
    {
        for (uint32 i = 0; i < 3; ++i)
        {
            if (changesMask[172 + i])
            {
                VirtualItems[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    if (changesMask[175])
    {
        for (uint32 i = 0; i < 2; ++i)
        {
            if (changesMask[176 + i])
            {
                data << uint32(AttackRoundBaseTime[i]);
            }
        }
    }
    if (changesMask[178])
    {
        for (uint32 i = 0; i < 4; ++i)
        {
            if (changesMask[179 + i])
            {
                data << int32(Stats[i]);
            }
            if (changesMask[183 + i])
            {
                data << int32(StatPosBuff[i]);
            }
            if (changesMask[187 + i])
            {
                data << int32(StatNegBuff[i]);
            }
            if (changesMask[191 + i])
            {
                data << int32(StatSupportBuff[i]);
            }
        }
    }
    if (changesMask[195])
    {
        for (uint32 i = 0; i < 7; ++i)
        {
            if (changesMask[196 + i])
            {
                data << int32(Resistances[i]);
            }
            if (changesMask[203 + i])
            {
                data << int32(BonusResistanceMods[i]);
            }
            if (changesMask[210 + i])
            {
                data << int32(ManaCostModifier[i]);
            }
        }
    }
}

void UnitData::ClearChangesMask()
{
    Base::ClearChangesMask(StateWorldEffectIDs);
    Base::ClearChangesMask(PassiveSpells);
    Base::ClearChangesMask(WorldEffects);
    Base::ClearChangesMask(ChannelObjects);
    Base::ClearChangesMask(DisplayID);
    Base::ClearChangesMask(StateSpellVisualID);
    Base::ClearChangesMask(StateAnimID);
    Base::ClearChangesMask(StateAnimKitID);
    Base::ClearChangesMask(StateWorldEffectsQuestObjectiveID);
    Base::ClearChangesMask(SpellOverrideNameID);
    Base::ClearChangesMask(Charm);
    Base::ClearChangesMask(Summon);
    Base::ClearChangesMask(Critter);
    Base::ClearChangesMask(CharmedBy);
    Base::ClearChangesMask(SummonedBy);
    Base::ClearChangesMask(CreatedBy);
    Base::ClearChangesMask(DemonCreator);
    Base::ClearChangesMask(LookAtControllerTarget);
    Base::ClearChangesMask(Target);
    Base::ClearChangesMask(BattlePetCompanionGUID);
    Base::ClearChangesMask(BattlePetDBID);
    Base::ClearChangesMask(ChannelData);
    Base::ClearChangesMask(SpellEmpowerStage);
    Base::ClearChangesMask(SummonedByHomeRealm);
    Base::ClearChangesMask(Race);
    Base::ClearChangesMask(ClassId);
    Base::ClearChangesMask(PlayerClassId);
    Base::ClearChangesMask(Sex);
    Base::ClearChangesMask(DisplayPower);
    Base::ClearChangesMask(OverrideDisplayPowerID);
    Base::ClearChangesMask(Health);
    Base::ClearChangesMask(MaxHealth);
    Base::ClearChangesMask(Level);
    Base::ClearChangesMask(EffectiveLevel);
    Base::ClearChangesMask(ContentTuningID);
    Base::ClearChangesMask(ScalingLevelMin);
    Base::ClearChangesMask(ScalingLevelMax);
    Base::ClearChangesMask(ScalingLevelDelta);
    Base::ClearChangesMask(ScalingFactionGroup);
    Base::ClearChangesMask(FactionTemplate);
    Base::ClearChangesMask(Flags);
    Base::ClearChangesMask(Flags2);
    Base::ClearChangesMask(Flags3);
    Base::ClearChangesMask(AuraState);
    Base::ClearChangesMask(RangedAttackRoundBaseTime);
    Base::ClearChangesMask(BoundingRadius);
    Base::ClearChangesMask(CombatReach);
    Base::ClearChangesMask(DisplayScale);
    Base::ClearChangesMask(CreatureFamily);
    Base::ClearChangesMask(CreatureType);
    Base::ClearChangesMask(NativeDisplayID);
    Base::ClearChangesMask(NativeXDisplayScale);
    Base::ClearChangesMask(MountDisplayID);
    Base::ClearChangesMask(CosmeticMountDisplayID);
    Base::ClearChangesMask(MinDamage);
    Base::ClearChangesMask(MaxDamage);
    Base::ClearChangesMask(MinOffHandDamage);
    Base::ClearChangesMask(MaxOffHandDamage);
    Base::ClearChangesMask(StandState);
    Base::ClearChangesMask(PetTalentPoints);
    Base::ClearChangesMask(VisFlags);
    Base::ClearChangesMask(AnimTier);
    Base::ClearChangesMask(PetNumber);
    Base::ClearChangesMask(PetNameTimestamp);
    Base::ClearChangesMask(PetExperience);
    Base::ClearChangesMask(PetNextLevelExperience);
    Base::ClearChangesMask(ModCastingSpeed);
    Base::ClearChangesMask(ModCastingSpeedNeg);
    Base::ClearChangesMask(ModSpellHaste);
    Base::ClearChangesMask(ModHaste);
    Base::ClearChangesMask(ModRangedHaste);
    Base::ClearChangesMask(ModHasteRegen);
    Base::ClearChangesMask(ModTimeRate);
    Base::ClearChangesMask(CreatedBySpell);
    Base::ClearChangesMask(EmoteState);
    Base::ClearChangesMask(BaseMana);
    Base::ClearChangesMask(BaseHealth);
    Base::ClearChangesMask(SheatheState);
    Base::ClearChangesMask(PvpFlags);
    Base::ClearChangesMask(PetFlags);
    Base::ClearChangesMask(ShapeshiftForm);
    Base::ClearChangesMask(AttackPower);
    Base::ClearChangesMask(AttackPowerModPos);
    Base::ClearChangesMask(AttackPowerModNeg);
    Base::ClearChangesMask(AttackPowerMultiplier);
    Base::ClearChangesMask(AttackPowerModSupport);
    Base::ClearChangesMask(RangedAttackPower);
    Base::ClearChangesMask(RangedAttackPowerModPos);
    Base::ClearChangesMask(RangedAttackPowerModNeg);
    Base::ClearChangesMask(RangedAttackPowerMultiplier);
    Base::ClearChangesMask(RangedAttackPowerModSupport);
    Base::ClearChangesMask(MainHandWeaponAttackPower);
    Base::ClearChangesMask(OffHandWeaponAttackPower);
    Base::ClearChangesMask(RangedWeaponAttackPower);
    Base::ClearChangesMask(SetAttackSpeedAura);
    Base::ClearChangesMask(Lifesteal);
    Base::ClearChangesMask(MinRangedDamage);
    Base::ClearChangesMask(MaxRangedDamage);
    Base::ClearChangesMask(ManaCostMultiplier);
    Base::ClearChangesMask(MaxHealthModifier);
    Base::ClearChangesMask(HoverHeight);
    Base::ClearChangesMask(MinItemLevelCutoff);
    Base::ClearChangesMask(MinItemLevel);
    Base::ClearChangesMask(MaxItemLevel);
    Base::ClearChangesMask(AzeriteItemLevel);
    Base::ClearChangesMask(WildBattlePetLevel);
    Base::ClearChangesMask(BattlePetCompanionExperience);
    Base::ClearChangesMask(BattlePetCompanionNameTimestamp);
    Base::ClearChangesMask(InteractSpellID);
    Base::ClearChangesMask(ScaleDuration);
    Base::ClearChangesMask(LooksLikeMountID);
    Base::ClearChangesMask(LooksLikeCreatureID);
    Base::ClearChangesMask(LookAtControllerID);
    Base::ClearChangesMask(PerksVendorItemID);
    Base::ClearChangesMask(TaxiNodesID);
    Base::ClearChangesMask(GuildGUID);
    Base::ClearChangesMask(FlightCapabilityID);
    Base::ClearChangesMask(GlideEventSpeedDivisor);
    Base::ClearChangesMask(Field_308);
    Base::ClearChangesMask(Field_30C);
    Base::ClearChangesMask(SilencedSchoolMask);
    Base::ClearChangesMask(CurrentAreaID);
    Base::ClearChangesMask(NameplateAttachToGUID);
    Base::ClearChangesMask(NpcFlags);
    Base::ClearChangesMask(Power);
    Base::ClearChangesMask(MaxPower);
    Base::ClearChangesMask(PowerRegenFlatModifier);
    Base::ClearChangesMask(PowerRegenInterruptedFlatModifier);
    Base::ClearChangesMask(VirtualItems);
    Base::ClearChangesMask(AttackRoundBaseTime);
    Base::ClearChangesMask(Stats);
    Base::ClearChangesMask(StatPosBuff);
    Base::ClearChangesMask(StatNegBuff);
    Base::ClearChangesMask(StatSupportBuff);
    Base::ClearChangesMask(Resistances);
    Base::ClearChangesMask(BonusResistanceMods);
    Base::ClearChangesMask(ManaCostModifier);
    _changesMask.ResetAll();
}

void ChrCustomizationChoice::WriteCreate(ByteBuffer& data, Object const* owner, Player const* receiver) const
{
    data << uint32(ChrCustomizationOptionID);
    data << uint32(ChrCustomizationChoiceID);
}

void ChrCustomizationChoice::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Object const* owner, Player const* receiver) const
{
    data << uint32(ChrCustomizationOptionID);
    data << uint32(ChrCustomizationChoiceID);
}

bool ChrCustomizationChoice::operator==(ChrCustomizationChoice const& right) const
{
    return ChrCustomizationOptionID == right.ChrCustomizationOptionID
        && ChrCustomizationChoiceID == right.ChrCustomizationChoiceID;
}

void QuestLog::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int64(EndTime);
    data << int32(QuestID);
    data << uint32(StateFlags);
    data << uint32(ObjectiveFlags);
    for (uint32 i = 0; i < 24; ++i)
    {
        data << int16(ObjectiveProgress[i]);
    }
}

void QuestLog::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlocksMask(0), 1);
    if (changesMask.GetBlock(0))
        data.WriteBits(changesMask.GetBlock(0), 32);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int64(EndTime);
        }
        if (changesMask[2])
        {
            data << int32(QuestID);
        }
        if (changesMask[3])
        {
            data << uint32(StateFlags);
        }
        if (changesMask[4])
        {
            data << uint32(ObjectiveFlags);
        }
    }
    if (changesMask[5])
    {
        for (uint32 i = 0; i < 24; ++i)
        {
            if (changesMask[6 + i])
            {
                data << int16(ObjectiveProgress[i]);
            }
        }
    }
}

void QuestLog::ClearChangesMask()
{
    Base::ClearChangesMask(EndTime);
    Base::ClearChangesMask(QuestID);
    Base::ClearChangesMask(StateFlags);
    Base::ClearChangesMask(ObjectiveFlags);
    Base::ClearChangesMask(ObjectiveProgress);
    _changesMask.ResetAll();
}

void ArenaCooldown::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(SpellID);
    data << int32(Charges);
    data << uint32(Flags);
    data << uint32(StartTime);
    data << uint32(EndTime);
    data << uint32(NextChargeTime);
    data << uint8(MaxCharges);
}

void ArenaCooldown::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 8);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(SpellID);
        }
        if (changesMask[2])
        {
            data << int32(Charges);
        }
        if (changesMask[3])
        {
            data << uint32(Flags);
        }
        if (changesMask[4])
        {
            data << uint32(StartTime);
        }
        if (changesMask[5])
        {
            data << uint32(EndTime);
        }
        if (changesMask[6])
        {
            data << uint32(NextChargeTime);
        }
        if (changesMask[7])
        {
            data << uint8(MaxCharges);
        }
    }
}

void ArenaCooldown::ClearChangesMask()
{
    Base::ClearChangesMask(SpellID);
    Base::ClearChangesMask(Charges);
    Base::ClearChangesMask(Flags);
    Base::ClearChangesMask(StartTime);
    Base::ClearChangesMask(EndTime);
    Base::ClearChangesMask(NextChargeTime);
    Base::ClearChangesMask(MaxCharges);
    _changesMask.ResetAll();
}

void PetCreatureName::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << uint32(CreatureID);
    data.WriteBits(Name->size(), 8);
    data.WriteString(Name);
    data.FlushBits();
}

void PetCreatureName::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 3);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << uint32(CreatureID);
        }
        if (changesMask[2])
        {
            data.WriteBits(Name->size(), 8);
            data.WriteString(Name);
        }
    }
    data.FlushBits();
}

void PetCreatureName::ClearChangesMask()
{
    Base::ClearChangesMask(CreatureID);
    Base::ClearChangesMask(Name);
    _changesMask.ResetAll();
}

void CTROptions::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(ContentTuningConditionMask);
    data << uint32(Field_4);
    data << uint32(ExpansionLevelMask);
}

void CTROptions::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << int32(ContentTuningConditionMask);
    data << uint32(Field_4);
    data << uint32(ExpansionLevelMask);
}

bool CTROptions::operator==(CTROptions const& right) const
{
    return ContentTuningConditionMask == right.ContentTuningConditionMask
        && Field_4 == right.Field_4
        && ExpansionLevelMask == right.ExpansionLevelMask;
}

void DeclinedNames::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    for (uint32 i = 0; i < 5; ++i)
    {
        data.WriteBits(Name[i].size(), 10);
    }
    data.FlushBits();
    for (uint32 i = 0; i < 5; ++i)
    {
        data.WriteString(Name[i]);
    }
    data.FlushBits();
}

void DeclinedNames::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlocksMask(0), 1);
    if (changesMask.GetBlock(0))
        data.WriteBits(changesMask.GetBlock(0), 32);

    data.FlushBits();
    if (changesMask[0])
    {
        for (uint32 i = 0; i < 5; ++i)
        {
            if (changesMask[1 + i])
            {
                data.WriteBits(Name[i].size(), 10);
            }
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        for (uint32 i = 0; i < 5; ++i)
        {
            if (changesMask[1 + i])
            {
                data.WriteString(Name[i]);
            }
        }
    }
    data.FlushBits();
}

void DeclinedNames::ClearChangesMask()
{
    Base::ClearChangesMask(Name);
    _changesMask.ResetAll();
}

void CustomTabardInfo::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(EmblemStyle);
    data << int32(EmblemColor);
    data << int32(BorderStyle);
    data << int32(BorderColor);
    data << int32(BackgroundColor);
}

void CustomTabardInfo::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 6);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(EmblemStyle);
        }
        if (changesMask[2])
        {
            data << int32(EmblemColor);
        }
        if (changesMask[3])
        {
            data << int32(BorderStyle);
        }
        if (changesMask[4])
        {
            data << int32(BorderColor);
        }
        if (changesMask[5])
        {
            data << int32(BackgroundColor);
        }
    }
}

void CustomTabardInfo::ClearChangesMask()
{
    Base::ClearChangesMask(EmblemStyle);
    Base::ClearChangesMask(EmblemColor);
    Base::ClearChangesMask(BorderStyle);
    Base::ClearChangesMask(BorderColor);
    Base::ClearChangesMask(BackgroundColor);
    _changesMask.ResetAll();
}

void PlayerData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Player const* owner, Player const* receiver) const
{
    data << DuelArbiter;
    data << WowAccount;
    data << BnetAccount;
    data << uint64(GuildClubMemberID);
    data << LootTargetGUID;
    data << uint32(PlayerFlags);
    data << uint32(PlayerFlagsEx);
    data << uint32(GuildRankID);
    data << uint32(GuildDeleteDate);
    data << int32(GuildLevel);
    data << uint32(Customizations.size());
    data << uint32(QaCustomizations.size());
    for (uint32 i = 0; i < 2; ++i)
    {
        data << uint8(PartyType[i]);
    }
    data << uint8(NativeSex);
    data << uint8(Inebriation);
    data << uint8(PvpTitle);
    data << uint8(ArenaFaction);
    data << uint32(DuelTeam);
    data << int32(GuildTimeStamp);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::PartyMember))
    {
        for (uint32 i = 0; i < 175; ++i)
        {
            QuestLog[i].WriteCreate(data, owner, receiver);
        }
        data << uint32(QuestSessionQuestLog.size());
    }
    for (uint32 i = 0; i < 19; ++i)
    {
        VisibleItems[i].WriteCreate(data, owner, receiver);
    }
    data << int32(PlayerTitle);
    data << int32(FakeInebriation);
    data << uint32(VirtualPlayerRealm);
    data << uint32(CurrentSpecID);
    data << int32(TaxiMountAnimKitID);
    for (uint32 i = 0; i < 6; ++i)
    {
        data << float(AvgItemLevel[i]);
    }
    data << uint8(CurrentBattlePetBreedQuality);
    data << int32(HonorLevel);
    data << int64(LogoutTime);
    data << uint32(ArenaCooldowns.size());
    data << int32(Field_1AC);
    data << int32(Field_1B0);
    data << int32(CurrentBattlePetSpeciesID);
    data << uint32(PetNames.size());
    CtrOptions->WriteCreate(data, owner, receiver);
    data << int32(CovenantID);
    data << int32(SoulbindID);
    data << SpectateTarget;
    data << int32(Field_200);
    data << uint32(VisualItemReplacements.size());
    for (uint32 i = 0; i < 19; ++i)
    {
        data << uint32(Field_3120[i]);
    }
    PersonalTabard->WriteCreate(data, owner, receiver);
    for (uint32 i = 0; i < Customizations.size(); ++i)
    {
        Customizations[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < QaCustomizations.size(); ++i)
    {
        QaCustomizations[i].WriteCreate(data, owner, receiver);
    }
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::PartyMember))
    {
        for (uint32 i = 0; i < QuestSessionQuestLog.size(); ++i)
        {
            QuestSessionQuestLog[i].WriteCreate(data, owner, receiver);
        }
    }
    for (uint32 i = 0; i < ArenaCooldowns.size(); ++i)
    {
        ArenaCooldowns[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < VisualItemReplacements.size(); ++i)
    {
        data << int32(VisualItemReplacements[i]);
    }
    data.FlushBits();
    data.WriteBits(Name->size(), 6);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::PartyMember))
    {
        data.WriteBit(HasQuestSession);
    }
    data.WriteBit(HasLevelLink);
    data.WriteBits(DeclinedNames.has_value(), 1);
    data << DungeonScore;
    data.WriteString(Name);
    for (uint32 i = 0; i < 16; ++i)
    {
        data << VisibleEquipableSpells[i];
    }
    for (uint32 i = 0; i < PetNames.size(); ++i)
    {
        PetNames[i].WriteCreate(data, owner, receiver);
    }
    if (DeclinedNames.has_value())
    {
        DeclinedNames->WriteCreate(data, owner, receiver);
    }
    data.FlushBits();
}

void PlayerData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Player const* owner, Player const* receiver) const
{
    Mask allowedMaskForTarget({ 0xFFFFFFDDu, 0x0001FFFFu, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0xFFFFFFFEu, 0xFFFFFFFFu, 0x00000001u });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    WriteUpdate(data, _changesMask & allowedMaskForTarget, false, owner, receiver);
}

void PlayerData::AppendAllowedFieldsMaskForFlag(Mask& allowedMaskForTarget, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags)
{
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::PartyMember))
        allowedMaskForTarget |= std::array<uint32, 10>{ 0x00000022u, 0xFFFE0000u, 0xFFFFFFFFu, 0xFFFFFFFFu, 0xFFFFFFFFu, 0xFFFFFFFFu, 0xFFFFFFFFu, 0x00000001u, 0x00000000u, 0x00000000u };
}

void PlayerData::FilterDisallowedFieldsMaskForFlag(Mask& changesMask, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags)
{
    Mask allowedMaskForTarget({ 0xFFFFFFDDu, 0x0001FFFFu, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0xFFFFFFFEu, 0xFFFFFFFFu, 0x00000001u });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    changesMask &= allowedMaskForTarget;
}

void PlayerData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Player const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlocksMask(0), 10);
    for (uint32 i = 0; i < 10; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    bool noQuestLogChangesMask = data.WriteBit(IsQuestLogChangesMaskSkipped());
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBit(HasQuestSession);
        }
        if (changesMask[2])
        {
            data.WriteBit(HasLevelLink);
        }
        if (changesMask[3])
        {
            if (!ignoreNestedChangesMask)
                Customizations.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Customizations.size(), data);
        }
        if (changesMask[4])
        {
            if (!ignoreNestedChangesMask)
                QaCustomizations.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(QaCustomizations.size(), data);
        }
        if (changesMask[5])
        {
            if (!ignoreNestedChangesMask)
                QuestSessionQuestLog.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(QuestSessionQuestLog.size(), data);
        }
        if (changesMask[6])
        {
            if (!ignoreNestedChangesMask)
                ArenaCooldowns.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(ArenaCooldowns.size(), data);
        }
        if (changesMask[7])
        {
            if (!ignoreNestedChangesMask)
                PetNames.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(PetNames.size(), data);
        }
        if (changesMask[8])
        {
            if (!ignoreNestedChangesMask)
                VisualItemReplacements.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(VisualItemReplacements.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[3])
        {
            for (uint32 i = 0; i < Customizations.size(); ++i)
            {
                if (Customizations.HasChanged(i) || ignoreNestedChangesMask)
                {
                    Customizations[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[4])
        {
            for (uint32 i = 0; i < QaCustomizations.size(); ++i)
            {
                if (QaCustomizations.HasChanged(i) || ignoreNestedChangesMask)
                {
                    QaCustomizations[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[5])
        {
            for (uint32 i = 0; i < QuestSessionQuestLog.size(); ++i)
            {
                if (QuestSessionQuestLog.HasChanged(i) || ignoreNestedChangesMask)
                {
                    if (noQuestLogChangesMask)
                        QuestSessionQuestLog[i].WriteCreate(data, owner, receiver);
                    else
                        QuestSessionQuestLog[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[6])
        {
            for (uint32 i = 0; i < ArenaCooldowns.size(); ++i)
            {
                if (ArenaCooldowns.HasChanged(i) || ignoreNestedChangesMask)
                {
                    ArenaCooldowns[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[8])
        {
            for (uint32 i = 0; i < VisualItemReplacements.size(); ++i)
            {
                if (VisualItemReplacements.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(VisualItemReplacements[i]);
                }
            }
        }
        if (changesMask[7])
        {
            for (uint32 i = 0; i < PetNames.size(); ++i)
            {
                if (PetNames.HasChanged(i) || ignoreNestedChangesMask)
                {
                    PetNames[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[9])
        {
            data << DuelArbiter;
        }
        if (changesMask[10])
        {
            data << WowAccount;
        }
        if (changesMask[11])
        {
            data << BnetAccount;
        }
        if (changesMask[12])
        {
            data << uint64(GuildClubMemberID);
        }
        if (changesMask[13])
        {
            data << LootTargetGUID;
        }
        if (changesMask[14])
        {
            data << uint32(PlayerFlags);
        }
        if (changesMask[15])
        {
            data << uint32(PlayerFlagsEx);
        }
        if (changesMask[16])
        {
            data << uint32(GuildRankID);
        }
        if (changesMask[17])
        {
            data << uint32(GuildDeleteDate);
        }
        if (changesMask[18])
        {
            data << int32(GuildLevel);
        }
        if (changesMask[19])
        {
            data << uint8(NativeSex);
        }
        if (changesMask[20])
        {
            data << uint8(Inebriation);
        }
        if (changesMask[21])
        {
            data << uint8(PvpTitle);
        }
        if (changesMask[22])
        {
            data << uint8(ArenaFaction);
        }
        if (changesMask[23])
        {
            data << uint32(DuelTeam);
        }
        if (changesMask[24])
        {
            data << int32(GuildTimeStamp);
        }
        if (changesMask[25])
        {
            data << int32(PlayerTitle);
        }
        if (changesMask[26])
        {
            data << int32(FakeInebriation);
        }
        if (changesMask[27])
        {
            data << uint32(VirtualPlayerRealm);
        }
        if (changesMask[28])
        {
            data << uint32(CurrentSpecID);
        }
        if (changesMask[29])
        {
            data << int32(TaxiMountAnimKitID);
        }
        if (changesMask[30])
        {
            data << uint8(CurrentBattlePetBreedQuality);
        }
        if (changesMask[31])
        {
            data << int32(HonorLevel);
        }
    }
    if (changesMask[32])
    {
        if (changesMask[33])
        {
            data << int64(LogoutTime);
        }
        if (changesMask[35])
        {
            data << int32(Field_1AC);
        }
        if (changesMask[36])
        {
            data << int32(Field_1B0);
        }
        if (changesMask[37])
        {
            data << int32(CurrentBattlePetSpeciesID);
        }
        if (changesMask[38])
        {
            CtrOptions->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[39])
        {
            data << int32(CovenantID);
        }
        if (changesMask[40])
        {
            data << int32(SoulbindID);
        }
        if (changesMask[42])
        {
            data << SpectateTarget;
        }
        if (changesMask[43])
        {
            data << int32(Field_200);
        }
        if (changesMask[45])
        {
            PersonalTabard->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[34])
        {
            data.WriteBits(Name->size(), 6);
        }
        data.WriteBits(DeclinedNames.has_value(), 1);
        data.FlushBits();
        if (changesMask[41])
        {
            data << DungeonScore;
        }
        if (changesMask[34])
        {
            data.WriteString(Name);
        }
        if (changesMask[44])
        {
            if (DeclinedNames.has_value())
            {
                DeclinedNames->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    if (changesMask[46])
    {
        for (uint32 i = 0; i < 2; ++i)
        {
            if (changesMask[47 + i])
            {
                data << uint8(PartyType[i]);
            }
        }
    }
    if (changesMask[49])
    {
        for (uint32 i = 0; i < 175; ++i)
        {
            if (changesMask[50 + i])
            {
                if (noQuestLogChangesMask)
                    QuestLog[i].WriteCreate(data, owner, receiver);
                else
                    QuestLog[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    if (changesMask[225])
    {
        for (uint32 i = 0; i < 19; ++i)
        {
            if (changesMask[226 + i])
            {
                VisibleItems[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    if (changesMask[245])
    {
        for (uint32 i = 0; i < 6; ++i)
        {
            if (changesMask[246 + i])
            {
                data << float(AvgItemLevel[i]);
            }
        }
    }
    if (changesMask[269])
    {
        for (uint32 i = 0; i < 19; ++i)
        {
            if (changesMask[270 + i])
            {
                data << uint32(Field_3120[i]);
            }
        }
    }
    if (changesMask[252])
    {
        for (uint32 i = 0; i < 16; ++i)
        {
            if (changesMask[253 + i])
            {
                data << VisibleEquipableSpells[i];
            }
        }
    }
    data.FlushBits();
}

void PlayerData::ClearChangesMask()
{
    Base::ClearChangesMask(HasQuestSession);
    Base::ClearChangesMask(HasLevelLink);
    Base::ClearChangesMask(Customizations);
    Base::ClearChangesMask(QaCustomizations);
    Base::ClearChangesMask(QuestSessionQuestLog);
    Base::ClearChangesMask(ArenaCooldowns);
    Base::ClearChangesMask(VisualItemReplacements);
    Base::ClearChangesMask(PetNames);
    Base::ClearChangesMask(DuelArbiter);
    Base::ClearChangesMask(WowAccount);
    Base::ClearChangesMask(BnetAccount);
    Base::ClearChangesMask(GuildClubMemberID);
    Base::ClearChangesMask(LootTargetGUID);
    Base::ClearChangesMask(PlayerFlags);
    Base::ClearChangesMask(PlayerFlagsEx);
    Base::ClearChangesMask(GuildRankID);
    Base::ClearChangesMask(GuildDeleteDate);
    Base::ClearChangesMask(GuildLevel);
    Base::ClearChangesMask(NativeSex);
    Base::ClearChangesMask(Inebriation);
    Base::ClearChangesMask(PvpTitle);
    Base::ClearChangesMask(ArenaFaction);
    Base::ClearChangesMask(DuelTeam);
    Base::ClearChangesMask(GuildTimeStamp);
    Base::ClearChangesMask(PlayerTitle);
    Base::ClearChangesMask(FakeInebriation);
    Base::ClearChangesMask(VirtualPlayerRealm);
    Base::ClearChangesMask(CurrentSpecID);
    Base::ClearChangesMask(TaxiMountAnimKitID);
    Base::ClearChangesMask(CurrentBattlePetBreedQuality);
    Base::ClearChangesMask(HonorLevel);
    Base::ClearChangesMask(LogoutTime);
    Base::ClearChangesMask(Name);
    Base::ClearChangesMask(Field_1AC);
    Base::ClearChangesMask(Field_1B0);
    Base::ClearChangesMask(CurrentBattlePetSpeciesID);
    Base::ClearChangesMask(CtrOptions);
    Base::ClearChangesMask(CovenantID);
    Base::ClearChangesMask(SoulbindID);
    Base::ClearChangesMask(DungeonScore);
    Base::ClearChangesMask(SpectateTarget);
    Base::ClearChangesMask(Field_200);
    Base::ClearChangesMask(DeclinedNames);
    Base::ClearChangesMask(PersonalTabard);
    Base::ClearChangesMask(PartyType);
    Base::ClearChangesMask(QuestLog);
    Base::ClearChangesMask(VisibleItems);
    Base::ClearChangesMask(AvgItemLevel);
    Base::ClearChangesMask(VisibleEquipableSpells);
    Base::ClearChangesMask(Field_3120);
    _changesMask.ResetAll();
}

void SkillInfo::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    for (uint32 i = 0; i < 256; ++i)
    {
        data << uint16(SkillLineID[i]);
        data << uint16(SkillStep[i]);
        data << uint16(SkillRank[i]);
        data << uint16(SkillStartingRank[i]);
        data << uint16(SkillMaxRank[i]);
        data << int16(SkillTempBonus[i]);
        data << uint16(SkillPermBonus[i]);
    }
}

void SkillInfo::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    for (uint32 i = 0; i < 1; ++i)
        data << uint32(changesMask.GetBlocksMask(i));
    data.WriteBits(changesMask.GetBlocksMask(1), 25);
    for (uint32 i = 0; i < 57; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    data.FlushBits();
    if (changesMask[0])
    {
        for (uint32 i = 0; i < 256; ++i)
        {
            if (changesMask[1 + i])
            {
                data << uint16(SkillLineID[i]);
            }
            if (changesMask[257 + i])
            {
                data << uint16(SkillStep[i]);
            }
            if (changesMask[513 + i])
            {
                data << uint16(SkillRank[i]);
            }
            if (changesMask[769 + i])
            {
                data << uint16(SkillStartingRank[i]);
            }
            if (changesMask[1025 + i])
            {
                data << uint16(SkillMaxRank[i]);
            }
            if (changesMask[1281 + i])
            {
                data << int16(SkillTempBonus[i]);
            }
            if (changesMask[1537 + i])
            {
                data << uint16(SkillPermBonus[i]);
            }
        }
    }
}

void SkillInfo::ClearChangesMask()
{
    Base::ClearChangesMask(SkillLineID);
    Base::ClearChangesMask(SkillStep);
    Base::ClearChangesMask(SkillRank);
    Base::ClearChangesMask(SkillStartingRank);
    Base::ClearChangesMask(SkillMaxRank);
    Base::ClearChangesMask(SkillTempBonus);
    Base::ClearChangesMask(SkillPermBonus);
    _changesMask.ResetAll();
}

void RestInfo::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << uint32(Threshold);
    data << uint8(StateID);
}

void RestInfo::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 3);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << uint32(Threshold);
        }
        if (changesMask[2])
        {
            data << uint8(StateID);
        }
    }
}

void RestInfo::ClearChangesMask()
{
    Base::ClearChangesMask(Threshold);
    Base::ClearChangesMask(StateID);
    _changesMask.ResetAll();
}

void PVPInfo::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int8(Bracket);
    data << int32(PvpRatingID);
    data << uint32(WeeklyPlayed);
    data << uint32(WeeklyWon);
    data << uint32(SeasonPlayed);
    data << uint32(SeasonWon);
    data << uint32(Rating);
    data << uint32(WeeklyBestRating);
    data << uint32(SeasonBestRating);
    data << uint32(PvpTierID);
    data << uint32(WeeklyBestWinPvpTierID);
    data << uint32(Field_28);
    data << uint32(Field_2C);
    data << uint32(WeeklyRoundsPlayed);
    data << uint32(WeeklyRoundsWon);
    data << uint32(SeasonRoundsPlayed);
    data << uint32(SeasonRoundsWon);
    data.WriteBit(Disqualified);
    data.FlushBits();
}

void PVPInfo::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 19);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBit(Disqualified);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            data << int8(Bracket);
        }
        if (changesMask[3])
        {
            data << int32(PvpRatingID);
        }
        if (changesMask[4])
        {
            data << uint32(WeeklyPlayed);
        }
        if (changesMask[5])
        {
            data << uint32(WeeklyWon);
        }
        if (changesMask[6])
        {
            data << uint32(SeasonPlayed);
        }
        if (changesMask[7])
        {
            data << uint32(SeasonWon);
        }
        if (changesMask[8])
        {
            data << uint32(Rating);
        }
        if (changesMask[9])
        {
            data << uint32(WeeklyBestRating);
        }
        if (changesMask[10])
        {
            data << uint32(SeasonBestRating);
        }
        if (changesMask[11])
        {
            data << uint32(PvpTierID);
        }
        if (changesMask[12])
        {
            data << uint32(WeeklyBestWinPvpTierID);
        }
        if (changesMask[13])
        {
            data << uint32(Field_28);
        }
        if (changesMask[14])
        {
            data << uint32(Field_2C);
        }
        if (changesMask[15])
        {
            data << uint32(WeeklyRoundsPlayed);
        }
        if (changesMask[16])
        {
            data << uint32(WeeklyRoundsWon);
        }
        if (changesMask[17])
        {
            data << uint32(SeasonRoundsPlayed);
        }
        if (changesMask[18])
        {
            data << uint32(SeasonRoundsWon);
        }
    }
    data.FlushBits();
}

void PVPInfo::ClearChangesMask()
{
    Base::ClearChangesMask(Disqualified);
    Base::ClearChangesMask(Bracket);
    Base::ClearChangesMask(PvpRatingID);
    Base::ClearChangesMask(WeeklyPlayed);
    Base::ClearChangesMask(WeeklyWon);
    Base::ClearChangesMask(SeasonPlayed);
    Base::ClearChangesMask(SeasonWon);
    Base::ClearChangesMask(Rating);
    Base::ClearChangesMask(WeeklyBestRating);
    Base::ClearChangesMask(SeasonBestRating);
    Base::ClearChangesMask(PvpTierID);
    Base::ClearChangesMask(WeeklyBestWinPvpTierID);
    Base::ClearChangesMask(Field_28);
    Base::ClearChangesMask(Field_2C);
    Base::ClearChangesMask(WeeklyRoundsPlayed);
    Base::ClearChangesMask(WeeklyRoundsWon);
    Base::ClearChangesMask(SeasonRoundsPlayed);
    Base::ClearChangesMask(SeasonRoundsWon);
    _changesMask.ResetAll();
}

void CharacterRestriction::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(Field_0);
    data << int32(Field_4);
    data << int32(Field_8);
    data.WriteBits(Type, 5);
    data.FlushBits();
}

void CharacterRestriction::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << int32(Field_0);
    data << int32(Field_4);
    data << int32(Field_8);
    data.WriteBits(Type, 5);
    data.FlushBits();
}

bool CharacterRestriction::operator==(CharacterRestriction const& right) const
{
    return Field_0 == right.Field_0
        && Field_4 == right.Field_4
        && Field_8 == right.Field_8
        && Type == right.Type;
}

void SpellPctModByLabel::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(ModIndex);
    data << float(ModifierValue);
    data << int32(LabelID);
}

void SpellPctModByLabel::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << int32(ModIndex);
    data << float(ModifierValue);
    data << int32(LabelID);
}

bool SpellPctModByLabel::operator==(SpellPctModByLabel const& right) const
{
    return ModIndex == right.ModIndex
        && ModifierValue == right.ModifierValue
        && LabelID == right.LabelID;
}

void SpellFlatModByLabel::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(ModIndex);
    data << int32(ModifierValue);
    data << int32(LabelID);
}

void SpellFlatModByLabel::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << int32(ModIndex);
    data << int32(ModifierValue);
    data << int32(LabelID);
}

bool SpellFlatModByLabel::operator==(SpellFlatModByLabel const& right) const
{
    return ModIndex == right.ModIndex
        && ModifierValue == right.ModifierValue
        && LabelID == right.LabelID;
}

void CompletedProject::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << uint32(ProjectID);
    data << int64(FirstCompleted);
    data << uint32(CompletionCount);
}

void CompletedProject::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 4);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << uint32(ProjectID);
        }
        if (changesMask[2])
        {
            data << int64(FirstCompleted);
        }
        if (changesMask[3])
        {
            data << uint32(CompletionCount);
        }
    }
}

void CompletedProject::ClearChangesMask()
{
    Base::ClearChangesMask(ProjectID);
    Base::ClearChangesMask(FirstCompleted);
    Base::ClearChangesMask(CompletionCount);
    _changesMask.ResetAll();
}

void ResearchHistory::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << uint32(CompletedProjects.size());
    for (uint32 i = 0; i < CompletedProjects.size(); ++i)
    {
        CompletedProjects[i].WriteCreate(data, owner, receiver);
    }
}

void ResearchHistory::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 2);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            if (!ignoreChangesMask)
                CompletedProjects.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(CompletedProjects.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            for (uint32 i = 0; i < CompletedProjects.size(); ++i)
            {
                if (CompletedProjects.HasChanged(i) || ignoreChangesMask)
                {
                    CompletedProjects[i].WriteUpdate(data, ignoreChangesMask, owner, receiver);
                }
            }
        }
    }
}

void ResearchHistory::ClearChangesMask()
{
    Base::ClearChangesMask(CompletedProjects);
    _changesMask.ResetAll();
}

void MawPower::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(SpellID);
    data << int32(MawPowerID);
    data << int32(Stacks);
}

void MawPower::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << int32(SpellID);
    data << int32(MawPowerID);
    data << int32(Stacks);
}

bool MawPower::operator==(MawPower const& right) const
{
    return SpellID == right.SpellID
        && MawPowerID == right.MawPowerID
        && Stacks == right.Stacks;
}

void MultiFloorExplore::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << uint32(WorldMapOverlayIDs.size());
    for (uint32 i = 0; i < WorldMapOverlayIDs.size(); ++i)
    {
        data << int32(WorldMapOverlayIDs[i]);
    }
}

void MultiFloorExplore::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << uint32(WorldMapOverlayIDs.size());
    for (uint32 i = 0; i < WorldMapOverlayIDs.size(); ++i)
    {
        data << int32(WorldMapOverlayIDs[i]);
    }
    data.FlushBits();
}

bool MultiFloorExplore::operator==(MultiFloorExplore const& right) const
{
    return WorldMapOverlayIDs == right.WorldMapOverlayIDs;
}

void RecipeProgressionInfo::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << uint16(RecipeProgressionGroupID);
    data << uint16(Experience);
}

void RecipeProgressionInfo::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << uint16(RecipeProgressionGroupID);
    data << uint16(Experience);
}

bool RecipeProgressionInfo::operator==(RecipeProgressionInfo const& right) const
{
    return RecipeProgressionGroupID == right.RecipeProgressionGroupID
        && Experience == right.Experience;
}

void ActivePlayerUnk901::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << Field_0;
    data << int32(Field_10);
}

void ActivePlayerUnk901::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 3);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << Field_0;
        }
        if (changesMask[2])
        {
            data << int32(Field_10);
        }
    }
}

void ActivePlayerUnk901::ClearChangesMask()
{
    Base::ClearChangesMask(Field_0);
    Base::ClearChangesMask(Field_10);
    _changesMask.ResetAll();
}

void QuestSession::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << Owner;
    for (uint32 i = 0; i < 950; ++i)
    {
        data << uint64(QuestCompleted[i]);
    }
}

void QuestSession::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlocksMask(0), 30);
    for (uint32 i = 0; i < 30; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << Owner;
        }
    }
    if (changesMask[2])
    {
        for (uint32 i = 0; i < 950; ++i)
        {
            if (changesMask[3 + i])
            {
                data << uint64(QuestCompleted[i]);
            }
        }
    }
}

void QuestSession::ClearChangesMask()
{
    Base::ClearChangesMask(Owner);
    Base::ClearChangesMask(QuestCompleted);
    _changesMask.ResetAll();
}

void ReplayedQuest::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(QuestID);
    data << uint32(ReplayTime);
}

void ReplayedQuest::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 3);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(QuestID);
        }
        if (changesMask[2])
        {
            data << uint32(ReplayTime);
        }
    }
}

void ReplayedQuest::ClearChangesMask()
{
    Base::ClearChangesMask(QuestID);
    Base::ClearChangesMask(ReplayTime);
    _changesMask.ResetAll();
}

void TraitEntry::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(TraitNodeID);
    data << int32(TraitNodeEntryID);
    data << int32(Rank);
    data << int32(GrantedRanks);
}

void TraitEntry::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << int32(TraitNodeID);
    data << int32(TraitNodeEntryID);
    data << int32(Rank);
    data << int32(GrantedRanks);
}

bool TraitEntry::operator==(TraitEntry const& right) const
{
    return TraitNodeID == right.TraitNodeID
        && TraitNodeEntryID == right.TraitNodeEntryID
        && Rank == right.Rank
        && GrantedRanks == right.GrantedRanks;
}

void TraitConfig::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(ID);
    data << int32(Type);
    data << uint32(Entries.size());
    if (Type == 2)
    {
        data << int32(SkillLineID);
    }
    if (Type == 1)
    {
        data << int32(ChrSpecializationID);
        data << int32(CombatConfigFlags);
        data << int32(LocalIdentifier);
    }
    if (Type == 3)
    {
        data << int32(TraitSystemID);
    }
    for (uint32 i = 0; i < Entries.size(); ++i)
    {
        Entries[i].WriteCreate(data, owner, receiver);
    }
    data.WriteBits(Name->size(), 9);
    data.WriteString(Name);
    data.FlushBits();
}

void TraitConfig::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 12);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            if (!ignoreChangesMask)
                Entries.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Entries.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            for (uint32 i = 0; i < Entries.size(); ++i)
            {
                if (Entries.HasChanged(i) || ignoreChangesMask)
                {
                    Entries[i].WriteUpdate(data, ignoreChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[2])
        {
            data << int32(ID);
        }
    }
    if (changesMask[4])
    {
        if (changesMask[5])
        {
            data << int32(Type);
        }
        if (changesMask[6])
        {
            if (Type == 2)
            {
                data << int32(SkillLineID);
            }
        }
        if (changesMask[7])
        {
            if (Type == 1)
            {
                data << int32(ChrSpecializationID);
            }
        }
    }
    if (changesMask[8])
    {
        if (changesMask[9])
        {
            if (Type == 1)
            {
                data << int32(CombatConfigFlags);
            }
        }
        if (changesMask[10])
        {
            if (Type == 1)
            {
                data << int32(LocalIdentifier);
            }
        }
        if (changesMask[11])
        {
            if (Type == 3)
            {
                data << int32(TraitSystemID);
            }
        }
    }
    if (changesMask[0])
    {
        if (changesMask[3])
        {
            data.WriteBits(Name->size(), 9);
            data.WriteString(Name);
        }
    }
    data.FlushBits();
}

void TraitConfig::ClearChangesMask()
{
    Base::ClearChangesMask(Entries);
    Base::ClearChangesMask(ID);
    Base::ClearChangesMask(Name);
    Base::ClearChangesMask(Type);
    Base::ClearChangesMask(SkillLineID);
    Base::ClearChangesMask(ChrSpecializationID);
    Base::ClearChangesMask(CombatConfigFlags);
    Base::ClearChangesMask(LocalIdentifier);
    Base::ClearChangesMask(TraitSystemID);
    _changesMask.ResetAll();
}

void CraftingOrderItem::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << uint64(Field_0);
    data << ItemGUID;
    data << OwnerGUID;
    data << int32(ItemID);
    data << uint32(Quantity);
    data << int32(ReagentQuality);
    data.WriteBits(DataSlotIndex.has_value(), 1);
    data.FlushBits();
    if (DataSlotIndex.has_value())
    {
        data << uint8(DataSlotIndex);
    }
}

void CraftingOrderItem::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 7);

    data.FlushBits();
    if (changesMask[0])
    {
        data << uint64(Field_0);
    }
    if (changesMask[1])
    {
        data << ItemGUID;
    }
    if (changesMask[2])
    {
        data << OwnerGUID;
    }
    if (changesMask[3])
    {
        data << int32(ItemID);
    }
    if (changesMask[4])
    {
        data << uint32(Quantity);
    }
    if (changesMask[5])
    {
        data << int32(ReagentQuality);
    }
    data.WriteBits(DataSlotIndex.has_value(), 1);
    data.FlushBits();
    if (changesMask[6])
    {
        if (DataSlotIndex.has_value())
        {
            data << uint8(DataSlotIndex);
        }
    }
}

void CraftingOrderItem::ClearChangesMask()
{
    Base::ClearChangesMask(Field_0);
    Base::ClearChangesMask(ItemGUID);
    Base::ClearChangesMask(OwnerGUID);
    Base::ClearChangesMask(ItemID);
    Base::ClearChangesMask(Quantity);
    Base::ClearChangesMask(ReagentQuality);
    Base::ClearChangesMask(DataSlotIndex);
    _changesMask.ResetAll();
}

void CraftingOrderData::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(Field_0);
    data << uint64(OrderID);
    data << int32(SkillLineAbilityID);
    data << uint8(OrderState);
    data << uint8(OrderType);
    data << uint8(MinQuality);
    data << int64(ExpirationTime);
    data << int64(ClaimEndTime);
    data << int64(TipAmount);
    data << int64(ConsortiumCut);
    data << uint32(Flags);
    data << CustomerGUID;
    data << CustomerAccountGUID;
    data << CrafterGUID;
    data << PersonalCrafterGUID;
    data << uint32(Reagents.size());
    data.WriteBits(CustomerNotes->size(), 10);
    data.WriteBits(OutputItem.has_value(), 1);
    data.WriteBits(OutputItemData.has_value(), 1);
    data.FlushBits();
    for (uint32 i = 0; i < Reagents.size(); ++i)
    {
        Reagents[i].WriteCreate(data, owner, receiver);
    }
    data.WriteString(CustomerNotes);
    if (OutputItem.has_value())
    {
        OutputItem->WriteCreate(data, owner, receiver);
    }
    if (OutputItemData.has_value())
    {
        data << OutputItemData;
    }
    data.FlushBits();
}

void CraftingOrderData::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 24);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            if (!ignoreChangesMask)
                Reagents.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Reagents.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            for (uint32 i = 0; i < Reagents.size(); ++i)
            {
                if (Reagents.HasChanged(i) || ignoreChangesMask)
                {
                    Reagents[i].WriteUpdate(data, ignoreChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[2])
        {
            data << int32(Field_0);
        }
        if (changesMask[3])
        {
            data << uint64(OrderID);
        }
        if (changesMask[4])
        {
            data << int32(SkillLineAbilityID);
        }
    }
    if (changesMask[5])
    {
        if (changesMask[6])
        {
            data << uint8(OrderState);
        }
        if (changesMask[7])
        {
            data << uint8(OrderType);
        }
        if (changesMask[8])
        {
            data << uint8(MinQuality);
        }
        if (changesMask[9])
        {
            data << int64(ExpirationTime);
        }
    }
    if (changesMask[10])
    {
        if (changesMask[11])
        {
            data << int64(ClaimEndTime);
        }
        if (changesMask[12])
        {
            data << int64(TipAmount);
        }
        if (changesMask[13])
        {
            data << int64(ConsortiumCut);
        }
        if (changesMask[14])
        {
            data << uint32(Flags);
        }
    }
    if (changesMask[15])
    {
        if (changesMask[16])
        {
            data << CustomerGUID;
        }
        if (changesMask[17])
        {
            data << CustomerAccountGUID;
        }
        if (changesMask[18])
        {
            data << CrafterGUID;
        }
        if (changesMask[19])
        {
            data << PersonalCrafterGUID;
        }
    }
    if (changesMask[20])
    {
        if (changesMask[21])
        {
            data.WriteBits(CustomerNotes->size(), 10);
            data.WriteString(CustomerNotes);
        }
        data.WriteBits(OutputItem.has_value(), 1);
        data.WriteBits(OutputItemData.has_value(), 1);
        data.FlushBits();
        if (changesMask[22])
        {
            if (OutputItem.has_value())
            {
                OutputItem->WriteUpdate(data, ignoreChangesMask, owner, receiver);
            }
        }
        if (changesMask[23])
        {
            if (OutputItemData.has_value())
            {
                data << OutputItemData;
            }
        }
    }
    data.FlushBits();
}

void CraftingOrderData::ClearChangesMask()
{
    Base::ClearChangesMask(Reagents);
    Base::ClearChangesMask(Field_0);
    Base::ClearChangesMask(OrderID);
    Base::ClearChangesMask(SkillLineAbilityID);
    Base::ClearChangesMask(OrderState);
    Base::ClearChangesMask(OrderType);
    Base::ClearChangesMask(MinQuality);
    Base::ClearChangesMask(ExpirationTime);
    Base::ClearChangesMask(ClaimEndTime);
    Base::ClearChangesMask(TipAmount);
    Base::ClearChangesMask(ConsortiumCut);
    Base::ClearChangesMask(Flags);
    Base::ClearChangesMask(CustomerGUID);
    Base::ClearChangesMask(CustomerAccountGUID);
    Base::ClearChangesMask(CrafterGUID);
    Base::ClearChangesMask(PersonalCrafterGUID);
    Base::ClearChangesMask(CustomerNotes);
    Base::ClearChangesMask(OutputItem);
    Base::ClearChangesMask(OutputItemData);
    _changesMask.ResetAll();
}

void CraftingOrder::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    Data->WriteCreate(data, owner, receiver);
    data.WriteBits(RecraftItemInfo.has_value(), 1);
    data.WriteBits(Enchantments.size(), 4);
    data.WriteBits(Gems.size(), 2);
    data.FlushBits();
    if (RecraftItemInfo.has_value())
    {
        data << RecraftItemInfo;
    }
    for (uint32 i = 0; i < Enchantments.size(); ++i)
    {
        data << Enchantments[i];
    }
    for (uint32 i = 0; i < Gems.size(); ++i)
    {
        data << Gems[i];
    }
    data.FlushBits();
}

void CraftingOrder::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 4);

    if (changesMask[0])
    {
        if (!ignoreChangesMask)
            Enchantments.WriteUpdateMask(data, 4);
        else
            WriteCompleteDynamicFieldUpdateMask(Enchantments.size(), data, 4);
    }
    if (changesMask[1])
    {
        if (!ignoreChangesMask)
            Gems.WriteUpdateMask(data, 2);
        else
            WriteCompleteDynamicFieldUpdateMask(Gems.size(), data, 2);
    }
    data.FlushBits();
    if (changesMask[0])
    {
        for (uint32 i = 0; i < Enchantments.size(); ++i)
        {
            if (Enchantments.HasChanged(i) || ignoreChangesMask)
            {
                data << Enchantments[i];
            }
        }
    }
    if (changesMask[1])
    {
        for (uint32 i = 0; i < Gems.size(); ++i)
        {
            if (Gems.HasChanged(i) || ignoreChangesMask)
            {
                data << Gems[i];
            }
        }
    }
    if (changesMask[2])
    {
        Data->WriteUpdate(data, ignoreChangesMask, owner, receiver);
    }
    data.WriteBits(RecraftItemInfo.has_value(), 1);
    data.FlushBits();
    if (changesMask[3])
    {
        if (RecraftItemInfo.has_value())
        {
            data << RecraftItemInfo;
        }
    }
    data.FlushBits();
}

void CraftingOrder::ClearChangesMask()
{
    Base::ClearChangesMask(Enchantments);
    Base::ClearChangesMask(Gems);
    Base::ClearChangesMask(Data);
    Base::ClearChangesMask(RecraftItemInfo);
    _changesMask.ResetAll();
}

void PersonalCraftingOrderCount::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(ProfessionID);
    data << uint32(Count);
}

void PersonalCraftingOrderCount::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 2);

    data.FlushBits();
    if (changesMask[0])
    {
        data << int32(ProfessionID);
    }
    if (changesMask[1])
    {
        data << uint32(Count);
    }
}

void PersonalCraftingOrderCount::ClearChangesMask()
{
    Base::ClearChangesMask(ProfessionID);
    Base::ClearChangesMask(Count);
    _changesMask.ResetAll();
}

void CategoryCooldownMod::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(SpellCategoryID);
    data << int32(ModCooldown);
}

void CategoryCooldownMod::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << int32(SpellCategoryID);
    data << int32(ModCooldown);
}

bool CategoryCooldownMod::operator==(CategoryCooldownMod const& right) const
{
    return SpellCategoryID == right.SpellCategoryID
        && ModCooldown == right.ModCooldown;
}

void WeeklySpellUse::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(SpellCategoryID);
    data << uint8(Uses);
}

void WeeklySpellUse::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << int32(SpellCategoryID);
    data << uint8(Uses);
}

bool WeeklySpellUse::operator==(WeeklySpellUse const& right) const
{
    return SpellCategoryID == right.SpellCategoryID
        && Uses == right.Uses;
}

void StablePetInfo::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << uint32(PetSlot);
    data << uint32(PetNumber);
    data << uint32(CreatureID);
    data << uint32(DisplayID);
    data << uint32(ExperienceLevel);
    data << uint8(PetFlags);
    data.WriteBits(Name->size(), 8);
    data.WriteString(Name);
    data.FlushBits();
}

void StablePetInfo::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 8);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << uint32(PetSlot);
        }
        if (changesMask[2])
        {
            data << uint32(PetNumber);
        }
        if (changesMask[3])
        {
            data << uint32(CreatureID);
        }
        if (changesMask[4])
        {
            data << uint32(DisplayID);
        }
        if (changesMask[5])
        {
            data << uint32(ExperienceLevel);
        }
        if (changesMask[7])
        {
            data << uint8(PetFlags);
        }
        if (changesMask[6])
        {
            data.WriteBits(Name->size(), 8);
            data.WriteString(Name);
        }
    }
    data.FlushBits();
}

void StablePetInfo::ClearChangesMask()
{
    Base::ClearChangesMask(PetSlot);
    Base::ClearChangesMask(PetNumber);
    Base::ClearChangesMask(CreatureID);
    Base::ClearChangesMask(DisplayID);
    Base::ClearChangesMask(ExperienceLevel);
    Base::ClearChangesMask(Name);
    Base::ClearChangesMask(PetFlags);
    _changesMask.ResetAll();
}

void StableInfo::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << uint32(Pets.size());
    data << StableMaster;
    for (uint32 i = 0; i < Pets.size(); ++i)
    {
        Pets[i].WriteCreate(data, owner, receiver);
    }
}

void StableInfo::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 3);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            if (!ignoreChangesMask)
                Pets.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Pets.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            for (uint32 i = 0; i < Pets.size(); ++i)
            {
                if (Pets.HasChanged(i) || ignoreChangesMask)
                {
                    Pets[i].WriteUpdate(data, ignoreChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[2])
        {
            data << StableMaster;
        }
    }
}

void StableInfo::ClearChangesMask()
{
    Base::ClearChangesMask(Pets);
    Base::ClearChangesMask(StableMaster);
    _changesMask.ResetAll();
}

void CollectableSourceTrackedData::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(TargetType);
    data << int32(TargetID);
    data << int32(CollectableSourceInfoID);
}

void CollectableSourceTrackedData::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 4);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(TargetType);
        }
        if (changesMask[2])
        {
            data << int32(TargetID);
        }
        if (changesMask[3])
        {
            data << int32(CollectableSourceInfoID);
        }
    }
}

void CollectableSourceTrackedData::ClearChangesMask()
{
    Base::ClearChangesMask(TargetType);
    Base::ClearChangesMask(TargetID);
    Base::ClearChangesMask(CollectableSourceInfoID);
    _changesMask.ResetAll();
}

void Research::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int16(ResearchProjectID);
}

void Research::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << int16(ResearchProjectID);
}

bool Research::operator==(Research const& right) const
{
    return ResearchProjectID == right.ResearchProjectID;
}

void ActivePlayerData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Player const* owner, Player const* receiver) const
{
    for (uint32 i = 0; i < 227; ++i)
    {
        data << InvSlots[i];
    }
    data << FarsightObject;
    data << SummonedBattlePetGUID;
    data << uint32(KnownTitles.size());
    data << uint64(Coinage);
    data << int32(XP);
    data << int32(NextLevelXP);
    data << int32(TrialXP);
    Skill->WriteCreate(data, owner, receiver);
    data << int32(CharacterPoints);
    data << int32(MaxTalentTiers);
    data << uint32(TrackCreatureMask);
    data << float(MainhandExpertise);
    data << float(OffhandExpertise);
    data << float(RangedExpertise);
    data << float(CombatRatingExpertise);
    data << float(BlockPercentage);
    data << float(DodgePercentage);
    data << float(DodgePercentageFromAttribute);
    data << float(ParryPercentage);
    data << float(ParryPercentageFromAttribute);
    data << float(CritPercentage);
    data << float(RangedCritPercentage);
    data << float(OffhandCritPercentage);
    data << float(SpellCritPercentage);
    data << int32(ShieldBlock);
    data << float(ShieldBlockCritPercentage);
    data << float(Mastery);
    data << float(Speed);
    data << float(Avoidance);
    data << float(Sturdiness);
    data << int32(Versatility);
    data << float(VersatilityBonus);
    data << float(PvpPowerDamage);
    data << float(PvpPowerHealing);
    for (uint32 i = 0; i < 9; ++i)
    {
        data << uint32(DataFlags[i].size());
        for (uint32 j = 0; j < DataFlags[i].size(); ++j)
        {
            data << uint64(DataFlags[i][j]);
        }
    }
    for (uint32 i = 0; i < 2; ++i)
    {
        RestInfo[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < 7; ++i)
    {
        data << int32(ModDamageDonePos[i]);
        data << int32(ModDamageDoneNeg[i]);
        data << float(ModDamageDonePercent[i]);
        data << float(ModHealingDonePercent[i]);
    }
    data << int32(ModHealingDonePos);
    data << float(ModHealingPercent);
    data << float(ModPeriodicHealingDonePercent);
    for (uint32 i = 0; i < 3; ++i)
    {
        data << float(WeaponDmgMultipliers[i]);
        data << float(WeaponAtkSpeedMultipliers[i]);
    }
    data << float(ModSpellPowerPercent);
    data << float(ModResiliencePercent);
    data << float(OverrideSpellPowerByAPPercent);
    data << float(OverrideAPBySpellPowerPercent);
    data << int32(ModTargetResistance);
    data << int32(ModTargetPhysicalResistance);
    data << uint32(LocalFlags);
    data << uint8(GrantableLevels);
    data << uint8(MultiActionBars);
    data << uint8(LifetimeMaxRank);
    data << uint8(NumRespecs);
    data << uint32(PvpMedals);
    for (uint32 i = 0; i < 12; ++i)
    {
        data << uint32(BuybackPrice[i]);
        data << int64(BuybackTimestamp[i]);
    }
    data << uint16(TodayHonorableKills);
    data << uint16(YesterdayHonorableKills);
    data << uint32(LifetimeHonorableKills);
    data << int32(WatchedFactionIndex);
    for (uint32 i = 0; i < 32; ++i)
    {
        data << int32(CombatRatings[i]);
    }
    data << uint32(PvpInfo.size());
    data << int32(MaxLevel);
    data << int32(ScalingPlayerLevelDelta);
    data << int32(MaxCreatureScalingLevel);
    for (uint32 i = 0; i < 4; ++i)
    {
        data << uint32(NoReagentCostMask[i]);
    }
    data << int32(PetSpellPower);
    for (uint32 i = 0; i < 2; ++i)
    {
        data << int32(ProfessionSkillLine[i]);
    }
    data << float(UiHitModifier);
    data << float(UiSpellHitModifier);
    data << int32(HomeRealmTimeOffset);
    data << float(ModPetHaste);
    data << int8(JailersTowerLevelMax);
    data << int8(JailersTowerLevel);
    data << uint8(LocalRegenFlags);
    data << uint8(AuraVision);
    data << uint8(NumBackpackSlots);
    data << int32(OverrideSpellsID);
    data << uint16(LootSpecID);
    data << uint32(OverrideZonePVPType);
    for (uint32 i = 0; i < 5; ++i)
    {
        data << uint32(BagSlotFlags[i]);
    }
    for (uint32 i = 0; i < 7; ++i)
    {
        data << uint32(BankBagSlotFlags[i]);
    }
    for (uint32 i = 0; i < 950; ++i)
    {
        data << uint64(QuestCompleted[i]);
    }
    data << int32(Honor);
    data << int32(HonorNextLevel);
    data << int32(PerksProgramCurrency);
    data << uint8(NumBankSlots);
    for (uint32 i = 0; i < 1; ++i)
    {
        data << uint32(ResearchSites[i].size());
        data << uint32(ResearchSiteProgress[i].size());
        data << uint32(Research[i].size());
        for (uint32 j = 0; j < ResearchSites[i].size(); ++j)
        {
            data << uint16(ResearchSites[i][j]);
        }
        for (uint32 j = 0; j < ResearchSiteProgress[i].size(); ++j)
        {
            data << uint32(ResearchSiteProgress[i][j]);
        }
        for (uint32 j = 0; j < Research[i].size(); ++j)
        {
            Research[i][j].WriteCreate(data, owner, receiver);
        }
    }
    data << uint32(DailyQuestsCompleted.size());
    data << uint32(AvailableQuestLineXQuestIDs.size());
    data << uint32(Heirlooms.size());
    data << uint32(HeirloomFlags.size());
    data << uint32(Toys.size());
    data << uint32(ToyFlags.size());
    data << uint32(Transmog.size());
    data << uint32(ConditionalTransmog.size());
    data << uint32(SelfResSpells.size());
    data << uint32(RuneforgePowers.size());
    data << uint32(TransmogIllusions.size());
    data << uint32(CharacterRestrictions.size());
    data << uint32(SpellPctModByLabel.size());
    data << uint32(SpellFlatModByLabel.size());
    data << uint32(MawPowers.size());
    data << uint32(MultiFloorExploration.size());
    data << uint32(RecipeProgression.size());
    data << uint32(ReplayedQuests.size());
    data << uint32(TaskQuests.size());
    data << uint32(DisabledSpells.size());
    data << int32(UiChromieTimeExpansionID);
    data << int32(TimerunningSeasonID);
    data << int32(TransportServerTime);
    data << uint32(WeeklyRewardsPeriodSinceOrigin);
    data << int16(DEBUGSoulbindConduitRank);
    data << uint32(TraitConfigs.size());
    data << uint32(ActiveCombatTraitConfigID);
    data << uint32(CraftingOrders.size());
    data << uint32(PersonalCraftingOrderCounts.size());
    data << uint32(CategoryCooldownMods.size());
    data << uint32(WeeklySpellUses.size());
    for (uint32 i = 0; i < 17; ++i)
    {
        data << float(ItemUpgradeHighWatermark[i]);
    }
    data << int32(ItemUpgradeHighOnehandWeaponItemID);
    data << int32(ItemUpgradeHighFingerItemID);
    data << float(ItemUpgradeHighFingerWatermark);
    data << int32(ItemUpgradeHighTrinketItemID);
    data << float(ItemUpgradeHighTrinketWatermark);
    data << uint64(LootHistoryInstanceID);
    data << uint32(TrackedCollectableSources.size());
    data << uint8(RequiredMountCapabilityFlags);
    for (uint32 i = 0; i < KnownTitles.size(); ++i)
    {
        data << uint64(KnownTitles[i]);
    }
    for (uint32 i = 0; i < DailyQuestsCompleted.size(); ++i)
    {
        data << int32(DailyQuestsCompleted[i]);
    }
    for (uint32 i = 0; i < AvailableQuestLineXQuestIDs.size(); ++i)
    {
        data << int32(AvailableQuestLineXQuestIDs[i]);
    }
    for (uint32 i = 0; i < Heirlooms.size(); ++i)
    {
        data << int32(Heirlooms[i]);
    }
    for (uint32 i = 0; i < HeirloomFlags.size(); ++i)
    {
        data << uint32(HeirloomFlags[i]);
    }
    for (uint32 i = 0; i < Toys.size(); ++i)
    {
        data << int32(Toys[i]);
    }
    for (uint32 i = 0; i < ToyFlags.size(); ++i)
    {
        data << uint32(ToyFlags[i]);
    }
    for (uint32 i = 0; i < Transmog.size(); ++i)
    {
        data << uint32(Transmog[i]);
    }
    for (uint32 i = 0; i < ConditionalTransmog.size(); ++i)
    {
        data << int32(ConditionalTransmog[i]);
    }
    for (uint32 i = 0; i < SelfResSpells.size(); ++i)
    {
        data << int32(SelfResSpells[i]);
    }
    for (uint32 i = 0; i < RuneforgePowers.size(); ++i)
    {
        data << uint32(RuneforgePowers[i]);
    }
    for (uint32 i = 0; i < TransmogIllusions.size(); ++i)
    {
        data << uint32(TransmogIllusions[i]);
    }
    for (uint32 i = 0; i < SpellPctModByLabel.size(); ++i)
    {
        SpellPctModByLabel[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < SpellFlatModByLabel.size(); ++i)
    {
        SpellFlatModByLabel[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < MawPowers.size(); ++i)
    {
        MawPowers[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < MultiFloorExploration.size(); ++i)
    {
        MultiFloorExploration[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < RecipeProgression.size(); ++i)
    {
        RecipeProgression[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < ReplayedQuests.size(); ++i)
    {
        ReplayedQuests[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < TaskQuests.size(); ++i)
    {
        TaskQuests[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < DisabledSpells.size(); ++i)
    {
        data << int32(DisabledSpells[i]);
    }
    for (uint32 i = 0; i < PersonalCraftingOrderCounts.size(); ++i)
    {
        PersonalCraftingOrderCounts[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < CategoryCooldownMods.size(); ++i)
    {
        CategoryCooldownMods[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < WeeklySpellUses.size(); ++i)
    {
        WeeklySpellUses[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < TrackedCollectableSources.size(); ++i)
    {
        TrackedCollectableSources[i].WriteCreate(data, owner, receiver);
    }
    data.FlushBits();
    data.WriteBit(BackpackAutoSortDisabled);
    data.WriteBit(BackpackSellJunkDisabled);
    data.WriteBit(BankAutoSortDisabled);
    data.WriteBit(SortBagsRightToLeft);
    data.WriteBit(InsertItemsLeftToRight);
    data.WriteBit(HasPerksProgramPendingReward);
    data.WriteBits(QuestSession.has_value(), 1);
    data.WriteBits(PetStable.has_value(), 1);
    data.FlushBits();
    ResearchHistory->WriteCreate(data, owner, receiver);
    if (QuestSession.has_value())
    {
        QuestSession->WriteCreate(data, owner, receiver);
    }
    data << FrozenPerksVendorItem;
    Field_1410->WriteCreate(data, owner, receiver);
    data << DungeonScore;
    for (uint32 i = 0; i < PvpInfo.size(); ++i)
    {
        PvpInfo[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < CharacterRestrictions.size(); ++i)
    {
        CharacterRestrictions[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < TraitConfigs.size(); ++i)
    {
        TraitConfigs[i].WriteCreate(data, owner, receiver);
    }
    for (uint32 i = 0; i < CraftingOrders.size(); ++i)
    {
        CraftingOrders[i].WriteCreate(data, owner, receiver);
    }
    if (PetStable.has_value())
    {
        PetStable->WriteCreate(data, owner, receiver);
    }
    data.FlushBits();
}

void ActivePlayerData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Player const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void ActivePlayerData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Player const* owner, Player const* receiver) const
{
    for (uint32 i = 0; i < 1; ++i)
        data << uint32(changesMask.GetBlocksMask(i));
    data.WriteBits(changesMask.GetBlocksMask(1), 14);
    for (uint32 i = 0; i < 46; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBit(BackpackAutoSortDisabled);
        }
        if (changesMask[2])
        {
            data.WriteBit(BackpackSellJunkDisabled);
        }
        if (changesMask[3])
        {
            data.WriteBit(BankAutoSortDisabled);
        }
        if (changesMask[4])
        {
            data.WriteBit(SortBagsRightToLeft);
        }
        if (changesMask[5])
        {
            data.WriteBit(InsertItemsLeftToRight);
        }
        if (changesMask[6])
        {
            data.WriteBit(HasPerksProgramPendingReward);
        }
        if (changesMask[7])
        {
            if (!ignoreNestedChangesMask)
                KnownTitles.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(KnownTitles.size(), data);
        }
    }
    if (changesMask[36])
    {
        for (uint32 i = 0; i < 9; ++i)
        {
            if (changesMask[37])
            {
                if (!ignoreNestedChangesMask)
                    DataFlags[i].WriteUpdateMask(data);
                else
                    WriteCompleteDynamicFieldUpdateMask(DataFlags[i].size(), data);
            }
        }
    }
    if (changesMask[36])
    {
        for (uint32 i = 0; i < 9; ++i)
        {
            if (changesMask[37])
            {
                for (uint32 j = 0; j < DataFlags[i].size(); ++j)
                {
                    if (DataFlags[i].HasChanged(j) || ignoreNestedChangesMask)
                    {
                        data << uint64(DataFlags[i][j]);
                    }
                }
            }
        }
    }
    if (changesMask[0])
    {
        if (changesMask[8])
        {
            if (!ignoreNestedChangesMask)
                PvpInfo.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(PvpInfo.size(), data);
        }
    }
    if (changesMask[38])
    {
        for (uint32 i = 0; i < 1; ++i)
        {
            if (changesMask[39])
            {
                if (!ignoreNestedChangesMask)
                    ResearchSites[i].WriteUpdateMask(data);
                else
                    WriteCompleteDynamicFieldUpdateMask(ResearchSites[i].size(), data);
            }
        }
    }
    if (changesMask[40])
    {
        for (uint32 i = 0; i < 1; ++i)
        {
            if (changesMask[41])
            {
                if (!ignoreNestedChangesMask)
                    ResearchSiteProgress[i].WriteUpdateMask(data);
                else
                    WriteCompleteDynamicFieldUpdateMask(ResearchSiteProgress[i].size(), data);
            }
        }
    }
    if (changesMask[42])
    {
        for (uint32 i = 0; i < 1; ++i)
        {
            if (changesMask[43])
            {
                if (!ignoreNestedChangesMask)
                    Research[i].WriteUpdateMask(data);
                else
                    WriteCompleteDynamicFieldUpdateMask(Research[i].size(), data);
            }
        }
    }
    if (changesMask[38])
    {
        for (uint32 i = 0; i < 1; ++i)
        {
            if (changesMask[39])
            {
                for (uint32 j = 0; j < ResearchSites[i].size(); ++j)
                {
                    if (ResearchSites[i].HasChanged(j) || ignoreNestedChangesMask)
                    {
                        data << uint16(ResearchSites[i][j]);
                    }
                }
            }
        }
    }
    if (changesMask[40])
    {
        for (uint32 i = 0; i < 1; ++i)
        {
            if (changesMask[41])
            {
                for (uint32 j = 0; j < ResearchSiteProgress[i].size(); ++j)
                {
                    if (ResearchSiteProgress[i].HasChanged(j) || ignoreNestedChangesMask)
                    {
                        data << uint32(ResearchSiteProgress[i][j]);
                    }
                }
            }
        }
    }
    if (changesMask[42])
    {
        for (uint32 i = 0; i < 1; ++i)
        {
            if (changesMask[43])
            {
                for (uint32 j = 0; j < Research[i].size(); ++j)
                {
                    if (Research[i].HasChanged(j) || ignoreNestedChangesMask)
                    {
                        Research[i][j].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                    }
                }
            }
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[9])
        {
            if (!ignoreNestedChangesMask)
                DailyQuestsCompleted.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(DailyQuestsCompleted.size(), data);
        }
        if (changesMask[10])
        {
            if (!ignoreNestedChangesMask)
                AvailableQuestLineXQuestIDs.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(AvailableQuestLineXQuestIDs.size(), data);
        }
        if (changesMask[11])
        {
            if (!ignoreNestedChangesMask)
                Heirlooms.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Heirlooms.size(), data);
        }
        if (changesMask[12])
        {
            if (!ignoreNestedChangesMask)
                HeirloomFlags.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(HeirloomFlags.size(), data);
        }
        if (changesMask[13])
        {
            if (!ignoreNestedChangesMask)
                Toys.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Toys.size(), data);
        }
        if (changesMask[14])
        {
            if (!ignoreNestedChangesMask)
                ToyFlags.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(ToyFlags.size(), data);
        }
        if (changesMask[15])
        {
            if (!ignoreNestedChangesMask)
                Transmog.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Transmog.size(), data);
        }
        if (changesMask[16])
        {
            if (!ignoreNestedChangesMask)
                ConditionalTransmog.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(ConditionalTransmog.size(), data);
        }
        if (changesMask[17])
        {
            if (!ignoreNestedChangesMask)
                SelfResSpells.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(SelfResSpells.size(), data);
        }
        if (changesMask[18])
        {
            if (!ignoreNestedChangesMask)
                RuneforgePowers.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(RuneforgePowers.size(), data);
        }
        if (changesMask[19])
        {
            if (!ignoreNestedChangesMask)
                TransmogIllusions.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(TransmogIllusions.size(), data);
        }
        if (changesMask[20])
        {
            if (!ignoreNestedChangesMask)
                CharacterRestrictions.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(CharacterRestrictions.size(), data);
        }
        if (changesMask[21])
        {
            if (!ignoreNestedChangesMask)
                SpellPctModByLabel.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(SpellPctModByLabel.size(), data);
        }
        if (changesMask[22])
        {
            if (!ignoreNestedChangesMask)
                SpellFlatModByLabel.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(SpellFlatModByLabel.size(), data);
        }
        if (changesMask[23])
        {
            if (!ignoreNestedChangesMask)
                MawPowers.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(MawPowers.size(), data);
        }
        if (changesMask[24])
        {
            if (!ignoreNestedChangesMask)
                MultiFloorExploration.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(MultiFloorExploration.size(), data);
        }
        if (changesMask[25])
        {
            if (!ignoreNestedChangesMask)
                RecipeProgression.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(RecipeProgression.size(), data);
        }
        if (changesMask[26])
        {
            if (!ignoreNestedChangesMask)
                ReplayedQuests.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(ReplayedQuests.size(), data);
        }
        if (changesMask[27])
        {
            if (!ignoreNestedChangesMask)
                TaskQuests.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(TaskQuests.size(), data);
        }
        if (changesMask[28])
        {
            if (!ignoreNestedChangesMask)
                DisabledSpells.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(DisabledSpells.size(), data);
        }
        if (changesMask[29])
        {
            if (!ignoreNestedChangesMask)
                TraitConfigs.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(TraitConfigs.size(), data);
        }
        if (changesMask[30])
        {
            if (!ignoreNestedChangesMask)
                CraftingOrders.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(CraftingOrders.size(), data);
        }
        if (changesMask[31])
        {
            if (!ignoreNestedChangesMask)
                PersonalCraftingOrderCounts.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(PersonalCraftingOrderCounts.size(), data);
        }
    }
    if (changesMask[32])
    {
        if (changesMask[33])
        {
            if (!ignoreNestedChangesMask)
                CategoryCooldownMods.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(CategoryCooldownMods.size(), data);
        }
        if (changesMask[34])
        {
            if (!ignoreNestedChangesMask)
                WeeklySpellUses.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(WeeklySpellUses.size(), data);
        }
        if (changesMask[35])
        {
            if (!ignoreNestedChangesMask)
                TrackedCollectableSources.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(TrackedCollectableSources.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[7])
        {
            for (uint32 i = 0; i < KnownTitles.size(); ++i)
            {
                if (KnownTitles.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << uint64(KnownTitles[i]);
                }
            }
        }
        if (changesMask[9])
        {
            for (uint32 i = 0; i < DailyQuestsCompleted.size(); ++i)
            {
                if (DailyQuestsCompleted.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(DailyQuestsCompleted[i]);
                }
            }
        }
        if (changesMask[10])
        {
            for (uint32 i = 0; i < AvailableQuestLineXQuestIDs.size(); ++i)
            {
                if (AvailableQuestLineXQuestIDs.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(AvailableQuestLineXQuestIDs[i]);
                }
            }
        }
        if (changesMask[11])
        {
            for (uint32 i = 0; i < Heirlooms.size(); ++i)
            {
                if (Heirlooms.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(Heirlooms[i]);
                }
            }
        }
        if (changesMask[12])
        {
            for (uint32 i = 0; i < HeirloomFlags.size(); ++i)
            {
                if (HeirloomFlags.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << uint32(HeirloomFlags[i]);
                }
            }
        }
        if (changesMask[13])
        {
            for (uint32 i = 0; i < Toys.size(); ++i)
            {
                if (Toys.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(Toys[i]);
                }
            }
        }
        if (changesMask[14])
        {
            for (uint32 i = 0; i < ToyFlags.size(); ++i)
            {
                if (ToyFlags.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << uint32(ToyFlags[i]);
                }
            }
        }
        if (changesMask[15])
        {
            for (uint32 i = 0; i < Transmog.size(); ++i)
            {
                if (Transmog.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << uint32(Transmog[i]);
                }
            }
        }
        if (changesMask[16])
        {
            for (uint32 i = 0; i < ConditionalTransmog.size(); ++i)
            {
                if (ConditionalTransmog.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(ConditionalTransmog[i]);
                }
            }
        }
        if (changesMask[17])
        {
            for (uint32 i = 0; i < SelfResSpells.size(); ++i)
            {
                if (SelfResSpells.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(SelfResSpells[i]);
                }
            }
        }
        if (changesMask[18])
        {
            for (uint32 i = 0; i < RuneforgePowers.size(); ++i)
            {
                if (RuneforgePowers.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << uint32(RuneforgePowers[i]);
                }
            }
        }
        if (changesMask[19])
        {
            for (uint32 i = 0; i < TransmogIllusions.size(); ++i)
            {
                if (TransmogIllusions.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << uint32(TransmogIllusions[i]);
                }
            }
        }
        if (changesMask[21])
        {
            for (uint32 i = 0; i < SpellPctModByLabel.size(); ++i)
            {
                if (SpellPctModByLabel.HasChanged(i) || ignoreNestedChangesMask)
                {
                    SpellPctModByLabel[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[22])
        {
            for (uint32 i = 0; i < SpellFlatModByLabel.size(); ++i)
            {
                if (SpellFlatModByLabel.HasChanged(i) || ignoreNestedChangesMask)
                {
                    SpellFlatModByLabel[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[23])
        {
            for (uint32 i = 0; i < MawPowers.size(); ++i)
            {
                if (MawPowers.HasChanged(i) || ignoreNestedChangesMask)
                {
                    MawPowers[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[24])
        {
            for (uint32 i = 0; i < MultiFloorExploration.size(); ++i)
            {
                if (MultiFloorExploration.HasChanged(i) || ignoreNestedChangesMask)
                {
                    MultiFloorExploration[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[25])
        {
            for (uint32 i = 0; i < RecipeProgression.size(); ++i)
            {
                if (RecipeProgression.HasChanged(i) || ignoreNestedChangesMask)
                {
                    RecipeProgression[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[26])
        {
            for (uint32 i = 0; i < ReplayedQuests.size(); ++i)
            {
                if (ReplayedQuests.HasChanged(i) || ignoreNestedChangesMask)
                {
                    ReplayedQuests[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[27])
        {
            for (uint32 i = 0; i < TaskQuests.size(); ++i)
            {
                if (TaskQuests.HasChanged(i) || ignoreNestedChangesMask)
                {
                    TaskQuests[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[28])
        {
            for (uint32 i = 0; i < DisabledSpells.size(); ++i)
            {
                if (DisabledSpells.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(DisabledSpells[i]);
                }
            }
        }
        if (changesMask[31])
        {
            for (uint32 i = 0; i < PersonalCraftingOrderCounts.size(); ++i)
            {
                if (PersonalCraftingOrderCounts.HasChanged(i) || ignoreNestedChangesMask)
                {
                    PersonalCraftingOrderCounts[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
    }
    if (changesMask[32])
    {
        if (changesMask[33])
        {
            for (uint32 i = 0; i < CategoryCooldownMods.size(); ++i)
            {
                if (CategoryCooldownMods.HasChanged(i) || ignoreNestedChangesMask)
                {
                    CategoryCooldownMods[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[34])
        {
            for (uint32 i = 0; i < WeeklySpellUses.size(); ++i)
            {
                if (WeeklySpellUses.HasChanged(i) || ignoreNestedChangesMask)
                {
                    WeeklySpellUses[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[35])
        {
            for (uint32 i = 0; i < TrackedCollectableSources.size(); ++i)
            {
                if (TrackedCollectableSources.HasChanged(i) || ignoreNestedChangesMask)
                {
                    TrackedCollectableSources[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
    }
    if (changesMask[0])
    {
        if (changesMask[8])
        {
            for (uint32 i = 0; i < PvpInfo.size(); ++i)
            {
                if (PvpInfo.HasChanged(i) || ignoreNestedChangesMask)
                {
                    PvpInfo[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[20])
        {
            for (uint32 i = 0; i < CharacterRestrictions.size(); ++i)
            {
                if (CharacterRestrictions.HasChanged(i) || ignoreNestedChangesMask)
                {
                    CharacterRestrictions[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[29])
        {
            for (uint32 i = 0; i < TraitConfigs.size(); ++i)
            {
                if (TraitConfigs.HasChanged(i) || ignoreNestedChangesMask)
                {
                    TraitConfigs[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[30])
        {
            for (uint32 i = 0; i < CraftingOrders.size(); ++i)
            {
                if (CraftingOrders.HasChanged(i) || ignoreNestedChangesMask)
                {
                    CraftingOrders[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
    }
    if (changesMask[32])
    {
        if (changesMask[44])
        {
            data << FarsightObject;
        }
        if (changesMask[45])
        {
            data << SummonedBattlePetGUID;
        }
        if (changesMask[46])
        {
            data << uint64(Coinage);
        }
        if (changesMask[47])
        {
            data << int32(XP);
        }
        if (changesMask[48])
        {
            data << int32(NextLevelXP);
        }
        if (changesMask[49])
        {
            data << int32(TrialXP);
        }
        if (changesMask[50])
        {
            Skill->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[51])
        {
            data << int32(CharacterPoints);
        }
        if (changesMask[52])
        {
            data << int32(MaxTalentTiers);
        }
        if (changesMask[53])
        {
            data << uint32(TrackCreatureMask);
        }
        if (changesMask[54])
        {
            data << float(MainhandExpertise);
        }
        if (changesMask[55])
        {
            data << float(OffhandExpertise);
        }
        if (changesMask[56])
        {
            data << float(RangedExpertise);
        }
        if (changesMask[57])
        {
            data << float(CombatRatingExpertise);
        }
        if (changesMask[58])
        {
            data << float(BlockPercentage);
        }
        if (changesMask[59])
        {
            data << float(DodgePercentage);
        }
        if (changesMask[60])
        {
            data << float(DodgePercentageFromAttribute);
        }
        if (changesMask[61])
        {
            data << float(ParryPercentage);
        }
        if (changesMask[62])
        {
            data << float(ParryPercentageFromAttribute);
        }
        if (changesMask[63])
        {
            data << float(CritPercentage);
        }
        if (changesMask[64])
        {
            data << float(RangedCritPercentage);
        }
        if (changesMask[65])
        {
            data << float(OffhandCritPercentage);
        }
        if (changesMask[66])
        {
            data << float(SpellCritPercentage);
        }
        if (changesMask[67])
        {
            data << int32(ShieldBlock);
        }
        if (changesMask[68])
        {
            data << float(ShieldBlockCritPercentage);
        }
        if (changesMask[69])
        {
            data << float(Mastery);
        }
        if (changesMask[70])
        {
            data << float(Speed);
        }
        if (changesMask[71])
        {
            data << float(Avoidance);
        }
    }
    if (changesMask[72])
    {
        if (changesMask[73])
        {
            data << float(Sturdiness);
        }
        if (changesMask[74])
        {
            data << int32(Versatility);
        }
        if (changesMask[75])
        {
            data << float(VersatilityBonus);
        }
        if (changesMask[76])
        {
            data << float(PvpPowerDamage);
        }
        if (changesMask[77])
        {
            data << float(PvpPowerHealing);
        }
        if (changesMask[78])
        {
            data << int32(ModHealingDonePos);
        }
        if (changesMask[79])
        {
            data << float(ModHealingPercent);
        }
        if (changesMask[80])
        {
            data << float(ModPeriodicHealingDonePercent);
        }
        if (changesMask[81])
        {
            data << float(ModSpellPowerPercent);
        }
        if (changesMask[82])
        {
            data << float(ModResiliencePercent);
        }
        if (changesMask[83])
        {
            data << float(OverrideSpellPowerByAPPercent);
        }
        if (changesMask[84])
        {
            data << float(OverrideAPBySpellPowerPercent);
        }
        if (changesMask[85])
        {
            data << int32(ModTargetResistance);
        }
        if (changesMask[86])
        {
            data << int32(ModTargetPhysicalResistance);
        }
        if (changesMask[87])
        {
            data << uint32(LocalFlags);
        }
        if (changesMask[88])
        {
            data << uint8(GrantableLevels);
        }
        if (changesMask[89])
        {
            data << uint8(MultiActionBars);
        }
        if (changesMask[90])
        {
            data << uint8(LifetimeMaxRank);
        }
        if (changesMask[91])
        {
            data << uint8(NumRespecs);
        }
        if (changesMask[92])
        {
            data << uint32(PvpMedals);
        }
        if (changesMask[93])
        {
            data << uint16(TodayHonorableKills);
        }
        if (changesMask[94])
        {
            data << uint16(YesterdayHonorableKills);
        }
        if (changesMask[95])
        {
            data << uint32(LifetimeHonorableKills);
        }
        if (changesMask[96])
        {
            data << int32(WatchedFactionIndex);
        }
        if (changesMask[97])
        {
            data << int32(MaxLevel);
        }
        if (changesMask[98])
        {
            data << int32(ScalingPlayerLevelDelta);
        }
        if (changesMask[99])
        {
            data << int32(MaxCreatureScalingLevel);
        }
        if (changesMask[100])
        {
            data << int32(PetSpellPower);
        }
        if (changesMask[101])
        {
            data << float(UiHitModifier);
        }
        if (changesMask[102])
        {
            data << float(UiSpellHitModifier);
        }
        if (changesMask[103])
        {
            data << int32(HomeRealmTimeOffset);
        }
    }
    if (changesMask[104])
    {
        if (changesMask[105])
        {
            data << float(ModPetHaste);
        }
        if (changesMask[106])
        {
            data << int8(JailersTowerLevelMax);
        }
        if (changesMask[107])
        {
            data << int8(JailersTowerLevel);
        }
        if (changesMask[108])
        {
            data << uint8(LocalRegenFlags);
        }
        if (changesMask[109])
        {
            data << uint8(AuraVision);
        }
        if (changesMask[110])
        {
            data << uint8(NumBackpackSlots);
        }
        if (changesMask[111])
        {
            data << int32(OverrideSpellsID);
        }
        if (changesMask[112])
        {
            data << uint16(LootSpecID);
        }
        if (changesMask[113])
        {
            data << uint32(OverrideZonePVPType);
        }
        if (changesMask[114])
        {
            data << int32(Honor);
        }
        if (changesMask[115])
        {
            data << int32(HonorNextLevel);
        }
        if (changesMask[116])
        {
            data << int32(PerksProgramCurrency);
        }
        if (changesMask[117])
        {
            data << uint8(NumBankSlots);
        }
        if (changesMask[122])
        {
            data << int32(UiChromieTimeExpansionID);
        }
        if (changesMask[123])
        {
            data << int32(TimerunningSeasonID);
        }
        if (changesMask[124])
        {
            data << int32(TransportServerTime);
        }
        if (changesMask[125])
        {
            data << uint32(WeeklyRewardsPeriodSinceOrigin);
        }
        if (changesMask[126])
        {
            data << int16(DEBUGSoulbindConduitRank);
        }
        if (changesMask[128])
        {
            data << uint32(ActiveCombatTraitConfigID);
        }
        if (changesMask[129])
        {
            data << int32(ItemUpgradeHighOnehandWeaponItemID);
        }
        if (changesMask[130])
        {
            data << int32(ItemUpgradeHighFingerItemID);
        }
        if (changesMask[131])
        {
            data << float(ItemUpgradeHighFingerWatermark);
        }
        if (changesMask[132])
        {
            data << int32(ItemUpgradeHighTrinketItemID);
        }
        if (changesMask[133])
        {
            data << float(ItemUpgradeHighTrinketWatermark);
        }
        if (changesMask[134])
        {
            data << uint64(LootHistoryInstanceID);
        }
    }
    if (changesMask[136])
    {
        if (changesMask[137])
        {
            data << uint8(RequiredMountCapabilityFlags);
        }
    }
    if (changesMask[104])
    {
        data.WriteBits(QuestSession.has_value(), 1);
        data.WriteBits(PetStable.has_value(), 1);
    }
    data.FlushBits();
    if (changesMask[104])
    {
        if (changesMask[118])
        {
            ResearchHistory->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[120])
        {
            if (QuestSession.has_value())
            {
                QuestSession->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
        if (changesMask[119])
        {
            data << FrozenPerksVendorItem;
        }
        if (changesMask[121])
        {
            Field_1410->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[127])
        {
            data << DungeonScore;
        }
        if (changesMask[135])
        {
            if (PetStable.has_value())
            {
                PetStable->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    if (changesMask[138])
    {
        for (uint32 i = 0; i < 227; ++i)
        {
            if (changesMask[139 + i])
            {
                data << InvSlots[i];
            }
        }
    }
    if (changesMask[366])
    {
        for (uint32 i = 0; i < 2; ++i)
        {
            if (changesMask[367 + i])
            {
                RestInfo[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    if (changesMask[369])
    {
        for (uint32 i = 0; i < 7; ++i)
        {
            if (changesMask[370 + i])
            {
                data << int32(ModDamageDonePos[i]);
            }
            if (changesMask[377 + i])
            {
                data << int32(ModDamageDoneNeg[i]);
            }
            if (changesMask[384 + i])
            {
                data << float(ModDamageDonePercent[i]);
            }
            if (changesMask[391 + i])
            {
                data << float(ModHealingDonePercent[i]);
            }
        }
    }
    if (changesMask[398])
    {
        for (uint32 i = 0; i < 3; ++i)
        {
            if (changesMask[399 + i])
            {
                data << float(WeaponDmgMultipliers[i]);
            }
            if (changesMask[402 + i])
            {
                data << float(WeaponAtkSpeedMultipliers[i]);
            }
        }
    }
    if (changesMask[405])
    {
        for (uint32 i = 0; i < 12; ++i)
        {
            if (changesMask[406 + i])
            {
                data << uint32(BuybackPrice[i]);
            }
            if (changesMask[418 + i])
            {
                data << int64(BuybackTimestamp[i]);
            }
        }
    }
    if (changesMask[430])
    {
        for (uint32 i = 0; i < 32; ++i)
        {
            if (changesMask[431 + i])
            {
                data << int32(CombatRatings[i]);
            }
        }
    }
    if (changesMask[463])
    {
        for (uint32 i = 0; i < 4; ++i)
        {
            if (changesMask[464 + i])
            {
                data << uint32(NoReagentCostMask[i]);
            }
        }
    }
    if (changesMask[468])
    {
        for (uint32 i = 0; i < 2; ++i)
        {
            if (changesMask[469 + i])
            {
                data << int32(ProfessionSkillLine[i]);
            }
        }
    }
    if (changesMask[471])
    {
        for (uint32 i = 0; i < 5; ++i)
        {
            if (changesMask[472 + i])
            {
                data << uint32(BagSlotFlags[i]);
            }
        }
    }
    if (changesMask[477])
    {
        for (uint32 i = 0; i < 7; ++i)
        {
            if (changesMask[478 + i])
            {
                data << uint32(BankBagSlotFlags[i]);
            }
        }
    }
    if (changesMask[485])
    {
        for (uint32 i = 0; i < 950; ++i)
        {
            if (changesMask[486 + i])
            {
                data << uint64(QuestCompleted[i]);
            }
        }
    }
    if (changesMask[1436])
    {
        for (uint32 i = 0; i < 17; ++i)
        {
            if (changesMask[1437 + i])
            {
                data << float(ItemUpgradeHighWatermark[i]);
            }
        }
    }
    data.FlushBits();
}

void ActivePlayerData::ClearChangesMask()
{
    Base::ClearChangesMask(BackpackAutoSortDisabled);
    Base::ClearChangesMask(BackpackSellJunkDisabled);
    Base::ClearChangesMask(BankAutoSortDisabled);
    Base::ClearChangesMask(SortBagsRightToLeft);
    Base::ClearChangesMask(InsertItemsLeftToRight);
    Base::ClearChangesMask(HasPerksProgramPendingReward);
    Base::ClearChangesMask(DataFlags);
    Base::ClearChangesMask(ResearchSites);
    Base::ClearChangesMask(ResearchSiteProgress);
    Base::ClearChangesMask(Research);
    Base::ClearChangesMask(KnownTitles);
    Base::ClearChangesMask(DailyQuestsCompleted);
    Base::ClearChangesMask(AvailableQuestLineXQuestIDs);
    Base::ClearChangesMask(Heirlooms);
    Base::ClearChangesMask(HeirloomFlags);
    Base::ClearChangesMask(Toys);
    Base::ClearChangesMask(ToyFlags);
    Base::ClearChangesMask(Transmog);
    Base::ClearChangesMask(ConditionalTransmog);
    Base::ClearChangesMask(SelfResSpells);
    Base::ClearChangesMask(RuneforgePowers);
    Base::ClearChangesMask(TransmogIllusions);
    Base::ClearChangesMask(SpellPctModByLabel);
    Base::ClearChangesMask(SpellFlatModByLabel);
    Base::ClearChangesMask(MawPowers);
    Base::ClearChangesMask(MultiFloorExploration);
    Base::ClearChangesMask(RecipeProgression);
    Base::ClearChangesMask(ReplayedQuests);
    Base::ClearChangesMask(TaskQuests);
    Base::ClearChangesMask(DisabledSpells);
    Base::ClearChangesMask(PersonalCraftingOrderCounts);
    Base::ClearChangesMask(CategoryCooldownMods);
    Base::ClearChangesMask(WeeklySpellUses);
    Base::ClearChangesMask(TrackedCollectableSources);
    Base::ClearChangesMask(PvpInfo);
    Base::ClearChangesMask(CharacterRestrictions);
    Base::ClearChangesMask(TraitConfigs);
    Base::ClearChangesMask(CraftingOrders);
    Base::ClearChangesMask(FarsightObject);
    Base::ClearChangesMask(SummonedBattlePetGUID);
    Base::ClearChangesMask(Coinage);
    Base::ClearChangesMask(XP);
    Base::ClearChangesMask(NextLevelXP);
    Base::ClearChangesMask(TrialXP);
    Base::ClearChangesMask(Skill);
    Base::ClearChangesMask(CharacterPoints);
    Base::ClearChangesMask(MaxTalentTiers);
    Base::ClearChangesMask(TrackCreatureMask);
    Base::ClearChangesMask(MainhandExpertise);
    Base::ClearChangesMask(OffhandExpertise);
    Base::ClearChangesMask(RangedExpertise);
    Base::ClearChangesMask(CombatRatingExpertise);
    Base::ClearChangesMask(BlockPercentage);
    Base::ClearChangesMask(DodgePercentage);
    Base::ClearChangesMask(DodgePercentageFromAttribute);
    Base::ClearChangesMask(ParryPercentage);
    Base::ClearChangesMask(ParryPercentageFromAttribute);
    Base::ClearChangesMask(CritPercentage);
    Base::ClearChangesMask(RangedCritPercentage);
    Base::ClearChangesMask(OffhandCritPercentage);
    Base::ClearChangesMask(SpellCritPercentage);
    Base::ClearChangesMask(ShieldBlock);
    Base::ClearChangesMask(ShieldBlockCritPercentage);
    Base::ClearChangesMask(Mastery);
    Base::ClearChangesMask(Speed);
    Base::ClearChangesMask(Avoidance);
    Base::ClearChangesMask(Sturdiness);
    Base::ClearChangesMask(Versatility);
    Base::ClearChangesMask(VersatilityBonus);
    Base::ClearChangesMask(PvpPowerDamage);
    Base::ClearChangesMask(PvpPowerHealing);
    Base::ClearChangesMask(ModHealingDonePos);
    Base::ClearChangesMask(ModHealingPercent);
    Base::ClearChangesMask(ModPeriodicHealingDonePercent);
    Base::ClearChangesMask(ModSpellPowerPercent);
    Base::ClearChangesMask(ModResiliencePercent);
    Base::ClearChangesMask(OverrideSpellPowerByAPPercent);
    Base::ClearChangesMask(OverrideAPBySpellPowerPercent);
    Base::ClearChangesMask(ModTargetResistance);
    Base::ClearChangesMask(ModTargetPhysicalResistance);
    Base::ClearChangesMask(LocalFlags);
    Base::ClearChangesMask(GrantableLevels);
    Base::ClearChangesMask(MultiActionBars);
    Base::ClearChangesMask(LifetimeMaxRank);
    Base::ClearChangesMask(NumRespecs);
    Base::ClearChangesMask(PvpMedals);
    Base::ClearChangesMask(TodayHonorableKills);
    Base::ClearChangesMask(YesterdayHonorableKills);
    Base::ClearChangesMask(LifetimeHonorableKills);
    Base::ClearChangesMask(WatchedFactionIndex);
    Base::ClearChangesMask(MaxLevel);
    Base::ClearChangesMask(ScalingPlayerLevelDelta);
    Base::ClearChangesMask(MaxCreatureScalingLevel);
    Base::ClearChangesMask(PetSpellPower);
    Base::ClearChangesMask(UiHitModifier);
    Base::ClearChangesMask(UiSpellHitModifier);
    Base::ClearChangesMask(HomeRealmTimeOffset);
    Base::ClearChangesMask(ModPetHaste);
    Base::ClearChangesMask(JailersTowerLevelMax);
    Base::ClearChangesMask(JailersTowerLevel);
    Base::ClearChangesMask(LocalRegenFlags);
    Base::ClearChangesMask(AuraVision);
    Base::ClearChangesMask(NumBackpackSlots);
    Base::ClearChangesMask(OverrideSpellsID);
    Base::ClearChangesMask(LootSpecID);
    Base::ClearChangesMask(OverrideZonePVPType);
    Base::ClearChangesMask(Honor);
    Base::ClearChangesMask(HonorNextLevel);
    Base::ClearChangesMask(PerksProgramCurrency);
    Base::ClearChangesMask(NumBankSlots);
    Base::ClearChangesMask(ResearchHistory);
    Base::ClearChangesMask(FrozenPerksVendorItem);
    Base::ClearChangesMask(Field_1410);
    Base::ClearChangesMask(QuestSession);
    Base::ClearChangesMask(UiChromieTimeExpansionID);
    Base::ClearChangesMask(TimerunningSeasonID);
    Base::ClearChangesMask(TransportServerTime);
    Base::ClearChangesMask(WeeklyRewardsPeriodSinceOrigin);
    Base::ClearChangesMask(DEBUGSoulbindConduitRank);
    Base::ClearChangesMask(DungeonScore);
    Base::ClearChangesMask(ActiveCombatTraitConfigID);
    Base::ClearChangesMask(ItemUpgradeHighOnehandWeaponItemID);
    Base::ClearChangesMask(ItemUpgradeHighFingerItemID);
    Base::ClearChangesMask(ItemUpgradeHighFingerWatermark);
    Base::ClearChangesMask(ItemUpgradeHighTrinketItemID);
    Base::ClearChangesMask(ItemUpgradeHighTrinketWatermark);
    Base::ClearChangesMask(LootHistoryInstanceID);
    Base::ClearChangesMask(PetStable);
    Base::ClearChangesMask(RequiredMountCapabilityFlags);
    Base::ClearChangesMask(InvSlots);
    Base::ClearChangesMask(RestInfo);
    Base::ClearChangesMask(ModDamageDonePos);
    Base::ClearChangesMask(ModDamageDoneNeg);
    Base::ClearChangesMask(ModDamageDonePercent);
    Base::ClearChangesMask(ModHealingDonePercent);
    Base::ClearChangesMask(WeaponDmgMultipliers);
    Base::ClearChangesMask(WeaponAtkSpeedMultipliers);
    Base::ClearChangesMask(BuybackPrice);
    Base::ClearChangesMask(BuybackTimestamp);
    Base::ClearChangesMask(CombatRatings);
    Base::ClearChangesMask(NoReagentCostMask);
    Base::ClearChangesMask(ProfessionSkillLine);
    Base::ClearChangesMask(BagSlotFlags);
    Base::ClearChangesMask(BankBagSlotFlags);
    Base::ClearChangesMask(QuestCompleted);
    Base::ClearChangesMask(ItemUpgradeHighWatermark);
    _changesMask.ResetAll();
}

void GameObjectData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, GameObject const* owner, Player const* receiver) const
{
    data << int32(DisplayID);
    data << uint32(SpellVisualID);
    data << uint32(StateSpellVisualID);
    data << uint32(SpawnTrackingStateAnimID);
    data << uint32(SpawnTrackingStateAnimKitID);
    data << uint32(StateWorldEffectIDs->size());
    data << uint32(StateWorldEffectsQuestObjectiveID);
    for (uint32 i = 0; i < StateWorldEffectIDs->size(); ++i)
    {
        data << uint32((*StateWorldEffectIDs)[i]);
    }
    data << CreatedBy;
    data << GuildGUID;
    data << uint32(ViewerDependentValue<FlagsTag>::GetValue(this, owner, receiver));
    data << float(ParentRotation->x);
    data << float(ParentRotation->y);
    data << float(ParentRotation->z);
    data << float(ParentRotation->w);
    data << int32(FactionTemplate);
    data << int8(ViewerDependentValue<StateTag>::GetValue(this, owner, receiver));
    data << int8(TypeID);
    data << uint8(PercentHealth);
    data << uint32(ArtKit);
    data << uint32(EnableDoodadSets.size());
    data << uint32(CustomParam);
    data << int32(Level);
    data << uint32(AnimGroupInstance);
    data << uint32(UiWidgetItemID);
    data << uint32(UiWidgetItemQuality);
    data << uint32(UiWidgetItemUnknown1000);
    data << uint32(WorldEffects.size());
    for (uint32 i = 0; i < EnableDoodadSets.size(); ++i)
    {
        data << int32(EnableDoodadSets[i]);
    }
    for (uint32 i = 0; i < WorldEffects.size(); ++i)
    {
        data << int32(WorldEffects[i]);
    }
}

void GameObjectData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, GameObject const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void GameObjectData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, GameObject const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlock(0), 25);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBits(StateWorldEffectIDs->size(), 32);
            for (uint32 i = 0; i < StateWorldEffectIDs->size(); ++i)
            {
                data << uint32((*StateWorldEffectIDs)[i]);
            }
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            if (!ignoreNestedChangesMask)
                EnableDoodadSets.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(EnableDoodadSets.size(), data);
        }
        if (changesMask[3])
        {
            if (!ignoreNestedChangesMask)
                WorldEffects.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(WorldEffects.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            for (uint32 i = 0; i < EnableDoodadSets.size(); ++i)
            {
                if (EnableDoodadSets.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(EnableDoodadSets[i]);
                }
            }
        }
        if (changesMask[3])
        {
            for (uint32 i = 0; i < WorldEffects.size(); ++i)
            {
                if (WorldEffects.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(WorldEffects[i]);
                }
            }
        }
        if (changesMask[4])
        {
            data << int32(DisplayID);
        }
        if (changesMask[5])
        {
            data << uint32(SpellVisualID);
        }
        if (changesMask[6])
        {
            data << uint32(StateSpellVisualID);
        }
        if (changesMask[7])
        {
            data << uint32(SpawnTrackingStateAnimID);
        }
        if (changesMask[8])
        {
            data << uint32(SpawnTrackingStateAnimKitID);
        }
        if (changesMask[9])
        {
            data << uint32(StateWorldEffectsQuestObjectiveID);
        }
        if (changesMask[10])
        {
            data << CreatedBy;
        }
        if (changesMask[11])
        {
            data << GuildGUID;
        }
        if (changesMask[12])
        {
            data << uint32(ViewerDependentValue<FlagsTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[13])
        {
            data << float(ParentRotation->x);
            data << float(ParentRotation->y);
            data << float(ParentRotation->z);
            data << float(ParentRotation->w);
        }
        if (changesMask[14])
        {
            data << int32(FactionTemplate);
        }
        if (changesMask[15])
        {
            data << int8(ViewerDependentValue<StateTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[16])
        {
            data << int8(TypeID);
        }
        if (changesMask[17])
        {
            data << uint8(PercentHealth);
        }
        if (changesMask[18])
        {
            data << uint32(ArtKit);
        }
        if (changesMask[19])
        {
            data << uint32(CustomParam);
        }
        if (changesMask[20])
        {
            data << int32(Level);
        }
        if (changesMask[21])
        {
            data << uint32(AnimGroupInstance);
        }
        if (changesMask[22])
        {
            data << uint32(UiWidgetItemID);
        }
        if (changesMask[23])
        {
            data << uint32(UiWidgetItemQuality);
        }
        if (changesMask[24])
        {
            data << uint32(UiWidgetItemUnknown1000);
        }
    }
}

void GameObjectData::ClearChangesMask()
{
    Base::ClearChangesMask(StateWorldEffectIDs);
    Base::ClearChangesMask(EnableDoodadSets);
    Base::ClearChangesMask(WorldEffects);
    Base::ClearChangesMask(DisplayID);
    Base::ClearChangesMask(SpellVisualID);
    Base::ClearChangesMask(StateSpellVisualID);
    Base::ClearChangesMask(SpawnTrackingStateAnimID);
    Base::ClearChangesMask(SpawnTrackingStateAnimKitID);
    Base::ClearChangesMask(StateWorldEffectsQuestObjectiveID);
    Base::ClearChangesMask(CreatedBy);
    Base::ClearChangesMask(GuildGUID);
    Base::ClearChangesMask(Flags);
    Base::ClearChangesMask(ParentRotation);
    Base::ClearChangesMask(FactionTemplate);
    Base::ClearChangesMask(State);
    Base::ClearChangesMask(TypeID);
    Base::ClearChangesMask(PercentHealth);
    Base::ClearChangesMask(ArtKit);
    Base::ClearChangesMask(CustomParam);
    Base::ClearChangesMask(Level);
    Base::ClearChangesMask(AnimGroupInstance);
    Base::ClearChangesMask(UiWidgetItemID);
    Base::ClearChangesMask(UiWidgetItemQuality);
    Base::ClearChangesMask(UiWidgetItemUnknown1000);
    _changesMask.ResetAll();
}

void DynamicObjectData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, DynamicObject const* owner, Player const* receiver) const
{
    data << Caster;
    data << uint8(Type);
    SpellVisual->WriteCreate(data, owner, receiver);
    data << int32(SpellID);
    data << float(Radius);
    data << uint32(CastTime);
}

void DynamicObjectData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, DynamicObject const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void DynamicObjectData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, DynamicObject const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlock(0), 7);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << Caster;
        }
        if (changesMask[2])
        {
            data << uint8(Type);
        }
        if (changesMask[3])
        {
            SpellVisual->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[4])
        {
            data << int32(SpellID);
        }
        if (changesMask[5])
        {
            data << float(Radius);
        }
        if (changesMask[6])
        {
            data << uint32(CastTime);
        }
    }
}

void DynamicObjectData::ClearChangesMask()
{
    Base::ClearChangesMask(Caster);
    Base::ClearChangesMask(Type);
    Base::ClearChangesMask(SpellVisual);
    Base::ClearChangesMask(SpellID);
    Base::ClearChangesMask(Radius);
    Base::ClearChangesMask(CastTime);
    _changesMask.ResetAll();
}

void CorpseData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Corpse const* owner, Player const* receiver) const
{
    data << uint32(DynamicFlags);
    data << Owner;
    data << PartyGUID;
    data << GuildGUID;
    data << uint32(DisplayID);
    for (uint32 i = 0; i < 19; ++i)
    {
        data << uint32(Items[i]);
    }
    data << uint8(RaceID);
    data << uint8(Sex);
    data << uint8(Class);
    data << uint32(Customizations.size());
    data << uint32(Flags);
    data << int32(FactionTemplate);
    data << uint32(StateSpellVisualKitID);
    for (uint32 i = 0; i < Customizations.size(); ++i)
    {
        Customizations[i].WriteCreate(data, owner, receiver);
    }
}

void CorpseData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Corpse const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void CorpseData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Corpse const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlocksMask(0), 2);
    for (uint32 i = 0; i < 2; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            if (!ignoreNestedChangesMask)
                Customizations.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Customizations.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            for (uint32 i = 0; i < Customizations.size(); ++i)
            {
                if (Customizations.HasChanged(i) || ignoreNestedChangesMask)
                {
                    Customizations[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[2])
        {
            data << uint32(DynamicFlags);
        }
        if (changesMask[3])
        {
            data << Owner;
        }
        if (changesMask[4])
        {
            data << PartyGUID;
        }
        if (changesMask[5])
        {
            data << GuildGUID;
        }
        if (changesMask[6])
        {
            data << uint32(DisplayID);
        }
        if (changesMask[7])
        {
            data << uint8(RaceID);
        }
        if (changesMask[8])
        {
            data << uint8(Sex);
        }
        if (changesMask[9])
        {
            data << uint8(Class);
        }
        if (changesMask[10])
        {
            data << uint32(Flags);
        }
        if (changesMask[11])
        {
            data << int32(FactionTemplate);
        }
        if (changesMask[12])
        {
            data << uint32(StateSpellVisualKitID);
        }
    }
    if (changesMask[13])
    {
        for (uint32 i = 0; i < 19; ++i)
        {
            if (changesMask[14 + i])
            {
                data << uint32(Items[i]);
            }
        }
    }
}

void CorpseData::ClearChangesMask()
{
    Base::ClearChangesMask(Customizations);
    Base::ClearChangesMask(DynamicFlags);
    Base::ClearChangesMask(Owner);
    Base::ClearChangesMask(PartyGUID);
    Base::ClearChangesMask(GuildGUID);
    Base::ClearChangesMask(DisplayID);
    Base::ClearChangesMask(RaceID);
    Base::ClearChangesMask(Sex);
    Base::ClearChangesMask(Class);
    Base::ClearChangesMask(Flags);
    Base::ClearChangesMask(FactionTemplate);
    Base::ClearChangesMask(StateSpellVisualKitID);
    Base::ClearChangesMask(Items);
    _changesMask.ResetAll();
}

void ScaleCurve::WriteCreate(ByteBuffer& data, AreaTrigger const* owner, Player const* receiver) const
{
    data << uint32(StartTimeOffset);
    for (uint32 i = 0; i < 2; ++i)
    {
        data << Points[i];
    }
    data << uint32(ParameterCurve);
    data.WriteBit(OverrideActive);
    data.FlushBits();
}

void ScaleCurve::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, AreaTrigger const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 7);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBit(OverrideActive);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            data << uint32(StartTimeOffset);
        }
        if (changesMask[3])
        {
            data << uint32(ParameterCurve);
        }
    }
    if (changesMask[4])
    {
        for (uint32 i = 0; i < 2; ++i)
        {
            if (changesMask[5 + i])
            {
                data << Points[i];
            }
        }
    }
    data.FlushBits();
}

void ScaleCurve::ClearChangesMask()
{
    Base::ClearChangesMask(OverrideActive);
    Base::ClearChangesMask(StartTimeOffset);
    Base::ClearChangesMask(ParameterCurve);
    Base::ClearChangesMask(Points);
    _changesMask.ResetAll();
}

void VisualAnim::WriteCreate(ByteBuffer& data, AreaTrigger const* owner, Player const* receiver) const
{
    data << uint32(AnimationDataID);
    data << uint32(AnimKitID);
    data << uint32(AnimProgress);
    data.WriteBit(Field_C);
    data.FlushBits();
}

void VisualAnim::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, AreaTrigger const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 5);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBit(Field_C);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            data << uint32(AnimationDataID);
        }
        if (changesMask[3])
        {
            data << uint32(AnimKitID);
        }
        if (changesMask[4])
        {
            data << uint32(AnimProgress);
        }
    }
    data.FlushBits();
}

void VisualAnim::ClearChangesMask()
{
    Base::ClearChangesMask(Field_C);
    Base::ClearChangesMask(AnimationDataID);
    Base::ClearChangesMask(AnimKitID);
    Base::ClearChangesMask(AnimProgress);
    _changesMask.ResetAll();
}

void AreaTriggerData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, AreaTrigger const* owner, Player const* receiver) const
{
    OverrideScaleCurve->WriteCreate(data, owner, receiver);
    data << Caster;
    data << uint32(Duration);
    data << uint32(TimeToTarget);
    data << uint32(TimeToTargetScale);
    data << uint32(TimeToTargetExtraScale);
    data << uint32(TimeToTargetPos);
    data << int32(SpellID);
    data << int32(SpellForVisuals);
    SpellVisual->WriteCreate(data, owner, receiver);
    data << float(BoundsRadius2D);
    data << uint32(DecalPropertiesID);
    data << CreatingEffectGUID;
    data << uint32(NumUnitsInside);
    data << uint32(NumPlayersInside);
    data << OrbitPathTarget;
    data << RollPitchYaw;
    data << int32(PositionalSoundKitID);
    ExtraScaleCurve->WriteCreate(data, owner, receiver);
    data.FlushBits();
    data.WriteBit(HeightIgnoresScale);
    data.WriteBit(Field_261);
    OverrideMoveCurveX->WriteCreate(data, owner, receiver);
    OverrideMoveCurveY->WriteCreate(data, owner, receiver);
    OverrideMoveCurveZ->WriteCreate(data, owner, receiver);
    VisualAnim->WriteCreate(data, owner, receiver);
    data.FlushBits();
}

void AreaTriggerData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, AreaTrigger const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void AreaTriggerData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, AreaTrigger const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlock(0), 26);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBit(HeightIgnoresScale);
        }
        if (changesMask[2])
        {
            data.WriteBit(Field_261);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[3])
        {
            OverrideScaleCurve->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[8])
        {
            data << Caster;
        }
        if (changesMask[9])
        {
            data << uint32(Duration);
        }
        if (changesMask[10])
        {
            data << uint32(TimeToTarget);
        }
        if (changesMask[11])
        {
            data << uint32(TimeToTargetScale);
        }
        if (changesMask[12])
        {
            data << uint32(TimeToTargetExtraScale);
        }
        if (changesMask[13])
        {
            data << uint32(TimeToTargetPos);
        }
        if (changesMask[14])
        {
            data << int32(SpellID);
        }
        if (changesMask[15])
        {
            data << int32(SpellForVisuals);
        }
        if (changesMask[16])
        {
            SpellVisual->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[17])
        {
            data << float(BoundsRadius2D);
        }
        if (changesMask[18])
        {
            data << uint32(DecalPropertiesID);
        }
        if (changesMask[19])
        {
            data << CreatingEffectGUID;
        }
        if (changesMask[20])
        {
            data << uint32(NumUnitsInside);
        }
        if (changesMask[21])
        {
            data << uint32(NumPlayersInside);
        }
        if (changesMask[22])
        {
            data << OrbitPathTarget;
        }
        if (changesMask[23])
        {
            data << RollPitchYaw;
        }
        if (changesMask[24])
        {
            data << int32(PositionalSoundKitID);
        }
        if (changesMask[4])
        {
            ExtraScaleCurve->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[5])
        {
            OverrideMoveCurveX->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[6])
        {
            OverrideMoveCurveY->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[7])
        {
            OverrideMoveCurveZ->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[25])
        {
            VisualAnim->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
    }
    data.FlushBits();
}

void AreaTriggerData::ClearChangesMask()
{
    Base::ClearChangesMask(HeightIgnoresScale);
    Base::ClearChangesMask(Field_261);
    Base::ClearChangesMask(OverrideScaleCurve);
    Base::ClearChangesMask(ExtraScaleCurve);
    Base::ClearChangesMask(OverrideMoveCurveX);
    Base::ClearChangesMask(OverrideMoveCurveY);
    Base::ClearChangesMask(OverrideMoveCurveZ);
    Base::ClearChangesMask(Caster);
    Base::ClearChangesMask(Duration);
    Base::ClearChangesMask(TimeToTarget);
    Base::ClearChangesMask(TimeToTargetScale);
    Base::ClearChangesMask(TimeToTargetExtraScale);
    Base::ClearChangesMask(TimeToTargetPos);
    Base::ClearChangesMask(SpellID);
    Base::ClearChangesMask(SpellForVisuals);
    Base::ClearChangesMask(SpellVisual);
    Base::ClearChangesMask(BoundsRadius2D);
    Base::ClearChangesMask(DecalPropertiesID);
    Base::ClearChangesMask(CreatingEffectGUID);
    Base::ClearChangesMask(NumUnitsInside);
    Base::ClearChangesMask(NumPlayersInside);
    Base::ClearChangesMask(OrbitPathTarget);
    Base::ClearChangesMask(RollPitchYaw);
    Base::ClearChangesMask(PositionalSoundKitID);
    Base::ClearChangesMask(VisualAnim);
    _changesMask.ResetAll();
}

void SceneObjectData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Object const* owner, Player const* receiver) const
{
    data << int32(ScriptPackageID);
    data << uint32(RndSeedVal);
    data << CreatedBy;
    data << uint32(SceneType);
}

void SceneObjectData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Object const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void SceneObjectData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Object const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlock(0), 5);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(ScriptPackageID);
        }
        if (changesMask[2])
        {
            data << uint32(RndSeedVal);
        }
        if (changesMask[3])
        {
            data << CreatedBy;
        }
        if (changesMask[4])
        {
            data << uint32(SceneType);
        }
    }
}

void SceneObjectData::ClearChangesMask()
{
    Base::ClearChangesMask(ScriptPackageID);
    Base::ClearChangesMask(RndSeedVal);
    Base::ClearChangesMask(CreatedBy);
    Base::ClearChangesMask(SceneType);
    _changesMask.ResetAll();
}

void ConversationLine::WriteCreate(ByteBuffer& data, Conversation const* owner, Player const* receiver) const
{
    data << int32(ConversationLineID);
    data << int32(BroadcastTextID);
    data << uint32(ViewerDependentValue<StartTimeTag>::GetValue(this, owner, receiver));
    data << int32(UiCameraID);
    data << uint8(ActorIndex);
    data << uint8(Flags);
    data << uint8(ChatType);
}

void ConversationLine::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Conversation const* owner, Player const* receiver) const
{
    data << int32(ConversationLineID);
    data << int32(BroadcastTextID);
    data << uint32(ViewerDependentValue<StartTimeTag>::GetValue(this, owner, receiver));
    data << int32(UiCameraID);
    data << uint8(ActorIndex);
    data << uint8(Flags);
    data << uint8(ChatType);
}

bool ConversationLine::operator==(ConversationLine const& right) const
{
    return ConversationLineID == right.ConversationLineID
        && BroadcastTextID == right.BroadcastTextID
        && StartTime == right.StartTime
        && UiCameraID == right.UiCameraID
        && ActorIndex == right.ActorIndex
        && Flags == right.Flags
        && ChatType == right.ChatType;
}

void ConversationActor::WriteCreate(ByteBuffer& data, Conversation const* owner, Player const* receiver) const
{
    data << uint32(CreatureID);
    data << uint32(CreatureDisplayInfoID);
    data << ActorGUID;
    data << int32(Id);
    data.WriteBits(Type, 1);
    data.WriteBits(NoActorObject, 1);
    data.FlushBits();
}

void ConversationActor::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Conversation const* owner, Player const* receiver) const
{
    data << uint32(CreatureID);
    data << uint32(CreatureDisplayInfoID);
    data << ActorGUID;
    data << int32(Id);
    data.WriteBits(Type, 1);
    data.WriteBits(NoActorObject, 1);
    data.FlushBits();
}

bool ConversationActor::operator==(ConversationActor const& right) const
{
    return CreatureID == right.CreatureID
        && CreatureDisplayInfoID == right.CreatureDisplayInfoID
        && ActorGUID == right.ActorGUID
        && Id == right.Id
        && Type == right.Type
        && NoActorObject == right.NoActorObject;
}

void ConversationData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Conversation const* owner, Player const* receiver) const
{
    data << uint32(Lines->size());
    data << int32(ViewerDependentValue<LastLineEndTimeTag>::GetValue(this, owner, receiver));
    data << uint32(Progress);
    for (uint32 i = 0; i < Lines->size(); ++i)
    {
        (*Lines)[i].WriteCreate(data, owner, receiver);
    }
    data.WriteBit(DontPlayBroadcastTextSounds);
    data << uint32(Actors.size());
    data << uint32(Flags);
    for (uint32 i = 0; i < Actors.size(); ++i)
    {
        Actors[i].WriteCreate(data, owner, receiver);
    }
    data.FlushBits();
}

void ConversationData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Conversation const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void ConversationData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Conversation const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlock(0), 7);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBit(DontPlayBroadcastTextSounds);
        }
        if (changesMask[2])
        {
            data.WriteBits(Lines->size(), 32);
            for (uint32 i = 0; i < Lines->size(); ++i)
            {
                (*Lines)[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[3])
        {
            if (!ignoreNestedChangesMask)
                Actors.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Actors.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[3])
        {
            for (uint32 i = 0; i < Actors.size(); ++i)
            {
                if (Actors.HasChanged(i) || ignoreNestedChangesMask)
                {
                    Actors[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[4])
        {
            data << int32(ViewerDependentValue<LastLineEndTimeTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[5])
        {
            data << uint32(Progress);
        }
        if (changesMask[6])
        {
            data << uint32(Flags);
        }
    }
    data.FlushBits();
}

void ConversationData::ClearChangesMask()
{
    Base::ClearChangesMask(DontPlayBroadcastTextSounds);
    Base::ClearChangesMask(Lines);
    Base::ClearChangesMask(Actors);
    Base::ClearChangesMask(LastLineEndTime);
    Base::ClearChangesMask(Progress);
    Base::ClearChangesMask(Flags);
    _changesMask.ResetAll();
}

}

#if TRINITY_COMPILER == TRINITY_COMPILER_GNU
#pragma GCC diagnostic pop
#else
#pragma warning(pop)
#endif
