// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/client/v2/report_types.proto

#ifndef PROTOBUF_api_2fclient_2fv2_2freport_5ftypes_2eproto__INCLUDED
#define PROTOBUF_api_2fclient_2fv2_2freport_5ftypes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "api/client/v2/attribute_types.pb.h"
#include "account_types.pb.h"
#include "rpc_types.pb.h"
#include "message_types.pb.h"
#include "Define.h" // for TC_PROTO_API
// @@protoc_insertion_point(includes)

namespace bgs {
namespace protocol {
namespace report {
namespace v2 {

// Internal implementation detail -- do not call these.
void TC_PROTO_API protobuf_AddDesc_api_2fclient_2fv2_2freport_5ftypes_2eproto();
void protobuf_AssignDesc_api_2fclient_2fv2_2freport_5ftypes_2eproto();
void protobuf_ShutdownFile_api_2fclient_2fv2_2freport_5ftypes_2eproto();

class ReportItem;
class UserOptions;
class ClubOptions;
class EntityOptions;

enum IssueType {
  ISSUE_TYPE_SPAM = 0,
  ISSUE_TYPE_HARASSMENT = 1,
  ISSUE_TYPE_OFFENSIVE_CONTENT = 3,
  ISSUE_TYPE_HACKING = 4,
  ISSUE_TYPE_BOTTING = 5
};
TC_PROTO_API bool IssueType_IsValid(int value);
const IssueType IssueType_MIN = ISSUE_TYPE_SPAM;
const IssueType IssueType_MAX = ISSUE_TYPE_BOTTING;
const int IssueType_ARRAYSIZE = IssueType_MAX + 1;

TC_PROTO_API const ::google::protobuf::EnumDescriptor* IssueType_descriptor();
inline const ::std::string& IssueType_Name(IssueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    IssueType_descriptor(), value);
}
inline bool IssueType_Parse(
    const ::std::string& name, IssueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IssueType>(
    IssueType_descriptor(), name, value);
}
enum UserSource {
  USER_SOURCE_OTHER = 0,
  USER_SOURCE_WHISPER = 1,
  USER_SOURCE_PROFILE = 2,
  USER_SOURCE_BATTLE_TAG = 3,
  USER_SOURCE_CHAT = 4,
  USER_SOURCE_FRIEND_INVITATION = 5,
  USER_SOURCE_VOICE = 6
};
TC_PROTO_API bool UserSource_IsValid(int value);
const UserSource UserSource_MIN = USER_SOURCE_OTHER;
const UserSource UserSource_MAX = USER_SOURCE_VOICE;
const int UserSource_ARRAYSIZE = UserSource_MAX + 1;

TC_PROTO_API const ::google::protobuf::EnumDescriptor* UserSource_descriptor();
inline const ::std::string& UserSource_Name(UserSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserSource_descriptor(), value);
}
inline bool UserSource_Parse(
    const ::std::string& name, UserSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserSource>(
    UserSource_descriptor(), name, value);
}
enum ClubSource {
  CLUB_SOURCE_OTHER = 0,
  CLUB_SOURCE_MESSAGE = 1,
  CLUB_SOURCE_CLUB_NAME = 2,
  CLUB_SOURCE_STREAM_NAME = 3
};
TC_PROTO_API bool ClubSource_IsValid(int value);
const ClubSource ClubSource_MIN = CLUB_SOURCE_OTHER;
const ClubSource ClubSource_MAX = CLUB_SOURCE_STREAM_NAME;
const int ClubSource_ARRAYSIZE = ClubSource_MAX + 1;

TC_PROTO_API const ::google::protobuf::EnumDescriptor* ClubSource_descriptor();
inline const ::std::string& ClubSource_Name(ClubSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClubSource_descriptor(), value);
}
inline bool ClubSource_Parse(
    const ::std::string& name, ClubSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClubSource>(
    ClubSource_descriptor(), name, value);
}
// ===================================================================

class TC_PROTO_API ReportItem : public ::google::protobuf::Message {
 public:
  ReportItem();
  virtual ~ReportItem();

  ReportItem(const ReportItem& from);

  inline ReportItem& operator=(const ReportItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportItem& default_instance();

  enum TypeCase {
    kMessageId = 1,
    TYPE_NOT_SET = 0,
  };

  void Swap(ReportItem* other);

  // implements Message ----------------------------------------------

  ReportItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReportItem& from);
  void MergeFrom(const ReportItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bgs.protocol.MessageId message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline const ::bgs::protocol::MessageId& message_id() const;
  inline ::bgs::protocol::MessageId* mutable_message_id();
  inline ::bgs::protocol::MessageId* release_message_id();
  inline void set_allocated_message_id(::bgs::protocol::MessageId* message_id);

  inline TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:bgs.protocol.report.v2.ReportItem)
 private:
  inline void set_has_message_id();

  inline bool has_type();
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union TypeUnion {
    ::bgs::protocol::MessageId* message_id_;
  } type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void TC_PROTO_API protobuf_AddDesc_api_2fclient_2fv2_2freport_5ftypes_2eproto();
  friend void protobuf_AssignDesc_api_2fclient_2fv2_2freport_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_api_2fclient_2fv2_2freport_5ftypes_2eproto();

  void InitAsDefaultInstance();
  static ReportItem* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API UserOptions : public ::google::protobuf::Message {
 public:
  UserOptions();
  virtual ~UserOptions();

  UserOptions(const UserOptions& from);

  inline UserOptions& operator=(const UserOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserOptions& default_instance();

  void Swap(UserOptions* other);

  // implements Message ----------------------------------------------

  UserOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserOptions& from);
  void MergeFrom(const UserOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bgs.protocol.account.v1.AccountId target_id = 1;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 1;
  inline const ::bgs::protocol::account::v1::AccountId& target_id() const;
  inline ::bgs::protocol::account::v1::AccountId* mutable_target_id();
  inline ::bgs::protocol::account::v1::AccountId* release_target_id();
  inline void set_allocated_target_id(::bgs::protocol::account::v1::AccountId* target_id);

  // optional .bgs.protocol.report.v2.IssueType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::bgs::protocol::report::v2::IssueType type() const;
  inline void set_type(::bgs::protocol::report::v2::IssueType value);

  // optional .bgs.protocol.report.v2.UserSource source = 3;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 3;
  inline ::bgs::protocol::report::v2::UserSource source() const;
  inline void set_source(::bgs::protocol::report::v2::UserSource value);

  // optional .bgs.protocol.report.v2.ReportItem item = 4;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 4;
  inline const ::bgs::protocol::report::v2::ReportItem& item() const;
  inline ::bgs::protocol::report::v2::ReportItem* mutable_item();
  inline ::bgs::protocol::report::v2::ReportItem* release_item();
  inline void set_allocated_item(::bgs::protocol::report::v2::ReportItem* item);

  // @@protoc_insertion_point(class_scope:bgs.protocol.report.v2.UserOptions)
 private:
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::bgs::protocol::account::v1::AccountId* target_id_;
  int type_;
  int source_;
  ::bgs::protocol::report::v2::ReportItem* item_;
  friend void TC_PROTO_API protobuf_AddDesc_api_2fclient_2fv2_2freport_5ftypes_2eproto();
  friend void protobuf_AssignDesc_api_2fclient_2fv2_2freport_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_api_2fclient_2fv2_2freport_5ftypes_2eproto();

  void InitAsDefaultInstance();
  static UserOptions* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API ClubOptions : public ::google::protobuf::Message {
 public:
  ClubOptions();
  virtual ~ClubOptions();

  ClubOptions(const ClubOptions& from);

  inline ClubOptions& operator=(const ClubOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClubOptions& default_instance();

  void Swap(ClubOptions* other);

  // implements Message ----------------------------------------------

  ClubOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClubOptions& from);
  void MergeFrom(const ClubOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 club_id = 1;
  inline bool has_club_id() const;
  inline void clear_club_id();
  static const int kClubIdFieldNumber = 1;
  inline ::google::protobuf::uint64 club_id() const;
  inline void set_club_id(::google::protobuf::uint64 value);

  // optional uint64 stream_id = 2;
  inline bool has_stream_id() const;
  inline void clear_stream_id();
  static const int kStreamIdFieldNumber = 2;
  inline ::google::protobuf::uint64 stream_id() const;
  inline void set_stream_id(::google::protobuf::uint64 value);

  // optional .bgs.protocol.report.v2.IssueType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::bgs::protocol::report::v2::IssueType type() const;
  inline void set_type(::bgs::protocol::report::v2::IssueType value);

  // optional .bgs.protocol.report.v2.ClubSource source = 4;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 4;
  inline ::bgs::protocol::report::v2::ClubSource source() const;
  inline void set_source(::bgs::protocol::report::v2::ClubSource value);

  // optional .bgs.protocol.report.v2.ReportItem item = 5;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 5;
  inline const ::bgs::protocol::report::v2::ReportItem& item() const;
  inline ::bgs::protocol::report::v2::ReportItem* mutable_item();
  inline ::bgs::protocol::report::v2::ReportItem* release_item();
  inline void set_allocated_item(::bgs::protocol::report::v2::ReportItem* item);

  // @@protoc_insertion_point(class_scope:bgs.protocol.report.v2.ClubOptions)
 private:
  inline void set_has_club_id();
  inline void clear_has_club_id();
  inline void set_has_stream_id();
  inline void clear_has_stream_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 club_id_;
  ::google::protobuf::uint64 stream_id_;
  int type_;
  int source_;
  ::bgs::protocol::report::v2::ReportItem* item_;
  friend void TC_PROTO_API protobuf_AddDesc_api_2fclient_2fv2_2freport_5ftypes_2eproto();
  friend void protobuf_AssignDesc_api_2fclient_2fv2_2freport_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_api_2fclient_2fv2_2freport_5ftypes_2eproto();

  void InitAsDefaultInstance();
  static ClubOptions* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API EntityOptions : public ::google::protobuf::Message {
 public:
  EntityOptions();
  virtual ~EntityOptions();

  EntityOptions(const EntityOptions& from);

  inline EntityOptions& operator=(const EntityOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityOptions& default_instance();

  void Swap(EntityOptions* other);

  // implements Message ----------------------------------------------

  EntityOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityOptions& from);
  void MergeFrom(const EntityOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string entity_id = 1;
  inline bool has_entity_id() const;
  inline void clear_entity_id();
  static const int kEntityIdFieldNumber = 1;
  inline const ::std::string& entity_id() const;
  inline void set_entity_id(const ::std::string& value);
  inline void set_entity_id(const char* value);
  inline void set_entity_id(const char* value, size_t size);
  inline ::std::string* mutable_entity_id();
  inline ::std::string* release_entity_id();
  inline void set_allocated_entity_id(::std::string* entity_id);

  // optional string entity_type = 2;
  inline bool has_entity_type() const;
  inline void clear_entity_type();
  static const int kEntityTypeFieldNumber = 2;
  inline const ::std::string& entity_type() const;
  inline void set_entity_type(const ::std::string& value);
  inline void set_entity_type(const char* value);
  inline void set_entity_type(const char* value, size_t size);
  inline ::std::string* mutable_entity_type();
  inline ::std::string* release_entity_type();
  inline void set_allocated_entity_type(::std::string* entity_type);

  // repeated .bgs.protocol.v2.Attribute attribute = 5;
  inline int attribute_size() const;
  inline void clear_attribute();
  static const int kAttributeFieldNumber = 5;
  inline const ::bgs::protocol::v2::Attribute& attribute(int index) const;
  inline ::bgs::protocol::v2::Attribute* mutable_attribute(int index);
  inline ::bgs::protocol::v2::Attribute* add_attribute();
  inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::v2::Attribute >&
      attribute() const;
  inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::v2::Attribute >*
      mutable_attribute();

  // @@protoc_insertion_point(class_scope:bgs.protocol.report.v2.EntityOptions)
 private:
  inline void set_has_entity_id();
  inline void clear_has_entity_id();
  inline void set_has_entity_type();
  inline void clear_has_entity_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* entity_id_;
  ::std::string* entity_type_;
  ::google::protobuf::RepeatedPtrField< ::bgs::protocol::v2::Attribute > attribute_;
  friend void TC_PROTO_API protobuf_AddDesc_api_2fclient_2fv2_2freport_5ftypes_2eproto();
  friend void protobuf_AssignDesc_api_2fclient_2fv2_2freport_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_api_2fclient_2fv2_2freport_5ftypes_2eproto();

  void InitAsDefaultInstance();
  static EntityOptions* default_instance_;
};
// ===================================================================

// ===================================================================

// ===================================================================

// ReportItem

// optional .bgs.protocol.MessageId message_id = 1;
inline bool ReportItem::has_message_id() const {
  return type_case() == kMessageId;
}
inline void ReportItem::set_has_message_id() {
  _oneof_case_[0] = kMessageId;
}
inline void ReportItem::clear_message_id() {
  if (has_message_id()) {
    delete type_.message_id_;
    clear_has_type();
  }
}
inline const ::bgs::protocol::MessageId& ReportItem::message_id() const {
  return has_message_id() ? *type_.message_id_
                      : ::bgs::protocol::MessageId::default_instance();
}
inline ::bgs::protocol::MessageId* ReportItem::mutable_message_id() {
  if (!has_message_id()) {
    clear_type();
    set_has_message_id();
    type_.message_id_ = new ::bgs::protocol::MessageId;
  }
  return type_.message_id_;
}
inline ::bgs::protocol::MessageId* ReportItem::release_message_id() {
  if (has_message_id()) {
    clear_has_type();
    ::bgs::protocol::MessageId* temp = type_.message_id_;
    type_.message_id_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReportItem::set_allocated_message_id(::bgs::protocol::MessageId* message_id) {
  clear_type();
  if (message_id) {
    set_has_message_id();
    type_.message_id_ = message_id;
  }
}

inline bool ReportItem::has_type() {
  return type_case() != TYPE_NOT_SET;
}
inline void ReportItem::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline ReportItem::TypeCase ReportItem::type_case() const {
  return ReportItem::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UserOptions

// optional .bgs.protocol.account.v1.AccountId target_id = 1;
inline bool UserOptions::has_target_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserOptions::set_has_target_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserOptions::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserOptions::clear_target_id() {
  if (target_id_ != NULL) target_id_->::bgs::protocol::account::v1::AccountId::Clear();
  clear_has_target_id();
}
inline const ::bgs::protocol::account::v1::AccountId& UserOptions::target_id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.report.v2.UserOptions.target_id)
  return target_id_ != NULL ? *target_id_ : *default_instance_->target_id_;
}
inline ::bgs::protocol::account::v1::AccountId* UserOptions::mutable_target_id() {
  set_has_target_id();
  if (target_id_ == NULL) target_id_ = new ::bgs::protocol::account::v1::AccountId;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.report.v2.UserOptions.target_id)
  return target_id_;
}
inline ::bgs::protocol::account::v1::AccountId* UserOptions::release_target_id() {
  clear_has_target_id();
  ::bgs::protocol::account::v1::AccountId* temp = target_id_;
  target_id_ = NULL;
  return temp;
}
inline void UserOptions::set_allocated_target_id(::bgs::protocol::account::v1::AccountId* target_id) {
  delete target_id_;
  target_id_ = target_id;
  if (target_id) {
    set_has_target_id();
  } else {
    clear_has_target_id();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.report.v2.UserOptions.target_id)
}

// optional .bgs.protocol.report.v2.IssueType type = 2;
inline bool UserOptions::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserOptions::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserOptions::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserOptions::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::bgs::protocol::report::v2::IssueType UserOptions::type() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.report.v2.UserOptions.type)
  return static_cast< ::bgs::protocol::report::v2::IssueType >(type_);
}
inline void UserOptions::set_type(::bgs::protocol::report::v2::IssueType value) {
  assert(::bgs::protocol::report::v2::IssueType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.report.v2.UserOptions.type)
}

// optional .bgs.protocol.report.v2.UserSource source = 3;
inline bool UserOptions::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserOptions::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserOptions::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserOptions::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::bgs::protocol::report::v2::UserSource UserOptions::source() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.report.v2.UserOptions.source)
  return static_cast< ::bgs::protocol::report::v2::UserSource >(source_);
}
inline void UserOptions::set_source(::bgs::protocol::report::v2::UserSource value) {
  assert(::bgs::protocol::report::v2::UserSource_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.report.v2.UserOptions.source)
}

// optional .bgs.protocol.report.v2.ReportItem item = 4;
inline bool UserOptions::has_item() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserOptions::set_has_item() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserOptions::clear_has_item() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserOptions::clear_item() {
  if (item_ != NULL) item_->::bgs::protocol::report::v2::ReportItem::Clear();
  clear_has_item();
}
inline const ::bgs::protocol::report::v2::ReportItem& UserOptions::item() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.report.v2.UserOptions.item)
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::bgs::protocol::report::v2::ReportItem* UserOptions::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::bgs::protocol::report::v2::ReportItem;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.report.v2.UserOptions.item)
  return item_;
}
inline ::bgs::protocol::report::v2::ReportItem* UserOptions::release_item() {
  clear_has_item();
  ::bgs::protocol::report::v2::ReportItem* temp = item_;
  item_ = NULL;
  return temp;
}
inline void UserOptions::set_allocated_item(::bgs::protocol::report::v2::ReportItem* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.report.v2.UserOptions.item)
}

// -------------------------------------------------------------------

// ClubOptions

// optional uint64 club_id = 1;
inline bool ClubOptions::has_club_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClubOptions::set_has_club_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClubOptions::clear_has_club_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClubOptions::clear_club_id() {
  club_id_ = GOOGLE_ULONGLONG(0);
  clear_has_club_id();
}
inline ::google::protobuf::uint64 ClubOptions::club_id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.report.v2.ClubOptions.club_id)
  return club_id_;
}
inline void ClubOptions::set_club_id(::google::protobuf::uint64 value) {
  set_has_club_id();
  club_id_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.report.v2.ClubOptions.club_id)
}

// optional uint64 stream_id = 2;
inline bool ClubOptions::has_stream_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClubOptions::set_has_stream_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClubOptions::clear_has_stream_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClubOptions::clear_stream_id() {
  stream_id_ = GOOGLE_ULONGLONG(0);
  clear_has_stream_id();
}
inline ::google::protobuf::uint64 ClubOptions::stream_id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.report.v2.ClubOptions.stream_id)
  return stream_id_;
}
inline void ClubOptions::set_stream_id(::google::protobuf::uint64 value) {
  set_has_stream_id();
  stream_id_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.report.v2.ClubOptions.stream_id)
}

// optional .bgs.protocol.report.v2.IssueType type = 3;
inline bool ClubOptions::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClubOptions::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClubOptions::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClubOptions::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::bgs::protocol::report::v2::IssueType ClubOptions::type() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.report.v2.ClubOptions.type)
  return static_cast< ::bgs::protocol::report::v2::IssueType >(type_);
}
inline void ClubOptions::set_type(::bgs::protocol::report::v2::IssueType value) {
  assert(::bgs::protocol::report::v2::IssueType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.report.v2.ClubOptions.type)
}

// optional .bgs.protocol.report.v2.ClubSource source = 4;
inline bool ClubOptions::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClubOptions::set_has_source() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClubOptions::clear_has_source() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClubOptions::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::bgs::protocol::report::v2::ClubSource ClubOptions::source() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.report.v2.ClubOptions.source)
  return static_cast< ::bgs::protocol::report::v2::ClubSource >(source_);
}
inline void ClubOptions::set_source(::bgs::protocol::report::v2::ClubSource value) {
  assert(::bgs::protocol::report::v2::ClubSource_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.report.v2.ClubOptions.source)
}

// optional .bgs.protocol.report.v2.ReportItem item = 5;
inline bool ClubOptions::has_item() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClubOptions::set_has_item() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClubOptions::clear_has_item() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClubOptions::clear_item() {
  if (item_ != NULL) item_->::bgs::protocol::report::v2::ReportItem::Clear();
  clear_has_item();
}
inline const ::bgs::protocol::report::v2::ReportItem& ClubOptions::item() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.report.v2.ClubOptions.item)
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::bgs::protocol::report::v2::ReportItem* ClubOptions::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::bgs::protocol::report::v2::ReportItem;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.report.v2.ClubOptions.item)
  return item_;
}
inline ::bgs::protocol::report::v2::ReportItem* ClubOptions::release_item() {
  clear_has_item();
  ::bgs::protocol::report::v2::ReportItem* temp = item_;
  item_ = NULL;
  return temp;
}
inline void ClubOptions::set_allocated_item(::bgs::protocol::report::v2::ReportItem* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.report.v2.ClubOptions.item)
}

// -------------------------------------------------------------------

// EntityOptions

// optional string entity_id = 1;
inline bool EntityOptions::has_entity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityOptions::set_has_entity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityOptions::clear_has_entity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityOptions::clear_entity_id() {
  if (entity_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entity_id_->clear();
  }
  clear_has_entity_id();
}
inline const ::std::string& EntityOptions::entity_id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.report.v2.EntityOptions.entity_id)
  return *entity_id_;
}
inline void EntityOptions::set_entity_id(const ::std::string& value) {
  set_has_entity_id();
  if (entity_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entity_id_ = new ::std::string;
  }
  entity_id_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.report.v2.EntityOptions.entity_id)
}
inline void EntityOptions::set_entity_id(const char* value) {
  set_has_entity_id();
  if (entity_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entity_id_ = new ::std::string;
  }
  entity_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.report.v2.EntityOptions.entity_id)
}
inline void EntityOptions::set_entity_id(const char* value, size_t size) {
  set_has_entity_id();
  if (entity_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entity_id_ = new ::std::string;
  }
  entity_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.report.v2.EntityOptions.entity_id)
}
inline ::std::string* EntityOptions::mutable_entity_id() {
  set_has_entity_id();
  if (entity_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entity_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.report.v2.EntityOptions.entity_id)
  return entity_id_;
}
inline ::std::string* EntityOptions::release_entity_id() {
  clear_has_entity_id();
  if (entity_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = entity_id_;
    entity_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EntityOptions::set_allocated_entity_id(::std::string* entity_id) {
  if (entity_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete entity_id_;
  }
  if (entity_id) {
    set_has_entity_id();
    entity_id_ = entity_id;
  } else {
    clear_has_entity_id();
    entity_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.report.v2.EntityOptions.entity_id)
}

// optional string entity_type = 2;
inline bool EntityOptions::has_entity_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntityOptions::set_has_entity_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntityOptions::clear_has_entity_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntityOptions::clear_entity_type() {
  if (entity_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entity_type_->clear();
  }
  clear_has_entity_type();
}
inline const ::std::string& EntityOptions::entity_type() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.report.v2.EntityOptions.entity_type)
  return *entity_type_;
}
inline void EntityOptions::set_entity_type(const ::std::string& value) {
  set_has_entity_type();
  if (entity_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entity_type_ = new ::std::string;
  }
  entity_type_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.report.v2.EntityOptions.entity_type)
}
inline void EntityOptions::set_entity_type(const char* value) {
  set_has_entity_type();
  if (entity_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entity_type_ = new ::std::string;
  }
  entity_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.report.v2.EntityOptions.entity_type)
}
inline void EntityOptions::set_entity_type(const char* value, size_t size) {
  set_has_entity_type();
  if (entity_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entity_type_ = new ::std::string;
  }
  entity_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.report.v2.EntityOptions.entity_type)
}
inline ::std::string* EntityOptions::mutable_entity_type() {
  set_has_entity_type();
  if (entity_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entity_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.report.v2.EntityOptions.entity_type)
  return entity_type_;
}
inline ::std::string* EntityOptions::release_entity_type() {
  clear_has_entity_type();
  if (entity_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = entity_type_;
    entity_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EntityOptions::set_allocated_entity_type(::std::string* entity_type) {
  if (entity_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete entity_type_;
  }
  if (entity_type) {
    set_has_entity_type();
    entity_type_ = entity_type;
  } else {
    clear_has_entity_type();
    entity_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.report.v2.EntityOptions.entity_type)
}

// repeated .bgs.protocol.v2.Attribute attribute = 5;
inline int EntityOptions::attribute_size() const {
  return attribute_.size();
}
inline void EntityOptions::clear_attribute() {
  attribute_.Clear();
}
inline const ::bgs::protocol::v2::Attribute& EntityOptions::attribute(int index) const {
  // @@protoc_insertion_point(field_get:bgs.protocol.report.v2.EntityOptions.attribute)
  return attribute_.Get(index);
}
inline ::bgs::protocol::v2::Attribute* EntityOptions::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:bgs.protocol.report.v2.EntityOptions.attribute)
  return attribute_.Mutable(index);
}
inline ::bgs::protocol::v2::Attribute* EntityOptions::add_attribute() {
  // @@protoc_insertion_point(field_add:bgs.protocol.report.v2.EntityOptions.attribute)
  return attribute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::v2::Attribute >&
EntityOptions::attribute() const {
  // @@protoc_insertion_point(field_list:bgs.protocol.report.v2.EntityOptions.attribute)
  return attribute_;
}
inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::v2::Attribute >*
EntityOptions::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:bgs.protocol.report.v2.EntityOptions.attribute)
  return &attribute_;
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace report
}  // namespace protocol
}  // namespace bgs

#ifndef SWIG
namespace google {
namespace protobuf {
template <> struct is_proto_enum< ::bgs::protocol::report::v2::IssueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bgs::protocol::report::v2::IssueType>() {
  return ::bgs::protocol::report::v2::IssueType_descriptor();
}
template <> struct is_proto_enum< ::bgs::protocol::report::v2::UserSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bgs::protocol::report::v2::UserSource>() {
  return ::bgs::protocol::report::v2::UserSource_descriptor();
}
template <> struct is_proto_enum< ::bgs::protocol::report::v2::ClubSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bgs::protocol::report::v2::ClubSource>() {
  return ::bgs::protocol::report::v2::ClubSource_descriptor();
}
}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_api_2fclient_2fv2_2freport_5ftypes_2eproto__INCLUDED
