// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: challenge_service.proto

#ifndef PROTOBUF_challenge_5fservice_2eproto__INCLUDED
#define PROTOBUF_challenge_5fservice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "attribute_types.pb.h"
#include "entity_types.pb.h"
#include "rpc_types.pb.h"
#include "ServiceBase.h"
#include "MessageBuffer.h"
#include <functional>
#include <type_traits>
// @@protoc_insertion_point(includes)

namespace bgs {
namespace protocol {
namespace challenge {
namespace v1 {

// Internal implementation detail -- do not call these.
void TC_PROTO_API protobuf_AddDesc_challenge_5fservice_2eproto();
void protobuf_AssignDesc_challenge_5fservice_2eproto();
void protobuf_ShutdownFile_challenge_5fservice_2eproto();

class Challenge;
class ChallengePickedRequest;
class ChallengePickedResponse;
class ChallengeAnsweredRequest;
class ChallengeAnsweredResponse;
class ChallengeCancelledRequest;
class SendChallengeToUserRequest;
class SendChallengeToUserResponse;
class ChallengeUserRequest;
class ChallengeResultRequest;
class ChallengeExternalRequest;
class ChallengeExternalResult;

// ===================================================================

class TC_PROTO_API Challenge : public ::google::protobuf::Message {
 public:
  Challenge();
  virtual ~Challenge();

  Challenge(const Challenge& from);

  inline Challenge& operator=(const Challenge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Challenge& default_instance();

  void Swap(Challenge* other);

  // implements Message ----------------------------------------------

  Challenge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Challenge& from);
  void MergeFrom(const Challenge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // optional string answer = 3;
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 3;
  inline const ::std::string& answer() const;
  inline void set_answer(const ::std::string& value);
  inline void set_answer(const char* value);
  inline void set_answer(const char* value, size_t size);
  inline ::std::string* mutable_answer();
  inline ::std::string* release_answer();
  inline void set_allocated_answer(::std::string* answer);

  // optional uint32 retries = 4;
  inline bool has_retries() const;
  inline void clear_retries();
  static const int kRetriesFieldNumber = 4;
  inline ::google::protobuf::uint32 retries() const;
  inline void set_retries(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:bgs.protocol.challenge.v1.Challenge)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_retries();
  inline void clear_has_retries();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* info_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 retries_;
  ::std::string* answer_;
  friend void TC_PROTO_API protobuf_AddDesc_challenge_5fservice_2eproto();
  friend void protobuf_AssignDesc_challenge_5fservice_2eproto();
  friend void protobuf_ShutdownFile_challenge_5fservice_2eproto();

  void InitAsDefaultInstance();
  static Challenge* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API ChallengePickedRequest : public ::google::protobuf::Message {
 public:
  ChallengePickedRequest();
  virtual ~ChallengePickedRequest();

  ChallengePickedRequest(const ChallengePickedRequest& from);

  inline ChallengePickedRequest& operator=(const ChallengePickedRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengePickedRequest& default_instance();

  void Swap(ChallengePickedRequest* other);

  // implements Message ----------------------------------------------

  ChallengePickedRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChallengePickedRequest& from);
  void MergeFrom(const ChallengePickedRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 challenge = 1;
  inline bool has_challenge() const;
  inline void clear_challenge();
  static const int kChallengeFieldNumber = 1;
  inline ::google::protobuf::uint32 challenge() const;
  inline void set_challenge(::google::protobuf::uint32 value);

  // optional uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional bool new_challenge_protocol = 3 [default = false];
  inline bool has_new_challenge_protocol() const;
  inline void clear_new_challenge_protocol();
  static const int kNewChallengeProtocolFieldNumber = 3;
  inline bool new_challenge_protocol() const;
  inline void set_new_challenge_protocol(bool value);

  // @@protoc_insertion_point(class_scope:bgs.protocol.challenge.v1.ChallengePickedRequest)
 private:
  inline void set_has_challenge();
  inline void clear_has_challenge();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_new_challenge_protocol();
  inline void clear_has_new_challenge_protocol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 challenge_;
  ::google::protobuf::uint32 id_;
  bool new_challenge_protocol_;
  friend void TC_PROTO_API protobuf_AddDesc_challenge_5fservice_2eproto();
  friend void protobuf_AssignDesc_challenge_5fservice_2eproto();
  friend void protobuf_ShutdownFile_challenge_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ChallengePickedRequest* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API ChallengePickedResponse : public ::google::protobuf::Message {
 public:
  ChallengePickedResponse();
  virtual ~ChallengePickedResponse();

  ChallengePickedResponse(const ChallengePickedResponse& from);

  inline ChallengePickedResponse& operator=(const ChallengePickedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengePickedResponse& default_instance();

  void Swap(ChallengePickedResponse* other);

  // implements Message ----------------------------------------------

  ChallengePickedResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChallengePickedResponse& from);
  void MergeFrom(const ChallengePickedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:bgs.protocol.challenge.v1.ChallengePickedResponse)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  friend void TC_PROTO_API protobuf_AddDesc_challenge_5fservice_2eproto();
  friend void protobuf_AssignDesc_challenge_5fservice_2eproto();
  friend void protobuf_ShutdownFile_challenge_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ChallengePickedResponse* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API ChallengeAnsweredRequest : public ::google::protobuf::Message {
 public:
  ChallengeAnsweredRequest();
  virtual ~ChallengeAnsweredRequest();

  ChallengeAnsweredRequest(const ChallengeAnsweredRequest& from);

  inline ChallengeAnsweredRequest& operator=(const ChallengeAnsweredRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengeAnsweredRequest& default_instance();

  void Swap(ChallengeAnsweredRequest* other);

  // implements Message ----------------------------------------------

  ChallengeAnsweredRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChallengeAnsweredRequest& from);
  void MergeFrom(const ChallengeAnsweredRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string answer = 1;
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 1;
  inline const ::std::string& answer() const;
  inline void set_answer(const ::std::string& value);
  inline void set_answer(const char* value);
  inline void set_answer(const char* value, size_t size);
  inline ::std::string* mutable_answer();
  inline ::std::string* release_answer();
  inline void set_allocated_answer(::std::string* answer);

  // optional bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional uint32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:bgs.protocol.challenge.v1.ChallengeAnsweredRequest)
 private:
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* answer_;
  ::std::string* data_;
  ::google::protobuf::uint32 id_;
  friend void TC_PROTO_API protobuf_AddDesc_challenge_5fservice_2eproto();
  friend void protobuf_AssignDesc_challenge_5fservice_2eproto();
  friend void protobuf_ShutdownFile_challenge_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ChallengeAnsweredRequest* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API ChallengeAnsweredResponse : public ::google::protobuf::Message {
 public:
  ChallengeAnsweredResponse();
  virtual ~ChallengeAnsweredResponse();

  ChallengeAnsweredResponse(const ChallengeAnsweredResponse& from);

  inline ChallengeAnsweredResponse& operator=(const ChallengeAnsweredResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengeAnsweredResponse& default_instance();

  void Swap(ChallengeAnsweredResponse* other);

  // implements Message ----------------------------------------------

  ChallengeAnsweredResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChallengeAnsweredResponse& from);
  void MergeFrom(const ChallengeAnsweredResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional bool do_retry = 2;
  inline bool has_do_retry() const;
  inline void clear_do_retry();
  static const int kDoRetryFieldNumber = 2;
  inline bool do_retry() const;
  inline void set_do_retry(bool value);

  // optional bool record_not_found = 3;
  inline bool has_record_not_found() const;
  inline void clear_record_not_found();
  static const int kRecordNotFoundFieldNumber = 3;
  inline bool record_not_found() const;
  inline void set_record_not_found(bool value);

  // @@protoc_insertion_point(class_scope:bgs.protocol.challenge.v1.ChallengeAnsweredResponse)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_do_retry();
  inline void clear_has_do_retry();
  inline void set_has_record_not_found();
  inline void clear_has_record_not_found();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  bool do_retry_;
  bool record_not_found_;
  friend void TC_PROTO_API protobuf_AddDesc_challenge_5fservice_2eproto();
  friend void protobuf_AssignDesc_challenge_5fservice_2eproto();
  friend void protobuf_ShutdownFile_challenge_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ChallengeAnsweredResponse* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API ChallengeCancelledRequest : public ::google::protobuf::Message {
 public:
  ChallengeCancelledRequest();
  virtual ~ChallengeCancelledRequest();

  ChallengeCancelledRequest(const ChallengeCancelledRequest& from);

  inline ChallengeCancelledRequest& operator=(const ChallengeCancelledRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengeCancelledRequest& default_instance();

  void Swap(ChallengeCancelledRequest* other);

  // implements Message ----------------------------------------------

  ChallengeCancelledRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChallengeCancelledRequest& from);
  void MergeFrom(const ChallengeCancelledRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:bgs.protocol.challenge.v1.ChallengeCancelledRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  friend void TC_PROTO_API protobuf_AddDesc_challenge_5fservice_2eproto();
  friend void protobuf_AssignDesc_challenge_5fservice_2eproto();
  friend void protobuf_ShutdownFile_challenge_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ChallengeCancelledRequest* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API SendChallengeToUserRequest : public ::google::protobuf::Message {
 public:
  SendChallengeToUserRequest();
  virtual ~SendChallengeToUserRequest();

  SendChallengeToUserRequest(const SendChallengeToUserRequest& from);

  inline SendChallengeToUserRequest& operator=(const SendChallengeToUserRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendChallengeToUserRequest& default_instance();

  void Swap(SendChallengeToUserRequest* other);

  // implements Message ----------------------------------------------

  SendChallengeToUserRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendChallengeToUserRequest& from);
  void MergeFrom(const SendChallengeToUserRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bgs.protocol.ProcessId peer_id = 1;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 1;
  inline const ::bgs::protocol::ProcessId& peer_id() const;
  inline ::bgs::protocol::ProcessId* mutable_peer_id();
  inline ::bgs::protocol::ProcessId* release_peer_id();
  inline void set_allocated_peer_id(::bgs::protocol::ProcessId* peer_id);

  // optional .bgs.protocol.EntityId game_account_id = 2;
  inline bool has_game_account_id() const;
  inline void clear_game_account_id();
  static const int kGameAccountIdFieldNumber = 2;
  inline const ::bgs::protocol::EntityId& game_account_id() const;
  inline ::bgs::protocol::EntityId* mutable_game_account_id();
  inline ::bgs::protocol::EntityId* release_game_account_id();
  inline void set_allocated_game_account_id(::bgs::protocol::EntityId* game_account_id);

  // repeated .bgs.protocol.challenge.v1.Challenge challenges = 3;
  inline int challenges_size() const;
  inline void clear_challenges();
  static const int kChallengesFieldNumber = 3;
  inline const ::bgs::protocol::challenge::v1::Challenge& challenges(int index) const;
  inline ::bgs::protocol::challenge::v1::Challenge* mutable_challenges(int index);
  inline ::bgs::protocol::challenge::v1::Challenge* add_challenges();
  inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::challenge::v1::Challenge >&
      challenges() const;
  inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::challenge::v1::Challenge >*
      mutable_challenges();

  // required fixed32 context = 4;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 4;
  inline ::google::protobuf::uint32 context() const;
  inline void set_context(::google::protobuf::uint32 value);

  // optional uint64 timeout = 5;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 5;
  inline ::google::protobuf::uint64 timeout() const;
  inline void set_timeout(::google::protobuf::uint64 value);

  // repeated .bgs.protocol.Attribute attributes = 6;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 6;
  inline const ::bgs::protocol::Attribute& attributes(int index) const;
  inline ::bgs::protocol::Attribute* mutable_attributes(int index);
  inline ::bgs::protocol::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::Attribute >*
      mutable_attributes();

  // optional .bgs.protocol.ProcessId host = 7;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 7;
  inline const ::bgs::protocol::ProcessId& host() const;
  inline ::bgs::protocol::ProcessId* mutable_host();
  inline ::bgs::protocol::ProcessId* release_host();
  inline void set_allocated_host(::bgs::protocol::ProcessId* host);

  // optional .bgs.protocol.EntityId account_id = 8;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 8;
  inline const ::bgs::protocol::EntityId& account_id() const;
  inline ::bgs::protocol::EntityId* mutable_account_id();
  inline ::bgs::protocol::EntityId* release_account_id();
  inline void set_allocated_account_id(::bgs::protocol::EntityId* account_id);

  // @@protoc_insertion_point(class_scope:bgs.protocol.challenge.v1.SendChallengeToUserRequest)
 private:
  inline void set_has_peer_id();
  inline void clear_has_peer_id();
  inline void set_has_game_account_id();
  inline void clear_has_game_account_id();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_account_id();
  inline void clear_has_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::bgs::protocol::ProcessId* peer_id_;
  ::bgs::protocol::EntityId* game_account_id_;
  ::google::protobuf::RepeatedPtrField< ::bgs::protocol::challenge::v1::Challenge > challenges_;
  ::google::protobuf::uint64 timeout_;
  ::google::protobuf::RepeatedPtrField< ::bgs::protocol::Attribute > attributes_;
  ::bgs::protocol::ProcessId* host_;
  ::bgs::protocol::EntityId* account_id_;
  ::google::protobuf::uint32 context_;
  friend void TC_PROTO_API protobuf_AddDesc_challenge_5fservice_2eproto();
  friend void protobuf_AssignDesc_challenge_5fservice_2eproto();
  friend void protobuf_ShutdownFile_challenge_5fservice_2eproto();

  void InitAsDefaultInstance();
  static SendChallengeToUserRequest* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API SendChallengeToUserResponse : public ::google::protobuf::Message {
 public:
  SendChallengeToUserResponse();
  virtual ~SendChallengeToUserResponse();

  SendChallengeToUserResponse(const SendChallengeToUserResponse& from);

  inline SendChallengeToUserResponse& operator=(const SendChallengeToUserResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendChallengeToUserResponse& default_instance();

  void Swap(SendChallengeToUserResponse* other);

  // implements Message ----------------------------------------------

  SendChallengeToUserResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendChallengeToUserResponse& from);
  void MergeFrom(const SendChallengeToUserResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:bgs.protocol.challenge.v1.SendChallengeToUserResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  friend void TC_PROTO_API protobuf_AddDesc_challenge_5fservice_2eproto();
  friend void protobuf_AssignDesc_challenge_5fservice_2eproto();
  friend void protobuf_ShutdownFile_challenge_5fservice_2eproto();

  void InitAsDefaultInstance();
  static SendChallengeToUserResponse* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API ChallengeUserRequest : public ::google::protobuf::Message {
 public:
  ChallengeUserRequest();
  virtual ~ChallengeUserRequest();

  ChallengeUserRequest(const ChallengeUserRequest& from);

  inline ChallengeUserRequest& operator=(const ChallengeUserRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengeUserRequest& default_instance();

  void Swap(ChallengeUserRequest* other);

  // implements Message ----------------------------------------------

  ChallengeUserRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChallengeUserRequest& from);
  void MergeFrom(const ChallengeUserRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bgs.protocol.challenge.v1.Challenge challenges = 1;
  inline int challenges_size() const;
  inline void clear_challenges();
  static const int kChallengesFieldNumber = 1;
  inline const ::bgs::protocol::challenge::v1::Challenge& challenges(int index) const;
  inline ::bgs::protocol::challenge::v1::Challenge* mutable_challenges(int index);
  inline ::bgs::protocol::challenge::v1::Challenge* add_challenges();
  inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::challenge::v1::Challenge >&
      challenges() const;
  inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::challenge::v1::Challenge >*
      mutable_challenges();

  // required fixed32 context = 2;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 2;
  inline ::google::protobuf::uint32 context() const;
  inline void set_context(::google::protobuf::uint32 value);

  // optional uint32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint64 deadline = 4;
  inline bool has_deadline() const;
  inline void clear_deadline();
  static const int kDeadlineFieldNumber = 4;
  inline ::google::protobuf::uint64 deadline() const;
  inline void set_deadline(::google::protobuf::uint64 value);

  // repeated .bgs.protocol.Attribute attributes = 5;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  inline const ::bgs::protocol::Attribute& attributes(int index) const;
  inline ::bgs::protocol::Attribute* mutable_attributes(int index);
  inline ::bgs::protocol::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::Attribute >*
      mutable_attributes();

  // optional .bgs.protocol.EntityId game_account_id = 6;
  inline bool has_game_account_id() const;
  inline void clear_game_account_id();
  static const int kGameAccountIdFieldNumber = 6;
  inline const ::bgs::protocol::EntityId& game_account_id() const;
  inline ::bgs::protocol::EntityId* mutable_game_account_id();
  inline ::bgs::protocol::EntityId* release_game_account_id();
  inline void set_allocated_game_account_id(::bgs::protocol::EntityId* game_account_id);

  // @@protoc_insertion_point(class_scope:bgs.protocol.challenge.v1.ChallengeUserRequest)
 private:
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_deadline();
  inline void clear_has_deadline();
  inline void set_has_game_account_id();
  inline void clear_has_game_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::bgs::protocol::challenge::v1::Challenge > challenges_;
  ::google::protobuf::uint32 context_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint64 deadline_;
  ::google::protobuf::RepeatedPtrField< ::bgs::protocol::Attribute > attributes_;
  ::bgs::protocol::EntityId* game_account_id_;
  friend void TC_PROTO_API protobuf_AddDesc_challenge_5fservice_2eproto();
  friend void protobuf_AssignDesc_challenge_5fservice_2eproto();
  friend void protobuf_ShutdownFile_challenge_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ChallengeUserRequest* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API ChallengeResultRequest : public ::google::protobuf::Message {
 public:
  ChallengeResultRequest();
  virtual ~ChallengeResultRequest();

  ChallengeResultRequest(const ChallengeResultRequest& from);

  inline ChallengeResultRequest& operator=(const ChallengeResultRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengeResultRequest& default_instance();

  void Swap(ChallengeResultRequest* other);

  // implements Message ----------------------------------------------

  ChallengeResultRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChallengeResultRequest& from);
  void MergeFrom(const ChallengeResultRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional fixed32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 error_id = 3;
  inline bool has_error_id() const;
  inline void clear_error_id();
  static const int kErrorIdFieldNumber = 3;
  inline ::google::protobuf::uint32 error_id() const;
  inline void set_error_id(::google::protobuf::uint32 value);

  // optional bytes answer = 4;
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 4;
  inline const ::std::string& answer() const;
  inline void set_answer(const ::std::string& value);
  inline void set_answer(const char* value);
  inline void set_answer(const void* value, size_t size);
  inline ::std::string* mutable_answer();
  inline ::std::string* release_answer();
  inline void set_allocated_answer(::std::string* answer);

  // @@protoc_insertion_point(class_scope:bgs.protocol.challenge.v1.ChallengeResultRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_error_id();
  inline void clear_has_error_id();
  inline void set_has_answer();
  inline void clear_has_answer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 type_;
  ::std::string* answer_;
  ::google::protobuf::uint32 error_id_;
  friend void TC_PROTO_API protobuf_AddDesc_challenge_5fservice_2eproto();
  friend void protobuf_AssignDesc_challenge_5fservice_2eproto();
  friend void protobuf_ShutdownFile_challenge_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ChallengeResultRequest* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API ChallengeExternalRequest : public ::google::protobuf::Message {
 public:
  ChallengeExternalRequest();
  virtual ~ChallengeExternalRequest();

  ChallengeExternalRequest(const ChallengeExternalRequest& from);

  inline ChallengeExternalRequest& operator=(const ChallengeExternalRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengeExternalRequest& default_instance();

  void Swap(ChallengeExternalRequest* other);

  // implements Message ----------------------------------------------

  ChallengeExternalRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChallengeExternalRequest& from);
  void MergeFrom(const ChallengeExternalRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string request_token = 1;
  inline bool has_request_token() const;
  inline void clear_request_token();
  static const int kRequestTokenFieldNumber = 1;
  inline const ::std::string& request_token() const;
  inline void set_request_token(const ::std::string& value);
  inline void set_request_token(const char* value);
  inline void set_request_token(const char* value, size_t size);
  inline ::std::string* mutable_request_token();
  inline ::std::string* release_request_token();
  inline void set_allocated_request_token(::std::string* request_token);

  // optional string payload_type = 2;
  inline bool has_payload_type() const;
  inline void clear_payload_type();
  static const int kPayloadTypeFieldNumber = 2;
  inline const ::std::string& payload_type() const;
  inline void set_payload_type(const ::std::string& value);
  inline void set_payload_type(const char* value);
  inline void set_payload_type(const char* value, size_t size);
  inline ::std::string* mutable_payload_type();
  inline ::std::string* release_payload_type();
  inline void set_allocated_payload_type(::std::string* payload_type);

  // optional bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:bgs.protocol.challenge.v1.ChallengeExternalRequest)
 private:
  inline void set_has_request_token();
  inline void clear_has_request_token();
  inline void set_has_payload_type();
  inline void clear_has_payload_type();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* request_token_;
  ::std::string* payload_type_;
  ::std::string* payload_;
  friend void TC_PROTO_API protobuf_AddDesc_challenge_5fservice_2eproto();
  friend void protobuf_AssignDesc_challenge_5fservice_2eproto();
  friend void protobuf_ShutdownFile_challenge_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ChallengeExternalRequest* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API ChallengeExternalResult : public ::google::protobuf::Message {
 public:
  ChallengeExternalResult();
  virtual ~ChallengeExternalResult();

  ChallengeExternalResult(const ChallengeExternalResult& from);

  inline ChallengeExternalResult& operator=(const ChallengeExternalResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengeExternalResult& default_instance();

  void Swap(ChallengeExternalResult* other);

  // implements Message ----------------------------------------------

  ChallengeExternalResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChallengeExternalResult& from);
  void MergeFrom(const ChallengeExternalResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string request_token = 1;
  inline bool has_request_token() const;
  inline void clear_request_token();
  static const int kRequestTokenFieldNumber = 1;
  inline const ::std::string& request_token() const;
  inline void set_request_token(const ::std::string& value);
  inline void set_request_token(const char* value);
  inline void set_request_token(const char* value, size_t size);
  inline ::std::string* mutable_request_token();
  inline ::std::string* release_request_token();
  inline void set_allocated_request_token(::std::string* request_token);

  // optional bool passed = 2 [default = true];
  inline bool has_passed() const;
  inline void clear_passed();
  static const int kPassedFieldNumber = 2;
  inline bool passed() const;
  inline void set_passed(bool value);

  // @@protoc_insertion_point(class_scope:bgs.protocol.challenge.v1.ChallengeExternalResult)
 private:
  inline void set_has_request_token();
  inline void clear_has_request_token();
  inline void set_has_passed();
  inline void clear_has_passed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* request_token_;
  bool passed_;
  friend void TC_PROTO_API protobuf_AddDesc_challenge_5fservice_2eproto();
  friend void protobuf_AssignDesc_challenge_5fservice_2eproto();
  friend void protobuf_ShutdownFile_challenge_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ChallengeExternalResult* default_instance_;
};
// ===================================================================

class TC_PROTO_API ChallengeService : public ServiceBase
{
 public:

  explicit ChallengeService(bool use_original_hash);
  virtual ~ChallengeService();

  typedef std::integral_constant<uint32, 0xDBBF6F19u> OriginalHash;
  typedef std::integral_constant<uint32, 0x71BB6833u> NameHash;

  static google::protobuf::ServiceDescriptor const* descriptor();

  // client methods --------------------------------------------------

  void ChallengePicked(::bgs::protocol::challenge::v1::ChallengePickedRequest const* request, std::function<void(::bgs::protocol::challenge::v1::ChallengePickedResponse const*)> responseCallback);
  void ChallengeAnswered(::bgs::protocol::challenge::v1::ChallengeAnsweredRequest const* request, std::function<void(::bgs::protocol::challenge::v1::ChallengeAnsweredResponse const*)> responseCallback);
  void ChallengeCancelled(::bgs::protocol::challenge::v1::ChallengeCancelledRequest const* request, std::function<void(::bgs::protocol::NoData const*)> responseCallback);
  void SendChallengeToUser(::bgs::protocol::challenge::v1::SendChallengeToUserRequest const* request, std::function<void(::bgs::protocol::challenge::v1::SendChallengeToUserResponse const*)> responseCallback);
  // server methods --------------------------------------------------

  void CallServerMethod(uint32 token, uint32 methodId, MessageBuffer buffer) override final;

 protected:
  virtual uint32 HandleChallengePicked(::bgs::protocol::challenge::v1::ChallengePickedRequest const* request, ::bgs::protocol::challenge::v1::ChallengePickedResponse* response, std::function<void(ServiceBase*, uint32, ::google::protobuf::Message const*)>& continuation);
  virtual uint32 HandleChallengeAnswered(::bgs::protocol::challenge::v1::ChallengeAnsweredRequest const* request, ::bgs::protocol::challenge::v1::ChallengeAnsweredResponse* response, std::function<void(ServiceBase*, uint32, ::google::protobuf::Message const*)>& continuation);
  virtual uint32 HandleChallengeCancelled(::bgs::protocol::challenge::v1::ChallengeCancelledRequest const* request, ::bgs::protocol::NoData* response, std::function<void(ServiceBase*, uint32, ::google::protobuf::Message const*)>& continuation);
  virtual uint32 HandleSendChallengeToUser(::bgs::protocol::challenge::v1::SendChallengeToUserRequest const* request, ::bgs::protocol::challenge::v1::SendChallengeToUserResponse* response, std::function<void(ServiceBase*, uint32, ::google::protobuf::Message const*)>& continuation);

 private:
  uint32 service_hash_;

  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ChallengeService);
};

// -------------------------------------------------------------------

class TC_PROTO_API ChallengeListener : public ServiceBase
{
 public:

  explicit ChallengeListener(bool use_original_hash);
  virtual ~ChallengeListener();

  typedef std::integral_constant<uint32, 0xBBDA171Fu> OriginalHash;
  typedef std::integral_constant<uint32, 0xC6D90AB8u> NameHash;

  static google::protobuf::ServiceDescriptor const* descriptor();

  // client methods --------------------------------------------------

  void OnChallengeUser(::bgs::protocol::challenge::v1::ChallengeUserRequest const* request);
  void OnChallengeResult(::bgs::protocol::challenge::v1::ChallengeResultRequest const* request);
  void OnExternalChallenge(::bgs::protocol::challenge::v1::ChallengeExternalRequest const* request);
  void OnExternalChallengeResult(::bgs::protocol::challenge::v1::ChallengeExternalResult const* request);
  // server methods --------------------------------------------------

  void CallServerMethod(uint32 token, uint32 methodId, MessageBuffer buffer) override final;

 protected:
  virtual uint32 HandleOnChallengeUser(::bgs::protocol::challenge::v1::ChallengeUserRequest const* request);
  virtual uint32 HandleOnChallengeResult(::bgs::protocol::challenge::v1::ChallengeResultRequest const* request);
  virtual uint32 HandleOnExternalChallenge(::bgs::protocol::challenge::v1::ChallengeExternalRequest const* request);
  virtual uint32 HandleOnExternalChallengeResult(::bgs::protocol::challenge::v1::ChallengeExternalResult const* request);

 private:
  uint32 service_hash_;

  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ChallengeListener);
};

// ===================================================================


// ===================================================================

// Challenge

// required fixed32 type = 1;
inline bool Challenge::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Challenge::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Challenge::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Challenge::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Challenge::type() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.Challenge.type)
  return type_;
}
inline void Challenge::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.Challenge.type)
}

// optional string info = 2;
inline bool Challenge::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Challenge::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Challenge::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Challenge::clear_info() {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& Challenge::info() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.Challenge.info)
  return *info_;
}
inline void Challenge::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.Challenge.info)
}
inline void Challenge::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.challenge.v1.Challenge.info)
}
inline void Challenge::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.challenge.v1.Challenge.info)
}
inline ::std::string* Challenge::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.Challenge.info)
  return info_;
}
inline ::std::string* Challenge::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Challenge::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.Challenge.info)
}

// optional string answer = 3;
inline bool Challenge::has_answer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Challenge::set_has_answer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Challenge::clear_has_answer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Challenge::clear_answer() {
  if (answer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_->clear();
  }
  clear_has_answer();
}
inline const ::std::string& Challenge::answer() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.Challenge.answer)
  return *answer_;
}
inline void Challenge::set_answer(const ::std::string& value) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.Challenge.answer)
}
inline void Challenge::set_answer(const char* value) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.challenge.v1.Challenge.answer)
}
inline void Challenge::set_answer(const char* value, size_t size) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_ = new ::std::string;
  }
  answer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.challenge.v1.Challenge.answer)
}
inline ::std::string* Challenge::mutable_answer() {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.Challenge.answer)
  return answer_;
}
inline ::std::string* Challenge::release_answer() {
  clear_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = answer_;
    answer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Challenge::set_allocated_answer(::std::string* answer) {
  if (answer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete answer_;
  }
  if (answer) {
    set_has_answer();
    answer_ = answer;
  } else {
    clear_has_answer();
    answer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.Challenge.answer)
}

// optional uint32 retries = 4;
inline bool Challenge::has_retries() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Challenge::set_has_retries() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Challenge::clear_has_retries() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Challenge::clear_retries() {
  retries_ = 0u;
  clear_has_retries();
}
inline ::google::protobuf::uint32 Challenge::retries() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.Challenge.retries)
  return retries_;
}
inline void Challenge::set_retries(::google::protobuf::uint32 value) {
  set_has_retries();
  retries_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.Challenge.retries)
}

// -------------------------------------------------------------------

// ChallengePickedRequest

// required fixed32 challenge = 1;
inline bool ChallengePickedRequest::has_challenge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChallengePickedRequest::set_has_challenge() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChallengePickedRequest::clear_has_challenge() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChallengePickedRequest::clear_challenge() {
  challenge_ = 0u;
  clear_has_challenge();
}
inline ::google::protobuf::uint32 ChallengePickedRequest::challenge() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengePickedRequest.challenge)
  return challenge_;
}
inline void ChallengePickedRequest::set_challenge(::google::protobuf::uint32 value) {
  set_has_challenge();
  challenge_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengePickedRequest.challenge)
}

// optional uint32 id = 2;
inline bool ChallengePickedRequest::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChallengePickedRequest::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChallengePickedRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChallengePickedRequest::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ChallengePickedRequest::id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengePickedRequest.id)
  return id_;
}
inline void ChallengePickedRequest::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengePickedRequest.id)
}

// optional bool new_challenge_protocol = 3 [default = false];
inline bool ChallengePickedRequest::has_new_challenge_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChallengePickedRequest::set_has_new_challenge_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChallengePickedRequest::clear_has_new_challenge_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChallengePickedRequest::clear_new_challenge_protocol() {
  new_challenge_protocol_ = false;
  clear_has_new_challenge_protocol();
}
inline bool ChallengePickedRequest::new_challenge_protocol() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengePickedRequest.new_challenge_protocol)
  return new_challenge_protocol_;
}
inline void ChallengePickedRequest::set_new_challenge_protocol(bool value) {
  set_has_new_challenge_protocol();
  new_challenge_protocol_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengePickedRequest.new_challenge_protocol)
}

// -------------------------------------------------------------------

// ChallengePickedResponse

// optional bytes data = 1;
inline bool ChallengePickedResponse::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChallengePickedResponse::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChallengePickedResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChallengePickedResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ChallengePickedResponse::data() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengePickedResponse.data)
  return *data_;
}
inline void ChallengePickedResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengePickedResponse.data)
}
inline void ChallengePickedResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.challenge.v1.ChallengePickedResponse.data)
}
inline void ChallengePickedResponse::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.challenge.v1.ChallengePickedResponse.data)
}
inline ::std::string* ChallengePickedResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.ChallengePickedResponse.data)
  return data_;
}
inline ::std::string* ChallengePickedResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChallengePickedResponse::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.ChallengePickedResponse.data)
}

// -------------------------------------------------------------------

// ChallengeAnsweredRequest

// required string answer = 1;
inline bool ChallengeAnsweredRequest::has_answer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChallengeAnsweredRequest::set_has_answer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChallengeAnsweredRequest::clear_has_answer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChallengeAnsweredRequest::clear_answer() {
  if (answer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_->clear();
  }
  clear_has_answer();
}
inline const ::std::string& ChallengeAnsweredRequest::answer() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.answer)
  return *answer_;
}
inline void ChallengeAnsweredRequest::set_answer(const ::std::string& value) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.answer)
}
inline void ChallengeAnsweredRequest::set_answer(const char* value) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.answer)
}
inline void ChallengeAnsweredRequest::set_answer(const char* value, size_t size) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_ = new ::std::string;
  }
  answer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.answer)
}
inline ::std::string* ChallengeAnsweredRequest::mutable_answer() {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.answer)
  return answer_;
}
inline ::std::string* ChallengeAnsweredRequest::release_answer() {
  clear_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = answer_;
    answer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChallengeAnsweredRequest::set_allocated_answer(::std::string* answer) {
  if (answer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete answer_;
  }
  if (answer) {
    set_has_answer();
    answer_ = answer;
  } else {
    clear_has_answer();
    answer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.answer)
}

// optional bytes data = 2;
inline bool ChallengeAnsweredRequest::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChallengeAnsweredRequest::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChallengeAnsweredRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChallengeAnsweredRequest::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ChallengeAnsweredRequest::data() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.data)
  return *data_;
}
inline void ChallengeAnsweredRequest::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.data)
}
inline void ChallengeAnsweredRequest::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.data)
}
inline void ChallengeAnsweredRequest::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.data)
}
inline ::std::string* ChallengeAnsweredRequest::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.data)
  return data_;
}
inline ::std::string* ChallengeAnsweredRequest::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChallengeAnsweredRequest::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.data)
}

// optional uint32 id = 3;
inline bool ChallengeAnsweredRequest::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChallengeAnsweredRequest::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChallengeAnsweredRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChallengeAnsweredRequest::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ChallengeAnsweredRequest::id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.id)
  return id_;
}
inline void ChallengeAnsweredRequest::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeAnsweredRequest.id)
}

// -------------------------------------------------------------------

// ChallengeAnsweredResponse

// optional bytes data = 1;
inline bool ChallengeAnsweredResponse::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChallengeAnsweredResponse::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChallengeAnsweredResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChallengeAnsweredResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ChallengeAnsweredResponse::data() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeAnsweredResponse.data)
  return *data_;
}
inline void ChallengeAnsweredResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeAnsweredResponse.data)
}
inline void ChallengeAnsweredResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.challenge.v1.ChallengeAnsweredResponse.data)
}
inline void ChallengeAnsweredResponse::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.challenge.v1.ChallengeAnsweredResponse.data)
}
inline ::std::string* ChallengeAnsweredResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.ChallengeAnsweredResponse.data)
  return data_;
}
inline ::std::string* ChallengeAnsweredResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChallengeAnsweredResponse::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.ChallengeAnsweredResponse.data)
}

// optional bool do_retry = 2;
inline bool ChallengeAnsweredResponse::has_do_retry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChallengeAnsweredResponse::set_has_do_retry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChallengeAnsweredResponse::clear_has_do_retry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChallengeAnsweredResponse::clear_do_retry() {
  do_retry_ = false;
  clear_has_do_retry();
}
inline bool ChallengeAnsweredResponse::do_retry() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeAnsweredResponse.do_retry)
  return do_retry_;
}
inline void ChallengeAnsweredResponse::set_do_retry(bool value) {
  set_has_do_retry();
  do_retry_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeAnsweredResponse.do_retry)
}

// optional bool record_not_found = 3;
inline bool ChallengeAnsweredResponse::has_record_not_found() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChallengeAnsweredResponse::set_has_record_not_found() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChallengeAnsweredResponse::clear_has_record_not_found() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChallengeAnsweredResponse::clear_record_not_found() {
  record_not_found_ = false;
  clear_has_record_not_found();
}
inline bool ChallengeAnsweredResponse::record_not_found() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeAnsweredResponse.record_not_found)
  return record_not_found_;
}
inline void ChallengeAnsweredResponse::set_record_not_found(bool value) {
  set_has_record_not_found();
  record_not_found_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeAnsweredResponse.record_not_found)
}

// -------------------------------------------------------------------

// ChallengeCancelledRequest

// optional uint32 id = 1;
inline bool ChallengeCancelledRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChallengeCancelledRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChallengeCancelledRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChallengeCancelledRequest::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ChallengeCancelledRequest::id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeCancelledRequest.id)
  return id_;
}
inline void ChallengeCancelledRequest::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeCancelledRequest.id)
}

// -------------------------------------------------------------------

// SendChallengeToUserRequest

// optional .bgs.protocol.ProcessId peer_id = 1;
inline bool SendChallengeToUserRequest::has_peer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendChallengeToUserRequest::set_has_peer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendChallengeToUserRequest::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendChallengeToUserRequest::clear_peer_id() {
  if (peer_id_ != NULL) peer_id_->::bgs::protocol::ProcessId::Clear();
  clear_has_peer_id();
}
inline const ::bgs::protocol::ProcessId& SendChallengeToUserRequest::peer_id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.SendChallengeToUserRequest.peer_id)
  return peer_id_ != NULL ? *peer_id_ : *default_instance_->peer_id_;
}
inline ::bgs::protocol::ProcessId* SendChallengeToUserRequest::mutable_peer_id() {
  set_has_peer_id();
  if (peer_id_ == NULL) peer_id_ = new ::bgs::protocol::ProcessId;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.SendChallengeToUserRequest.peer_id)
  return peer_id_;
}
inline ::bgs::protocol::ProcessId* SendChallengeToUserRequest::release_peer_id() {
  clear_has_peer_id();
  ::bgs::protocol::ProcessId* temp = peer_id_;
  peer_id_ = NULL;
  return temp;
}
inline void SendChallengeToUserRequest::set_allocated_peer_id(::bgs::protocol::ProcessId* peer_id) {
  delete peer_id_;
  peer_id_ = peer_id;
  if (peer_id) {
    set_has_peer_id();
  } else {
    clear_has_peer_id();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.SendChallengeToUserRequest.peer_id)
}

// optional .bgs.protocol.EntityId game_account_id = 2;
inline bool SendChallengeToUserRequest::has_game_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendChallengeToUserRequest::set_has_game_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendChallengeToUserRequest::clear_has_game_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendChallengeToUserRequest::clear_game_account_id() {
  if (game_account_id_ != NULL) game_account_id_->::bgs::protocol::EntityId::Clear();
  clear_has_game_account_id();
}
inline const ::bgs::protocol::EntityId& SendChallengeToUserRequest::game_account_id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.SendChallengeToUserRequest.game_account_id)
  return game_account_id_ != NULL ? *game_account_id_ : *default_instance_->game_account_id_;
}
inline ::bgs::protocol::EntityId* SendChallengeToUserRequest::mutable_game_account_id() {
  set_has_game_account_id();
  if (game_account_id_ == NULL) game_account_id_ = new ::bgs::protocol::EntityId;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.SendChallengeToUserRequest.game_account_id)
  return game_account_id_;
}
inline ::bgs::protocol::EntityId* SendChallengeToUserRequest::release_game_account_id() {
  clear_has_game_account_id();
  ::bgs::protocol::EntityId* temp = game_account_id_;
  game_account_id_ = NULL;
  return temp;
}
inline void SendChallengeToUserRequest::set_allocated_game_account_id(::bgs::protocol::EntityId* game_account_id) {
  delete game_account_id_;
  game_account_id_ = game_account_id;
  if (game_account_id) {
    set_has_game_account_id();
  } else {
    clear_has_game_account_id();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.SendChallengeToUserRequest.game_account_id)
}

// repeated .bgs.protocol.challenge.v1.Challenge challenges = 3;
inline int SendChallengeToUserRequest::challenges_size() const {
  return challenges_.size();
}
inline void SendChallengeToUserRequest::clear_challenges() {
  challenges_.Clear();
}
inline const ::bgs::protocol::challenge::v1::Challenge& SendChallengeToUserRequest::challenges(int index) const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.SendChallengeToUserRequest.challenges)
  return challenges_.Get(index);
}
inline ::bgs::protocol::challenge::v1::Challenge* SendChallengeToUserRequest::mutable_challenges(int index) {
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.SendChallengeToUserRequest.challenges)
  return challenges_.Mutable(index);
}
inline ::bgs::protocol::challenge::v1::Challenge* SendChallengeToUserRequest::add_challenges() {
  // @@protoc_insertion_point(field_add:bgs.protocol.challenge.v1.SendChallengeToUserRequest.challenges)
  return challenges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::challenge::v1::Challenge >&
SendChallengeToUserRequest::challenges() const {
  // @@protoc_insertion_point(field_list:bgs.protocol.challenge.v1.SendChallengeToUserRequest.challenges)
  return challenges_;
}
inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::challenge::v1::Challenge >*
SendChallengeToUserRequest::mutable_challenges() {
  // @@protoc_insertion_point(field_mutable_list:bgs.protocol.challenge.v1.SendChallengeToUserRequest.challenges)
  return &challenges_;
}

// required fixed32 context = 4;
inline bool SendChallengeToUserRequest::has_context() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendChallengeToUserRequest::set_has_context() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendChallengeToUserRequest::clear_has_context() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendChallengeToUserRequest::clear_context() {
  context_ = 0u;
  clear_has_context();
}
inline ::google::protobuf::uint32 SendChallengeToUserRequest::context() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.SendChallengeToUserRequest.context)
  return context_;
}
inline void SendChallengeToUserRequest::set_context(::google::protobuf::uint32 value) {
  set_has_context();
  context_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.SendChallengeToUserRequest.context)
}

// optional uint64 timeout = 5;
inline bool SendChallengeToUserRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SendChallengeToUserRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SendChallengeToUserRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SendChallengeToUserRequest::clear_timeout() {
  timeout_ = GOOGLE_ULONGLONG(0);
  clear_has_timeout();
}
inline ::google::protobuf::uint64 SendChallengeToUserRequest::timeout() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.SendChallengeToUserRequest.timeout)
  return timeout_;
}
inline void SendChallengeToUserRequest::set_timeout(::google::protobuf::uint64 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.SendChallengeToUserRequest.timeout)
}

// repeated .bgs.protocol.Attribute attributes = 6;
inline int SendChallengeToUserRequest::attributes_size() const {
  return attributes_.size();
}
inline void SendChallengeToUserRequest::clear_attributes() {
  attributes_.Clear();
}
inline const ::bgs::protocol::Attribute& SendChallengeToUserRequest::attributes(int index) const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.SendChallengeToUserRequest.attributes)
  return attributes_.Get(index);
}
inline ::bgs::protocol::Attribute* SendChallengeToUserRequest::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.SendChallengeToUserRequest.attributes)
  return attributes_.Mutable(index);
}
inline ::bgs::protocol::Attribute* SendChallengeToUserRequest::add_attributes() {
  // @@protoc_insertion_point(field_add:bgs.protocol.challenge.v1.SendChallengeToUserRequest.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::Attribute >&
SendChallengeToUserRequest::attributes() const {
  // @@protoc_insertion_point(field_list:bgs.protocol.challenge.v1.SendChallengeToUserRequest.attributes)
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::Attribute >*
SendChallengeToUserRequest::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:bgs.protocol.challenge.v1.SendChallengeToUserRequest.attributes)
  return &attributes_;
}

// optional .bgs.protocol.ProcessId host = 7;
inline bool SendChallengeToUserRequest::has_host() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SendChallengeToUserRequest::set_has_host() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SendChallengeToUserRequest::clear_has_host() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SendChallengeToUserRequest::clear_host() {
  if (host_ != NULL) host_->::bgs::protocol::ProcessId::Clear();
  clear_has_host();
}
inline const ::bgs::protocol::ProcessId& SendChallengeToUserRequest::host() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.SendChallengeToUserRequest.host)
  return host_ != NULL ? *host_ : *default_instance_->host_;
}
inline ::bgs::protocol::ProcessId* SendChallengeToUserRequest::mutable_host() {
  set_has_host();
  if (host_ == NULL) host_ = new ::bgs::protocol::ProcessId;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.SendChallengeToUserRequest.host)
  return host_;
}
inline ::bgs::protocol::ProcessId* SendChallengeToUserRequest::release_host() {
  clear_has_host();
  ::bgs::protocol::ProcessId* temp = host_;
  host_ = NULL;
  return temp;
}
inline void SendChallengeToUserRequest::set_allocated_host(::bgs::protocol::ProcessId* host) {
  delete host_;
  host_ = host;
  if (host) {
    set_has_host();
  } else {
    clear_has_host();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.SendChallengeToUserRequest.host)
}

// optional .bgs.protocol.EntityId account_id = 8;
inline bool SendChallengeToUserRequest::has_account_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SendChallengeToUserRequest::set_has_account_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SendChallengeToUserRequest::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SendChallengeToUserRequest::clear_account_id() {
  if (account_id_ != NULL) account_id_->::bgs::protocol::EntityId::Clear();
  clear_has_account_id();
}
inline const ::bgs::protocol::EntityId& SendChallengeToUserRequest::account_id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.SendChallengeToUserRequest.account_id)
  return account_id_ != NULL ? *account_id_ : *default_instance_->account_id_;
}
inline ::bgs::protocol::EntityId* SendChallengeToUserRequest::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == NULL) account_id_ = new ::bgs::protocol::EntityId;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.SendChallengeToUserRequest.account_id)
  return account_id_;
}
inline ::bgs::protocol::EntityId* SendChallengeToUserRequest::release_account_id() {
  clear_has_account_id();
  ::bgs::protocol::EntityId* temp = account_id_;
  account_id_ = NULL;
  return temp;
}
inline void SendChallengeToUserRequest::set_allocated_account_id(::bgs::protocol::EntityId* account_id) {
  delete account_id_;
  account_id_ = account_id;
  if (account_id) {
    set_has_account_id();
  } else {
    clear_has_account_id();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.SendChallengeToUserRequest.account_id)
}

// -------------------------------------------------------------------

// SendChallengeToUserResponse

// optional uint32 id = 1;
inline bool SendChallengeToUserResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendChallengeToUserResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendChallengeToUserResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendChallengeToUserResponse::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 SendChallengeToUserResponse::id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.SendChallengeToUserResponse.id)
  return id_;
}
inline void SendChallengeToUserResponse::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.SendChallengeToUserResponse.id)
}

// -------------------------------------------------------------------

// ChallengeUserRequest

// repeated .bgs.protocol.challenge.v1.Challenge challenges = 1;
inline int ChallengeUserRequest::challenges_size() const {
  return challenges_.size();
}
inline void ChallengeUserRequest::clear_challenges() {
  challenges_.Clear();
}
inline const ::bgs::protocol::challenge::v1::Challenge& ChallengeUserRequest::challenges(int index) const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeUserRequest.challenges)
  return challenges_.Get(index);
}
inline ::bgs::protocol::challenge::v1::Challenge* ChallengeUserRequest::mutable_challenges(int index) {
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.ChallengeUserRequest.challenges)
  return challenges_.Mutable(index);
}
inline ::bgs::protocol::challenge::v1::Challenge* ChallengeUserRequest::add_challenges() {
  // @@protoc_insertion_point(field_add:bgs.protocol.challenge.v1.ChallengeUserRequest.challenges)
  return challenges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::challenge::v1::Challenge >&
ChallengeUserRequest::challenges() const {
  // @@protoc_insertion_point(field_list:bgs.protocol.challenge.v1.ChallengeUserRequest.challenges)
  return challenges_;
}
inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::challenge::v1::Challenge >*
ChallengeUserRequest::mutable_challenges() {
  // @@protoc_insertion_point(field_mutable_list:bgs.protocol.challenge.v1.ChallengeUserRequest.challenges)
  return &challenges_;
}

// required fixed32 context = 2;
inline bool ChallengeUserRequest::has_context() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChallengeUserRequest::set_has_context() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChallengeUserRequest::clear_has_context() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChallengeUserRequest::clear_context() {
  context_ = 0u;
  clear_has_context();
}
inline ::google::protobuf::uint32 ChallengeUserRequest::context() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeUserRequest.context)
  return context_;
}
inline void ChallengeUserRequest::set_context(::google::protobuf::uint32 value) {
  set_has_context();
  context_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeUserRequest.context)
}

// optional uint32 id = 3;
inline bool ChallengeUserRequest::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChallengeUserRequest::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChallengeUserRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChallengeUserRequest::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ChallengeUserRequest::id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeUserRequest.id)
  return id_;
}
inline void ChallengeUserRequest::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeUserRequest.id)
}

// optional uint64 deadline = 4;
inline bool ChallengeUserRequest::has_deadline() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChallengeUserRequest::set_has_deadline() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChallengeUserRequest::clear_has_deadline() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChallengeUserRequest::clear_deadline() {
  deadline_ = GOOGLE_ULONGLONG(0);
  clear_has_deadline();
}
inline ::google::protobuf::uint64 ChallengeUserRequest::deadline() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeUserRequest.deadline)
  return deadline_;
}
inline void ChallengeUserRequest::set_deadline(::google::protobuf::uint64 value) {
  set_has_deadline();
  deadline_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeUserRequest.deadline)
}

// repeated .bgs.protocol.Attribute attributes = 5;
inline int ChallengeUserRequest::attributes_size() const {
  return attributes_.size();
}
inline void ChallengeUserRequest::clear_attributes() {
  attributes_.Clear();
}
inline const ::bgs::protocol::Attribute& ChallengeUserRequest::attributes(int index) const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeUserRequest.attributes)
  return attributes_.Get(index);
}
inline ::bgs::protocol::Attribute* ChallengeUserRequest::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.ChallengeUserRequest.attributes)
  return attributes_.Mutable(index);
}
inline ::bgs::protocol::Attribute* ChallengeUserRequest::add_attributes() {
  // @@protoc_insertion_point(field_add:bgs.protocol.challenge.v1.ChallengeUserRequest.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::Attribute >&
ChallengeUserRequest::attributes() const {
  // @@protoc_insertion_point(field_list:bgs.protocol.challenge.v1.ChallengeUserRequest.attributes)
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::Attribute >*
ChallengeUserRequest::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:bgs.protocol.challenge.v1.ChallengeUserRequest.attributes)
  return &attributes_;
}

// optional .bgs.protocol.EntityId game_account_id = 6;
inline bool ChallengeUserRequest::has_game_account_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChallengeUserRequest::set_has_game_account_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChallengeUserRequest::clear_has_game_account_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChallengeUserRequest::clear_game_account_id() {
  if (game_account_id_ != NULL) game_account_id_->::bgs::protocol::EntityId::Clear();
  clear_has_game_account_id();
}
inline const ::bgs::protocol::EntityId& ChallengeUserRequest::game_account_id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeUserRequest.game_account_id)
  return game_account_id_ != NULL ? *game_account_id_ : *default_instance_->game_account_id_;
}
inline ::bgs::protocol::EntityId* ChallengeUserRequest::mutable_game_account_id() {
  set_has_game_account_id();
  if (game_account_id_ == NULL) game_account_id_ = new ::bgs::protocol::EntityId;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.ChallengeUserRequest.game_account_id)
  return game_account_id_;
}
inline ::bgs::protocol::EntityId* ChallengeUserRequest::release_game_account_id() {
  clear_has_game_account_id();
  ::bgs::protocol::EntityId* temp = game_account_id_;
  game_account_id_ = NULL;
  return temp;
}
inline void ChallengeUserRequest::set_allocated_game_account_id(::bgs::protocol::EntityId* game_account_id) {
  delete game_account_id_;
  game_account_id_ = game_account_id;
  if (game_account_id) {
    set_has_game_account_id();
  } else {
    clear_has_game_account_id();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.ChallengeUserRequest.game_account_id)
}

// -------------------------------------------------------------------

// ChallengeResultRequest

// optional uint32 id = 1;
inline bool ChallengeResultRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChallengeResultRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChallengeResultRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChallengeResultRequest::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ChallengeResultRequest::id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeResultRequest.id)
  return id_;
}
inline void ChallengeResultRequest::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeResultRequest.id)
}

// optional fixed32 type = 2;
inline bool ChallengeResultRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChallengeResultRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChallengeResultRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChallengeResultRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ChallengeResultRequest::type() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeResultRequest.type)
  return type_;
}
inline void ChallengeResultRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeResultRequest.type)
}

// optional uint32 error_id = 3;
inline bool ChallengeResultRequest::has_error_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChallengeResultRequest::set_has_error_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChallengeResultRequest::clear_has_error_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChallengeResultRequest::clear_error_id() {
  error_id_ = 0u;
  clear_has_error_id();
}
inline ::google::protobuf::uint32 ChallengeResultRequest::error_id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeResultRequest.error_id)
  return error_id_;
}
inline void ChallengeResultRequest::set_error_id(::google::protobuf::uint32 value) {
  set_has_error_id();
  error_id_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeResultRequest.error_id)
}

// optional bytes answer = 4;
inline bool ChallengeResultRequest::has_answer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChallengeResultRequest::set_has_answer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChallengeResultRequest::clear_has_answer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChallengeResultRequest::clear_answer() {
  if (answer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_->clear();
  }
  clear_has_answer();
}
inline const ::std::string& ChallengeResultRequest::answer() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeResultRequest.answer)
  return *answer_;
}
inline void ChallengeResultRequest::set_answer(const ::std::string& value) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeResultRequest.answer)
}
inline void ChallengeResultRequest::set_answer(const char* value) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.challenge.v1.ChallengeResultRequest.answer)
}
inline void ChallengeResultRequest::set_answer(const void* value, size_t size) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_ = new ::std::string;
  }
  answer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.challenge.v1.ChallengeResultRequest.answer)
}
inline ::std::string* ChallengeResultRequest::mutable_answer() {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    answer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.ChallengeResultRequest.answer)
  return answer_;
}
inline ::std::string* ChallengeResultRequest::release_answer() {
  clear_has_answer();
  if (answer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = answer_;
    answer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChallengeResultRequest::set_allocated_answer(::std::string* answer) {
  if (answer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete answer_;
  }
  if (answer) {
    set_has_answer();
    answer_ = answer;
  } else {
    clear_has_answer();
    answer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.ChallengeResultRequest.answer)
}

// -------------------------------------------------------------------

// ChallengeExternalRequest

// optional string request_token = 1;
inline bool ChallengeExternalRequest::has_request_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChallengeExternalRequest::set_has_request_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChallengeExternalRequest::clear_has_request_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChallengeExternalRequest::clear_request_token() {
  if (request_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_token_->clear();
  }
  clear_has_request_token();
}
inline const ::std::string& ChallengeExternalRequest::request_token() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeExternalRequest.request_token)
  return *request_token_;
}
inline void ChallengeExternalRequest::set_request_token(const ::std::string& value) {
  set_has_request_token();
  if (request_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_token_ = new ::std::string;
  }
  request_token_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeExternalRequest.request_token)
}
inline void ChallengeExternalRequest::set_request_token(const char* value) {
  set_has_request_token();
  if (request_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_token_ = new ::std::string;
  }
  request_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.challenge.v1.ChallengeExternalRequest.request_token)
}
inline void ChallengeExternalRequest::set_request_token(const char* value, size_t size) {
  set_has_request_token();
  if (request_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_token_ = new ::std::string;
  }
  request_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.challenge.v1.ChallengeExternalRequest.request_token)
}
inline ::std::string* ChallengeExternalRequest::mutable_request_token() {
  set_has_request_token();
  if (request_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.ChallengeExternalRequest.request_token)
  return request_token_;
}
inline ::std::string* ChallengeExternalRequest::release_request_token() {
  clear_has_request_token();
  if (request_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = request_token_;
    request_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChallengeExternalRequest::set_allocated_request_token(::std::string* request_token) {
  if (request_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete request_token_;
  }
  if (request_token) {
    set_has_request_token();
    request_token_ = request_token;
  } else {
    clear_has_request_token();
    request_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.ChallengeExternalRequest.request_token)
}

// optional string payload_type = 2;
inline bool ChallengeExternalRequest::has_payload_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChallengeExternalRequest::set_has_payload_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChallengeExternalRequest::clear_has_payload_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChallengeExternalRequest::clear_payload_type() {
  if (payload_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_type_->clear();
  }
  clear_has_payload_type();
}
inline const ::std::string& ChallengeExternalRequest::payload_type() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeExternalRequest.payload_type)
  return *payload_type_;
}
inline void ChallengeExternalRequest::set_payload_type(const ::std::string& value) {
  set_has_payload_type();
  if (payload_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_type_ = new ::std::string;
  }
  payload_type_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeExternalRequest.payload_type)
}
inline void ChallengeExternalRequest::set_payload_type(const char* value) {
  set_has_payload_type();
  if (payload_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_type_ = new ::std::string;
  }
  payload_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.challenge.v1.ChallengeExternalRequest.payload_type)
}
inline void ChallengeExternalRequest::set_payload_type(const char* value, size_t size) {
  set_has_payload_type();
  if (payload_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_type_ = new ::std::string;
  }
  payload_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.challenge.v1.ChallengeExternalRequest.payload_type)
}
inline ::std::string* ChallengeExternalRequest::mutable_payload_type() {
  set_has_payload_type();
  if (payload_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.ChallengeExternalRequest.payload_type)
  return payload_type_;
}
inline ::std::string* ChallengeExternalRequest::release_payload_type() {
  clear_has_payload_type();
  if (payload_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = payload_type_;
    payload_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChallengeExternalRequest::set_allocated_payload_type(::std::string* payload_type) {
  if (payload_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete payload_type_;
  }
  if (payload_type) {
    set_has_payload_type();
    payload_type_ = payload_type;
  } else {
    clear_has_payload_type();
    payload_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.ChallengeExternalRequest.payload_type)
}

// optional bytes payload = 3;
inline bool ChallengeExternalRequest::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChallengeExternalRequest::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChallengeExternalRequest::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChallengeExternalRequest::clear_payload() {
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& ChallengeExternalRequest::payload() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeExternalRequest.payload)
  return *payload_;
}
inline void ChallengeExternalRequest::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeExternalRequest.payload)
}
inline void ChallengeExternalRequest::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.challenge.v1.ChallengeExternalRequest.payload)
}
inline void ChallengeExternalRequest::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.challenge.v1.ChallengeExternalRequest.payload)
}
inline ::std::string* ChallengeExternalRequest::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.ChallengeExternalRequest.payload)
  return payload_;
}
inline ::std::string* ChallengeExternalRequest::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChallengeExternalRequest::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.ChallengeExternalRequest.payload)
}

// -------------------------------------------------------------------

// ChallengeExternalResult

// optional string request_token = 1;
inline bool ChallengeExternalResult::has_request_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChallengeExternalResult::set_has_request_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChallengeExternalResult::clear_has_request_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChallengeExternalResult::clear_request_token() {
  if (request_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_token_->clear();
  }
  clear_has_request_token();
}
inline const ::std::string& ChallengeExternalResult::request_token() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeExternalResult.request_token)
  return *request_token_;
}
inline void ChallengeExternalResult::set_request_token(const ::std::string& value) {
  set_has_request_token();
  if (request_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_token_ = new ::std::string;
  }
  request_token_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeExternalResult.request_token)
}
inline void ChallengeExternalResult::set_request_token(const char* value) {
  set_has_request_token();
  if (request_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_token_ = new ::std::string;
  }
  request_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.challenge.v1.ChallengeExternalResult.request_token)
}
inline void ChallengeExternalResult::set_request_token(const char* value, size_t size) {
  set_has_request_token();
  if (request_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_token_ = new ::std::string;
  }
  request_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.challenge.v1.ChallengeExternalResult.request_token)
}
inline ::std::string* ChallengeExternalResult::mutable_request_token() {
  set_has_request_token();
  if (request_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.challenge.v1.ChallengeExternalResult.request_token)
  return request_token_;
}
inline ::std::string* ChallengeExternalResult::release_request_token() {
  clear_has_request_token();
  if (request_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = request_token_;
    request_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChallengeExternalResult::set_allocated_request_token(::std::string* request_token) {
  if (request_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete request_token_;
  }
  if (request_token) {
    set_has_request_token();
    request_token_ = request_token;
  } else {
    clear_has_request_token();
    request_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.challenge.v1.ChallengeExternalResult.request_token)
}

// optional bool passed = 2 [default = true];
inline bool ChallengeExternalResult::has_passed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChallengeExternalResult::set_has_passed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChallengeExternalResult::clear_has_passed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChallengeExternalResult::clear_passed() {
  passed_ = true;
  clear_has_passed();
}
inline bool ChallengeExternalResult::passed() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.challenge.v1.ChallengeExternalResult.passed)
  return passed_;
}
inline void ChallengeExternalResult::set_passed(bool value) {
  set_has_passed();
  passed_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.challenge.v1.ChallengeExternalResult.passed)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace challenge
}  // namespace protocol
}  // namespace bgs

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_challenge_5fservice_2eproto__INCLUDED
