// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: connection_service.proto

#ifndef PROTOBUF_connection_5fservice_2eproto__INCLUDED
#define PROTOBUF_connection_5fservice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "content_handle_types.pb.h"
#include "rpc_types.pb.h"
#include "ServiceBase.h"
#include "MessageBuffer.h"
#include <functional>
#include <type_traits>
// @@protoc_insertion_point(includes)

namespace bgs {
namespace protocol {
namespace connection {
namespace v1 {

// Internal implementation detail -- do not call these.
void TC_PROTO_API protobuf_AddDesc_connection_5fservice_2eproto();
void protobuf_AssignDesc_connection_5fservice_2eproto();
void protobuf_ShutdownFile_connection_5fservice_2eproto();

class ConnectRequest;
class ConnectionMeteringContentHandles;
class ConnectResponse;
class BoundService;
class BindRequest;
class BindResponse;
class EchoRequest;
class EchoResponse;
class DisconnectRequest;
class DisconnectNotification;
class EncryptRequest;

// ===================================================================

class TC_PROTO_API ConnectRequest : public ::google::protobuf::Message {
 public:
  ConnectRequest();
  virtual ~ConnectRequest();

  ConnectRequest(const ConnectRequest& from);

  inline ConnectRequest& operator=(const ConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectRequest& default_instance();

  void Swap(ConnectRequest* other);

  // implements Message ----------------------------------------------

  ConnectRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectRequest& from);
  void MergeFrom(const ConnectRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bgs.protocol.ProcessId client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::bgs::protocol::ProcessId& client_id() const;
  inline ::bgs::protocol::ProcessId* mutable_client_id();
  inline ::bgs::protocol::ProcessId* release_client_id();
  inline void set_allocated_client_id(::bgs::protocol::ProcessId* client_id);

  // optional .bgs.protocol.connection.v1.BindRequest bind_request = 2;
  inline bool has_bind_request() const;
  inline void clear_bind_request();
  static const int kBindRequestFieldNumber = 2;
  inline const ::bgs::protocol::connection::v1::BindRequest& bind_request() const;
  inline ::bgs::protocol::connection::v1::BindRequest* mutable_bind_request();
  inline ::bgs::protocol::connection::v1::BindRequest* release_bind_request();
  inline void set_allocated_bind_request(::bgs::protocol::connection::v1::BindRequest* bind_request);

  // optional bool use_bindless_rpc = 3 [default = true];
  inline bool has_use_bindless_rpc() const;
  inline void clear_use_bindless_rpc();
  static const int kUseBindlessRpcFieldNumber = 3;
  inline bool use_bindless_rpc() const;
  inline void set_use_bindless_rpc(bool value);

  // @@protoc_insertion_point(class_scope:bgs.protocol.connection.v1.ConnectRequest)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_bind_request();
  inline void clear_has_bind_request();
  inline void set_has_use_bindless_rpc();
  inline void clear_has_use_bindless_rpc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::bgs::protocol::ProcessId* client_id_;
  ::bgs::protocol::connection::v1::BindRequest* bind_request_;
  bool use_bindless_rpc_;
  friend void TC_PROTO_API protobuf_AddDesc_connection_5fservice_2eproto();
  friend void protobuf_AssignDesc_connection_5fservice_2eproto();
  friend void protobuf_ShutdownFile_connection_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ConnectRequest* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API ConnectionMeteringContentHandles : public ::google::protobuf::Message {
 public:
  ConnectionMeteringContentHandles();
  virtual ~ConnectionMeteringContentHandles();

  ConnectionMeteringContentHandles(const ConnectionMeteringContentHandles& from);

  inline ConnectionMeteringContentHandles& operator=(const ConnectionMeteringContentHandles& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionMeteringContentHandles& default_instance();

  void Swap(ConnectionMeteringContentHandles* other);

  // implements Message ----------------------------------------------

  ConnectionMeteringContentHandles* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectionMeteringContentHandles& from);
  void MergeFrom(const ConnectionMeteringContentHandles& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bgs.protocol.ContentHandle content_handle = 1;
  inline int content_handle_size() const;
  inline void clear_content_handle();
  static const int kContentHandleFieldNumber = 1;
  inline const ::bgs::protocol::ContentHandle& content_handle(int index) const;
  inline ::bgs::protocol::ContentHandle* mutable_content_handle(int index);
  inline ::bgs::protocol::ContentHandle* add_content_handle();
  inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::ContentHandle >&
      content_handle() const;
  inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::ContentHandle >*
      mutable_content_handle();

  // @@protoc_insertion_point(class_scope:bgs.protocol.connection.v1.ConnectionMeteringContentHandles)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::bgs::protocol::ContentHandle > content_handle_;
  friend void TC_PROTO_API protobuf_AddDesc_connection_5fservice_2eproto();
  friend void protobuf_AssignDesc_connection_5fservice_2eproto();
  friend void protobuf_ShutdownFile_connection_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ConnectionMeteringContentHandles* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API ConnectResponse : public ::google::protobuf::Message {
 public:
  ConnectResponse();
  virtual ~ConnectResponse();

  ConnectResponse(const ConnectResponse& from);

  inline ConnectResponse& operator=(const ConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectResponse& default_instance();

  void Swap(ConnectResponse* other);

  // implements Message ----------------------------------------------

  ConnectResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectResponse& from);
  void MergeFrom(const ConnectResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .bgs.protocol.ProcessId server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline const ::bgs::protocol::ProcessId& server_id() const;
  inline ::bgs::protocol::ProcessId* mutable_server_id();
  inline ::bgs::protocol::ProcessId* release_server_id();
  inline void set_allocated_server_id(::bgs::protocol::ProcessId* server_id);

  // optional .bgs.protocol.ProcessId client_id = 2;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 2;
  inline const ::bgs::protocol::ProcessId& client_id() const;
  inline ::bgs::protocol::ProcessId* mutable_client_id();
  inline ::bgs::protocol::ProcessId* release_client_id();
  inline void set_allocated_client_id(::bgs::protocol::ProcessId* client_id);

  // optional uint32 bind_result = 3;
  inline bool has_bind_result() const;
  inline void clear_bind_result();
  static const int kBindResultFieldNumber = 3;
  inline ::google::protobuf::uint32 bind_result() const;
  inline void set_bind_result(::google::protobuf::uint32 value);

  // optional .bgs.protocol.connection.v1.BindResponse bind_response = 4;
  inline bool has_bind_response() const;
  inline void clear_bind_response();
  static const int kBindResponseFieldNumber = 4;
  inline const ::bgs::protocol::connection::v1::BindResponse& bind_response() const;
  inline ::bgs::protocol::connection::v1::BindResponse* mutable_bind_response();
  inline ::bgs::protocol::connection::v1::BindResponse* release_bind_response();
  inline void set_allocated_bind_response(::bgs::protocol::connection::v1::BindResponse* bind_response);

  // optional .bgs.protocol.connection.v1.ConnectionMeteringContentHandles content_handle_array = 5;
  inline bool has_content_handle_array() const;
  inline void clear_content_handle_array();
  static const int kContentHandleArrayFieldNumber = 5;
  inline const ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles& content_handle_array() const;
  inline ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* mutable_content_handle_array();
  inline ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* release_content_handle_array();
  inline void set_allocated_content_handle_array(::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* content_handle_array);

  // optional uint64 server_time = 6;
  inline bool has_server_time() const;
  inline void clear_server_time();
  static const int kServerTimeFieldNumber = 6;
  inline ::google::protobuf::uint64 server_time() const;
  inline void set_server_time(::google::protobuf::uint64 value);

  // optional bool use_bindless_rpc = 7 [default = false];
  inline bool has_use_bindless_rpc() const;
  inline void clear_use_bindless_rpc();
  static const int kUseBindlessRpcFieldNumber = 7;
  inline bool use_bindless_rpc() const;
  inline void set_use_bindless_rpc(bool value);

  // optional .bgs.protocol.connection.v1.ConnectionMeteringContentHandles binary_content_handle_array = 8;
  inline bool has_binary_content_handle_array() const;
  inline void clear_binary_content_handle_array();
  static const int kBinaryContentHandleArrayFieldNumber = 8;
  inline const ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles& binary_content_handle_array() const;
  inline ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* mutable_binary_content_handle_array();
  inline ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* release_binary_content_handle_array();
  inline void set_allocated_binary_content_handle_array(::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* binary_content_handle_array);

  // @@protoc_insertion_point(class_scope:bgs.protocol.connection.v1.ConnectResponse)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_bind_result();
  inline void clear_has_bind_result();
  inline void set_has_bind_response();
  inline void clear_has_bind_response();
  inline void set_has_content_handle_array();
  inline void clear_has_content_handle_array();
  inline void set_has_server_time();
  inline void clear_has_server_time();
  inline void set_has_use_bindless_rpc();
  inline void clear_has_use_bindless_rpc();
  inline void set_has_binary_content_handle_array();
  inline void clear_has_binary_content_handle_array();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::bgs::protocol::ProcessId* server_id_;
  ::bgs::protocol::ProcessId* client_id_;
  ::bgs::protocol::connection::v1::BindResponse* bind_response_;
  ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* content_handle_array_;
  ::google::protobuf::uint32 bind_result_;
  bool use_bindless_rpc_;
  ::google::protobuf::uint64 server_time_;
  ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* binary_content_handle_array_;
  friend void TC_PROTO_API protobuf_AddDesc_connection_5fservice_2eproto();
  friend void protobuf_AssignDesc_connection_5fservice_2eproto();
  friend void protobuf_ShutdownFile_connection_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ConnectResponse* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API BoundService : public ::google::protobuf::Message {
 public:
  BoundService();
  virtual ~BoundService();

  BoundService(const BoundService& from);

  inline BoundService& operator=(const BoundService& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundService& default_instance();

  void Swap(BoundService* other);

  // implements Message ----------------------------------------------

  BoundService* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoundService& from);
  void MergeFrom(const BoundService& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline ::google::protobuf::uint32 hash() const;
  inline void set_hash(::google::protobuf::uint32 value);

  // required uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:bgs.protocol.connection.v1.BoundService)
 private:
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 hash_;
  ::google::protobuf::uint32 id_;
  friend void TC_PROTO_API protobuf_AddDesc_connection_5fservice_2eproto();
  friend void protobuf_AssignDesc_connection_5fservice_2eproto();
  friend void protobuf_ShutdownFile_connection_5fservice_2eproto();

  void InitAsDefaultInstance();
  static BoundService* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API BindRequest : public ::google::protobuf::Message {
 public:
  BindRequest();
  virtual ~BindRequest();

  BindRequest(const BindRequest& from);

  inline BindRequest& operator=(const BindRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindRequest& default_instance();

  void Swap(BindRequest* other);

  // implements Message ----------------------------------------------

  BindRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BindRequest& from);
  void MergeFrom(const BindRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed32 deprecated_imported_service_hash = 1 [packed = true, deprecated = true];
  inline int deprecated_imported_service_hash_size() const PROTOBUF_DEPRECATED;
  inline void clear_deprecated_imported_service_hash() PROTOBUF_DEPRECATED;
  static const int kDeprecatedImportedServiceHashFieldNumber = 1;
  inline ::google::protobuf::uint32 deprecated_imported_service_hash(int index) const PROTOBUF_DEPRECATED;
  inline void set_deprecated_imported_service_hash(int index, ::google::protobuf::uint32 value) PROTOBUF_DEPRECATED;
  inline void add_deprecated_imported_service_hash(::google::protobuf::uint32 value) PROTOBUF_DEPRECATED;
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      deprecated_imported_service_hash() const PROTOBUF_DEPRECATED;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_deprecated_imported_service_hash() PROTOBUF_DEPRECATED;

  // repeated .bgs.protocol.connection.v1.BoundService deprecated_exported_service = 2 [deprecated = true];
  inline int deprecated_exported_service_size() const PROTOBUF_DEPRECATED;
  inline void clear_deprecated_exported_service() PROTOBUF_DEPRECATED;
  static const int kDeprecatedExportedServiceFieldNumber = 2;
  inline const ::bgs::protocol::connection::v1::BoundService& deprecated_exported_service(int index) const PROTOBUF_DEPRECATED;
  inline ::bgs::protocol::connection::v1::BoundService* mutable_deprecated_exported_service(int index) PROTOBUF_DEPRECATED;
  inline ::bgs::protocol::connection::v1::BoundService* add_deprecated_exported_service() PROTOBUF_DEPRECATED;
  inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService >&
      deprecated_exported_service() const PROTOBUF_DEPRECATED;
  inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService >*
      mutable_deprecated_exported_service() PROTOBUF_DEPRECATED;

  // repeated .bgs.protocol.connection.v1.BoundService exported_service = 3;
  inline int exported_service_size() const;
  inline void clear_exported_service();
  static const int kExportedServiceFieldNumber = 3;
  inline const ::bgs::protocol::connection::v1::BoundService& exported_service(int index) const;
  inline ::bgs::protocol::connection::v1::BoundService* mutable_exported_service(int index);
  inline ::bgs::protocol::connection::v1::BoundService* add_exported_service();
  inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService >&
      exported_service() const;
  inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService >*
      mutable_exported_service();

  // repeated .bgs.protocol.connection.v1.BoundService imported_service = 4;
  inline int imported_service_size() const;
  inline void clear_imported_service();
  static const int kImportedServiceFieldNumber = 4;
  inline const ::bgs::protocol::connection::v1::BoundService& imported_service(int index) const;
  inline ::bgs::protocol::connection::v1::BoundService* mutable_imported_service(int index);
  inline ::bgs::protocol::connection::v1::BoundService* add_imported_service();
  inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService >&
      imported_service() const;
  inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService >*
      mutable_imported_service();

  // @@protoc_insertion_point(class_scope:bgs.protocol.connection.v1.BindRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > deprecated_imported_service_hash_;
  mutable int _deprecated_imported_service_hash_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService > deprecated_exported_service_;
  ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService > exported_service_;
  ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService > imported_service_;
  friend void TC_PROTO_API protobuf_AddDesc_connection_5fservice_2eproto();
  friend void protobuf_AssignDesc_connection_5fservice_2eproto();
  friend void protobuf_ShutdownFile_connection_5fservice_2eproto();

  void InitAsDefaultInstance();
  static BindRequest* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API BindResponse : public ::google::protobuf::Message {
 public:
  BindResponse();
  virtual ~BindResponse();

  BindResponse(const BindResponse& from);

  inline BindResponse& operator=(const BindResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindResponse& default_instance();

  void Swap(BindResponse* other);

  // implements Message ----------------------------------------------

  BindResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BindResponse& from);
  void MergeFrom(const BindResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 imported_service_id = 1 [packed = true, deprecated = true];
  inline int imported_service_id_size() const PROTOBUF_DEPRECATED;
  inline void clear_imported_service_id() PROTOBUF_DEPRECATED;
  static const int kImportedServiceIdFieldNumber = 1;
  inline ::google::protobuf::uint32 imported_service_id(int index) const PROTOBUF_DEPRECATED;
  inline void set_imported_service_id(int index, ::google::protobuf::uint32 value) PROTOBUF_DEPRECATED;
  inline void add_imported_service_id(::google::protobuf::uint32 value) PROTOBUF_DEPRECATED;
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      imported_service_id() const PROTOBUF_DEPRECATED;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_imported_service_id() PROTOBUF_DEPRECATED;

  // @@protoc_insertion_point(class_scope:bgs.protocol.connection.v1.BindResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > imported_service_id_;
  mutable int _imported_service_id_cached_byte_size_;
  friend void TC_PROTO_API protobuf_AddDesc_connection_5fservice_2eproto();
  friend void protobuf_AssignDesc_connection_5fservice_2eproto();
  friend void protobuf_ShutdownFile_connection_5fservice_2eproto();

  void InitAsDefaultInstance();
  static BindResponse* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API EchoRequest : public ::google::protobuf::Message {
 public:
  EchoRequest();
  virtual ~EchoRequest();

  EchoRequest(const EchoRequest& from);

  inline EchoRequest& operator=(const EchoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EchoRequest& default_instance();

  void Swap(EchoRequest* other);

  // implements Message ----------------------------------------------

  EchoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EchoRequest& from);
  void MergeFrom(const EchoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // optional bool network_only = 2 [default = false];
  inline bool has_network_only() const;
  inline void clear_network_only();
  static const int kNetworkOnlyFieldNumber = 2;
  inline bool network_only() const;
  inline void set_network_only(bool value);

  // optional bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional .bgs.protocol.ProcessId forward = 4;
  inline bool has_forward() const;
  inline void clear_forward();
  static const int kForwardFieldNumber = 4;
  inline const ::bgs::protocol::ProcessId& forward() const;
  inline ::bgs::protocol::ProcessId* mutable_forward();
  inline ::bgs::protocol::ProcessId* release_forward();
  inline void set_allocated_forward(::bgs::protocol::ProcessId* forward);

  // optional string forward_client_id = 5;
  inline bool has_forward_client_id() const;
  inline void clear_forward_client_id();
  static const int kForwardClientIdFieldNumber = 5;
  inline const ::std::string& forward_client_id() const;
  inline void set_forward_client_id(const ::std::string& value);
  inline void set_forward_client_id(const char* value);
  inline void set_forward_client_id(const char* value, size_t size);
  inline ::std::string* mutable_forward_client_id();
  inline ::std::string* release_forward_client_id();
  inline void set_allocated_forward_client_id(::std::string* forward_client_id);

  // @@protoc_insertion_point(class_scope:bgs.protocol.connection.v1.EchoRequest)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_network_only();
  inline void clear_has_network_only();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_forward();
  inline void clear_has_forward();
  inline void set_has_forward_client_id();
  inline void clear_has_forward_client_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_;
  ::std::string* payload_;
  ::bgs::protocol::ProcessId* forward_;
  ::std::string* forward_client_id_;
  bool network_only_;
  friend void TC_PROTO_API protobuf_AddDesc_connection_5fservice_2eproto();
  friend void protobuf_AssignDesc_connection_5fservice_2eproto();
  friend void protobuf_ShutdownFile_connection_5fservice_2eproto();

  void InitAsDefaultInstance();
  static EchoRequest* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API EchoResponse : public ::google::protobuf::Message {
 public:
  EchoResponse();
  virtual ~EchoResponse();

  EchoResponse(const EchoResponse& from);

  inline EchoResponse& operator=(const EchoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EchoResponse& default_instance();

  void Swap(EchoResponse* other);

  // implements Message ----------------------------------------------

  EchoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EchoResponse& from);
  void MergeFrom(const EchoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // optional bytes payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:bgs.protocol.connection.v1.EchoResponse)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_;
  ::std::string* payload_;
  friend void TC_PROTO_API protobuf_AddDesc_connection_5fservice_2eproto();
  friend void protobuf_AssignDesc_connection_5fservice_2eproto();
  friend void protobuf_ShutdownFile_connection_5fservice_2eproto();

  void InitAsDefaultInstance();
  static EchoResponse* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API DisconnectRequest : public ::google::protobuf::Message {
 public:
  DisconnectRequest();
  virtual ~DisconnectRequest();

  DisconnectRequest(const DisconnectRequest& from);

  inline DisconnectRequest& operator=(const DisconnectRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisconnectRequest& default_instance();

  void Swap(DisconnectRequest* other);

  // implements Message ----------------------------------------------

  DisconnectRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DisconnectRequest& from);
  void MergeFrom(const DisconnectRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:bgs.protocol.connection.v1.DisconnectRequest)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 error_code_;
  friend void TC_PROTO_API protobuf_AddDesc_connection_5fservice_2eproto();
  friend void protobuf_AssignDesc_connection_5fservice_2eproto();
  friend void protobuf_ShutdownFile_connection_5fservice_2eproto();

  void InitAsDefaultInstance();
  static DisconnectRequest* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API DisconnectNotification : public ::google::protobuf::Message {
 public:
  DisconnectNotification();
  virtual ~DisconnectNotification();

  DisconnectNotification(const DisconnectNotification& from);

  inline DisconnectNotification& operator=(const DisconnectNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisconnectNotification& default_instance();

  void Swap(DisconnectNotification* other);

  // implements Message ----------------------------------------------

  DisconnectNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DisconnectNotification& from);
  void MergeFrom(const DisconnectNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // optional string reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:bgs.protocol.connection.v1.DisconnectNotification)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* reason_;
  ::google::protobuf::uint32 error_code_;
  friend void TC_PROTO_API protobuf_AddDesc_connection_5fservice_2eproto();
  friend void protobuf_AssignDesc_connection_5fservice_2eproto();
  friend void protobuf_ShutdownFile_connection_5fservice_2eproto();

  void InitAsDefaultInstance();
  static DisconnectNotification* default_instance_;
};
// -------------------------------------------------------------------

class TC_PROTO_API EncryptRequest : public ::google::protobuf::Message {
 public:
  EncryptRequest();
  virtual ~EncryptRequest();

  EncryptRequest(const EncryptRequest& from);

  inline EncryptRequest& operator=(const EncryptRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncryptRequest& default_instance();

  void Swap(EncryptRequest* other);

  // implements Message ----------------------------------------------

  EncryptRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncryptRequest& from);
  void MergeFrom(const EncryptRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bgs.protocol.connection.v1.EncryptRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void TC_PROTO_API protobuf_AddDesc_connection_5fservice_2eproto();
  friend void protobuf_AssignDesc_connection_5fservice_2eproto();
  friend void protobuf_ShutdownFile_connection_5fservice_2eproto();

  void InitAsDefaultInstance();
  static EncryptRequest* default_instance_;
};
// ===================================================================

class TC_PROTO_API ConnectionService : public ServiceBase
{
 public:

  explicit ConnectionService(bool use_original_hash);
  virtual ~ConnectionService();

  typedef std::integral_constant<uint32, 0x65446991u> OriginalHash;
  typedef std::integral_constant<uint32, 0x2782094Bu> NameHash;

  static google::protobuf::ServiceDescriptor const* descriptor();

  // client methods --------------------------------------------------
  void Connect(::bgs::protocol::connection::v1::ConnectRequest const* request, std::function<void(::bgs::protocol::connection::v1::ConnectResponse const*)> responseCallback, bool client = false, bool server = false);
  void Bind(::bgs::protocol::connection::v1::BindRequest const* request, std::function<void(::bgs::protocol::connection::v1::BindResponse const*)> responseCallback, bool client = false, bool server = false);
  void Echo(::bgs::protocol::connection::v1::EchoRequest const* request, std::function<void(::bgs::protocol::connection::v1::EchoResponse const*)> responseCallback, bool client = false, bool server = false);
  void ForceDisconnect(::bgs::protocol::connection::v1::DisconnectNotification const* request, bool client = false, bool server = false);
  void KeepAlive(::bgs::protocol::NoData const* request, bool client = false, bool server = false);
  void Encrypt(::bgs::protocol::connection::v1::EncryptRequest const* request, std::function<void(::bgs::protocol::NoData const*)> responseCallback, bool client = false, bool server = false);
  void RequestDisconnect(::bgs::protocol::connection::v1::DisconnectRequest const* request, bool client = false, bool server = false);

  void CallServerMethod(uint32 token, uint32 methodId, MessageBuffer buffer) final;

 protected:
  // server methods --------------------------------------------------
  virtual uint32 HandleConnect(::bgs::protocol::connection::v1::ConnectRequest const* request, ::bgs::protocol::connection::v1::ConnectResponse* response, std::function<void(ServiceBase*, uint32, ::google::protobuf::Message const*)>& continuation);
  virtual uint32 HandleBind(::bgs::protocol::connection::v1::BindRequest const* request, ::bgs::protocol::connection::v1::BindResponse* response, std::function<void(ServiceBase*, uint32, ::google::protobuf::Message const*)>& continuation);
  virtual uint32 HandleEcho(::bgs::protocol::connection::v1::EchoRequest const* request, ::bgs::protocol::connection::v1::EchoResponse* response, std::function<void(ServiceBase*, uint32, ::google::protobuf::Message const*)>& continuation);
  virtual uint32 HandleForceDisconnect(::bgs::protocol::connection::v1::DisconnectNotification const* request);
  virtual uint32 HandleKeepAlive(::bgs::protocol::NoData const* request);
  virtual uint32 HandleEncrypt(::bgs::protocol::connection::v1::EncryptRequest const* request, ::bgs::protocol::NoData* response, std::function<void(ServiceBase*, uint32, ::google::protobuf::Message const*)>& continuation);
  virtual uint32 HandleRequestDisconnect(::bgs::protocol::connection::v1::DisconnectRequest const* request);

 private:
  uint32 service_hash_;

  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ConnectionService);
};

// ===================================================================


// ===================================================================

// ConnectRequest

// optional .bgs.protocol.ProcessId client_id = 1;
inline bool ConnectRequest::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectRequest::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectRequest::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectRequest::clear_client_id() {
  if (client_id_ != NULL) client_id_->::bgs::protocol::ProcessId::Clear();
  clear_has_client_id();
}
inline const ::bgs::protocol::ProcessId& ConnectRequest::client_id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.ConnectRequest.client_id)
  return client_id_ != NULL ? *client_id_ : *default_instance_->client_id_;
}
inline ::bgs::protocol::ProcessId* ConnectRequest::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == NULL) client_id_ = new ::bgs::protocol::ProcessId;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.ConnectRequest.client_id)
  return client_id_;
}
inline ::bgs::protocol::ProcessId* ConnectRequest::release_client_id() {
  clear_has_client_id();
  ::bgs::protocol::ProcessId* temp = client_id_;
  client_id_ = NULL;
  return temp;
}
inline void ConnectRequest::set_allocated_client_id(::bgs::protocol::ProcessId* client_id) {
  delete client_id_;
  client_id_ = client_id;
  if (client_id) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.connection.v1.ConnectRequest.client_id)
}

// optional .bgs.protocol.connection.v1.BindRequest bind_request = 2;
inline bool ConnectRequest::has_bind_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectRequest::set_has_bind_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectRequest::clear_has_bind_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectRequest::clear_bind_request() {
  if (bind_request_ != NULL) bind_request_->::bgs::protocol::connection::v1::BindRequest::Clear();
  clear_has_bind_request();
}
inline const ::bgs::protocol::connection::v1::BindRequest& ConnectRequest::bind_request() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.ConnectRequest.bind_request)
  return bind_request_ != NULL ? *bind_request_ : *default_instance_->bind_request_;
}
inline ::bgs::protocol::connection::v1::BindRequest* ConnectRequest::mutable_bind_request() {
  set_has_bind_request();
  if (bind_request_ == NULL) bind_request_ = new ::bgs::protocol::connection::v1::BindRequest;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.ConnectRequest.bind_request)
  return bind_request_;
}
inline ::bgs::protocol::connection::v1::BindRequest* ConnectRequest::release_bind_request() {
  clear_has_bind_request();
  ::bgs::protocol::connection::v1::BindRequest* temp = bind_request_;
  bind_request_ = NULL;
  return temp;
}
inline void ConnectRequest::set_allocated_bind_request(::bgs::protocol::connection::v1::BindRequest* bind_request) {
  delete bind_request_;
  bind_request_ = bind_request;
  if (bind_request) {
    set_has_bind_request();
  } else {
    clear_has_bind_request();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.connection.v1.ConnectRequest.bind_request)
}

// optional bool use_bindless_rpc = 3 [default = true];
inline bool ConnectRequest::has_use_bindless_rpc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectRequest::set_has_use_bindless_rpc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectRequest::clear_has_use_bindless_rpc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectRequest::clear_use_bindless_rpc() {
  use_bindless_rpc_ = true;
  clear_has_use_bindless_rpc();
}
inline bool ConnectRequest::use_bindless_rpc() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.ConnectRequest.use_bindless_rpc)
  return use_bindless_rpc_;
}
inline void ConnectRequest::set_use_bindless_rpc(bool value) {
  set_has_use_bindless_rpc();
  use_bindless_rpc_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.ConnectRequest.use_bindless_rpc)
}

// -------------------------------------------------------------------

// ConnectionMeteringContentHandles

// repeated .bgs.protocol.ContentHandle content_handle = 1;
inline int ConnectionMeteringContentHandles::content_handle_size() const {
  return content_handle_.size();
}
inline void ConnectionMeteringContentHandles::clear_content_handle() {
  content_handle_.Clear();
}
inline const ::bgs::protocol::ContentHandle& ConnectionMeteringContentHandles::content_handle(int index) const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.ConnectionMeteringContentHandles.content_handle)
  return content_handle_.Get(index);
}
inline ::bgs::protocol::ContentHandle* ConnectionMeteringContentHandles::mutable_content_handle(int index) {
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.ConnectionMeteringContentHandles.content_handle)
  return content_handle_.Mutable(index);
}
inline ::bgs::protocol::ContentHandle* ConnectionMeteringContentHandles::add_content_handle() {
  // @@protoc_insertion_point(field_add:bgs.protocol.connection.v1.ConnectionMeteringContentHandles.content_handle)
  return content_handle_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::ContentHandle >&
ConnectionMeteringContentHandles::content_handle() const {
  // @@protoc_insertion_point(field_list:bgs.protocol.connection.v1.ConnectionMeteringContentHandles.content_handle)
  return content_handle_;
}
inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::ContentHandle >*
ConnectionMeteringContentHandles::mutable_content_handle() {
  // @@protoc_insertion_point(field_mutable_list:bgs.protocol.connection.v1.ConnectionMeteringContentHandles.content_handle)
  return &content_handle_;
}

// -------------------------------------------------------------------

// ConnectResponse

// required .bgs.protocol.ProcessId server_id = 1;
inline bool ConnectResponse::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectResponse::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectResponse::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectResponse::clear_server_id() {
  if (server_id_ != NULL) server_id_->::bgs::protocol::ProcessId::Clear();
  clear_has_server_id();
}
inline const ::bgs::protocol::ProcessId& ConnectResponse::server_id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.ConnectResponse.server_id)
  return server_id_ != NULL ? *server_id_ : *default_instance_->server_id_;
}
inline ::bgs::protocol::ProcessId* ConnectResponse::mutable_server_id() {
  set_has_server_id();
  if (server_id_ == NULL) server_id_ = new ::bgs::protocol::ProcessId;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.ConnectResponse.server_id)
  return server_id_;
}
inline ::bgs::protocol::ProcessId* ConnectResponse::release_server_id() {
  clear_has_server_id();
  ::bgs::protocol::ProcessId* temp = server_id_;
  server_id_ = NULL;
  return temp;
}
inline void ConnectResponse::set_allocated_server_id(::bgs::protocol::ProcessId* server_id) {
  delete server_id_;
  server_id_ = server_id;
  if (server_id) {
    set_has_server_id();
  } else {
    clear_has_server_id();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.connection.v1.ConnectResponse.server_id)
}

// optional .bgs.protocol.ProcessId client_id = 2;
inline bool ConnectResponse::has_client_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectResponse::set_has_client_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectResponse::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectResponse::clear_client_id() {
  if (client_id_ != NULL) client_id_->::bgs::protocol::ProcessId::Clear();
  clear_has_client_id();
}
inline const ::bgs::protocol::ProcessId& ConnectResponse::client_id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.ConnectResponse.client_id)
  return client_id_ != NULL ? *client_id_ : *default_instance_->client_id_;
}
inline ::bgs::protocol::ProcessId* ConnectResponse::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == NULL) client_id_ = new ::bgs::protocol::ProcessId;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.ConnectResponse.client_id)
  return client_id_;
}
inline ::bgs::protocol::ProcessId* ConnectResponse::release_client_id() {
  clear_has_client_id();
  ::bgs::protocol::ProcessId* temp = client_id_;
  client_id_ = NULL;
  return temp;
}
inline void ConnectResponse::set_allocated_client_id(::bgs::protocol::ProcessId* client_id) {
  delete client_id_;
  client_id_ = client_id;
  if (client_id) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.connection.v1.ConnectResponse.client_id)
}

// optional uint32 bind_result = 3;
inline bool ConnectResponse::has_bind_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectResponse::set_has_bind_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectResponse::clear_has_bind_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectResponse::clear_bind_result() {
  bind_result_ = 0u;
  clear_has_bind_result();
}
inline ::google::protobuf::uint32 ConnectResponse::bind_result() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.ConnectResponse.bind_result)
  return bind_result_;
}
inline void ConnectResponse::set_bind_result(::google::protobuf::uint32 value) {
  set_has_bind_result();
  bind_result_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.ConnectResponse.bind_result)
}

// optional .bgs.protocol.connection.v1.BindResponse bind_response = 4;
inline bool ConnectResponse::has_bind_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectResponse::set_has_bind_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectResponse::clear_has_bind_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectResponse::clear_bind_response() {
  if (bind_response_ != NULL) bind_response_->::bgs::protocol::connection::v1::BindResponse::Clear();
  clear_has_bind_response();
}
inline const ::bgs::protocol::connection::v1::BindResponse& ConnectResponse::bind_response() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.ConnectResponse.bind_response)
  return bind_response_ != NULL ? *bind_response_ : *default_instance_->bind_response_;
}
inline ::bgs::protocol::connection::v1::BindResponse* ConnectResponse::mutable_bind_response() {
  set_has_bind_response();
  if (bind_response_ == NULL) bind_response_ = new ::bgs::protocol::connection::v1::BindResponse;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.ConnectResponse.bind_response)
  return bind_response_;
}
inline ::bgs::protocol::connection::v1::BindResponse* ConnectResponse::release_bind_response() {
  clear_has_bind_response();
  ::bgs::protocol::connection::v1::BindResponse* temp = bind_response_;
  bind_response_ = NULL;
  return temp;
}
inline void ConnectResponse::set_allocated_bind_response(::bgs::protocol::connection::v1::BindResponse* bind_response) {
  delete bind_response_;
  bind_response_ = bind_response;
  if (bind_response) {
    set_has_bind_response();
  } else {
    clear_has_bind_response();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.connection.v1.ConnectResponse.bind_response)
}

// optional .bgs.protocol.connection.v1.ConnectionMeteringContentHandles content_handle_array = 5;
inline bool ConnectResponse::has_content_handle_array() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConnectResponse::set_has_content_handle_array() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConnectResponse::clear_has_content_handle_array() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConnectResponse::clear_content_handle_array() {
  if (content_handle_array_ != NULL) content_handle_array_->::bgs::protocol::connection::v1::ConnectionMeteringContentHandles::Clear();
  clear_has_content_handle_array();
}
inline const ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles& ConnectResponse::content_handle_array() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.ConnectResponse.content_handle_array)
  return content_handle_array_ != NULL ? *content_handle_array_ : *default_instance_->content_handle_array_;
}
inline ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* ConnectResponse::mutable_content_handle_array() {
  set_has_content_handle_array();
  if (content_handle_array_ == NULL) content_handle_array_ = new ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.ConnectResponse.content_handle_array)
  return content_handle_array_;
}
inline ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* ConnectResponse::release_content_handle_array() {
  clear_has_content_handle_array();
  ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* temp = content_handle_array_;
  content_handle_array_ = NULL;
  return temp;
}
inline void ConnectResponse::set_allocated_content_handle_array(::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* content_handle_array) {
  delete content_handle_array_;
  content_handle_array_ = content_handle_array;
  if (content_handle_array) {
    set_has_content_handle_array();
  } else {
    clear_has_content_handle_array();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.connection.v1.ConnectResponse.content_handle_array)
}

// optional uint64 server_time = 6;
inline bool ConnectResponse::has_server_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConnectResponse::set_has_server_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConnectResponse::clear_has_server_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConnectResponse::clear_server_time() {
  server_time_ = GOOGLE_ULONGLONG(0);
  clear_has_server_time();
}
inline ::google::protobuf::uint64 ConnectResponse::server_time() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.ConnectResponse.server_time)
  return server_time_;
}
inline void ConnectResponse::set_server_time(::google::protobuf::uint64 value) {
  set_has_server_time();
  server_time_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.ConnectResponse.server_time)
}

// optional bool use_bindless_rpc = 7 [default = false];
inline bool ConnectResponse::has_use_bindless_rpc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ConnectResponse::set_has_use_bindless_rpc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ConnectResponse::clear_has_use_bindless_rpc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ConnectResponse::clear_use_bindless_rpc() {
  use_bindless_rpc_ = false;
  clear_has_use_bindless_rpc();
}
inline bool ConnectResponse::use_bindless_rpc() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.ConnectResponse.use_bindless_rpc)
  return use_bindless_rpc_;
}
inline void ConnectResponse::set_use_bindless_rpc(bool value) {
  set_has_use_bindless_rpc();
  use_bindless_rpc_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.ConnectResponse.use_bindless_rpc)
}

// optional .bgs.protocol.connection.v1.ConnectionMeteringContentHandles binary_content_handle_array = 8;
inline bool ConnectResponse::has_binary_content_handle_array() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ConnectResponse::set_has_binary_content_handle_array() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ConnectResponse::clear_has_binary_content_handle_array() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ConnectResponse::clear_binary_content_handle_array() {
  if (binary_content_handle_array_ != NULL) binary_content_handle_array_->::bgs::protocol::connection::v1::ConnectionMeteringContentHandles::Clear();
  clear_has_binary_content_handle_array();
}
inline const ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles& ConnectResponse::binary_content_handle_array() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.ConnectResponse.binary_content_handle_array)
  return binary_content_handle_array_ != NULL ? *binary_content_handle_array_ : *default_instance_->binary_content_handle_array_;
}
inline ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* ConnectResponse::mutable_binary_content_handle_array() {
  set_has_binary_content_handle_array();
  if (binary_content_handle_array_ == NULL) binary_content_handle_array_ = new ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.ConnectResponse.binary_content_handle_array)
  return binary_content_handle_array_;
}
inline ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* ConnectResponse::release_binary_content_handle_array() {
  clear_has_binary_content_handle_array();
  ::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* temp = binary_content_handle_array_;
  binary_content_handle_array_ = NULL;
  return temp;
}
inline void ConnectResponse::set_allocated_binary_content_handle_array(::bgs::protocol::connection::v1::ConnectionMeteringContentHandles* binary_content_handle_array) {
  delete binary_content_handle_array_;
  binary_content_handle_array_ = binary_content_handle_array;
  if (binary_content_handle_array) {
    set_has_binary_content_handle_array();
  } else {
    clear_has_binary_content_handle_array();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.connection.v1.ConnectResponse.binary_content_handle_array)
}

// -------------------------------------------------------------------

// BoundService

// required fixed32 hash = 1;
inline bool BoundService::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoundService::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoundService::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoundService::clear_hash() {
  hash_ = 0u;
  clear_has_hash();
}
inline ::google::protobuf::uint32 BoundService::hash() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.BoundService.hash)
  return hash_;
}
inline void BoundService::set_hash(::google::protobuf::uint32 value) {
  set_has_hash();
  hash_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.BoundService.hash)
}

// required uint32 id = 2;
inline bool BoundService::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoundService::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoundService::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoundService::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 BoundService::id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.BoundService.id)
  return id_;
}
inline void BoundService::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.BoundService.id)
}

// -------------------------------------------------------------------

// BindRequest

// repeated fixed32 deprecated_imported_service_hash = 1 [packed = true, deprecated = true];
inline int BindRequest::deprecated_imported_service_hash_size() const {
  return deprecated_imported_service_hash_.size();
}
inline void BindRequest::clear_deprecated_imported_service_hash() {
  deprecated_imported_service_hash_.Clear();
}
inline ::google::protobuf::uint32 BindRequest::deprecated_imported_service_hash(int index) const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.BindRequest.deprecated_imported_service_hash)
  return deprecated_imported_service_hash_.Get(index);
}
inline void BindRequest::set_deprecated_imported_service_hash(int index, ::google::protobuf::uint32 value) {
  deprecated_imported_service_hash_.Set(index, value);
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.BindRequest.deprecated_imported_service_hash)
}
inline void BindRequest::add_deprecated_imported_service_hash(::google::protobuf::uint32 value) {
  deprecated_imported_service_hash_.Add(value);
  // @@protoc_insertion_point(field_add:bgs.protocol.connection.v1.BindRequest.deprecated_imported_service_hash)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BindRequest::deprecated_imported_service_hash() const {
  // @@protoc_insertion_point(field_list:bgs.protocol.connection.v1.BindRequest.deprecated_imported_service_hash)
  return deprecated_imported_service_hash_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BindRequest::mutable_deprecated_imported_service_hash() {
  // @@protoc_insertion_point(field_mutable_list:bgs.protocol.connection.v1.BindRequest.deprecated_imported_service_hash)
  return &deprecated_imported_service_hash_;
}

// repeated .bgs.protocol.connection.v1.BoundService deprecated_exported_service = 2 [deprecated = true];
inline int BindRequest::deprecated_exported_service_size() const {
  return deprecated_exported_service_.size();
}
inline void BindRequest::clear_deprecated_exported_service() {
  deprecated_exported_service_.Clear();
}
inline const ::bgs::protocol::connection::v1::BoundService& BindRequest::deprecated_exported_service(int index) const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.BindRequest.deprecated_exported_service)
  return deprecated_exported_service_.Get(index);
}
inline ::bgs::protocol::connection::v1::BoundService* BindRequest::mutable_deprecated_exported_service(int index) {
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.BindRequest.deprecated_exported_service)
  return deprecated_exported_service_.Mutable(index);
}
inline ::bgs::protocol::connection::v1::BoundService* BindRequest::add_deprecated_exported_service() {
  // @@protoc_insertion_point(field_add:bgs.protocol.connection.v1.BindRequest.deprecated_exported_service)
  return deprecated_exported_service_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService >&
BindRequest::deprecated_exported_service() const {
  // @@protoc_insertion_point(field_list:bgs.protocol.connection.v1.BindRequest.deprecated_exported_service)
  return deprecated_exported_service_;
}
inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService >*
BindRequest::mutable_deprecated_exported_service() {
  // @@protoc_insertion_point(field_mutable_list:bgs.protocol.connection.v1.BindRequest.deprecated_exported_service)
  return &deprecated_exported_service_;
}

// repeated .bgs.protocol.connection.v1.BoundService exported_service = 3;
inline int BindRequest::exported_service_size() const {
  return exported_service_.size();
}
inline void BindRequest::clear_exported_service() {
  exported_service_.Clear();
}
inline const ::bgs::protocol::connection::v1::BoundService& BindRequest::exported_service(int index) const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.BindRequest.exported_service)
  return exported_service_.Get(index);
}
inline ::bgs::protocol::connection::v1::BoundService* BindRequest::mutable_exported_service(int index) {
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.BindRequest.exported_service)
  return exported_service_.Mutable(index);
}
inline ::bgs::protocol::connection::v1::BoundService* BindRequest::add_exported_service() {
  // @@protoc_insertion_point(field_add:bgs.protocol.connection.v1.BindRequest.exported_service)
  return exported_service_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService >&
BindRequest::exported_service() const {
  // @@protoc_insertion_point(field_list:bgs.protocol.connection.v1.BindRequest.exported_service)
  return exported_service_;
}
inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService >*
BindRequest::mutable_exported_service() {
  // @@protoc_insertion_point(field_mutable_list:bgs.protocol.connection.v1.BindRequest.exported_service)
  return &exported_service_;
}

// repeated .bgs.protocol.connection.v1.BoundService imported_service = 4;
inline int BindRequest::imported_service_size() const {
  return imported_service_.size();
}
inline void BindRequest::clear_imported_service() {
  imported_service_.Clear();
}
inline const ::bgs::protocol::connection::v1::BoundService& BindRequest::imported_service(int index) const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.BindRequest.imported_service)
  return imported_service_.Get(index);
}
inline ::bgs::protocol::connection::v1::BoundService* BindRequest::mutable_imported_service(int index) {
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.BindRequest.imported_service)
  return imported_service_.Mutable(index);
}
inline ::bgs::protocol::connection::v1::BoundService* BindRequest::add_imported_service() {
  // @@protoc_insertion_point(field_add:bgs.protocol.connection.v1.BindRequest.imported_service)
  return imported_service_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService >&
BindRequest::imported_service() const {
  // @@protoc_insertion_point(field_list:bgs.protocol.connection.v1.BindRequest.imported_service)
  return imported_service_;
}
inline ::google::protobuf::RepeatedPtrField< ::bgs::protocol::connection::v1::BoundService >*
BindRequest::mutable_imported_service() {
  // @@protoc_insertion_point(field_mutable_list:bgs.protocol.connection.v1.BindRequest.imported_service)
  return &imported_service_;
}

// -------------------------------------------------------------------

// BindResponse

// repeated uint32 imported_service_id = 1 [packed = true, deprecated = true];
inline int BindResponse::imported_service_id_size() const {
  return imported_service_id_.size();
}
inline void BindResponse::clear_imported_service_id() {
  imported_service_id_.Clear();
}
inline ::google::protobuf::uint32 BindResponse::imported_service_id(int index) const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.BindResponse.imported_service_id)
  return imported_service_id_.Get(index);
}
inline void BindResponse::set_imported_service_id(int index, ::google::protobuf::uint32 value) {
  imported_service_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.BindResponse.imported_service_id)
}
inline void BindResponse::add_imported_service_id(::google::protobuf::uint32 value) {
  imported_service_id_.Add(value);
  // @@protoc_insertion_point(field_add:bgs.protocol.connection.v1.BindResponse.imported_service_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BindResponse::imported_service_id() const {
  // @@protoc_insertion_point(field_list:bgs.protocol.connection.v1.BindResponse.imported_service_id)
  return imported_service_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BindResponse::mutable_imported_service_id() {
  // @@protoc_insertion_point(field_mutable_list:bgs.protocol.connection.v1.BindResponse.imported_service_id)
  return &imported_service_id_;
}

// -------------------------------------------------------------------

// EchoRequest

// optional fixed64 time = 1;
inline bool EchoRequest::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EchoRequest::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EchoRequest::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EchoRequest::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 EchoRequest::time() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.EchoRequest.time)
  return time_;
}
inline void EchoRequest::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.EchoRequest.time)
}

// optional bool network_only = 2 [default = false];
inline bool EchoRequest::has_network_only() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EchoRequest::set_has_network_only() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EchoRequest::clear_has_network_only() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EchoRequest::clear_network_only() {
  network_only_ = false;
  clear_has_network_only();
}
inline bool EchoRequest::network_only() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.EchoRequest.network_only)
  return network_only_;
}
inline void EchoRequest::set_network_only(bool value) {
  set_has_network_only();
  network_only_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.EchoRequest.network_only)
}

// optional bytes payload = 3;
inline bool EchoRequest::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EchoRequest::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EchoRequest::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EchoRequest::clear_payload() {
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& EchoRequest::payload() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.EchoRequest.payload)
  return *payload_;
}
inline void EchoRequest::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.EchoRequest.payload)
}
inline void EchoRequest::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.connection.v1.EchoRequest.payload)
}
inline void EchoRequest::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.connection.v1.EchoRequest.payload)
}
inline ::std::string* EchoRequest::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.EchoRequest.payload)
  return payload_;
}
inline ::std::string* EchoRequest::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EchoRequest::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.connection.v1.EchoRequest.payload)
}

// optional .bgs.protocol.ProcessId forward = 4;
inline bool EchoRequest::has_forward() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EchoRequest::set_has_forward() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EchoRequest::clear_has_forward() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EchoRequest::clear_forward() {
  if (forward_ != NULL) forward_->::bgs::protocol::ProcessId::Clear();
  clear_has_forward();
}
inline const ::bgs::protocol::ProcessId& EchoRequest::forward() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.EchoRequest.forward)
  return forward_ != NULL ? *forward_ : *default_instance_->forward_;
}
inline ::bgs::protocol::ProcessId* EchoRequest::mutable_forward() {
  set_has_forward();
  if (forward_ == NULL) forward_ = new ::bgs::protocol::ProcessId;
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.EchoRequest.forward)
  return forward_;
}
inline ::bgs::protocol::ProcessId* EchoRequest::release_forward() {
  clear_has_forward();
  ::bgs::protocol::ProcessId* temp = forward_;
  forward_ = NULL;
  return temp;
}
inline void EchoRequest::set_allocated_forward(::bgs::protocol::ProcessId* forward) {
  delete forward_;
  forward_ = forward;
  if (forward) {
    set_has_forward();
  } else {
    clear_has_forward();
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.connection.v1.EchoRequest.forward)
}

// optional string forward_client_id = 5;
inline bool EchoRequest::has_forward_client_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EchoRequest::set_has_forward_client_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EchoRequest::clear_has_forward_client_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EchoRequest::clear_forward_client_id() {
  if (forward_client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    forward_client_id_->clear();
  }
  clear_has_forward_client_id();
}
inline const ::std::string& EchoRequest::forward_client_id() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.EchoRequest.forward_client_id)
  return *forward_client_id_;
}
inline void EchoRequest::set_forward_client_id(const ::std::string& value) {
  set_has_forward_client_id();
  if (forward_client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    forward_client_id_ = new ::std::string;
  }
  forward_client_id_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.EchoRequest.forward_client_id)
}
inline void EchoRequest::set_forward_client_id(const char* value) {
  set_has_forward_client_id();
  if (forward_client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    forward_client_id_ = new ::std::string;
  }
  forward_client_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.connection.v1.EchoRequest.forward_client_id)
}
inline void EchoRequest::set_forward_client_id(const char* value, size_t size) {
  set_has_forward_client_id();
  if (forward_client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    forward_client_id_ = new ::std::string;
  }
  forward_client_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.connection.v1.EchoRequest.forward_client_id)
}
inline ::std::string* EchoRequest::mutable_forward_client_id() {
  set_has_forward_client_id();
  if (forward_client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    forward_client_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.EchoRequest.forward_client_id)
  return forward_client_id_;
}
inline ::std::string* EchoRequest::release_forward_client_id() {
  clear_has_forward_client_id();
  if (forward_client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = forward_client_id_;
    forward_client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EchoRequest::set_allocated_forward_client_id(::std::string* forward_client_id) {
  if (forward_client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete forward_client_id_;
  }
  if (forward_client_id) {
    set_has_forward_client_id();
    forward_client_id_ = forward_client_id;
  } else {
    clear_has_forward_client_id();
    forward_client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.connection.v1.EchoRequest.forward_client_id)
}

// -------------------------------------------------------------------

// EchoResponse

// optional fixed64 time = 1;
inline bool EchoResponse::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EchoResponse::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EchoResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EchoResponse::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 EchoResponse::time() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.EchoResponse.time)
  return time_;
}
inline void EchoResponse::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.EchoResponse.time)
}

// optional bytes payload = 2;
inline bool EchoResponse::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EchoResponse::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EchoResponse::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EchoResponse::clear_payload() {
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& EchoResponse::payload() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.EchoResponse.payload)
  return *payload_;
}
inline void EchoResponse::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.EchoResponse.payload)
}
inline void EchoResponse::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.connection.v1.EchoResponse.payload)
}
inline void EchoResponse::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.connection.v1.EchoResponse.payload)
}
inline ::std::string* EchoResponse::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.EchoResponse.payload)
  return payload_;
}
inline ::std::string* EchoResponse::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EchoResponse::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.connection.v1.EchoResponse.payload)
}

// -------------------------------------------------------------------

// DisconnectRequest

// required uint32 error_code = 1;
inline bool DisconnectRequest::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisconnectRequest::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DisconnectRequest::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DisconnectRequest::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 DisconnectRequest::error_code() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.DisconnectRequest.error_code)
  return error_code_;
}
inline void DisconnectRequest::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.DisconnectRequest.error_code)
}

// -------------------------------------------------------------------

// DisconnectNotification

// required uint32 error_code = 1;
inline bool DisconnectNotification::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisconnectNotification::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DisconnectNotification::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DisconnectNotification::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 DisconnectNotification::error_code() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.DisconnectNotification.error_code)
  return error_code_;
}
inline void DisconnectNotification::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.DisconnectNotification.error_code)
}

// optional string reason = 2;
inline bool DisconnectNotification::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DisconnectNotification::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DisconnectNotification::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DisconnectNotification::clear_reason() {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& DisconnectNotification::reason() const {
  // @@protoc_insertion_point(field_get:bgs.protocol.connection.v1.DisconnectNotification.reason)
  return *reason_;
}
inline void DisconnectNotification::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set:bgs.protocol.connection.v1.DisconnectNotification.reason)
}
inline void DisconnectNotification::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set_char:bgs.protocol.connection.v1.DisconnectNotification.reason)
}
inline void DisconnectNotification::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bgs.protocol.connection.v1.DisconnectNotification.reason)
}
inline ::std::string* DisconnectNotification::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bgs.protocol.connection.v1.DisconnectNotification.reason)
  return reason_;
}
inline ::std::string* DisconnectNotification::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DisconnectNotification::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bgs.protocol.connection.v1.DisconnectNotification.reason)
}

// -------------------------------------------------------------------

// EncryptRequest


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace connection
}  // namespace protocol
}  // namespace bgs

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_connection_5fservice_2eproto__INCLUDED
