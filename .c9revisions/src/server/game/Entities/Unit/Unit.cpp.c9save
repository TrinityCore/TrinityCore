{"ts":1348522029745,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>\n * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"Common.h\"\n#include \"CreatureAIImpl.h\"\n#include \"Log.h\"\n#include \"Opcodes.h\"\n#include \"WorldPacket.h\"\n#include \"WorldSession.h\"\n#include \"World.h\"\n#include \"ObjectMgr.h\"\n#include \"SpellMgr.h\"\n#include \"Unit.h\"\n#include \"QuestDef.h\"\n#include \"Player.h\"\n#include \"Creature.h\"\n#include \"Spell.h\"\n#include \"Group.h\"\n#include \"SpellAuras.h\"\n#include \"SpellAuraEffects.h\"\n#include \"MapManager.h\"\n#include \"ObjectAccessor.h\"\n#include \"CreatureAI.h\"\n#include \"Formulas.h\"\n#include \"Pet.h\"\n#include \"Util.h\"\n#include \"Totem.h\"\n#include \"Battleground.h\"\n#include \"OutdoorPvP.h\"\n#include \"InstanceSaveMgr.h\"\n#include \"GridNotifiersImpl.h\"\n#include \"CellImpl.h\"\n#include \"CreatureGroups.h\"\n#include \"PetAI.h\"\n#include \"PassiveAI.h\"\n#include \"TemporarySummon.h\"\n#include \"Vehicle.h\"\n#include \"Transport.h\"\n#include \"InstanceScript.h\"\n#include \"SpellInfo.h\"\n#include \"MoveSplineInit.h\"\n#include \"MoveSpline.h\"\n#include \"ConditionMgr.h\"\n#include \"UpdateFieldFlags.h\"\n#include \"Battlefield.h\"\n#include \"BattlefieldMgr.h\"\n\n#include <math.h>\n\nfloat baseMoveSpeed[MAX_MOVE_TYPE] =\n{\n    2.5f,                  // MOVE_WALK\n    7.0f,                  // MOVE_RUN\n    4.5f,                  // MOVE_RUN_BACK\n    4.722222f,             // MOVE_SWIM\n    2.5f,                  // MOVE_SWIM_BACK\n    3.141594f,             // MOVE_TURN_RATE\n    7.0f,                  // MOVE_FLIGHT\n    4.5f,                  // MOVE_FLIGHT_BACK\n    3.14f                  // MOVE_PITCH_RATE\n};\n\nfloat playerBaseMoveSpeed[MAX_MOVE_TYPE] =\n{\n    2.5f,                  // MOVE_WALK\n    7.0f,                  // MOVE_RUN\n    4.5f,                  // MOVE_RUN_BACK\n    4.722222f,             // MOVE_SWIM\n    2.5f,                  // MOVE_SWIM_BACK\n    3.141594f,             // MOVE_TURN_RATE\n    7.0f,                  // MOVE_FLIGHT\n    4.5f,                  // MOVE_FLIGHT_BACK\n    3.14f                  // MOVE_PITCH_RATE\n};\n\n// Used for prepare can/can`t triggr aura\nstatic bool InitTriggerAuraData();\n// Define can trigger auras\nstatic bool isTriggerAura[TOTAL_AURAS];\n// Define can't trigger auras (need for disable second trigger)\nstatic bool isNonTriggerAura[TOTAL_AURAS];\n// Triggered always, even from triggered spells\nstatic bool isAlwaysTriggeredAura[TOTAL_AURAS];\n// Prepare lists\nstatic bool procPrepared = InitTriggerAuraData();\n\nDamageInfo::DamageInfo(Unit* _attacker, Unit* _victim, uint32 _damage, SpellInfo const* _spellInfo, SpellSchoolMask _schoolMask, DamageEffectType _damageType)\n: m_attacker(_attacker), m_victim(_victim), m_damage(_damage), m_spellInfo(_spellInfo), m_schoolMask(_schoolMask),\nm_damageType(_damageType), m_attackType(BASE_ATTACK)\n{\n    m_absorb = 0;\n    m_resist = 0;\n    m_block = 0;\n}\nDamageInfo::DamageInfo(CalcDamageInfo& dmgInfo)\n: m_attacker(dmgInfo.attacker), m_victim(dmgInfo.target), m_damage(dmgInfo.damage), m_spellInfo(NULL), m_schoolMask(SpellSchoolMask(dmgInfo.damageSchoolMask)),\nm_damageType(DIRECT_DAMAGE), m_attackType(dmgInfo.attackType)\n{\n    m_absorb = 0;\n    m_resist = 0;\n    m_block = 0;\n}\n\nvoid DamageInfo::ModifyDamage(int32 amount)\n{\n    amount = std::min(amount, int32(GetDamage()));\n    m_damage += amount;\n}\n\nvoid DamageInfo::AbsorbDamage(uint32 amount)\n{\n    amount = std::min(amount, GetDamage());\n    m_absorb += amount;\n    m_damage -= amount;\n}\n\nvoid DamageInfo::ResistDamage(uint32 amount)\n{\n    amount = std::min(amount, GetDamage());\n    m_resist += amount;\n    m_damage -= amount;\n}\n\nvoid DamageInfo::BlockDamage(uint32 amount)\n{\n    amount = std::min(amount, GetDamage());\n    m_block += amount;\n    m_damage -= amount;\n}\n\nProcEventInfo::ProcEventInfo(Unit* actor, Unit* actionTarget, Unit* procTarget, uint32 typeMask, uint32 spellTypeMask, uint32 spellPhaseMask, uint32 hitMask, Spell* spell, DamageInfo* damageInfo, HealInfo* healInfo)\n:_actor(actor), _actionTarget(actionTarget), _procTarget(procTarget), _typeMask(typeMask), _spellTypeMask(spellTypeMask), _spellPhaseMask(spellPhaseMask),\n_hitMask(hitMask), _spell(spell), _damageInfo(damageInfo), _healInfo(healInfo)\n{\n}\n\n// we can disable this warning for this since it only\n// causes undefined behavior when passed to the base class constructor\n#ifdef _MSC_VER\n#pragma warning(disable:4355)\n#endif\nUnit::Unit(bool isWorldObject): WorldObject(isWorldObject)\n    , m_movedPlayer(NULL)\n    , m_lastSanctuaryTime(0)\n    , m_TempSpeed(0.0f)\n    , IsAIEnabled(false)\n    , NeedChangeAI(false)\n    , m_ControlledByPlayer(false)\n    , movespline(new Movement::MoveSpline())\n    , i_AI(NULL)\n    , i_disabledAI(NULL)\n    , m_AutoRepeatFirstCast(false)\n    , m_procDeep(0)\n    , m_removedAurasCount(0)\n    , i_motionMaster(this)\n    , m_ThreatManager(this)\n    , m_vehicle(NULL)\n    , m_vehicleKit(NULL)\n    , m_unitTypeMask(UNIT_MASK_NONE)\n    , m_HostileRefManager(this)\n    , _lastDamagedTime(0)\n{\n#ifdef _MSC_VER\n#pragma warning(default:4355)\n#endif\n    m_objectType |= TYPEMASK_UNIT;\n    m_objectTypeId = TYPEID_UNIT;\n\n    m_updateFlag = (UPDATEFLAG_LIVING | UPDATEFLAG_STATIONARY_POSITION);\n\n    m_attackTimer[BASE_ATTACK] = 0;\n    m_attackTimer[OFF_ATTACK] = 0;\n    m_attackTimer[RANGED_ATTACK] = 0;\n    m_modAttackSpeedPct[BASE_ATTACK] = 1.0f;\n    m_modAttackSpeedPct[OFF_ATTACK] = 1.0f;\n    m_modAttackSpeedPct[RANGED_ATTACK] = 1.0f;\n\n    m_extraAttacks = 0;\n    m_canDualWield = false;\n\n    m_rootTimes = 0;\n\n    m_state = 0;\n    m_deathState = ALIVE;\n\n    for (uint8 i = 0; i < CURRENT_MAX_SPELL; ++i)\n        m_currentSpells[i] = NULL;\n\n    m_addDmgOnce = 0;\n\n    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)\n        m_SummonSlot[i] = 0;\n\n    for (uint8 i = 0; i < MAX_GAMEOBJECT_SLOT; ++i)\n        m_ObjectSlot[i] = 0;\n\n    m_auraUpdateIterator = m_ownedAuras.end();\n\n    m_interruptMask = 0;\n    m_transform = 0;\n    m_canModifyStats = false;\n\n    for (uint8 i = 0; i < MAX_SPELL_IMMUNITY; ++i)\n        m_spellImmune[i].clear();\n\n    for (uint8 i = 0; i < UNIT_MOD_END; ++i)\n    {\n        m_auraModifiersGroup[i][BASE_VALUE] = 0.0f;\n        m_auraModifiersGroup[i][BASE_PCT] = 1.0f;\n        m_auraModifiersGroup[i][TOTAL_VALUE] = 0.0f;\n        m_auraModifiersGroup[i][TOTAL_PCT] = 1.0f;\n    }\n                                                            // implement 50% base damage from offhand\n    m_auraModifiersGroup[UNIT_MOD_DAMAGE_OFFHAND][TOTAL_PCT] = 0.5f;\n\n    for (uint8 i = 0; i < MAX_ATTACK; ++i)\n    {\n        m_weaponDamage[i][MINDAMAGE] = BASE_MINDAMAGE;\n        m_weaponDamage[i][MAXDAMAGE] = BASE_MAXDAMAGE;\n    }\n\n    for (uint8 i = 0; i < MAX_STATS; ++i)\n        m_createStats[i] = 0.0f;\n\n    m_attacking = NULL;\n    m_modMeleeHitChance = 0.0f;\n    m_modRangedHitChance = 0.0f;\n    m_modSpellHitChance = 0.0f;\n    m_baseSpellCritChance = 5;\n\n    m_CombatTimer = 0;\n    m_lastManaUse = 0;\n\n    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)\n        m_threatModifier[i] = 1.0f;\n\n    m_isSorted = true;\n\n    for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)\n        m_speed_rate[i] = 1.0f;\n\n    m_charmInfo = NULL;\n    m_reducedThreatPercent = 0;\n    m_misdirectionTargetGUID = 0;\n\n    // remove aurastates allowing special moves\n    for (uint8 i = 0; i < MAX_REACTIVE; ++i)\n        m_reactiveTimer[i] = 0;\n\n    m_cleanupDone = false;\n    m_duringRemoveFromWorld = false;\n\n    m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GHOST, GHOST_VISIBILITY_ALIVE);\n\n    _focusSpell = NULL;\n    _lastLiquid = NULL;\n    _isWalkingBeforeCharm = false;\n}\n\n////////////////////////////////////////////////////////////\n// Methods of class GlobalCooldownMgr\nbool GlobalCooldownMgr::HasGlobalCooldown(SpellInfo const* spellInfo) const\n{\n    GlobalCooldownList::const_iterator itr = m_GlobalCooldowns.find(spellInfo->StartRecoveryCategory);\n    return itr != m_GlobalCooldowns.end() && itr->second.duration && getMSTimeDiff(itr->second.cast_time, getMSTime()) < itr->second.duration;\n}\n\nvoid GlobalCooldownMgr::AddGlobalCooldown(SpellInfo const* spellInfo, uint32 gcd)\n{\n    m_GlobalCooldowns[spellInfo->StartRecoveryCategory] = GlobalCooldown(gcd, getMSTime());\n}\n\nvoid GlobalCooldownMgr::CancelGlobalCooldown(SpellInfo const* spellInfo)\n{\n    m_GlobalCooldowns[spellInfo->StartRecoveryCategory].duration = 0;\n}\n\n////////////////////////////////////////////////////////////\n// Methods of class Unit\nUnit::~Unit()\n{\n    // set current spells as deletable\n    for (uint8 i = 0; i < CURRENT_MAX_SPELL; ++i)\n        if (m_currentSpells[i])\n        {\n            m_currentSpells[i]->SetReferencedFromCurrent(false);\n            m_currentSpells[i] = NULL;\n        }\n\n    _DeleteRemovedAuras();\n\n    delete m_charmInfo;\n    delete movespline;\n\n    ASSERT(!m_duringRemoveFromWorld);\n    ASSERT(!m_attacking);\n    ASSERT(m_attackers.empty());\n    ASSERT(m_sharedVision.empty());\n    ASSERT(m_Controlled.empty());\n    ASSERT(m_appliedAuras.empty());\n    ASSERT(m_ownedAuras.empty());\n    ASSERT(m_removedAuras.empty());\n    ASSERT(m_gameObj.empty());\n    ASSERT(m_dynObj.empty());\n}\n\nvoid Unit::Update(uint32 p_time)\n{\n    // WARNING! Order of execution here is important, do not change.\n    // Spells must be processed with event system BEFORE they go to _UpdateSpells.\n    // Or else we may have some SPELL_STATE_FINISHED spells stalled in pointers, that is bad.\n    m_Events.Update(p_time);\n\n    if (!IsInWorld())\n        return;\n\n    _UpdateSpells(p_time);\n\n    // If this is set during update SetCantProc(false) call is missing somewhere in the code\n    // Having this would prevent spells from being proced, so let's crash\n    ASSERT(!m_procDeep);\n\n    if (CanHaveThreatList() && getThreatManager().isNeedUpdateToClient(p_time))\n        SendThreatListUpdate();\n\n    // update combat timer only for players and pets (only pets with PetAI)\n    if (isInCombat() && (GetTypeId() == TYPEID_PLAYER || (ToCreature()->isPet() && IsControlledByPlayer())))\n    {\n        // Check UNIT_STATE_MELEE_ATTACKING or UNIT_STATE_CHASE (without UNIT_STATE_FOLLOW in this case) so pets can reach far away\n        // targets without stopping half way there and running off.\n        // These flags are reset after target dies or another command is given.\n        if (m_HostileRefManager.isEmpty())\n        {\n            // m_CombatTimer set at aura start and it will be freeze until aura removing\n            if (m_CombatTimer <= p_time)\n                ClearInCombat();\n            else\n                m_CombatTimer -= p_time;\n        }\n    }\n\n    // not implemented before 3.0.2\n    if (uint32 base_att = getAttackTimer(BASE_ATTACK))\n        setAttackTimer(BASE_ATTACK, (p_time >= base_att ? 0 : base_att - p_time));\n    if (uint32 ranged_att = getAttackTimer(RANGED_ATTACK))\n        setAttackTimer(RANGED_ATTACK, (p_time >= ranged_att ? 0 : ranged_att - p_time));\n    if (uint32 off_att = getAttackTimer(OFF_ATTACK))\n        setAttackTimer(OFF_ATTACK, (p_time >= off_att ? 0 : off_att - p_time));\n\n    // update abilities available only for fraction of time\n    UpdateReactives(p_time);\n\n    if (isAlive())\n    {\n        ModifyAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, HealthBelowPct(20));\n        ModifyAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, HealthBelowPct(35));\n        ModifyAuraState(AURA_STATE_HEALTH_ABOVE_75_PERCENT, HealthAbovePct(75));\n    }\n\n    UpdateSplineMovement(p_time);\n    i_motionMaster.UpdateMotion(p_time);\n}\n\nbool Unit::haveOffhandWeapon() const\n{\n    if (GetTypeId() == TYPEID_PLAYER)\n        return ToPlayer()->GetWeaponForAttack(OFF_ATTACK, true);\n    else\n        return m_canDualWield;\n}\n\nvoid Unit::MonsterMoveWithSpeed(float x, float y, float z, float speed)\n{\n    Movement::MoveSplineInit init(*this);\n    init.MoveTo(x,y,z);\n    init.SetVelocity(speed);\n    init.Launch();\n}\n\nvoid Unit::UpdateSplineMovement(uint32 t_diff)\n{\n    uint32 const positionUpdateDelay = 400;\n\n    if (movespline->Finalized())\n        return;\n\n    movespline->updateState(t_diff);\n    bool arrived = movespline->Finalized();\n\n    if (arrived)\n        DisableSpline();\n\n    m_movesplineTimer.Update(t_diff);\n    if (m_movesplineTimer.Passed() || arrived)\n    {\n        m_movesplineTimer.Reset(positionUpdateDelay);\n        Movement::Location loc = movespline->ComputePosition();\n\n        if (HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT))\n        {\n            Position& pos = m_movementInfo.t_pos;\n            pos.m_positionX = loc.x;\n            pos.m_positionY = loc.y;\n            pos.m_positionZ = loc.z;\n            pos.m_orientation = loc.orientation;\n\n            if (TransportBase* transport = GetDirectTransport())\n                transport->CalculatePassengerPosition(loc.x, loc.y, loc.z, loc.orientation);\n        }\n\n        if (HasUnitState(UNIT_STATE_CANNOT_TURN))\n            loc.orientation = GetOrientation();\n\n        UpdatePosition(loc.x, loc.y, loc.z, loc.orientation);\n    }\n}\n\nvoid Unit::DisableSpline()\n{\n    m_movementInfo.RemoveMovementFlag(MovementFlags(MOVEMENTFLAG_SPLINE_ENABLED|MOVEMENTFLAG_FORWARD));\n    movespline->_Interrupt();\n}\n\nvoid Unit::resetAttackTimer(WeaponAttackType type)\n{\n    m_attackTimer[type] = uint32(GetAttackTime(type) * m_modAttackSpeedPct[type]);\n}\n\nbool Unit::IsWithinCombatRange(const Unit* obj, float dist2compare) const\n{\n    if (!obj || !IsInMap(obj) || !InSamePhase(obj))\n        return false;\n\n    float dx = GetPositionX() - obj->GetPositionX();\n    float dy = GetPositionY() - obj->GetPositionY();\n    float dz = GetPositionZ() - obj->GetPositionZ();\n    float distsq = dx * dx + dy * dy + dz * dz;\n\n    float sizefactor = GetCombatReach() + obj->GetCombatReach();\n    float maxdist = dist2compare + sizefactor;\n\n    return distsq < maxdist * maxdist;\n}\n\nbool Unit::IsWithinMeleeRange(const Unit* obj, float dist) const\n{\n    if (!obj || !IsInMap(obj) || !InSamePhase(obj))\n        return false;\n\n    float dx = GetPositionX() - obj->GetPositionX();\n    float dy = GetPositionY() - obj->GetPositionY();\n    float dz = GetPositionZ() - obj->GetPositionZ();\n    float distsq = dx*dx + dy*dy + dz*dz;\n\n    float sizefactor = GetMeleeReach() + obj->GetMeleeReach();\n    float maxdist = dist + sizefactor;\n\n    return distsq < maxdist * maxdist;\n}\n\nvoid Unit::GetRandomContactPoint(const Unit* obj, float &x, float &y, float &z, float distance2dMin, float distance2dMax) const\n{\n    float combat_reach = GetCombatReach();\n    if (combat_reach < 0.1f) // sometimes bugged for players\n        combat_reach = DEFAULT_COMBAT_REACH;\n\n    uint32 attacker_number = getAttackers().size();\n    if (attacker_number > 0)\n        --attacker_number;\n    GetNearPoint(obj, x, y, z, obj->GetCombatReach(), distance2dMin+(distance2dMax-distance2dMin) * (float)rand_norm()\n        , GetAngle(obj) + (attacker_number ? (static_cast<float>(M_PI/2) - static_cast<float>(M_PI) * (float)rand_norm()) * float(attacker_number) / combat_reach * 0.3f : 0));\n}\n\nvoid Unit::UpdateInterruptMask()\n{\n    m_interruptMask = 0;\n    for (AuraApplicationList::const_iterator i = m_interruptableAuras.begin(); i != m_interruptableAuras.end(); ++i)\n        m_interruptMask |= (*i)->GetBase()->GetSpellInfo()->AuraInterruptFlags;\n\n    if (Spell* spell = m_currentSpells[CURRENT_CHANNELED_SPELL])\n        if (spell->getState() == SPELL_STATE_CASTING)\n            m_interruptMask |= spell->m_spellInfo->ChannelInterruptFlags;\n}\n\nbool Unit::HasAuraTypeWithFamilyFlags(AuraType auraType, uint32 familyName, uint32 familyFlags) const\n{\n    if (!HasAuraType(auraType))\n        return false;\n    AuraEffectList const& auras = GetAuraEffectsByType(auraType);\n    for (AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)\n        if (SpellInfo const* iterSpellProto = (*itr)->GetSpellInfo())\n            if (iterSpellProto->SpellFamilyName == familyName && iterSpellProto->SpellFamilyFlags[0] & familyFlags)\n                return true;\n    return false;\n}\n\nbool Unit::HasBreakableByDamageAuraType(AuraType type, uint32 excludeAura) const\n{\n    AuraEffectList const& auras = GetAuraEffectsByType(type);\n    for (AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)\n        if ((!excludeAura || excludeAura != (*itr)->GetSpellInfo()->Id) && //Avoid self interrupt of channeled Crowd Control spells like Seduction\n            ((*itr)->GetSpellInfo()->Attributes & SPELL_ATTR0_BREAKABLE_BY_DAMAGE || (*itr)->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE))\n            return true;\n    return false;\n}\n\nbool Unit::HasBreakableByDamageCrowdControlAura(Unit* excludeCasterChannel) const\n{\n    uint32 excludeAura = 0;\n    if (Spell* currentChanneledSpell = excludeCasterChannel ? excludeCasterChannel->GetCurrentSpell(CURRENT_CHANNELED_SPELL) : NULL)\n        excludeAura = currentChanneledSpell->GetSpellInfo()->Id; //Avoid self interrupt of channeled Crowd Control spells like Seduction\n\n    return (   HasBreakableByDamageAuraType(SPELL_AURA_MOD_CONFUSE, excludeAura)\n            || HasBreakableByDamageAuraType(SPELL_AURA_MOD_FEAR, excludeAura)\n            || HasBreakableByDamageAuraType(SPELL_AURA_MOD_STUN, excludeAura)\n            || HasBreakableByDamageAuraType(SPELL_AURA_MOD_ROOT, excludeAura)\n            || HasBreakableByDamageAuraType(SPELL_AURA_TRANSFORM, excludeAura));\n}\n\nvoid Unit::DealDamageMods(Unit* victim, uint32 &damage, uint32* absorb)\n{\n    if (!victim || !victim->isAlive() || victim->HasUnitState(UNIT_STATE_IN_FLIGHT) || (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode()))\n    {\n        if (absorb)\n            *absorb += damage;\n        damage = 0;\n    }\n}\n\nuint32 Unit::DealDamage(Unit* victim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellSchoolMask damageSchoolMask, SpellInfo const* spellProto, bool durabilityLoss)\n{\n    if (victim->IsAIEnabled)\n        victim->GetAI()->DamageTaken(this, damage);\n\n    if (IsAIEnabled)\n        GetAI()->DamageDealt(victim, damage, damagetype);\n\n    if (victim->GetTypeId() == TYPEID_PLAYER)\n    {\n        if (victim->ToPlayer()->GetCommandStatus(CHEAT_GOD))\n            return 0;\n\n        // Signal to pets that their owner was attacked\n        Pet* pet = victim->ToPlayer()->GetPet();\n\n        if (pet && pet->isAlive())\n            pet->AI()->OwnerDamagedBy(this);\n    }\n\n    if (damagetype != NODAMAGE)\n    {\n        // interrupting auras with AURA_INTERRUPT_FLAG_DAMAGE before checking !damage (absorbed damage breaks that type of auras)\n        if (spellProto)\n        {\n            if (!(spellProto->AttributesEx4 & SPELL_ATTR4_DAMAGE_DOESNT_BREAK_AURAS))\n                victim->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TAKE_DAMAGE, spellProto->Id);\n        }\n        else\n            victim->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TAKE_DAMAGE, 0);\n\n        // We're going to call functions which can modify content of the list during iteration over it's elements\n        // Let's copy the list so we can prevent iterator invalidation\n        AuraEffectList vCopyDamageCopy(victim->GetAuraEffectsByType(SPELL_AURA_SHARE_DAMAGE_PCT));\n        // copy damage to casters of this aura\n        for (AuraEffectList::iterator i = vCopyDamageCopy.begin(); i != vCopyDamageCopy.end(); ++i)\n        {\n            // Check if aura was removed during iteration - we don't need to work on such auras\n            if (!((*i)->GetBase()->IsAppliedOnTarget(victim->GetGUID())))\n                continue;\n            // check damage school mask\n            if (((*i)->GetMiscValue() & damageSchoolMask) == 0)\n                continue;\n\n            Unit* shareDamageTarget = (*i)->GetCaster();\n            if (!shareDamageTarget)\n                continue;\n            SpellInfo const* spell = (*i)->GetSpellInfo();\n\n            uint32 share = CalculatePctN(damage, (*i)->GetAmount());\n\n            // TODO: check packets if damage is done by victim, or by attacker of victim\n            DealDamageMods(shareDamageTarget, share, NULL);\n            DealDamage(shareDamageTarget, share, NULL, NODAMAGE, spell->GetSchoolMask(), spell, false);\n        }\n    }\n\n    // Rage from Damage made (only from direct weapon damage)\n    if (cleanDamage && damagetype == DIRECT_DAMAGE && this != victim && getPowerType() == POWER_RAGE)\n    {\n        uint32 weaponSpeedHitFactor;\n        uint32 rage_damage = damage + cleanDamage->absorbed_damage;\n\n        switch (cleanDamage->attackType)\n        {\n            case BASE_ATTACK:\n            {\n                weaponSpeedHitFactor = uint32(GetAttackTime(cleanDamage->attackType) / 1000.0f * 3.5f);\n                if (cleanDamage->hitOutCome == MELEE_HIT_CRIT)\n                    weaponSpeedHitFactor *= 2;\n\n                RewardRage(rage_damage, weaponSpeedHitFactor, true);\n\n                break;\n            }\n            case OFF_ATTACK:\n            {\n                weaponSpeedHitFactor = uint32(GetAttackTime(cleanDamage->attackType) / 1000.0f * 1.75f);\n                if (cleanDamage->hitOutCome == MELEE_HIT_CRIT)\n                    weaponSpeedHitFactor *= 2;\n\n                RewardRage(rage_damage, weaponSpeedHitFactor, true);\n\n                break;\n            }\n            case RANGED_ATTACK:\n                break;\n            default:\n                break;\n        }\n    }\n\n    if (!damage)\n    {\n        // Rage from absorbed damage\n        if (cleanDamage && cleanDamage->absorbed_damage && victim->getPowerType() == POWER_RAGE)\n            victim->RewardRage(cleanDamage->absorbed_damage, 0, false);\n\n        return 0;\n    }\n\n    sLog->outDebug(LOG_FILTER_UNITS, \"DealDamageStart\");\n\n    uint32 health = victim->GetHealth();\n    sLog->outInfo(LOG_FILTER_UNITS, \"deal dmg:%d to health:%d \", damage, health);\n\n    // duel ends when player has 1 or less hp\n    bool duel_hasEnded = false;\n    bool duel_wasMounted = false;\n    if (victim->GetTypeId() == TYPEID_PLAYER && victim->ToPlayer()->duel && damage >= (health-1))\n    {\n        // prevent kill only if killed in duel and killed by opponent or opponent controlled creature\n        if (victim->ToPlayer()->duel->opponent == this || victim->ToPlayer()->duel->opponent->GetGUID() == GetOwnerGUID())\n            damage = health - 1;\n\n        duel_hasEnded = true;\n    }\n    else if (victim->IsVehicle() && damage >= (health-1) && victim->GetCharmer() && victim->GetCharmer()->GetTypeId() == TYPEID_PLAYER)\n    {\n        Player* victimRider = victim->GetCharmer()->ToPlayer();\n\n        if (victimRider && victimRider->duel && victimRider->duel->isMounted)\n        {\n            // prevent kill only if killed in duel and killed by opponent or opponent controlled creature\n            if (victimRider->duel->opponent == this || victimRider->duel->opponent->GetGUID() == GetCharmerGUID())\n                damage = health - 1;\n\n            duel_wasMounted = true;\n            duel_hasEnded = true;\n        }\n    }\n\n    if (GetTypeId() == TYPEID_PLAYER && this != victim)\n    {\n        Player* killer = ToPlayer();\n\n        // in bg, count dmg if victim is also a player\n        if (victim->GetTypeId() == TYPEID_PLAYER)\n            if (Battleground* bg = killer->GetBattleground())\n                bg->UpdatePlayerScore(killer, SCORE_DAMAGE_DONE, damage);\n\n        killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DAMAGE_DONE, damage, 0, victim);\n        killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HIT_DEALT, damage);\n    }\n\n    if (victim->GetTypeId() == TYPEID_PLAYER)\n        victim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HIT_RECEIVED, damage);\n    else if (!victim->IsControlledByPlayer() || victim->IsVehicle())\n    {\n        if (!victim->ToCreature()->hasLootRecipient())\n            victim->ToCreature()->SetLootRecipient(this);\n\n        if (IsControlledByPlayer())\n            victim->ToCreature()->LowerPlayerDamageReq(health < damage ?  health : damage);\n    }\n\n    if (health <= damage)\n    {\n        sLog->outDebug(LOG_FILTER_UNITS, \"DealDamage: victim just died\");\n\n        if (victim->GetTypeId() == TYPEID_PLAYER && victim != this)\n        {\n            victim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_DAMAGE_RECEIVED, health);\n\n            // call before auras are removed\n            if (Player* killer = GetCharmerOrOwnerPlayerOrPlayerItself())\n                killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL, 1, 0, victim);\n        }\n\n        Kill(victim, durabilityLoss);\n    }\n    else\n    {\n        sLog->outDebug(LOG_FILTER_UNITS, \"DealDamageAlive\");\n\n        if (victim->GetTypeId() == TYPEID_PLAYER)\n            victim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_DAMAGE_RECEIVED, damage);\n\n        victim->ModifyHealth(- (int32)damage);\n\n        if (damagetype == DIRECT_DAMAGE || damagetype == SPELL_DIRECT_DAMAGE)\n            victim->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_DIRECT_DAMAGE, spellProto ? spellProto->Id : 0);\n\n        if (victim->GetTypeId() != TYPEID_PLAYER)\n            victim->AddThreat(this, float(damage), damageSchoolMask, spellProto);\n        else                                                // victim is a player\n        {\n            // random durability for items (HIT TAKEN)\n            if (roll_chance_f(sWorld->getRate(RATE_DURABILITY_LOSS_DAMAGE)))\n            {\n                EquipmentSlots slot = EquipmentSlots(urand(0, EQUIPMENT_SLOT_END-1));\n                victim->ToPlayer()->DurabilityPointLossForEquipSlot(slot);\n            }\n        }\n\n        // Rage from damage received\n        if (this != victim && victim->getPowerType() == POWER_RAGE)\n        {\n            uint32 rage_damage = damage + (cleanDamage ? cleanDamage->absorbed_damage : 0);\n            victim->RewardRage(rage_damage, 0, false);\n        }\n\n        if (GetTypeId() == TYPEID_PLAYER)\n        {\n            // random durability for items (HIT DONE)\n            if (roll_chance_f(sWorld->getRate(RATE_DURABILITY_LOSS_DAMAGE)))\n            {\n                EquipmentSlots slot = EquipmentSlots(urand(0, EQUIPMENT_SLOT_END-1));\n                ToPlayer()->DurabilityPointLossForEquipSlot(slot);\n            }\n        }\n\n        if (damagetype != NODAMAGE && damage)\n        {\n            if (victim != this && victim->GetTypeId() == TYPEID_PLAYER) // does not support creature push_back\n            {\n                if (damagetype != DOT)\n                    if (Spell* spell = victim->m_currentSpells[CURRENT_GENERIC_SPELL])\n                        if (spell->getState() == SPELL_STATE_PREPARING)\n                        {\n                            uint32 interruptFlags = spell->m_spellInfo->InterruptFlags;\n                            if (interruptFlags & SPELL_INTERRUPT_FLAG_ABORT_ON_DMG)\n                                victim->InterruptNonMeleeSpells(false);\n                            else if (interruptFlags & SPELL_INTERRUPT_FLAG_PUSH_BACK)\n                                spell->Delayed();\n                        }\n\n                if (Spell* spell = victim->m_currentSpells[CURRENT_CHANNELED_SPELL])\n                    if (spell->getState() == SPELL_STATE_CASTING)\n                    {\n                        uint32 channelInterruptFlags = spell->m_spellInfo->ChannelInterruptFlags;\n                        if (((channelInterruptFlags & CHANNEL_FLAG_DELAY) != 0) && (damagetype != DOT))\n                            spell->DelayedChannel();\n                    }\n            }\n        }\n\n        // last damage from duel opponent\n        if (duel_hasEnded)\n        {\n            Player* he = duel_wasMounted ? victim->GetCharmer()->ToPlayer() : victim->ToPlayer();\n\n            ASSERT(he && he->duel);\n\n            if (duel_wasMounted) // In this case victim==mount\n                victim->SetHealth(1);\n            else\n                he->SetHealth(1);\n\n            he->duel->opponent->CombatStopWithPets(true);\n            he->CombatStopWithPets(true);\n\n            he->CastSpell(he, 7267, true);                  // beg\n            he->DuelComplete(DUEL_WON);\n        }\n    }\n\n    sLog->outDebug(LOG_FILTER_UNITS, \"DealDamageEnd returned %d damage\", damage);\n\n    return damage;\n}\n\nvoid Unit::CastStop(uint32 except_spellid)\n{\n    for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; i++)\n        if (m_currentSpells[i] && m_currentSpells[i]->m_spellInfo->Id != except_spellid)\n            InterruptSpell(CurrentSpellTypes(i), false);\n}\n\nvoid Unit::CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo, CustomSpellValues const* value, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)\n{\n    if (!spellInfo)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"CastSpell: unknown spell by caster: %s %u)\", (GetTypeId() == TYPEID_PLAYER ? \"player (GUID:\" : \"creature (Entry:\"), (GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));\n        return;\n    }\n\n    // TODO: this is a workaround - not needed anymore, but required for some scripts :(\n    if (!originalCaster && triggeredByAura)\n        originalCaster = triggeredByAura->GetCasterGUID();\n\n    Spell* spell = new Spell(this, spellInfo, triggerFlags, originalCaster);\n\n    if (value)\n        for (CustomSpellValues::const_iterator itr = value->begin(); itr != value->end(); ++itr)\n            spell->SetSpellValue(itr->first, itr->second);\n\n    spell->m_CastItem = castItem;\n    spell->prepare(&targets, triggeredByAura);\n}\n\nvoid Unit::CastSpell(Unit* victim, uint32 spellId, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)\n{\n    CastSpell(victim, spellId, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);\n}\n\nvoid Unit::CastSpell(Unit* victim, uint32 spellId, TriggerCastFlags triggerFlags /*= TRIGGER_NONE*/, Item* castItem /*= NULL*/, AuraEffect const* triggeredByAura /*= NULL*/, uint64 originalCaster /*= 0*/)\n{\n    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);\n    if (!spellInfo)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"CastSpell: unknown spell id %u by caster: %s %u)\", spellId, (GetTypeId() == TYPEID_PLAYER ? \"player (GUID:\" : \"creature (Entry:\"), (GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));\n        return;\n    }\n\n    CastSpell(victim, spellInfo, triggerFlags, castItem, triggeredByAura, originalCaster);\n}\n\nvoid Unit::CastSpell(Unit* victim, SpellInfo const* spellInfo, bool triggered, Item* castItem/*= NULL*/, AuraEffect const* triggeredByAura /*= NULL*/, uint64 originalCaster /*= 0*/)\n{\n    CastSpell(victim, spellInfo, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);\n}\n\nvoid Unit::CastSpell(Unit* victim, SpellInfo const* spellInfo, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)\n{\n    SpellCastTargets targets;\n    targets.SetUnitTarget(victim);\n    CastSpell(targets, spellInfo, NULL, triggerFlags, castItem, triggeredByAura, originalCaster);\n}\n\nvoid Unit::CastCustomSpell(Unit* target, uint32 spellId, int32 const* bp0, int32 const* bp1, int32 const* bp2, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)\n{\n    CustomSpellValues values;\n    if (bp0)\n        values.AddSpellMod(SPELLVALUE_BASE_POINT0, *bp0);\n    if (bp1)\n        values.AddSpellMod(SPELLVALUE_BASE_POINT1, *bp1);\n    if (bp2)\n        values.AddSpellMod(SPELLVALUE_BASE_POINT2, *bp2);\n    CastCustomSpell(spellId, values, target, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);\n}\n\nvoid Unit::CastCustomSpell(uint32 spellId, SpellValueMod mod, int32 value, Unit* target, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)\n{\n    CustomSpellValues values;\n    values.AddSpellMod(mod, value);\n    CastCustomSpell(spellId, values, target, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);\n}\n\nvoid Unit::CastCustomSpell(uint32 spellId, SpellValueMod mod, int32 value, Unit* target, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)\n{\n    CustomSpellValues values;\n    values.AddSpellMod(mod, value);\n    CastCustomSpell(spellId, values, target, triggerFlags, castItem, triggeredByAura, originalCaster);\n}\n\nvoid Unit::CastCustomSpell(uint32 spellId, CustomSpellValues const& value, Unit* victim, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)\n{\n    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);\n    if (!spellInfo)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"CastSpell: unknown spell id %u by caster: %s %u)\", spellId, (GetTypeId() == TYPEID_PLAYER ? \"player (GUID:\" : \"creature (Entry:\"), (GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));\n        return;\n    }\n    SpellCastTargets targets;\n    targets.SetUnitTarget(victim);\n\n    CastSpell(targets, spellInfo, &value, triggerFlags, castItem, triggeredByAura, originalCaster);\n}\n\nvoid Unit::CastSpell(float x, float y, float z, uint32 spellId, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)\n{\n    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);\n    if (!spellInfo)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"CastSpell: unknown spell id %u by caster: %s %u)\", spellId, (GetTypeId() == TYPEID_PLAYER ? \"player (GUID:\" : \"creature (Entry:\"), (GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));\n        return;\n    }\n    SpellCastTargets targets;\n    targets.SetDst(x, y, z, GetOrientation());\n\n    CastSpell(targets, spellInfo, NULL, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);\n}\n\nvoid Unit::CastSpell(GameObject* go, uint32 spellId, bool triggered, Item* castItem, AuraEffect* triggeredByAura, uint64 originalCaster)\n{\n    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);\n    if (!spellInfo)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"CastSpell: unknown spell id %u by caster: %s %u)\", spellId, (GetTypeId() == TYPEID_PLAYER ? \"player (GUID:\" : \"creature (Entry:\"), (GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));\n        return;\n    }\n    SpellCastTargets targets;\n    targets.SetGOTarget(go);\n\n    CastSpell(targets, spellInfo, NULL, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);\n}\n\n// Obsolete func need remove, here only for comotability vs another patches\nuint32 Unit::SpellNonMeleeDamageLog(Unit* victim, uint32 spellID, uint32 damage)\n{\n    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellID);\n    SpellNonMeleeDamage damageInfo(this, victim, spellInfo->Id, spellInfo->SchoolMask);\n    damage = SpellDamageBonusDone(victim, spellInfo, damage, SPELL_DIRECT_DAMAGE);\n    damage = victim->SpellDamageBonusTaken(this, spellInfo, damage, SPELL_DIRECT_DAMAGE);\n\n    CalculateSpellDamageTaken(&damageInfo, damage, spellInfo);\n    DealDamageMods(damageInfo.target, damageInfo.damage, &damageInfo.absorb);\n    SendSpellNonMeleeDamageLog(&damageInfo);\n    DealSpellDamage(&damageInfo, true);\n    return damageInfo.damage;\n}\n\nvoid Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 damage, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit)\n{\n    if (damage < 0)\n        return;\n\n    Unit* victim = damageInfo->target;\n    if (!victim || !victim->isAlive())\n        return;\n\n    SpellSchoolMask damageSchoolMask = SpellSchoolMask(damageInfo->schoolMask);\n    uint32 crTypeMask = victim->GetCreatureTypeMask();\n\n    if (IsDamageReducedByArmor(damageSchoolMask, spellInfo))\n        damage = CalcArmorReducedDamage(victim, damage, spellInfo, attackType);\n\n    bool blocked = false;\n    // Per-school calc\n    switch (spellInfo->DmgClass)\n    {\n        // Melee and Ranged Spells\n        case SPELL_DAMAGE_CLASS_RANGED:\n        case SPELL_DAMAGE_CLASS_MELEE:\n        {\n            // Physical Damage\n            if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)\n            {\n                // Get blocked status\n                blocked = isSpellBlocked(victim, spellInfo, attackType);\n            }\n\n            if (crit)\n            {\n                damageInfo->HitInfo |= SPELL_HIT_TYPE_CRIT;\n\n                // Calculate crit bonus\n                uint32 crit_bonus = damage;\n                // Apply crit_damage bonus for melee spells\n                if (Player* modOwner = GetSpellModOwner())\n                    modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_CRIT_DAMAGE_BONUS, crit_bonus);\n                damage += crit_bonus;\n\n                // Apply SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE or SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE\n                float critPctDamageMod = 0.0f;\n                if (attackType == RANGED_ATTACK)\n                    critPctDamageMod += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE);\n                else\n                    critPctDamageMod += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE);\n\n                // Increase crit damage from SPELL_AURA_MOD_CRIT_DAMAGE_BONUS\n                critPctDamageMod += (GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS, spellInfo->GetSchoolMask()) - 1.0f) * 100;\n\n                // Increase crit damage from SPELL_AURA_MOD_CRIT_PERCENT_VERSUS\n                critPctDamageMod += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, crTypeMask);\n\n                if (critPctDamageMod != 0)\n                    AddPctF(damage, critPctDamageMod);\n            }\n\n            // Spell weapon based damage CAN BE crit & blocked at same time\n            if (blocked)\n            {\n                damageInfo->blocked = victim->GetShieldBlockValue();\n                // double blocked amount if block is critical\n                if (victim->isBlockCritical())\n                    damageInfo->blocked += damageInfo->blocked;\n                if (damage < int32(damageInfo->blocked))\n                    damageInfo->blocked = uint32(damage);\n                damage -= damageInfo->blocked;\n            }\n\n            if (attackType != RANGED_ATTACK)\n                ApplyResilience(victim, NULL, &damage, crit, CR_CRIT_TAKEN_MELEE);\n            else\n                ApplyResilience(victim, NULL, &damage, crit, CR_CRIT_TAKEN_RANGED);\n            break;\n        }\n        // Magical Attacks\n        case SPELL_DAMAGE_CLASS_NONE:\n        case SPELL_DAMAGE_CLASS_MAGIC:\n        {\n            // If crit add critical bonus\n            if (crit)\n            {\n                damageInfo->HitInfo |= SPELL_HIT_TYPE_CRIT;\n                damage = SpellCriticalDamageBonus(spellInfo, damage, victim);\n            }\n\n            ApplyResilience(victim, NULL, &damage, crit, CR_CRIT_TAKEN_SPELL);\n            break;\n        }\n        default:\n            break;\n    }\n\n    // Calculate absorb resist\n    if (damage > 0)\n    {\n        CalcAbsorbResist(victim, damageSchoolMask, SPELL_DIRECT_DAMAGE, damage, &damageInfo->absorb, &damageInfo->resist, spellInfo);\n        damage -= damageInfo->absorb + damageInfo->resist;\n    }\n    else\n        damage = 0;\n\n    damageInfo->damage = damage;\n}\n\nvoid Unit::DealSpellDamage(SpellNonMeleeDamage* damageInfo, bool durabilityLoss)\n{\n    if (damageInfo == 0)\n        return;\n\n    Unit* victim = damageInfo->target;\n\n    if (!victim)\n        return;\n\n    if (!victim->isAlive() || victim->HasUnitState(UNIT_STATE_IN_FLIGHT) || (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode()))\n        return;\n\n    SpellInfo const* spellProto = sSpellMgr->GetSpellInfo(damageInfo->SpellID);\n    if (spellProto == NULL)\n    {\n        sLog->outDebug(LOG_FILTER_UNITS, \"Unit::DealSpellDamage has wrong damageInfo->SpellID: %u\", damageInfo->SpellID);\n        return;\n    }\n\n    // Call default DealDamage\n    CleanDamage cleanDamage(damageInfo->cleanDamage, damageInfo->absorb, BASE_ATTACK, MELEE_HIT_NORMAL);\n    DealDamage(victim, damageInfo->damage, &cleanDamage, SPELL_DIRECT_DAMAGE, SpellSchoolMask(damageInfo->schoolMask), spellProto, durabilityLoss);\n}\n\n// TODO for melee need create structure as in\nvoid Unit::CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* damageInfo, WeaponAttackType attackType)\n{\n    damageInfo->attacker         = this;\n    damageInfo->target           = victim;\n    damageInfo->damageSchoolMask = GetMeleeDamageSchoolMask();\n    damageInfo->attackType       = attackType;\n    damageInfo->damage           = 0;\n    damageInfo->cleanDamage      = 0;\n    damageInfo->absorb           = 0;\n    damageInfo->resist           = 0;\n    damageInfo->blocked_amount   = 0;\n\n    damageInfo->TargetState      = 0;\n    damageInfo->HitInfo          = 0;\n    damageInfo->procAttacker     = PROC_FLAG_NONE;\n    damageInfo->procVictim       = PROC_FLAG_NONE;\n    damageInfo->procEx           = PROC_EX_NONE;\n    damageInfo->hitOutCome       = MELEE_HIT_EVADE;\n\n    if (!victim)\n        return;\n\n    if (!isAlive() || !victim->isAlive())\n        return;\n\n    // Select HitInfo/procAttacker/procVictim flag based on attack type\n    switch (attackType)\n    {\n        case BASE_ATTACK:\n            damageInfo->procAttacker = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_MAINHAND_ATTACK;\n            damageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;\n            break;\n        case OFF_ATTACK:\n            damageInfo->procAttacker = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_OFFHAND_ATTACK;\n            damageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;\n            damageInfo->HitInfo      = HITINFO_OFFHAND;\n            break;\n        default:\n            return;\n    }\n\n    // Physical Immune check\n    if (damageInfo->target->IsImmunedToDamage(SpellSchoolMask(damageInfo->damageSchoolMask)))\n    {\n       damageInfo->HitInfo       |= HITINFO_NORMALSWING;\n       damageInfo->TargetState    = VICTIMSTATE_IS_IMMUNE;\n\n       damageInfo->procEx        |= PROC_EX_IMMUNE;\n       damageInfo->damage         = 0;\n       damageInfo->cleanDamage    = 0;\n       return;\n    }\n\n    damage += CalculateDamage(damageInfo->attackType, false, true);\n    // Add melee damage bonus\n    damage = MeleeDamageBonusDone(damageInfo->target, damage, damageInfo->attackType);\n    damage = damageInfo->target->MeleeDamageBonusTaken(this, damage, damageInfo->attackType);\n\n    // Calculate armor reduction\n    if (IsDamageReducedByArmor((SpellSchoolMask)(damageInfo->damageSchoolMask)))\n    {\n        damageInfo->damage = CalcArmorReducedDamage(damageInfo->target, damage, NULL, damageInfo->attackType);\n        damageInfo->cleanDamage += damage - damageInfo->damage;\n    }\n    else\n        damageInfo->damage = damage;\n\n    damageInfo->hitOutCome = RollMeleeOutcomeAgainst(damageInfo->target, damageInfo->attackType);\n\n    switch (damageInfo->hitOutCome)\n    {\n        case MELEE_HIT_EVADE:\n            damageInfo->HitInfo        |= HITINFO_MISS | HITINFO_SWINGNOHITSOUND;\n            damageInfo->TargetState     = VICTIMSTATE_EVADES;\n            damageInfo->procEx         |= PROC_EX_EVADE;\n            damageInfo->damage = 0;\n            damageInfo->cleanDamage = 0;\n            return;\n        case MELEE_HIT_MISS:\n            damageInfo->HitInfo        |= HITINFO_MISS;\n            damageInfo->TargetState     = VICTIMSTATE_INTACT;\n            damageInfo->procEx         |= PROC_EX_MISS;\n            damageInfo->damage          = 0;\n            damageInfo->cleanDamage     = 0;\n            break;\n        case MELEE_HIT_NORMAL:\n            damageInfo->TargetState     = VICTIMSTATE_HIT;\n            damageInfo->procEx         |= PROC_EX_NORMAL_HIT;\n            break;\n        case MELEE_HIT_CRIT:\n        {\n            damageInfo->HitInfo        |= HITINFO_CRITICALHIT;\n            damageInfo->TargetState     = VICTIMSTATE_HIT;\n\n            damageInfo->procEx         |= PROC_EX_CRITICAL_HIT;\n            // Crit bonus calc\n            damageInfo->damage += damageInfo->damage;\n            float mod = 0.0f;\n            // Apply SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE or SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE\n            if (damageInfo->attackType == RANGED_ATTACK)\n                mod += damageInfo->target->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE);\n            else\n                mod += damageInfo->target->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE);\n\n            // Increase crit damage from SPELL_AURA_MOD_CRIT_DAMAGE_BONUS\n            mod += (GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS, damageInfo->damageSchoolMask) - 1.0f) * 100;\n\n            uint32 crTypeMask = damageInfo->target->GetCreatureTypeMask();\n\n            // Increase crit damage from SPELL_AURA_MOD_CRIT_PERCENT_VERSUS\n            mod += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, crTypeMask);\n            if (mod != 0)\n                AddPctF(damageInfo->damage, mod);\n            break;\n        }\n        case MELEE_HIT_PARRY:\n            damageInfo->TargetState  = VICTIMSTATE_PARRY;\n            damageInfo->procEx      |= PROC_EX_PARRY;\n            damageInfo->cleanDamage += damageInfo->damage;\n            damageInfo->damage = 0;\n            break;\n        case MELEE_HIT_DODGE:\n            damageInfo->TargetState  = VICTIMSTATE_DODGE;\n            damageInfo->procEx      |= PROC_EX_DODGE;\n            damageInfo->cleanDamage += damageInfo->damage;\n            damageInfo->damage = 0;\n            break;\n        case MELEE_HIT_BLOCK:\n            damageInfo->TargetState = VICTIMSTATE_HIT;\n            damageInfo->HitInfo    |= HITINFO_BLOCK;\n            damageInfo->procEx     |= PROC_EX_BLOCK;\n            damageInfo->blocked_amount = damageInfo->target->GetShieldBlockValue();\n            // double blocked amount if block is critical\n            if (damageInfo->target->isBlockCritical())\n                damageInfo->blocked_amount+=damageInfo->blocked_amount;\n            if (damageInfo->blocked_amount >= damageInfo->damage)\n            {\n                damageInfo->TargetState = VICTIMSTATE_BLOCKS;\n                damageInfo->blocked_amount = damageInfo->damage;\n                damageInfo->procEx |= PROC_EX_FULL_BLOCK;\n            }\n            else\n                damageInfo->procEx  |= PROC_EX_NORMAL_HIT;\n            damageInfo->damage      -= damageInfo->blocked_amount;\n            damageInfo->cleanDamage += damageInfo->blocked_amount;\n            break;\n        case MELEE_HIT_GLANCING:\n        {\n            damageInfo->HitInfo     |= HITINFO_GLANCING;\n            damageInfo->TargetState  = VICTIMSTATE_HIT;\n            damageInfo->procEx      |= PROC_EX_NORMAL_HIT;\n            int32 leveldif = int32(victim->getLevel()) - int32(getLevel());\n            if (leveldif > 3)\n                leveldif = 3;\n            float reducePercent = 1 - leveldif * 0.1f;\n            damageInfo->cleanDamage += damageInfo->damage - uint32(reducePercent * damageInfo->damage);\n            damageInfo->damage = uint32(reducePercent * damageInfo->damage);\n            break;\n        }\n        case MELEE_HIT_CRUSHING:\n            damageInfo->HitInfo     |= HITINFO_CRUSHING;\n            damageInfo->TargetState  = VICTIMSTATE_HIT;\n            damageInfo->procEx      |= PROC_EX_NORMAL_HIT;\n            // 150% normal damage\n            damageInfo->damage += (damageInfo->damage / 2);\n            break;\n        default:\n            break;\n    }\n\n    // Always apply HITINFO_AFFECTS_VICTIM in case its not a miss\n    if (!(damageInfo->HitInfo & HITINFO_MISS))\n        damageInfo->HitInfo |= HITINFO_AFFECTS_VICTIM;\n\n    int32 resilienceReduction = damageInfo->damage;\n    if (attackType != RANGED_ATTACK)\n        ApplyResilience(victim, NULL, &resilienceReduction, (damageInfo->hitOutCome == MELEE_HIT_CRIT), CR_CRIT_TAKEN_MELEE);\n    else\n        ApplyResilience(victim, NULL, &resilienceReduction, (damageInfo->hitOutCome == MELEE_HIT_CRIT), CR_CRIT_TAKEN_RANGED);\n    resilienceReduction = damageInfo->damage - resilienceReduction;\n    damageInfo->damage      -= resilienceReduction;\n    damageInfo->cleanDamage += resilienceReduction;\n\n    // Calculate absorb resist\n    if (int32(damageInfo->damage) > 0)\n    {\n        damageInfo->procVictim |= PROC_FLAG_TAKEN_DAMAGE;\n        // Calculate absorb & resists\n        CalcAbsorbResist(damageInfo->target, SpellSchoolMask(damageInfo->damageSchoolMask), DIRECT_DAMAGE, damageInfo->damage, &damageInfo->absorb, &damageInfo->resist);\n\n        if (damageInfo->absorb)\n        {\n            damageInfo->HitInfo |= (damageInfo->damage - damageInfo->absorb == 0 ? HITINFO_FULL_ABSORB : HITINFO_PARTIAL_ABSORB);\n            damageInfo->procEx  |= PROC_EX_ABSORB;\n        }\n\n        if (damageInfo->resist)\n            damageInfo->HitInfo |= (damageInfo->damage - damageInfo->resist == 0 ? HITINFO_FULL_RESIST : HITINFO_PARTIAL_RESIST);\n\n        damageInfo->damage -= damageInfo->absorb + damageInfo->resist;\n    }\n    else // Impossible get negative result but....\n        damageInfo->damage = 0;\n}\n\nvoid Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)\n{\n    Unit* victim = damageInfo->target;\n\n    if (!victim->isAlive() || victim->HasUnitState(UNIT_STATE_IN_FLIGHT) || (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode()))\n        return;\n\n    // Hmmmm dont like this emotes client must by self do all animations\n    if (damageInfo->HitInfo & HITINFO_CRITICALHIT)\n        victim->HandleEmoteCommand(EMOTE_ONESHOT_WOUND_CRITICAL);\n    if (damageInfo->blocked_amount && damageInfo->TargetState != VICTIMSTATE_BLOCKS)\n        victim->HandleEmoteCommand(EMOTE_ONESHOT_PARRY_SHIELD);\n\n    if (damageInfo->TargetState == VICTIMSTATE_PARRY)\n    {\n        // Get attack timers\n        float offtime  = float(victim->getAttackTimer(OFF_ATTACK));\n        float basetime = float(victim->getAttackTimer(BASE_ATTACK));\n        // Reduce attack time\n        if (victim->haveOffhandWeapon() && offtime < basetime)\n        {\n            float percent20 = victim->GetAttackTime(OFF_ATTACK) * 0.20f;\n            float percent60 = 3.0f * percent20;\n            if (offtime > percent20 && offtime <= percent60)\n                victim->setAttackTimer(OFF_ATTACK, uint32(percent20));\n            else if (offtime > percent60)\n            {\n                offtime -= 2.0f * percent20;\n                victim->setAttackTimer(OFF_ATTACK, uint32(offtime));\n            }\n        }\n        else\n        {\n            float percent20 = victim->GetAttackTime(BASE_ATTACK) * 0.20f;\n            float percent60 = 3.0f * percent20;\n            if (basetime > percent20 && basetime <= percent60)\n                victim->setAttackTimer(BASE_ATTACK, uint32(percent20));\n            else if (basetime > percent60)\n            {\n                basetime -= 2.0f * percent20;\n                victim->setAttackTimer(BASE_ATTACK, uint32(basetime));\n            }\n        }\n    }\n\n    // Call default DealDamage\n    CleanDamage cleanDamage(damageInfo->cleanDamage, damageInfo->absorb, damageInfo->attackType, damageInfo->hitOutCome);\n    DealDamage(victim, damageInfo->damage, &cleanDamage, DIRECT_DAMAGE, SpellSchoolMask(damageInfo->damageSchoolMask), NULL, durabilityLoss);\n\n    // If this is a creature and it attacks from behind it has a probability to daze it's victim\n    if ((damageInfo->hitOutCome == MELEE_HIT_CRIT || damageInfo->hitOutCome == MELEE_HIT_CRUSHING || damageInfo->hitOutCome == MELEE_HIT_NORMAL || damageInfo->hitOutCome == MELEE_HIT_GLANCING) &&\n        GetTypeId() != TYPEID_PLAYER && !ToCreature()->IsControlledByPlayer() && !victim->HasInArc(M_PI, this)\n        && (victim->GetTypeId() == TYPEID_PLAYER || !victim->ToCreature()->isWorldBoss()))\n    {\n        // -probability is between 0% and 40%\n        // 20% base chance\n        float Probability = 20.0f;\n\n        // there is a newbie protection, at level 10 just 7% base chance; assuming linear function\n        if (victim->getLevel() < 30)\n            Probability = 0.65f * victim->getLevel() + 0.5f;\n\n        uint32 VictimDefense=victim->GetDefenseSkillValue();\n        uint32 AttackerMeleeSkill=GetUnitMeleeSkill();\n\n        Probability *= AttackerMeleeSkill/(float)VictimDefense;\n\n        if (Probability > 40.0f)\n            Probability = 40.0f;\n\n        if (roll_chance_f(Probability))\n            CastSpell(victim, 1604, true);\n    }\n\n    if (GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->CastItemCombatSpell(victim, damageInfo->attackType, damageInfo->procVictim, damageInfo->procEx);\n\n    // Do effect if any damage done to target\n    if (damageInfo->damage)\n    {\n        // We're going to call functions which can modify content of the list during iteration over it's elements\n        // Let's copy the list so we can prevent iterator invalidation\n        AuraEffectList vDamageShieldsCopy(victim->GetAuraEffectsByType(SPELL_AURA_DAMAGE_SHIELD));\n        for (AuraEffectList::const_iterator dmgShieldItr = vDamageShieldsCopy.begin(); dmgShieldItr != vDamageShieldsCopy.end(); ++dmgShieldItr)\n        {\n            SpellInfo const* i_spellProto = (*dmgShieldItr)->GetSpellInfo();\n            // Damage shield can be resisted...\n            if (SpellMissInfo missInfo = victim->SpellHitResult(this, i_spellProto, false))\n            {\n                victim->SendSpellMiss(this, i_spellProto->Id, missInfo);\n                continue;\n            }\n\n            // ...or immuned\n            if (IsImmunedToDamage(i_spellProto))\n            {\n                victim->SendSpellDamageImmune(this, i_spellProto->Id);\n                continue;\n            }\n\n            uint32 damage = (*dmgShieldItr)->GetAmount();\n\n            if (Unit* caster = (*dmgShieldItr)->GetCaster())\n            {\n                damage = caster->SpellDamageBonusDone(this, i_spellProto, damage, SPELL_DIRECT_DAMAGE);\n                damage = this->SpellDamageBonusTaken(caster, i_spellProto, damage, SPELL_DIRECT_DAMAGE);\n            }\n\n            // No Unit::CalcAbsorbResist here - opcode doesn't send that data - this damage is probably not affected by that\n            victim->DealDamageMods(this, damage, NULL);\n\n            // TODO: Move this to a packet handler\n            WorldPacket data(SMSG_SPELLDAMAGESHIELD, (8+8+4+4+4+4));\n            data << uint64(victim->GetGUID());\n            data << uint64(GetGUID());\n            data << uint32(i_spellProto->Id);\n            data << uint32(damage);                  // Damage\n            int32 overkill = int32(damage) - int32(GetHealth());\n            data << uint32(overkill > 0 ? overkill : 0); // Overkill\n            data << uint32(i_spellProto->SchoolMask);\n            victim->SendMessageToSet(&data, true);\n\n            victim->DealDamage(this, damage, 0, SPELL_DIRECT_DAMAGE, i_spellProto->GetSchoolMask(), i_spellProto, true);\n        }\n    }\n}\n\nvoid Unit::HandleEmoteCommand(uint32 anim_id)\n{\n    WorldPacket data(SMSG_EMOTE, 4 + 8);\n    data << uint32(anim_id);\n    data << uint64(GetGUID());\n    SendMessageToSet(&data, true);\n}\n\nbool Unit::IsDamageReducedByArmor(SpellSchoolMask schoolMask, SpellInfo const* spellInfo, uint8 effIndex)\n{\n    // only physical spells damage gets reduced by armor\n    if ((schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0)\n        return false;\n    if (spellInfo)\n    {\n        // there are spells with no specific attribute but they have \"ignores armor\" in tooltip\n        if (spellInfo->AttributesCu & SPELL_ATTR0_CU_IGNORE_ARMOR)\n            return false;\n\n        // bleeding effects are not reduced by armor\n        if (effIndex != MAX_SPELL_EFFECTS)\n        {\n            if (spellInfo->Effects[effIndex].ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE ||\n                spellInfo->Effects[effIndex].Effect == SPELL_EFFECT_SCHOOL_DAMAGE)\n                if (spellInfo->GetEffectMechanicMask(effIndex) & (1<<MECHANIC_BLEED))\n                    return false;\n        }\n    }\n    return true;\n}\n\nuint32 Unit::CalcArmorReducedDamage(Unit* victim, const uint32 damage, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/)\n{\n    uint32 newdamage = 0;\n    float armor = float(victim->GetArmor());\n\n    // Ignore enemy armor by SPELL_AURA_MOD_TARGET_RESISTANCE aura\n    armor += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, SPELL_SCHOOL_MASK_NORMAL);\n\n    if (spellInfo)\n        if (Player* modOwner = GetSpellModOwner())\n            modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_IGNORE_ARMOR, armor);\n\n    AuraEffectList const& ResIgnoreAurasAb = GetAuraEffectsByType(SPELL_AURA_MOD_ABILITY_IGNORE_TARGET_RESIST);\n    for (AuraEffectList::const_iterator j = ResIgnoreAurasAb.begin(); j != ResIgnoreAurasAb.end(); ++j)\n    {\n        if ((*j)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL\n            && (*j)->IsAffectedOnSpell(spellInfo))\n            armor = floor(AddPctN(armor, -(*j)->GetAmount()));\n    }\n\n    AuraEffectList const& ResIgnoreAuras = GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);\n    for (AuraEffectList::const_iterator j = ResIgnoreAuras.begin(); j != ResIgnoreAuras.end(); ++j)\n    {\n        if ((*j)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)\n            armor = floor(AddPctN(armor, -(*j)->GetAmount()));\n    }\n\n    // Apply Player CR_ARMOR_PENETRATION rating and buffs from stances\\specializations etc.\n    if (GetTypeId() == TYPEID_PLAYER)\n    {\n        float bonusPct = 0;\n        AuraEffectList const& armorPenAuras = GetAuraEffectsByType(SPELL_AURA_MOD_ARMOR_PENETRATION_PCT);\n        for (AuraEffectList::const_iterator itr = armorPenAuras.begin(); itr != armorPenAuras.end(); ++itr)\n        {\n            if ((*itr)->GetSpellInfo()->EquippedItemClass == -1)\n            {\n                if (!spellInfo || (*itr)->IsAffectedOnSpell(spellInfo) || (*itr)->GetMiscValue() & spellInfo->GetSchoolMask())\n                    bonusPct += (*itr)->GetAmount();\n                else if (!(*itr)->GetMiscValue() && !(*itr)->HasSpellClassMask())\n                    bonusPct += (*itr)->GetAmount();\n            }\n            else\n            {\n                if (ToPlayer()->HasItemFitToSpellRequirements((*itr)->GetSpellInfo()))\n                    bonusPct += (*itr)->GetAmount();\n            }\n        }\n\n        float maxArmorPen = 0;\n        if (victim->getLevel() < 60)\n            maxArmorPen = float(400 + 85 * victim->getLevel());\n        else\n            maxArmorPen = 400 + 85 * victim->getLevel() + 4.5f * 85 * (victim->getLevel() - 59);\n\n        // Cap armor penetration to this number\n        maxArmorPen = std::min((armor + maxArmorPen) / 3, armor);\n        // Figure out how much armor do we ignore\n        float armorPen = CalculatePctF(maxArmorPen, bonusPct + ToPlayer()->GetRatingBonusValue(CR_ARMOR_PENETRATION));\n        // Got the value, apply it\n        armor -= std::min(armorPen, maxArmorPen);\n    }\n\n    if (armor < 0.0f)\n        armor = 0.0f;\n\n    float levelModifier = getLevel();\n    if (levelModifier > 59)\n        levelModifier = levelModifier + (4.5f * (levelModifier - 59));\n\n    float tmpvalue = 0.1f * armor / (8.5f * levelModifier + 40);\n    tmpvalue = tmpvalue / (1.0f + tmpvalue);\n\n    if (tmpvalue < 0.0f)\n        tmpvalue = 0.0f;\n    if (tmpvalue > 0.75f)\n        tmpvalue = 0.75f;\n\n    newdamage = uint32(damage - (damage * tmpvalue));\n\n    return (newdamage > 1) ? newdamage : 1;\n}\n\nvoid Unit::CalcAbsorbResist(Unit* victim, SpellSchoolMask schoolMask, DamageEffectType damagetype, uint32 const damage, uint32 *absorb, uint32 *resist, SpellInfo const* spellInfo)\n{\n    if (!victim || !victim->isAlive() || !damage)\n        return;\n\n    DamageInfo dmgInfo = DamageInfo(this, victim, damage, spellInfo, schoolMask, damagetype);\n\n    // Magic damage, check for resists\n    // Ignore spells that cant be resisted\n    if ((schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0 && (!spellInfo || (spellInfo->AttributesEx4 & SPELL_ATTR4_IGNORE_RESISTANCES) == 0))\n    {\n        float victimResistance = float(victim->GetResistance(schoolMask));\n        victimResistance += float(GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, schoolMask));\n\n        if (Player* player = ToPlayer())\n            victimResistance -= float(player->GetSpellPenetrationItemMod());\n\n        // Resistance can't be lower then 0.\n        if (victimResistance < 0.0f)\n            victimResistance = 0.0f;\n\n        static uint32 const BOSS_LEVEL = 83;\n        static float const BOSS_RESISTANCE_CONSTANT = 510.0f;\n        uint32 level = victim->getLevel();\n        float resistanceConstant = 0.0f;\n\n        if (level == BOSS_LEVEL)\n            resistanceConstant = BOSS_RESISTANCE_CONSTANT;\n        else\n            resistanceConstant = level * 5.0f;\n\n        float averageResist = victimResistance / (victimResistance + resistanceConstant);\n        float discreteResistProbability[11];\n        for (uint32 i = 0; i < 11; ++i)\n        {\n            discreteResistProbability[i] = 0.5f - 2.5f * fabs(0.1f * i - averageResist);\n            if (discreteResistProbability[i] < 0.0f)\n                discreteResistProbability[i] = 0.0f;\n        }\n\n        if (averageResist <= 0.1f)\n        {\n            discreteResistProbability[0] = 1.0f - 7.5f * averageResist;\n            discreteResistProbability[1] = 5.0f * averageResist;\n            discreteResistProbability[2] = 2.5f * averageResist;\n        }\n\n        float r = float(rand_norm());\n        uint32 i = 0;\n        float probabilitySum = discreteResistProbability[0];\n\n        while (r >= probabilitySum && i < 10)\n            probabilitySum += discreteResistProbability[++i];\n\n        float damageResisted = float(damage * i / 10);\n\n        AuraEffectList const& ResIgnoreAurasAb = GetAuraEffectsByType(SPELL_AURA_MOD_ABILITY_IGNORE_TARGET_RESIST);\n        for (AuraEffectList::const_iterator j = ResIgnoreAurasAb.begin(); j != ResIgnoreAurasAb.end(); ++j)\n            if (((*j)->GetMiscValue() & schoolMask) && (*j)->IsAffectedOnSpell(spellInfo))\n                AddPctN(damageResisted, -(*j)->GetAmount());\n\n        AuraEffectList const& ResIgnoreAuras = GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);\n        for (AuraEffectList::const_iterator j = ResIgnoreAuras.begin(); j != ResIgnoreAuras.end(); ++j)\n            if ((*j)->GetMiscValue() & schoolMask)\n                AddPctN(damageResisted, -(*j)->GetAmount());\n\n        dmgInfo.ResistDamage(uint32(damageResisted));\n    }\n\n    // Ignore Absorption Auras\n    float auraAbsorbMod = 0;\n    AuraEffectList const& AbsIgnoreAurasA = GetAuraEffectsByType(SPELL_AURA_MOD_TARGET_ABSORB_SCHOOL);\n    for (AuraEffectList::const_iterator itr = AbsIgnoreAurasA.begin(); itr != AbsIgnoreAurasA.end(); ++itr)\n    {\n        if (!((*itr)->GetMiscValue() & schoolMask))\n            continue;\n\n        if ((*itr)->GetAmount() > auraAbsorbMod)\n            auraAbsorbMod = float((*itr)->GetAmount());\n    }\n\n    AuraEffectList const& AbsIgnoreAurasB = GetAuraEffectsByType(SPELL_AURA_MOD_TARGET_ABILITY_ABSORB_SCHOOL);\n    for (AuraEffectList::const_iterator itr = AbsIgnoreAurasB.begin(); itr != AbsIgnoreAurasB.end(); ++itr)\n    {\n        if (!((*itr)->GetMiscValue() & schoolMask))\n            continue;\n\n        if (((*itr)->GetAmount() > auraAbsorbMod) && (*itr)->IsAffectedOnSpell(spellInfo))\n            auraAbsorbMod = float((*itr)->GetAmount());\n    }\n    RoundToInterval(auraAbsorbMod, 0.0f, 100.0f);\n\n    // We're going to call functions which can modify content of the list during iteration over it's elements\n    // Let's copy the list so we can prevent iterator invalidation\n    AuraEffectList vSchoolAbsorbCopy(victim->GetAuraEffectsByType(SPELL_AURA_SCHOOL_ABSORB));\n    vSchoolAbsorbCopy.sort(Trinity::AbsorbAuraOrderPred());\n\n    // absorb without mana cost\n    for (AuraEffectList::iterator itr = vSchoolAbsorbCopy.begin(); (itr != vSchoolAbsorbCopy.end()) && (dmgInfo.GetDamage() > 0); ++itr)\n    {\n        AuraEffect* absorbAurEff = *itr;\n        // Check if aura was removed during iteration - we don't need to work on such auras\n        AuraApplication const* aurApp = absorbAurEff->GetBase()->GetApplicationOfTarget(victim->GetGUID());\n        if (!aurApp)\n            continue;\n        if (!(absorbAurEff->GetMiscValue() & schoolMask))\n            continue;\n\n        // get amount which can be still absorbed by the aura\n        int32 currentAbsorb = absorbAurEff->GetAmount();\n        // aura with infinite absorb amount - let the scripts handle absorbtion amount, set here to 0 for safety\n        if (currentAbsorb < 0)\n            currentAbsorb = 0;\n\n        uint32 tempAbsorb = uint32(currentAbsorb);\n\n        bool defaultPrevented = false;\n\n        absorbAurEff->GetBase()->CallScriptEffectAbsorbHandlers(absorbAurEff, aurApp, dmgInfo, tempAbsorb, defaultPrevented);\n        currentAbsorb = tempAbsorb;\n\n        if (defaultPrevented)\n            continue;\n\n        // Apply absorb mod auras\n        AddPctF(currentAbsorb, -auraAbsorbMod);\n\n        // absorb must be smaller than the damage itself\n        currentAbsorb = RoundToInterval(currentAbsorb, 0, int32(dmgInfo.GetDamage()));\n\n        dmgInfo.AbsorbDamage(currentAbsorb);\n\n        tempAbsorb = currentAbsorb;\n        absorbAurEff->GetBase()->CallScriptEffectAfterAbsorbHandlers(absorbAurEff, aurApp, dmgInfo, tempAbsorb);\n\n        // Check if our aura is using amount to count damage\n        if (absorbAurEff->GetAmount() >= 0)\n        {\n            // Reduce shield amount\n            absorbAurEff->SetAmount(absorbAurEff->GetAmount() - currentAbsorb);\n            // Aura cannot absorb anything more - remove it\n            if (absorbAurEff->GetAmount() <= 0)\n                absorbAurEff->GetBase()->Remove(AURA_REMOVE_BY_ENEMY_SPELL);\n        }\n    }\n\n    // absorb by mana cost\n    AuraEffectList vManaShieldCopy(victim->GetAuraEffectsByType(SPELL_AURA_MANA_SHIELD));\n    for (AuraEffectList::const_iterator itr = vManaShieldCopy.begin(); (itr != vManaShieldCopy.end()) && (dmgInfo.GetDamage() > 0); ++itr)\n    {\n        AuraEffect* absorbAurEff = *itr;\n        // Check if aura was removed during iteration - we don't need to work on such auras\n        AuraApplication const* aurApp = absorbAurEff->GetBase()->GetApplicationOfTarget(victim->GetGUID());\n        if (!aurApp)\n            continue;\n        // check damage school mask\n        if (!(absorbAurEff->GetMiscValue() & schoolMask))\n            continue;\n\n        // get amount which can be still absorbed by the aura\n        int32 currentAbsorb = absorbAurEff->GetAmount();\n        // aura with infinite absorb amount - let the scripts handle absorbtion amount, set here to 0 for safety\n        if (currentAbsorb < 0)\n            currentAbsorb = 0;\n\n        uint32 tempAbsorb = currentAbsorb;\n\n        bool defaultPrevented = false;\n\n        absorbAurEff->GetBase()->CallScriptEffectManaShieldHandlers(absorbAurEff, aurApp, dmgInfo, tempAbsorb, defaultPrevented);\n        currentAbsorb = tempAbsorb;\n\n        if (defaultPrevented)\n            continue;\n\n        AddPctF(currentAbsorb, -auraAbsorbMod);\n\n        // absorb must be smaller than the damage itself\n        currentAbsorb = RoundToInterval(currentAbsorb, 0, int32(dmgInfo.GetDamage()));\n\n        int32 manaReduction = currentAbsorb;\n\n        // lower absorb amount by talents\n        if (float manaMultiplier = absorbAurEff->GetSpellInfo()->Effects[absorbAurEff->GetEffIndex()].CalcValueMultiplier(absorbAurEff->GetCaster()))\n            manaReduction = int32(float(manaReduction) * manaMultiplier);\n\n        int32 manaTaken = -victim->ModifyPower(POWER_MANA, -manaReduction);\n\n        // take case when mana has ended up into account\n        currentAbsorb = currentAbsorb ? int32(float(currentAbsorb) * (float(manaTaken) / float(manaReduction))) : 0;\n\n        dmgInfo.AbsorbDamage(currentAbsorb);\n\n        tempAbsorb = currentAbsorb;\n        absorbAurEff->GetBase()->CallScriptEffectAfterManaShieldHandlers(absorbAurEff, aurApp, dmgInfo, tempAbsorb);\n\n        // Check if our aura is using amount to count damage\n        if (absorbAurEff->GetAmount() >= 0)\n        {\n            absorbAurEff->SetAmount(absorbAurEff->GetAmount() - currentAbsorb);\n            if ((absorbAurEff->GetAmount() <= 0))\n                absorbAurEff->GetBase()->Remove(AURA_REMOVE_BY_ENEMY_SPELL);\n        }\n    }\n\n    // split damage auras - only when not damaging self\n    if (victim != this)\n    {\n        // We're going to call functions which can modify content of the list during iteration over it's elements\n        // Let's copy the list so we can prevent iterator invalidation\n        AuraEffectList vSplitDamageFlatCopy(victim->GetAuraEffectsByType(SPELL_AURA_SPLIT_DAMAGE_FLAT));\n        for (AuraEffectList::iterator itr = vSplitDamageFlatCopy.begin(); (itr != vSplitDamageFlatCopy.end()) && (dmgInfo.GetDamage() > 0); ++itr)\n        {\n            // Check if aura was removed during iteration - we don't need to work on such auras\n            if (!((*itr)->GetBase()->IsAppliedOnTarget(victim->GetGUID())))\n                continue;\n            // check damage school mask\n            if (!((*itr)->GetMiscValue() & schoolMask))\n                continue;\n\n            // Damage can be splitted only if aura has an alive caster\n            Unit* caster = (*itr)->GetCaster();\n            if (!caster || (caster == victim) || !caster->IsInWorld() || !caster->isAlive())\n                continue;\n\n            int32 splitDamage = (*itr)->GetAmount();\n\n            // absorb must be smaller than the damage itself\n            splitDamage = RoundToInterval(splitDamage, 0, int32(dmgInfo.GetDamage()));\n\n            dmgInfo.AbsorbDamage(splitDamage);\n\n            uint32 splitted = splitDamage;\n            uint32 splitted_absorb = 0;\n            DealDamageMods(caster, splitted, &splitted_absorb);\n\n            SendSpellNonMeleeDamageLog(caster, (*itr)->GetSpellInfo()->Id, splitted, schoolMask, splitted_absorb, 0, false, 0, false);\n\n            CleanDamage cleanDamage = CleanDamage(splitted, 0, BASE_ATTACK, MELEE_HIT_NORMAL);\n            DealDamage(caster, splitted, &cleanDamage, DIRECT_DAMAGE, schoolMask, (*itr)->GetSpellInfo(), false);\n        }\n\n        // We're going to call functions which can modify content of the list during iteration over it's elements\n        // Let's copy the list so we can prevent iterator invalidation\n        AuraEffectList vSplitDamagePctCopy(victim->GetAuraEffectsByType(SPELL_AURA_SPLIT_DAMAGE_PCT));\n        for (AuraEffectList::iterator itr = vSplitDamagePctCopy.begin(), next; (itr != vSplitDamagePctCopy.end()) &&  (dmgInfo.GetDamage() > 0); ++itr)\n        {\n            // Check if aura was removed during iteration - we don't need to work on such auras\n            AuraApplication const* aurApp = (*itr)->GetBase()->GetApplicationOfTarget(victim->GetGUID());\n            if (!aurApp)\n                continue;\n\n            // check damage school mask\n            if (!((*itr)->GetMiscValue() & schoolMask))\n                continue;\n\n            // Damage can be splitted only if aura has an alive caster\n            Unit* caster = (*itr)->GetCaster();\n            if (!caster || (caster == victim) || !caster->IsInWorld() || !caster->isAlive())\n                continue;\n\n            uint32 splitDamage = CalculatePctN(dmgInfo.GetDamage(), (*itr)->GetAmount());\n\n            (*itr)->GetBase()->CallScriptEffectSplitHandlers((*itr), aurApp, dmgInfo, splitDamage);\n\n            // absorb must be smaller than the damage itself\n            splitDamage = RoundToInterval(splitDamage, uint32(0), uint32(dmgInfo.GetDamage()));\n\n            dmgInfo.AbsorbDamage(splitDamage);\n            uint32 splitted = splitDamage;\n            uint32 split_absorb = 0;\n            DealDamageMods(caster, splitted, &split_absorb);\n\n            SendSpellNonMeleeDamageLog(caster, (*itr)->GetSpellInfo()->Id, splitted, schoolMask, split_absorb, 0, false, 0, false);\n\n            CleanDamage cleanDamage = CleanDamage(splitted, 0, BASE_ATTACK, MELEE_HIT_NORMAL);\n            DealDamage(caster, splitted, &cleanDamage, DIRECT_DAMAGE, schoolMask, (*itr)->GetSpellInfo(), false);\n        }\n    }\n\n    *resist = dmgInfo.GetResist();\n    *absorb = dmgInfo.GetAbsorb();\n}\n\nvoid Unit::CalcHealAbsorb(Unit* victim, const SpellInfo* healSpell, uint32 &healAmount, uint32 &absorb)\n{\n    if (!healAmount)\n        return;\n\n    int32 RemainingHeal = healAmount;\n\n    // Need remove expired auras after\n    bool existExpired = false;\n\n    // absorb without mana cost\n    AuraEffectList const& vHealAbsorb = victim->GetAuraEffectsByType(SPELL_AURA_SCHOOL_HEAL_ABSORB);\n    for (AuraEffectList::const_iterator i = vHealAbsorb.begin(); i != vHealAbsorb.end() && RemainingHeal > 0; ++i)\n    {\n        if (!((*i)->GetMiscValue() & healSpell->SchoolMask))\n            continue;\n\n        // Max Amount can be absorbed by this aura\n        int32 currentAbsorb = (*i)->GetAmount();\n\n        // Found empty aura (impossible but..)\n        if (currentAbsorb <= 0)\n        {\n            existExpired = true;\n            continue;\n        }\n\n        // currentAbsorb - damage can be absorbed by shield\n        // If need absorb less damage\n        if (RemainingHeal < currentAbsorb)\n            currentAbsorb = RemainingHeal;\n\n        RemainingHeal -= currentAbsorb;\n\n        // Reduce shield amount\n        (*i)->SetAmount((*i)->GetAmount() - currentAbsorb);\n        // Need remove it later\n        if ((*i)->GetAmount() <= 0)\n            existExpired = true;\n    }\n\n    // Remove all expired absorb auras\n    if (existExpired)\n    {\n        for (AuraEffectList::const_iterator i = vHealAbsorb.begin(); i != vHealAbsorb.end();)\n        {\n            AuraEffect* auraEff = *i;\n            ++i;\n            if (auraEff->GetAmount() <= 0)\n            {\n                uint32 removedAuras = victim->m_removedAurasCount;\n                auraEff->GetBase()->Remove(AURA_REMOVE_BY_ENEMY_SPELL);\n                if (removedAuras+1 < victim->m_removedAurasCount)\n                    i = vHealAbsorb.begin();\n            }\n        }\n    }\n\n    absorb = RemainingHeal > 0 ? (healAmount - RemainingHeal) : healAmount;\n    healAmount = RemainingHeal;\n}\n\nvoid Unit::AttackerStateUpdate (Unit* victim, WeaponAttackType attType, bool extra)\n{\n    if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))\n        return;\n\n    if (!victim->isAlive())\n        return;\n\n    if ((attType == BASE_ATTACK || attType == OFF_ATTACK) && !IsWithinLOSInMap(victim))\n        return;\n\n    CombatStart(victim);\n    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MELEE_ATTACK);\n\n    if (attType != BASE_ATTACK && attType != OFF_ATTACK)\n        return;                                             // ignore ranged case\n\n    // melee attack spell casted at main hand attack only - no normal melee dmg dealt\n    if (attType == BASE_ATTACK && m_currentSpells[CURRENT_MELEE_SPELL] && !extra)\n        m_currentSpells[CURRENT_MELEE_SPELL]->cast();\n    else\n    {\n        // attack can be redirected to another target\n        victim = GetMeleeHitRedirectTarget(victim);\n\n        CalcDamageInfo damageInfo;\n        CalculateMeleeDamage(victim, 0, &damageInfo, attType);\n        // Send log damage message to client\n        DealDamageMods(victim, damageInfo.damage, &damageInfo.absorb);\n        SendAttackStateUpdate(&damageInfo);\n\n        //TriggerAurasProcOnEvent(damageInfo);\n        ProcDamageAndSpell(damageInfo.target, damageInfo.procAttacker, damageInfo.procVictim, damageInfo.procEx, damageInfo.damage, damageInfo.attackType);\n\n        DealMeleeDamage(&damageInfo, true);\n\n        if (GetTypeId() == TYPEID_PLAYER)\n            sLog->outDebug(LOG_FILTER_UNITS, \"AttackerStateUpdate: (Player) %u attacked %u (TypeId: %u) for %u dmg, absorbed %u, blocked %u, resisted %u.\",\n                GetGUIDLow(), victim->GetGUIDLow(), victim->GetTypeId(), damageInfo.damage, damageInfo.absorb, damageInfo.blocked_amount, damageInfo.resist);\n        else\n            sLog->outDebug(LOG_FILTER_UNITS, \"AttackerStateUpdate: (NPC)    %u attacked %u (TypeId: %u) for %u dmg, absorbed %u, blocked %u, resisted %u.\",\n                GetGUIDLow(), victim->GetGUIDLow(), victim->GetTypeId(), damageInfo.damage, damageInfo.absorb, damageInfo.blocked_amount, damageInfo.resist);\n    }\n}\n\nvoid Unit::HandleProcExtraAttackFor(Unit* victim)\n{\n    while (m_extraAttacks)\n    {\n        AttackerStateUpdate(victim, BASE_ATTACK, true);\n        --m_extraAttacks;\n    }\n}\n\nMeleeHitOutcome Unit::RollMeleeOutcomeAgainst(const Unit* victim, WeaponAttackType attType) const\n{\n    // This is only wrapper\n\n    // Miss chance based on melee\n    //float miss_chance = MeleeMissChanceCalc(victim, attType);\n    float miss_chance = MeleeSpellMissChance(victim, attType, int32(GetWeaponSkillValue(attType, victim)) - int32(GetMaxSkillValueForLevel(this)), 0);\n\n    // Critical hit chance\n    float crit_chance = GetUnitCriticalChance(attType, victim);\n\n    // stunned target cannot dodge and this is check in GetUnitDodgeChance() (returned 0 in this case)\n    float dodge_chance = victim->GetUnitDodgeChance();\n    float block_chance = victim->GetUnitBlockChance();\n    float parry_chance = victim->GetUnitParryChance();\n\n    // Useful if want to specify crit & miss chances for melee, else it could be removed\n    sLog->outDebug(LOG_FILTER_UNITS, \"MELEE OUTCOME: miss %f crit %f dodge %f parry %f block %f\", miss_chance, crit_chance, dodge_chance, parry_chance, block_chance);\n\n    return RollMeleeOutcomeAgainst(victim, attType, int32(crit_chance*100), int32(miss_chance*100), int32(dodge_chance*100), int32(parry_chance*100), int32(block_chance*100));\n}\n\nMeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackType attType, int32 crit_chance, int32 miss_chance, int32 dodge_chance, int32 parry_chance, int32 block_chance) const\n{\n    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode())\n        return MELEE_HIT_EVADE;\n\n    int32 attackerMaxSkillValueForLevel = GetMaxSkillValueForLevel(victim);\n    int32 victimMaxSkillValueForLevel = victim->GetMaxSkillValueForLevel(this);\n\n    int32 attackerWeaponSkill = GetWeaponSkillValue(attType, victim);\n    int32 victimDefenseSkill = victim->GetDefenseSkillValue(this);\n\n    // bonus from skills is 0.04%\n    int32    skillBonus  = 4 * (attackerWeaponSkill - victimMaxSkillValueForLevel);\n    int32    sum = 0, tmp = 0;\n    int32    roll = urand (0, 10000);\n\n    sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: skill bonus of %d for attacker\", skillBonus);\n    sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: rolled %d, miss %d, dodge %d, parry %d, block %d, crit %d\",\n        roll, miss_chance, dodge_chance, parry_chance, block_chance, crit_chance);\n\n    tmp = miss_chance;\n\n    if (tmp > 0 && roll < (sum += tmp))\n    {\n        sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: MISS\");\n        return MELEE_HIT_MISS;\n    }\n\n    // always crit against a sitting target (except 0 crit chance)\n    if (victim->GetTypeId() == TYPEID_PLAYER && crit_chance > 0 && !victim->IsStandState())\n    {\n        sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: CRIT (sitting victim)\");\n        return MELEE_HIT_CRIT;\n    }\n\n    // Dodge chance\n\n    // only players can't dodge if attacker is behind\n    if (victim->GetTypeId() == TYPEID_PLAYER && !victim->HasInArc(M_PI, this) && !victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))\n    {\n        sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: attack came from behind and victim was a player.\");\n    }\n    else\n    {\n        // Reduce dodge chance by attacker expertise rating\n        if (GetTypeId() == TYPEID_PLAYER)\n            dodge_chance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100);\n        else\n            dodge_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;\n\n        // Modify dodge chance by attacker SPELL_AURA_MOD_COMBAT_RESULT_CHANCE\n        dodge_chance+= GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_COMBAT_RESULT_CHANCE, VICTIMSTATE_DODGE) * 100;\n        dodge_chance = int32 (float (dodge_chance) * GetTotalAuraMultiplier(SPELL_AURA_MOD_ENEMY_DODGE));\n\n        tmp = dodge_chance;\n        if ((tmp > 0)                                        // check if unit _can_ dodge\n            && ((tmp -= skillBonus) > 0)\n            && roll < (sum += tmp))\n        {\n            sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: DODGE <%d, %d)\", sum-tmp, sum);\n            return MELEE_HIT_DODGE;\n        }\n    }\n\n    // parry & block chances\n\n    // check if attack comes from behind, nobody can parry or block if attacker is behind\n    if (!victim->HasInArc(M_PI, this) && !victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))\n        sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: attack came from behind.\");\n    else\n    {\n        // Reduce parry chance by attacker expertise rating\n        if (GetTypeId() == TYPEID_PLAYER)\n            parry_chance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100);\n        else\n            parry_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;\n\n        if (victim->GetTypeId() == TYPEID_PLAYER || !(victim->ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_PARRY))\n        {\n            int32 tmp2 = int32(parry_chance);\n            if (tmp2 > 0                                         // check if unit _can_ parry\n                && (tmp2 -= skillBonus) > 0\n                && roll < (sum += tmp2))\n            {\n                sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: PARRY <%d, %d)\", sum-tmp2, sum);\n                return MELEE_HIT_PARRY;\n            }\n        }\n\n        if (victim->GetTypeId() == TYPEID_PLAYER || !(victim->ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))\n        {\n            tmp = block_chance;\n            if (tmp > 0                                          // check if unit _can_ block\n                && (tmp -= skillBonus) > 0\n                && roll < (sum += tmp))\n            {\n                sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: BLOCK <%d, %d)\", sum-tmp, sum);\n                return MELEE_HIT_BLOCK;\n            }\n        }\n    }\n\n    // Critical chance\n    tmp = crit_chance;\n\n    if (tmp > 0 && roll < (sum += tmp))\n    {\n        sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: CRIT <%d, %d)\", sum-tmp, sum);\n        if (GetTypeId() == TYPEID_UNIT && (ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_CRIT))\n            sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: CRIT DISABLED)\");\n        else\n            return MELEE_HIT_CRIT;\n    }\n\n    // Max 40% chance to score a glancing blow against mobs that are higher level (can do only players and pets and not with ranged weapon)\n    if (attType != RANGED_ATTACK &&\n        (GetTypeId() == TYPEID_PLAYER || ToCreature()->isPet()) &&\n        victim->GetTypeId() != TYPEID_PLAYER && !victim->ToCreature()->isPet() &&\n        getLevel() < victim->getLevelForTarget(this))\n    {\n        // cap possible value (with bonuses > max skill)\n        int32 skill = attackerWeaponSkill;\n        int32 maxskill = attackerMaxSkillValueForLevel;\n        skill = (skill > maxskill) ? maxskill : skill;\n\n        tmp = (10 + (victimDefenseSkill - skill)) * 100;\n        tmp = tmp > 4000 ? 4000 : tmp;\n        if (roll < (sum += tmp))\n        {\n            sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: GLANCING <%d, %d)\", sum-4000, sum);\n            return MELEE_HIT_GLANCING;\n        }\n    }\n\n    // mobs can score crushing blows if they're 4 or more levels above victim\n    if (getLevelForTarget(victim) >= victim->getLevelForTarget(this) + 4 &&\n        // can be from by creature (if can) or from controlled player that considered as creature\n        !IsControlledByPlayer() &&\n        !(GetTypeId() == TYPEID_UNIT && ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_CRUSH))\n    {\n        // when their weapon skill is 15 or more above victim's defense skill\n        tmp = victimDefenseSkill;\n        int32 tmpmax = victimMaxSkillValueForLevel;\n        // having defense above your maximum (from items, talents etc.) has no effect\n        tmp = tmp > tmpmax ? tmpmax : tmp;\n        // tmp = mob's level * 5 - player's current defense skill\n        tmp = attackerMaxSkillValueForLevel - tmp;\n        if (tmp >= 15)\n        {\n            // add 2% chance per lacking skill point, min. is 15%\n            tmp = tmp * 200 - 1500;\n            if (roll < (sum += tmp))\n            {\n                sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: CRUSHING <%d, %d)\", sum-tmp, sum);\n                return MELEE_HIT_CRUSHING;\n            }\n        }\n    }\n\n    sLog->outDebug(LOG_FILTER_UNITS, \"RollMeleeOutcomeAgainst: NORMAL\");\n    return MELEE_HIT_NORMAL;\n}\n\nuint32 Unit::CalculateDamage(WeaponAttackType attType, bool normalized, bool addTotalPct)\n{\n    float min_damage, max_damage;\n\n    if (GetTypeId() == TYPEID_PLAYER && (normalized || !addTotalPct))\n        ToPlayer()->CalculateMinMaxDamage(attType, normalized, addTotalPct, min_damage, max_damage);\n    else\n    {\n        switch (attType)\n        {\n            case RANGED_ATTACK:\n                min_damage = GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE);\n                max_damage = GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE);\n                break;\n            case BASE_ATTACK:\n                min_damage = GetFloatValue(UNIT_FIELD_MINDAMAGE);\n                max_damage = GetFloatValue(UNIT_FIELD_MAXDAMAGE);\n                break;\n            case OFF_ATTACK:\n                min_damage = GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE);\n                max_damage = GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE);\n                break;\n                // Just for good manner\n            default:\n                min_damage = 0.0f;\n                max_damage = 0.0f;\n                break;\n        }\n    }\n\n    if (min_damage > max_damage)\n        std::swap(min_damage, max_damage);\n\n    if (max_damage == 0.0f)\n        max_damage = 5.0f;\n\n    return urand((uint32)min_damage, (uint32)max_damage);\n}\n\nfloat Unit::CalculateLevelPenalty(SpellInfo const* spellProto) const\n{\n    if (spellProto->SpellLevel <= 0 || spellProto->SpellLevel >= spellProto->MaxLevel)\n        return 1.0f;\n\n    float LvlPenalty = 0.0f;\n\n    if (spellProto->SpellLevel < 20)\n        LvlPenalty = 20.0f - spellProto->SpellLevel * 3.75f;\n    float LvlFactor = (float(spellProto->SpellLevel) + 6.0f) / float(getLevel());\n    if (LvlFactor > 1.0f)\n        LvlFactor = 1.0f;\n\n    return AddPctF(LvlFactor, -LvlPenalty);\n}\n\nvoid Unit::SendMeleeAttackStart(Unit* victim)\n{\n    WorldPacket data(SMSG_ATTACKSTART, 8 + 8);\n    data << uint64(GetGUID());\n    data << uint64(victim->GetGUID());\n    SendMessageToSet(&data, true);\n    sLog->outDebug(LOG_FILTER_UNITS, \"WORLD: Sent SMSG_ATTACKSTART\");\n}\n\nvoid Unit::SendMeleeAttackStop(Unit* victim)\n{\n    WorldPacket data(SMSG_ATTACKSTOP, (8+8+4));\n    data.append(GetPackGUID());\n    data.append(victim ? victim->GetPackGUID() : 0);\n    data << uint32(0);                                     //! Can also take the value 0x01, which seems related to updating rotation\n    SendMessageToSet(&data, true);\n    sLog->outDebug(LOG_FILTER_UNITS, \"WORLD: Sent SMSG_ATTACKSTOP\");\n\n    if (victim)\n        sLog->outInfo(LOG_FILTER_UNITS, \"%s %u stopped attacking %s %u\", (GetTypeId() == TYPEID_PLAYER ? \"Player\" : \"Creature\"), GetGUIDLow(), (victim->GetTypeId() == TYPEID_PLAYER ? \"player\" : \"creature\"), victim->GetGUIDLow());\n    else\n        sLog->outInfo(LOG_FILTER_UNITS, \"%s %u stopped attacking\", (GetTypeId() == TYPEID_PLAYER ? \"Player\" : \"Creature\"), GetGUIDLow());\n}\n\nbool Unit::isSpellBlocked(Unit* victim, SpellInfo const* spellProto, WeaponAttackType attackType)\n{\n    // These spells can't be blocked\n    if (spellProto && spellProto->Attributes & SPELL_ATTR0_IMPOSSIBLE_DODGE_PARRY_BLOCK)\n        return false;\n\n    if (victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION) || victim->HasInArc(M_PI, this))\n    {\n        // Check creatures flags_extra for disable block\n        if (victim->GetTypeId() == TYPEID_UNIT &&\n            victim->ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)\n                return false;\n\n        float blockChance = victim->GetUnitBlockChance();\n        blockChance += (int32(GetWeaponSkillValue(attackType)) - int32(victim->GetMaxSkillValueForLevel())) * 0.04f;\n        if (roll_chance_f(blockChance))\n            return true;\n    }\n    return false;\n}\n\nbool Unit::isBlockCritical()\n{\n    if (roll_chance_i(GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_CRIT_CHANCE)))\n        return true;\n    return false;\n}\n\nint32 Unit::GetMechanicResistChance(const SpellInfo* spell)\n{\n    if (!spell)\n        return 0;\n    int32 resist_mech = 0;\n    for (uint8 eff = 0; eff < MAX_SPELL_EFFECTS; ++eff)\n    {\n        if (!spell->Effects[eff].IsEffect())\n           break;\n        int32 effect_mech = spell->GetEffectMechanic(eff);\n        if (effect_mech)\n        {\n            int32 temp = GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_MECHANIC_RESISTANCE, effect_mech);\n            if (resist_mech < temp)\n                resist_mech = temp;\n        }\n    }\n    return resist_mech;\n}\n\n// Melee based spells hit result calculations\nSpellMissInfo Unit::MeleeSpellHitResult(Unit* victim, SpellInfo const* spell)\n{\n    // Spells with SPELL_ATTR3_IGNORE_HIT_RESULT will additionally fully ignore\n    // resist and deflect chances\n    if (spell->AttributesEx3 & SPELL_ATTR3_IGNORE_HIT_RESULT)\n        return SPELL_MISS_NONE;\n\n    WeaponAttackType attType = BASE_ATTACK;\n\n    // Check damage class instead of attack type to correctly handle judgements\n    // - they are meele, but can't be dodged/parried/deflected because of ranged dmg class\n    if (spell->DmgClass == SPELL_DAMAGE_CLASS_RANGED)\n        attType = RANGED_ATTACK;\n\n    int32 attackerWeaponSkill;\n    // skill value for these spells (for example judgements) is 5* level\n    if (spell->DmgClass == SPELL_DAMAGE_CLASS_RANGED && !spell->IsRangedWeaponSpell())\n        attackerWeaponSkill = getLevel() * 5;\n    // bonus from skills is 0.04% per skill Diff\n    else\n        attackerWeaponSkill = int32(GetWeaponSkillValue(attType, victim));\n\n    int32 skillDiff = attackerWeaponSkill - int32(victim->GetMaxSkillValueForLevel(this));\n\n    uint32 roll = urand (0, 10000);\n\n    uint32 missChance = uint32(MeleeSpellMissChance(victim, attType, skillDiff, spell->Id) * 100.0f);\n    // Roll miss\n    uint32 tmp = missChance;\n    if (roll < tmp)\n        return SPELL_MISS_MISS;\n\n    // Chance resist mechanic (select max value from every mechanic spell effect)\n    int32 resist_mech = 0;\n    // Get effects mechanic and chance\n    for (uint8 eff = 0; eff < MAX_SPELL_EFFECTS; ++eff)\n    {\n        int32 effect_mech = spell->GetEffectMechanic(eff);\n        if (effect_mech)\n        {\n            int32 temp = victim->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_MECHANIC_RESISTANCE, effect_mech);\n            if (resist_mech < temp*100)\n                resist_mech = temp*100;\n        }\n    }\n    // Roll chance\n    tmp += resist_mech;\n    if (roll < tmp)\n        return SPELL_MISS_RESIST;\n\n    bool canDodge = true;\n    bool canParry = true;\n    bool canBlock = spell->AttributesEx3 & SPELL_ATTR3_BLOCKABLE_SPELL;\n\n    // Same spells cannot be parry/dodge\n    if (spell->Attributes & SPELL_ATTR0_IMPOSSIBLE_DODGE_PARRY_BLOCK)\n        return SPELL_MISS_NONE;\n\n    // Chance resist mechanic\n    int32 resist_chance = victim->GetMechanicResistChance(spell) * 100;\n    tmp += resist_chance;\n    if (roll < tmp)\n        return SPELL_MISS_RESIST;\n\n    // Ranged attacks can only miss, resist and deflect\n    if (attType == RANGED_ATTACK)\n    {\n        // only if in front\n        if (victim->HasInArc(M_PI, this) || victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))\n        {\n            int32 deflect_chance = victim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS) * 100;\n            tmp+=deflect_chance;\n            if (roll < tmp)\n                return SPELL_MISS_DEFLECT;\n        }\n        return SPELL_MISS_NONE;\n    }\n\n    // Check for attack from behind\n    if (!victim->HasInArc(M_PI, this))\n    {\n        if (!victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))\n        {\n            // Can`t dodge from behind in PvP (but its possible in PvE)\n            if (victim->GetTypeId() == TYPEID_PLAYER)\n                canDodge = false;\n            // Can`t parry or block\n            canParry = false;\n            canBlock = false;\n        }\n        else // Only deterrence as of 3.3.5\n        {\n            if (spell->AttributesCu & SPELL_ATTR0_CU_REQ_CASTER_BEHIND_TARGET)\n                canParry = false;\n        }\n    }\n    // Check creatures flags_extra for disable parry\n    if (victim->GetTypeId() == TYPEID_UNIT)\n    {\n        uint32 flagEx = victim->ToCreature()->GetCreatureTemplate()->flags_extra;\n        if (flagEx & CREATURE_FLAG_EXTRA_NO_PARRY)\n            canParry = false;\n        // Check creatures flags_extra for disable block\n        if (flagEx & CREATURE_FLAG_EXTRA_NO_BLOCK)\n            canBlock = false;\n    }\n    // Ignore combat result aura\n    AuraEffectList const& ignore = GetAuraEffectsByType(SPELL_AURA_IGNORE_COMBAT_RESULT);\n    for (AuraEffectList::const_iterator i = ignore.begin(); i != ignore.end(); ++i)\n    {\n        if (!(*i)->IsAffectedOnSpell(spell))\n            continue;\n        switch ((*i)->GetMiscValue())\n        {\n            case MELEE_HIT_DODGE: canDodge = false; break;\n            case MELEE_HIT_BLOCK: canBlock = false; break;\n            case MELEE_HIT_PARRY: canParry = false; break;\n            default:\n                sLog->outDebug(LOG_FILTER_UNITS, \"Spell %u SPELL_AURA_IGNORE_COMBAT_RESULT has unhandled state %d\", (*i)->GetId(), (*i)->GetMiscValue());\n                break;\n        }\n    }\n\n    if (canDodge)\n    {\n        // Roll dodge\n        int32 dodgeChance = int32(victim->GetUnitDodgeChance() * 100.0f) - skillDiff * 4;\n        // Reduce enemy dodge chance by SPELL_AURA_MOD_COMBAT_RESULT_CHANCE\n        dodgeChance += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_COMBAT_RESULT_CHANCE, VICTIMSTATE_DODGE) * 100;\n        dodgeChance = int32(float(dodgeChance) * GetTotalAuraMultiplier(SPELL_AURA_MOD_ENEMY_DODGE));\n        // Reduce dodge chance by attacker expertise rating\n        if (GetTypeId() == TYPEID_PLAYER)\n            dodgeChance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100.0f);\n        else\n            dodgeChance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;\n        if (dodgeChance < 0)\n            dodgeChance = 0;\n\n        if (roll < (tmp += dodgeChance))\n            return SPELL_MISS_DODGE;\n    }\n\n    if (canParry)\n    {\n        // Roll parry\n        int32 parryChance = int32(victim->GetUnitParryChance() * 100.0f)  - skillDiff * 4;\n        // Reduce parry chance by attacker expertise rating\n        if (GetTypeId() == TYPEID_PLAYER)\n            parryChance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100.0f);\n        else\n            parryChance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;\n        if (parryChance < 0)\n            parryChance = 0;\n\n        tmp += parryChance;\n        if (roll < tmp)\n            return SPELL_MISS_PARRY;\n    }\n\n    if (canBlock)\n    {\n        int32 blockChance = int32(victim->GetUnitBlockChance() * 100.0f) - skillDiff * 4;\n        if (blockChance < 0)\n            blockChance = 0;\n        tmp += blockChance;\n\n        if (roll < tmp)\n            return SPELL_MISS_BLOCK;\n    }\n\n    return SPELL_MISS_NONE;\n}\n\n// TODO need use unit spell resistances in calculations\nSpellMissInfo Unit::MagicSpellHitResult(Unit* victim, SpellInfo const* spell)\n{\n    // Can`t miss on dead target (on skinning for example)\n    if (!victim->isAlive() && victim->GetTypeId() != TYPEID_PLAYER)\n        return SPELL_MISS_NONE;\n\n    SpellSchoolMask schoolMask = spell->GetSchoolMask();\n    // PvP - PvE spell misschances per leveldif > 2\n    int32 lchance = victim->GetTypeId() == TYPEID_PLAYER ? 7 : 11;\n    int32 thisLevel = getLevelForTarget(victim);\n    if (GetTypeId() == TYPEID_UNIT && ToCreature()->isTrigger())\n        thisLevel = std::max<int32>(thisLevel, spell->SpellLevel);\n    int32 leveldif = int32(victim->getLevelForTarget(this)) - thisLevel;\n\n    // Base hit chance from attacker and victim levels\n    int32 modHitChance;\n    if (leveldif < 3)\n        modHitChance = 96 - leveldif;\n    else\n        modHitChance = 94 - (leveldif - 2) * lchance;\n\n    // Spellmod from SPELLMOD_RESIST_MISS_CHANCE\n    if (Player* modOwner = GetSpellModOwner())\n        modOwner->ApplySpellMod(spell->Id, SPELLMOD_RESIST_MISS_CHANCE, modHitChance);\n\n    // Increase from attacker SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT auras\n    modHitChance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT, schoolMask);\n\n    // Spells with SPELL_ATTR3_IGNORE_HIT_RESULT will ignore target's avoidance effects\n    if (!(spell->AttributesEx3 & SPELL_ATTR3_IGNORE_HIT_RESULT))\n    {\n        // Chance hit from victim SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE auras\n        modHitChance += victim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE, schoolMask);\n        // Reduce spell hit chance for Area of effect spells from victim SPELL_AURA_MOD_AOE_AVOIDANCE aura\n        if (spell->IsTargetingArea())\n            modHitChance -= victim->GetTotalAuraModifier(SPELL_AURA_MOD_AOE_AVOIDANCE);\n\n        // Decrease hit chance from victim rating bonus\n        if (victim->GetTypeId() == TYPEID_PLAYER)\n            modHitChance -= int32(victim->ToPlayer()->GetRatingBonusValue(CR_HIT_TAKEN_SPELL));\n    }\n\n    int32 HitChance = modHitChance * 100;\n    // Increase hit chance from attacker SPELL_AURA_MOD_SPELL_HIT_CHANCE and attacker ratings\n    HitChance += int32(m_modSpellHitChance * 100.0f);\n\n    if (HitChance < 100)\n        HitChance = 100;\n    else if (HitChance > 10000)\n        HitChance = 10000;\n\n    int32 tmp = 10000 - HitChance;\n\n    int32 rand = irand(0, 10000);\n\n    if (rand < tmp)\n        return SPELL_MISS_MISS;\n\n    // Spells with SPELL_ATTR3_IGNORE_HIT_RESULT will additionally fully ignore\n    // resist and deflect chances\n    if (spell->AttributesEx3 & SPELL_ATTR3_IGNORE_HIT_RESULT)\n        return SPELL_MISS_NONE;\n\n    // Chance resist mechanic (select max value from every mechanic spell effect)\n    int32 resist_chance = victim->GetMechanicResistChance(spell) * 100;\n    tmp += resist_chance;\n\n    // Chance resist debuff\n    if (!spell->IsPositive())\n    {\n        bool bNegativeAura = true;\n        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)\n        {\n            if (spell->Effects[i].ApplyAuraName == 0)\n            {\n                bNegativeAura = false;\n                break;\n            }\n        }\n\n        if (bNegativeAura)\n        {\n            tmp += victim->GetMaxPositiveAuraModifierByMiscValue(SPELL_AURA_MOD_DEBUFF_RESISTANCE, int32(spell->Dispel)) * 100;\n            tmp += victim->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MOD_DEBUFF_RESISTANCE, int32(spell->Dispel)) * 100;\n        }\n    }\n\n   // Roll chance\n    if (rand < tmp)\n        return SPELL_MISS_RESIST;\n\n    // cast by caster in front of victim\n    if (victim->HasInArc(M_PI, this) || victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))\n    {\n        int32 deflect_chance = victim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS) * 100;\n        tmp += deflect_chance;\n        if (rand < tmp)\n            return SPELL_MISS_DEFLECT;\n    }\n\n    return SPELL_MISS_NONE;\n}\n\n// Calculate spell hit result can be:\n// Every spell can: Evade/Immune/Reflect/Sucesful hit\n// For melee based spells:\n//   Miss\n//   Dodge\n//   Parry\n// For spells\n//   Resist\nSpellMissInfo Unit::SpellHitResult(Unit* victim, SpellInfo const* spell, bool CanReflect)\n{\n    // Check for immune\n    if (victim->IsImmunedToSpell(spell))\n        return SPELL_MISS_IMMUNE;\n\n    // All positive spells can`t miss\n    // TODO: client not show miss log for this spells - so need find info for this in dbc and use it!\n    if (spell->IsPositive()\n        &&(!IsHostileTo(victim)))  // prevent from affecting enemy by \"positive\" spell\n        return SPELL_MISS_NONE;\n    // Check for immune\n    if (victim->IsImmunedToDamage(spell))\n        return SPELL_MISS_IMMUNE;\n\n    if (this == victim)\n        return SPELL_MISS_NONE;\n\n    // Return evade for units in evade mode\n    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode())\n        return SPELL_MISS_EVADE;\n\n    // Try victim reflect spell\n    if (CanReflect)\n    {\n        int32 reflectchance = victim->GetTotalAuraModifier(SPELL_AURA_REFLECT_SPELLS);\n        Unit::AuraEffectList const& mReflectSpellsSchool = victim->GetAuraEffectsByType(SPELL_AURA_REFLECT_SPELLS_SCHOOL);\n        for (Unit::AuraEffectList::const_iterator i = mReflectSpellsSchool.begin(); i != mReflectSpellsSchool.end(); ++i)\n            if ((*i)->GetMiscValue() & spell->GetSchoolMask())\n                reflectchance += (*i)->GetAmount();\n        if (reflectchance > 0 && roll_chance_i(reflectchance))\n        {\n            // Start triggers for remove charges if need (trigger only for victim, and mark as active spell)\n            ProcDamageAndSpell(victim, PROC_FLAG_NONE, PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_NEG, PROC_EX_REFLECT, 1, BASE_ATTACK, spell);\n            return SPELL_MISS_REFLECT;\n        }\n    }\n\n    switch (spell->DmgClass)\n    {\n        case SPELL_DAMAGE_CLASS_RANGED:\n        case SPELL_DAMAGE_CLASS_MELEE:\n            return MeleeSpellHitResult(victim, spell);\n        case SPELL_DAMAGE_CLASS_NONE:\n            return SPELL_MISS_NONE;\n        case SPELL_DAMAGE_CLASS_MAGIC:\n            return MagicSpellHitResult(victim, spell);\n    }\n    return SPELL_MISS_NONE;\n}\n\nuint32 Unit::GetDefenseSkillValue(Unit const* target) const\n{\n    if (GetTypeId() == TYPEID_PLAYER)\n    {\n        // in PvP use full skill instead current skill value\n        uint32 value = (target && target->GetTypeId() == TYPEID_PLAYER)\n            ? ToPlayer()->GetMaxSkillValue(SKILL_DEFENSE)\n            : ToPlayer()->GetSkillValue(SKILL_DEFENSE);\n        value += uint32(ToPlayer()->GetRatingBonusValue(CR_DEFENSE_SKILL));\n        return value;\n    }\n    else\n        return GetUnitMeleeSkill(target);\n}\n\nfloat Unit::GetUnitDodgeChance() const\n{\n    if (IsNonMeleeSpellCasted(false) || HasUnitState(UNIT_STATE_CONTROLLED))\n        return 0.0f;\n\n    if (GetTypeId() == TYPEID_PLAYER)\n        return GetFloatValue(PLAYER_DODGE_PERCENTAGE);\n    else\n    {\n        if (ToCreature()->isTotem())\n            return 0.0f;\n        else\n        {\n            float dodge = 5.0f;\n            dodge += GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);\n            return dodge > 0.0f ? dodge : 0.0f;\n        }\n    }\n}\n\nfloat Unit::GetUnitParryChance() const\n{\n    if (IsNonMeleeSpellCasted(false) || HasUnitState(UNIT_STATE_CONTROLLED))\n        return 0.0f;\n\n    float chance = 0.0f;\n\n    if (Player const* player = ToPlayer())\n    {\n        if (player->CanParry())\n        {\n            Item* tmpitem = player->GetWeaponForAttack(BASE_ATTACK, true);\n            if (!tmpitem)\n                tmpitem = player->GetWeaponForAttack(OFF_ATTACK, true);\n\n            if (tmpitem)\n                chance = GetFloatValue(PLAYER_PARRY_PERCENTAGE);\n        }\n    }\n    else if (GetTypeId() == TYPEID_UNIT)\n    {\n        if (GetCreatureType() == CREATURE_TYPE_HUMANOID)\n        {\n            chance = 5.0f;\n            chance += GetTotalAuraModifier(SPELL_AURA_MOD_PARRY_PERCENT);\n        }\n    }\n\n    return chance > 0.0f ? chance : 0.0f;\n}\n\nfloat Unit::GetUnitMissChance(WeaponAttackType attType) const\n{\n    float miss_chance = 5.00f;\n\n    if (Player const* player = ToPlayer())\n        miss_chance += player->GetMissPercentageFromDefence();\n\n    if (attType == RANGED_ATTACK)\n        miss_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_HIT_CHANCE);\n    else\n        miss_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE);\n\n    return miss_chance;\n}\n\nfloat Unit::GetUnitBlockChance() const\n{\n    if (IsNonMeleeSpellCasted(false) || HasUnitState(UNIT_STATE_CONTROLLED))\n        return 0.0f;\n\n    if (Player const* player = ToPlayer())\n    {\n        if (player->CanBlock())\n        {\n            Item* tmpitem = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);\n            if (tmpitem && !tmpitem->IsBroken() && tmpitem->GetTemplate()->Block)\n                return GetFloatValue(PLAYER_BLOCK_PERCENTAGE);\n        }\n        // is player but has no block ability or no not broken shield equipped\n        return 0.0f;\n    }\n    else\n    {\n        if (ToCreature()->isTotem())\n            return 0.0f;\n        else\n        {\n            float block = 5.0f;\n            block += GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_PERCENT);\n            return block > 0.0f ? block : 0.0f;\n        }\n    }\n}\n\nfloat Unit::GetUnitCriticalChance(WeaponAttackType attackType, const Unit* victim) const\n{\n    float crit;\n\n    if (GetTypeId() == TYPEID_PLAYER)\n    {\n        switch (attackType)\n        {\n            case BASE_ATTACK:\n                crit = GetFloatValue(PLAYER_CRIT_PERCENTAGE);\n                break;\n            case OFF_ATTACK:\n                crit = GetFloatValue(PLAYER_OFFHAND_CRIT_PERCENTAGE);\n                break;\n            case RANGED_ATTACK:\n                crit = GetFloatValue(PLAYER_RANGED_CRIT_PERCENTAGE);\n                break;\n                // Just for good manner\n            default:\n                crit = 0.0f;\n                break;\n        }\n    }\n    else\n    {\n        crit = 5.0f;\n        crit += GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);\n        crit += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);\n    }\n\n    // flat aura mods\n    if (attackType == RANGED_ATTACK)\n        crit += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_CHANCE);\n    else\n        crit += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_CHANCE);\n\n    crit += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE);\n\n    // reduce crit chance from Rating for players\n    if (attackType != RANGED_ATTACK)\n    {\n        ApplyResilience(victim, &crit, NULL, false, CR_CRIT_TAKEN_MELEE);\n        // Glyph of barkskin\n        if (victim->HasAura(63057) && victim->HasAura(22812))\n            crit -= 25.0f;\n    }\n    else\n        ApplyResilience(victim, &crit, NULL, false, CR_CRIT_TAKEN_RANGED);\n\n    // Apply crit chance from defence skill\n    crit += (int32(GetMaxSkillValueForLevel(victim)) - int32(victim->GetDefenseSkillValue(this))) * 0.04f;\n\n    if (crit < 0.0f)\n        crit = 0.0f;\n    return crit;\n}\n\nuint32 Unit::GetWeaponSkillValue (WeaponAttackType attType, Unit const* target) const\n{\n    uint32 value = 0;\n    if (Player const* player = ToPlayer())\n    {\n        Item* item = player->GetWeaponForAttack(attType, true);\n\n        // feral or unarmed skill only for base attack\n        if (attType != BASE_ATTACK && !item)\n            return 0;\n\n        if (IsInFeralForm())\n            return GetMaxSkillValueForLevel();              // always maximized SKILL_FERAL_COMBAT in fact\n\n        // weapon skill or (unarmed for base attack and fist weapons)\n        uint32 skill;\n        if (item && item->GetSkill() != SKILL_FIST_WEAPONS)\n            skill = item->GetSkill();\n        else\n            skill = SKILL_UNARMED;\n\n        // in PvP use full skill instead current skill value\n        value = (target && target->IsControlledByPlayer())\n            ? player->GetMaxSkillValue(skill)\n            : player->GetSkillValue(skill);\n        // Modify value from ratings\n        value += uint32(player->GetRatingBonusValue(CR_WEAPON_SKILL));\n        switch (attType)\n        {\n            case BASE_ATTACK:   value += uint32(player->GetRatingBonusValue(CR_WEAPON_SKILL_MAINHAND)); break;\n            case OFF_ATTACK:    value += uint32(player->GetRatingBonusValue(CR_WEAPON_SKILL_OFFHAND));  break;\n            case RANGED_ATTACK: value += uint32(player->GetRatingBonusValue(CR_WEAPON_SKILL_RANGED));   break;\n            default: break;\n        }\n    }\n    else\n        value = GetUnitMeleeSkill(target);\n   return value;\n}\n\nvoid Unit::_DeleteRemovedAuras()\n{\n    while (!m_removedAuras.empty())\n    {\n        delete m_removedAuras.front();\n        m_removedAuras.pop_front();\n    }\n}\n\nvoid Unit::_UpdateSpells(uint32 time)\n{\n    if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL])\n        _UpdateAutoRepeatSpell();\n\n    // remove finished spells from current pointers\n    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)\n    {\n        if (m_currentSpells[i] && m_currentSpells[i]->getState() == SPELL_STATE_FINISHED)\n        {\n            m_currentSpells[i]->SetReferencedFromCurrent(false);\n            m_currentSpells[i] = NULL;                      // remove pointer\n        }\n    }\n\n    // m_auraUpdateIterator can be updated in indirect called code at aura remove to skip next planned to update but removed auras\n    for (m_auraUpdateIterator = m_ownedAuras.begin(); m_auraUpdateIterator != m_ownedAuras.end();)\n    {\n        Aura* i_aura = m_auraUpdateIterator->second;\n        ++m_auraUpdateIterator;                            // need shift to next for allow update if need into aura update\n        i_aura->UpdateOwner(time, this);\n    }\n\n    // remove expired auras - do that after updates(used in scripts?)\n    for (AuraMap::iterator i = m_ownedAuras.begin(); i != m_ownedAuras.end();)\n    {\n        if (i->second->IsExpired())\n            RemoveOwnedAura(i, AURA_REMOVE_BY_EXPIRE);\n        else\n            ++i;\n    }\n\n    for (VisibleAuraMap::iterator itr = m_visibleAuras.begin(); itr != m_visibleAuras.end(); ++itr)\n        if (itr->second->IsNeedClientUpdate())\n            itr->second->ClientUpdate();\n\n    _DeleteRemovedAuras();\n\n    if (!m_gameObj.empty())\n    {\n        GameObjectList::iterator itr;\n        for (itr = m_gameObj.begin(); itr != m_gameObj.end();)\n        {\n            if (!(*itr)->isSpawned())\n            {\n                (*itr)->SetOwnerGUID(0);\n                (*itr)->SetRespawnTime(0);\n                (*itr)->Delete();\n                m_gameObj.erase(itr++);\n            }\n            else\n                ++itr;\n        }\n    }\n}\n\nvoid Unit::_UpdateAutoRepeatSpell()\n{\n    // check \"realtime\" interrupts\n    if ((GetTypeId() == TYPEID_PLAYER && ToPlayer()->isMoving()) || IsNonMeleeSpellCasted(false, false, true, m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id == 75))\n    {\n        // cancel wand shoot\n        if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)\n            InterruptSpell(CURRENT_AUTOREPEAT_SPELL);\n        m_AutoRepeatFirstCast = true;\n        return;\n    }\n\n    // apply delay (Auto Shot (spellID 75) not affected)\n    if (m_AutoRepeatFirstCast && getAttackTimer(RANGED_ATTACK) < 500 && m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)\n        setAttackTimer(RANGED_ATTACK, 500);\n    m_AutoRepeatFirstCast = false;\n\n    // castroutine\n    if (isAttackReady(RANGED_ATTACK))\n    {\n        // Check if able to cast\n        if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->CheckCast(true) != SPELL_CAST_OK)\n        {\n            InterruptSpell(CURRENT_AUTOREPEAT_SPELL);\n            return;\n        }\n\n        // we want to shoot\n        Spell* spell = new Spell(this, m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo, TRIGGERED_FULL_MASK);\n        spell->prepare(&(m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_targets));\n\n        // all went good, reset attack\n        resetAttackTimer(RANGED_ATTACK);\n    }\n}\n\nvoid Unit::SetCurrentCastedSpell(Spell* pSpell)\n{\n    ASSERT(pSpell);                                         // NULL may be never passed here, use InterruptSpell or InterruptNonMeleeSpells\n\n    CurrentSpellTypes CSpellType = pSpell->GetCurrentContainer();\n\n    if (pSpell == m_currentSpells[CSpellType])             // avoid breaking self\n        return;\n\n    // break same type spell if it is not delayed\n    InterruptSpell(CSpellType, false);\n\n    // special breakage effects:\n    switch (CSpellType)\n    {\n        case CURRENT_GENERIC_SPELL:\n        {\n            // generic spells always break channeled not delayed spells\n            InterruptSpell(CURRENT_CHANNELED_SPELL, false);\n\n            // autorepeat breaking\n            if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL])\n            {\n                // break autorepeat if not Auto Shot\n                if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)\n                    InterruptSpell(CURRENT_AUTOREPEAT_SPELL);\n                m_AutoRepeatFirstCast = true;\n            }\n            if (pSpell->m_spellInfo->CalcCastTime(this) > 0)\n                AddUnitState(UNIT_STATE_CASTING);\n\n            break;\n        }\n        case CURRENT_CHANNELED_SPELL:\n        {\n            // channel spells always break generic non-delayed and any channeled spells\n            InterruptSpell(CURRENT_GENERIC_SPELL, false);\n            InterruptSpell(CURRENT_CHANNELED_SPELL);\n\n            // it also does break autorepeat if not Auto Shot\n            if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL] &&\n                m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)\n                InterruptSpell(CURRENT_AUTOREPEAT_SPELL);\n            AddUnitState(UNIT_STATE_CASTING);\n\n            break;\n        }\n        case CURRENT_AUTOREPEAT_SPELL:\n        {\n            // only Auto Shoot does not break anything\n            if (pSpell->m_spellInfo->Id != 75)\n            {\n                // generic autorepeats break generic non-delayed and channeled non-delayed spells\n                InterruptSpell(CURRENT_GENERIC_SPELL, false);\n                InterruptSpell(CURRENT_CHANNELED_SPELL, false);\n            }\n            // special action: set first cast flag\n            m_AutoRepeatFirstCast = true;\n\n            break;\n        }\n        default:\n            break; // other spell types don't break anything now\n    }\n\n    // current spell (if it is still here) may be safely deleted now\n    if (m_currentSpells[CSpellType])\n        m_currentSpells[CSpellType]->SetReferencedFromCurrent(false);\n\n    // set new current spell\n    m_currentSpells[CSpellType] = pSpell;\n    pSpell->SetReferencedFromCurrent(true);\n\n    pSpell->m_selfContainer = &(m_currentSpells[pSpell->GetCurrentContainer()]);\n}\n\nvoid Unit::InterruptSpell(CurrentSpellTypes spellType, bool withDelayed, bool withInstant)\n{\n    ASSERT(spellType < CURRENT_MAX_SPELL);\n\n    //sLog->outDebug(LOG_FILTER_UNITS, \"Interrupt spell for unit %u.\", GetEntry());\n    Spell* spell = m_currentSpells[spellType];\n    if (spell\n        && (withDelayed || spell->getState() != SPELL_STATE_DELAYED)\n        && (withInstant || spell->GetCastTime() > 0))\n    {\n        // for example, do not let self-stun aura interrupt itself\n        if (!spell->IsInterruptable())\n            return;\n\n        // send autorepeat cancel message for autorepeat spells\n        if (spellType == CURRENT_AUTOREPEAT_SPELL)\n            if (GetTypeId() == TYPEID_PLAYER)\n                ToPlayer()->SendAutoRepeatCancel(this);\n\n        if (spell->getState() != SPELL_STATE_FINISHED)\n            spell->cancel();\n\n        m_currentSpells[spellType] = NULL;\n        spell->SetReferencedFromCurrent(false);\n    }\n}\n\nvoid Unit::FinishSpell(CurrentSpellTypes spellType, bool ok /*= true*/)\n{\n    Spell* spell = m_currentSpells[spellType];\n    if (!spell)\n        return;\n\n    if (spellType == CURRENT_CHANNELED_SPELL)\n        spell->SendChannelUpdate(0);\n\n    spell->finish(ok);\n}\n\nbool Unit::IsNonMeleeSpellCasted(bool withDelayed, bool skipChanneled, bool skipAutorepeat, bool isAutoshoot, bool skipInstant) const\n{\n    // We don't do loop here to explicitly show that melee spell is excluded.\n    // Maybe later some special spells will be excluded too.\n\n    // if skipInstant then instant spells shouldn't count as being casted\n    if (skipInstant && m_currentSpells[CURRENT_GENERIC_SPELL] && !m_currentSpells[CURRENT_GENERIC_SPELL]->GetCastTime())\n        return false;\n\n    // generic spells are casted when they are not finished and not delayed\n    if (m_currentSpells[CURRENT_GENERIC_SPELL] &&\n        (m_currentSpells[CURRENT_GENERIC_SPELL]->getState() != SPELL_STATE_FINISHED) &&\n        (withDelayed || m_currentSpells[CURRENT_GENERIC_SPELL]->getState() != SPELL_STATE_DELAYED))\n    {\n        if (!isAutoshoot || !(m_currentSpells[CURRENT_GENERIC_SPELL]->m_spellInfo->AttributesEx2 & SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS))\n            return true;\n    }\n    // channeled spells may be delayed, but they are still considered casted\n    else if (!skipChanneled && m_currentSpells[CURRENT_CHANNELED_SPELL] &&\n        (m_currentSpells[CURRENT_CHANNELED_SPELL]->getState() != SPELL_STATE_FINISHED))\n    {\n        if (!isAutoshoot || !(m_currentSpells[CURRENT_CHANNELED_SPELL]->m_spellInfo->AttributesEx2 & SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS))\n            return true;\n    }\n    // autorepeat spells may be finished or delayed, but they are still considered casted\n    else if (!skipAutorepeat && m_currentSpells[CURRENT_AUTOREPEAT_SPELL])\n        return true;\n\n    return false;\n}\n\nvoid Unit::InterruptNonMeleeSpells(bool withDelayed, uint32 spell_id, bool withInstant)\n{\n    // generic spells are interrupted if they are not finished or delayed\n    if (m_currentSpells[CURRENT_GENERIC_SPELL] && (!spell_id || m_currentSpells[CURRENT_GENERIC_SPELL]->m_spellInfo->Id == spell_id))\n        InterruptSpell(CURRENT_GENERIC_SPELL, withDelayed, withInstant);\n\n    // autorepeat spells are interrupted if they are not finished or delayed\n    if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL] && (!spell_id || m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id == spell_id))\n        InterruptSpell(CURRENT_AUTOREPEAT_SPELL, withDelayed, withInstant);\n\n    // channeled spells are interrupted if they are not finished, even if they are delayed\n    if (m_currentSpells[CURRENT_CHANNELED_SPELL] && (!spell_id || m_currentSpells[CURRENT_CHANNELED_SPELL]->m_spellInfo->Id == spell_id))\n        InterruptSpell(CURRENT_CHANNELED_SPELL, true, true);\n}\n\nSpell* Unit::FindCurrentSpellBySpellId(uint32 spell_id) const\n{\n    for (uint32 i = 0; i < CURRENT_MAX_SPELL; i++)\n        if (m_currentSpells[i] && m_currentSpells[i]->m_spellInfo->Id == spell_id)\n            return m_currentSpells[i];\n    return NULL;\n}\n\nint32 Unit::GetCurrentSpellCastTime(uint32 spell_id) const\n{\n    if (Spell const* spell = FindCurrentSpellBySpellId(spell_id))\n        return spell->GetCastTime();\n    return 0;\n}\n\nbool Unit::isInFrontInMap(Unit const* target, float distance,  float arc) const\n{\n    return IsWithinDistInMap(target, distance) && HasInArc(arc, target);\n}\n\nbool Unit::isInBackInMap(Unit const* target, float distance, float arc) const\n{\n    return IsWithinDistInMap(target, distance) && !HasInArc(2 * M_PI - arc, target);\n}\n\nbool Unit::isInAccessiblePlaceFor(Creature const* c) const\n{\n    if (IsInWater())\n        return c->canSwim();\n    else\n        return c->canWalk() || c->CanFly();\n}\n\nbool Unit::IsInWater() const\n{\n    return GetBaseMap()->IsInWater(GetPositionX(), GetPositionY(), GetPositionZ());\n}\n\nbool Unit::IsUnderWater() const\n{\n    return GetBaseMap()->IsUnderWater(GetPositionX(), GetPositionY(), GetPositionZ());\n}\n\nvoid Unit::UpdateUnderwaterState(Map* m, float x, float y, float z)\n{\n    if (!isPet() && !IsVehicle())\n        return;\n\n    LiquidData liquid_status;\n    ZLiquidStatus res = m->getLiquidStatus(x, y, z, MAP_ALL_LIQUIDS, &liquid_status);\n    if (!res)\n    {\n        if (_lastLiquid && _lastLiquid->SpellId)\n            RemoveAurasDueToSpell(_lastLiquid->SpellId);\n\n        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_UNDERWATER);\n        _lastLiquid = NULL;\n        return;\n    }\n\n    if (uint32 liqEntry = liquid_status.entry)\n    {\n        LiquidTypeEntry const* liquid = sLiquidTypeStore.LookupEntry(liqEntry);\n        if (_lastLiquid && _lastLiquid->SpellId && _lastLiquid->Id != liqEntry)\n            RemoveAurasDueToSpell(_lastLiquid->SpellId);\n\n        if (liquid && liquid->SpellId)\n        {\n            if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER))\n                CastSpell(this, liquid->SpellId, true);\n            else\n                RemoveAurasDueToSpell(liquid->SpellId);\n        }\n\n        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_ABOVEWATER);\n        _lastLiquid = liquid;\n    }\n    else if (_lastLiquid && _lastLiquid->SpellId)\n    {\n        RemoveAurasDueToSpell(_lastLiquid->SpellId);\n        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_UNDERWATER);\n        _lastLiquid = NULL;\n    }\n}\n\nvoid Unit::DeMorph()\n{\n    SetDisplayId(GetNativeDisplayId());\n}\n\nAura* Unit::_TryStackingOrRefreshingExistingAura(SpellInfo const* newAura, uint8 effMask, Unit* caster, int32* baseAmount /*= NULL*/, Item* castItem /*= NULL*/, uint64 casterGUID /*= 0*/)\n{\n    ASSERT(casterGUID || caster);\n    if (!casterGUID)\n        casterGUID = caster->GetGUID();\n\n    // passive and Incanter's Absorption and auras with different type can stack with themselves any number of times\n    if (!newAura->IsMultiSlotAura())\n    {\n        // check if cast item changed\n        uint64 castItemGUID = 0;\n        if (castItem)\n            castItemGUID = castItem->GetGUID();\n\n        // find current aura from spell and change it's stackamount, or refresh it's duration\n        if (Aura* foundAura = GetOwnedAura(newAura->Id, casterGUID, (newAura->AttributesCu & SPELL_ATTR0_CU_ENCHANT_PROC) ? castItemGUID : 0, 0))\n        {\n            // effect masks do not match\n            // extremely rare case\n            // let's just recreate aura\n            if (effMask != foundAura->GetEffectMask())\n                return NULL;\n\n            // update basepoints with new values - effect amount will be recalculated in ModStackAmount\n            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)\n            {\n                if (!foundAura->HasEffect(i))\n                    continue;\n\n                int bp;\n                if (baseAmount)\n                    bp = *(baseAmount + i);\n                else\n                    bp = foundAura->GetSpellInfo()->Effects[i].BasePoints;\n\n                int32* oldBP = const_cast<int32*>(&(foundAura->GetEffect(i)->m_baseAmount));\n                *oldBP = bp;\n            }\n\n            // correct cast item guid if needed\n            if (castItemGUID != foundAura->GetCastItemGUID())\n            {\n                uint64* oldGUID = const_cast<uint64 *>(&foundAura->m_castItemGuid);\n                *oldGUID = castItemGUID;\n            }\n\n            // try to increase stack amount\n            foundAura->ModStackAmount(1);\n            return foundAura;\n        }\n    }\n\n    return NULL;\n}\n\nvoid Unit::_AddAura(UnitAura* aura, Unit* caster)\n{\n    ASSERT(!m_cleanupDone);\n    m_ownedAuras.insert(AuraMap::value_type(aura->GetId(), aura));\n\n    _RemoveNoStackAurasDueToAura(aura);\n\n    if (aura->IsRemoved())\n        return;\n\n    aura->SetIsSingleTarget(caster && aura->GetSpellInfo()->IsSingleTarget());\n    if (aura->IsSingleTarget())\n    {\n        ASSERT((IsInWorld() && !IsDuringRemoveFromWorld()) || (aura->GetCasterGUID() == GetGUID()));\n        // register single target aura\n        caster->GetSingleCastAuras().push_back(aura);\n        // remove other single target auras\n        Unit::AuraList& scAuras = caster->GetSingleCastAuras();\n        for (Unit::AuraList::iterator itr = scAuras.begin(); itr != scAuras.end();)\n        {\n            if ((*itr) != aura &&\n                (*itr)->GetSpellInfo()->IsSingleTargetWith(aura->GetSpellInfo()))\n            {\n                (*itr)->Remove();\n                itr = scAuras.begin();\n            }\n            else\n                ++itr;\n        }\n    }\n}\n\n// creates aura application instance and registers it in lists\n// aura application effects are handled separately to prevent aura list corruption\nAuraApplication * Unit::_CreateAuraApplication(Aura* aura, uint8 effMask)\n{\n    // can't apply aura on unit which is going to be deleted - to not create a memory leak\n    ASSERT(!m_cleanupDone);\n    // aura musn't be removed\n    ASSERT(!aura->IsRemoved());\n\n    // aura mustn't be already applied on target\n    ASSERT (!aura->IsAppliedOnTarget(GetGUID()) && \"Unit::_CreateAuraApplication: aura musn't be applied on target\");\n\n    SpellInfo const* aurSpellInfo = aura->GetSpellInfo();\n    uint32 aurId = aurSpellInfo->Id;\n\n    // ghost spell check, allow apply any auras at player loading in ghost mode (will be cleanup after load)\n    if (!isAlive() && !aurSpellInfo->IsDeathPersistent() &&\n        (GetTypeId() != TYPEID_PLAYER || !ToPlayer()->GetSession()->PlayerLoading()))\n        return NULL;\n\n    Unit* caster = aura->GetCaster();\n\n    AuraApplication * aurApp = new AuraApplication(this, caster, aura, effMask);\n    m_appliedAuras.insert(AuraApplicationMap::value_type(aurId, aurApp));\n\n    if (aurSpellInfo->AuraInterruptFlags)\n    {\n        m_interruptableAuras.push_back(aurApp);\n        AddInterruptMask(aurSpellInfo->AuraInterruptFlags);\n    }\n\n    if (AuraStateType aState = aura->GetSpellInfo()->GetAuraState())\n        m_auraStateAuras.insert(AuraStateAurasMap::value_type(aState, aurApp));\n\n    aura->_ApplyForTarget(this, caster, aurApp);\n    return aurApp;\n}\n\nvoid Unit::_ApplyAuraEffect(Aura* aura, uint8 effIndex)\n{\n    ASSERT(aura);\n    ASSERT(aura->HasEffect(effIndex));\n    AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID());\n    ASSERT(aurApp);\n    if (!aurApp->GetEffectMask())\n        _ApplyAura(aurApp, 1<<effIndex);\n    else\n        aurApp->_HandleEffect(effIndex, true);\n}\n\n// handles effects of aura application\n// should be done after registering aura in lists\nvoid Unit::_ApplyAura(AuraApplication * aurApp, uint8 effMask)\n{\n    Aura* aura = aurApp->GetBase();\n\n    _RemoveNoStackAurasDueToAura(aura);\n\n    if (aurApp->GetRemoveMode())\n        return;\n\n    // Update target aura state flag\n    if (AuraStateType aState = aura->GetSpellInfo()->GetAuraState())\n        ModifyAuraState(aState, true);\n\n    if (aurApp->GetRemoveMode())\n        return;\n\n    // Sitdown on apply aura req seated\n    if (aura->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED && !IsSitState())\n        SetStandState(UNIT_STAND_STATE_SIT);\n\n    Unit* caster = aura->GetCaster();\n\n    if (aurApp->GetRemoveMode())\n        return;\n\n    aura->HandleAuraSpecificMods(aurApp, caster, true, false);\n\n    // apply effects of the aura\n    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)\n    {\n        if (effMask & 1<<i && (!aurApp->GetRemoveMode()))\n            aurApp->_HandleEffect(i, true);\n    }\n}\n\n// removes aura application from lists and unapplies effects\nvoid Unit::_UnapplyAura(AuraApplicationMap::iterator &i, AuraRemoveMode removeMode)\n{\n    AuraApplication * aurApp = i->second;\n    ASSERT(aurApp);\n    ASSERT(!aurApp->GetRemoveMode());\n    ASSERT(aurApp->GetTarget() == this);\n\n    aurApp->SetRemoveMode(removeMode);\n    Aura* aura = aurApp->GetBase();\n    sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"Aura %u now is remove mode %d\", aura->GetId(), removeMode);\n\n    // dead loop is killing the server probably\n    ASSERT(m_removedAurasCount < 0xFFFFFFFF);\n\n    ++m_removedAurasCount;\n\n    Unit* caster = aura->GetCaster();\n\n    // Remove all pointers from lists here to prevent possible pointer invalidation on spellcast/auraapply/auraremove\n    m_appliedAuras.erase(i);\n\n    if (aura->GetSpellInfo()->AuraInterruptFlags)\n    {\n        m_interruptableAuras.remove(aurApp);\n        UpdateInterruptMask();\n    }\n\n    bool auraStateFound = false;\n    AuraStateType auraState = aura->GetSpellInfo()->GetAuraState();\n    if (auraState)\n    {\n        bool canBreak = false;\n        // Get mask of all aurastates from remaining auras\n        for (AuraStateAurasMap::iterator itr = m_auraStateAuras.lower_bound(auraState); itr != m_auraStateAuras.upper_bound(auraState) && !(auraStateFound && canBreak);)\n        {\n            if (itr->second == aurApp)\n            {\n                m_auraStateAuras.erase(itr);\n                itr = m_auraStateAuras.lower_bound(auraState);\n                canBreak = true;\n                continue;\n            }\n            auraStateFound = true;\n            ++itr;\n        }\n    }\n\n    aurApp->_Remove();\n    aura->_UnapplyForTarget(this, caster, aurApp);\n\n    // remove effects of the spell - needs to be done after removing aura from lists\n    for (uint8 itr = 0; itr < MAX_SPELL_EFFECTS; ++itr)\n    {\n        if (aurApp->HasEffect(itr))\n            aurApp->_HandleEffect(itr, false);\n    }\n\n    // all effect mustn't be applied\n    ASSERT(!aurApp->GetEffectMask());\n\n    // Remove totem at next update if totem loses its aura\n    if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE && GetTypeId() == TYPEID_UNIT && ToCreature()->isTotem()&& ToTotem()->GetSummonerGUID() == aura->GetCasterGUID())\n    {\n        if (ToTotem()->GetSpell() == aura->GetId() && ToTotem()->GetTotemType() == TOTEM_PASSIVE)\n            ToTotem()->setDeathState(JUST_DIED);\n    }\n\n    // Remove aurastates only if were not found\n    if (!auraStateFound)\n        ModifyAuraState(auraState, false);\n\n    aura->HandleAuraSpecificMods(aurApp, caster, false, false);\n\n    // only way correctly remove all auras from list\n    //if (removedAuras != m_removedAurasCount) new aura may be added\n        i = m_appliedAuras.begin();\n}\n\nvoid Unit::_UnapplyAura(AuraApplication * aurApp, AuraRemoveMode removeMode)\n{\n    // aura can be removed from unit only if it's applied on it, shouldn't happen\n    ASSERT(aurApp->GetBase()->GetApplicationOfTarget(GetGUID()) == aurApp);\n    uint32 spellId = aurApp->GetBase()->GetId();\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)\n    {\n        if (iter->second == aurApp)\n        {\n            _UnapplyAura(iter, removeMode);\n            return;\n        }\n        else\n            ++iter;\n    }\n    ASSERT(false);\n}\n\nvoid Unit::_RemoveNoStackAurasDueToAura(Aura* aura)\n{\n    SpellInfo const* spellProto = aura->GetSpellInfo();\n\n    // passive spell special case (only non stackable with ranks)\n    if (spellProto->IsPassiveStackableWithRanks())\n        return;\n\n    bool remove = false;\n    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)\n    {\n        if (remove)\n        {\n            remove = false;\n            i = m_appliedAuras.begin();\n        }\n\n        if (aura->CanStackWith(i->second->GetBase()))\n            continue;\n\n        RemoveAura(i, AURA_REMOVE_BY_DEFAULT);\n        if (i == m_appliedAuras.end())\n            break;\n        remove = true;\n    }\n}\n\nvoid Unit::_RegisterAuraEffect(AuraEffect* aurEff, bool apply)\n{\n    if (apply)\n        m_modAuras[aurEff->GetAuraType()].push_back(aurEff);\n    else\n        m_modAuras[aurEff->GetAuraType()].remove(aurEff);\n}\n\n// All aura base removes should go threw this function!\nvoid Unit::RemoveOwnedAura(AuraMap::iterator &i, AuraRemoveMode removeMode)\n{\n    Aura* aura = i->second;\n    ASSERT(!aura->IsRemoved());\n\n    // if unit currently update aura list then make safe update iterator shift to next\n    if (m_auraUpdateIterator == i)\n        ++m_auraUpdateIterator;\n\n    m_ownedAuras.erase(i);\n    m_removedAuras.push_back(aura);\n\n    // Unregister single target aura\n    if (aura->IsSingleTarget())\n        aura->UnregisterSingleTarget();\n\n    aura->_Remove(removeMode);\n\n    i = m_ownedAuras.begin();\n}\n\nvoid Unit::RemoveOwnedAura(uint32 spellId, uint64 casterGUID, uint8 reqEffMask, AuraRemoveMode removeMode)\n{\n    for (AuraMap::iterator itr = m_ownedAuras.lower_bound(spellId); itr != m_ownedAuras.upper_bound(spellId);)\n        if (((itr->second->GetEffectMask() & reqEffMask) == reqEffMask) && (!casterGUID || itr->second->GetCasterGUID() == casterGUID))\n        {\n            RemoveOwnedAura(itr, removeMode);\n            itr = m_ownedAuras.lower_bound(spellId);\n        }\n        else\n            ++itr;\n}\n\nvoid Unit::RemoveOwnedAura(Aura* aura, AuraRemoveMode removeMode)\n{\n    if (aura->IsRemoved())\n        return;\n\n    ASSERT(aura->GetOwner() == this);\n\n    uint32 spellId = aura->GetId();\n    for (AuraMap::iterator itr = m_ownedAuras.lower_bound(spellId); itr != m_ownedAuras.upper_bound(spellId); ++itr)\n        if (itr->second == aura)\n        {\n            RemoveOwnedAura(itr, removeMode);\n            return;\n        }\n    ASSERT(false);\n}\n\nAura* Unit::GetOwnedAura(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint8 reqEffMask, Aura* except) const\n{\n    for (AuraMap::const_iterator itr = m_ownedAuras.lower_bound(spellId); itr != m_ownedAuras.upper_bound(spellId); ++itr)\n        if (((itr->second->GetEffectMask() & reqEffMask) == reqEffMask) && (!casterGUID || itr->second->GetCasterGUID() == casterGUID) && (!itemCasterGUID || itr->second->GetCastItemGUID() == itemCasterGUID) && (!except || except != itr->second))\n            return itr->second;\n    return NULL;\n}\n\nvoid Unit::RemoveAura(AuraApplicationMap::iterator &i, AuraRemoveMode mode)\n{\n    AuraApplication * aurApp = i->second;\n    // Do not remove aura which is already being removed\n    if (aurApp->GetRemoveMode())\n        return;\n    Aura* aura = aurApp->GetBase();\n    _UnapplyAura(i, mode);\n    // Remove aura - for Area and Target auras\n    if (aura->GetOwner() == this)\n        aura->Remove(mode);\n}\n\nvoid Unit::RemoveAura(uint32 spellId, uint64 caster, uint8 reqEffMask, AuraRemoveMode removeMode)\n{\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)\n    {\n        Aura const* aura = iter->second->GetBase();\n        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask)\n            && (!caster || aura->GetCasterGUID() == caster))\n        {\n            RemoveAura(iter, removeMode);\n            return;\n        }\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::RemoveAura(AuraApplication * aurApp, AuraRemoveMode mode)\n{\n    // we've special situation here, RemoveAura called while during aura removal\n    // this kind of call is needed only when aura effect removal handler\n    // or event triggered by it expects to remove\n    // not yet removed effects of an aura\n    if (aurApp->GetRemoveMode())\n    {\n        // remove remaining effects of an aura\n        for (uint8 itr = 0; itr < MAX_SPELL_EFFECTS; ++itr)\n        {\n            if (aurApp->HasEffect(itr))\n                aurApp->_HandleEffect(itr, false);\n        }\n        return;\n    }\n    // no need to remove\n    if (aurApp->GetBase()->GetApplicationOfTarget(GetGUID()) != aurApp || aurApp->GetBase()->IsRemoved())\n        return;\n    uint32 spellId = aurApp->GetBase()->GetId();\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)\n    {\n        if (aurApp == iter->second)\n        {\n            RemoveAura(iter, mode);\n            return;\n        }\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::RemoveAura(Aura* aura, AuraRemoveMode mode)\n{\n    if (aura->IsRemoved())\n        return;\n    if (AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID()))\n        RemoveAura(aurApp, mode);\n}\n\nvoid Unit::RemoveAurasDueToSpell(uint32 spellId, uint64 casterGUID, uint8 reqEffMask, AuraRemoveMode removeMode)\n{\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)\n    {\n        Aura const* aura = iter->second->GetBase();\n        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask)\n            && (!casterGUID || aura->GetCasterGUID() == casterGUID))\n        {\n            RemoveAura(iter, removeMode);\n            iter = m_appliedAuras.lower_bound(spellId);\n        }\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::RemoveAuraFromStack(uint32 spellId, uint64 casterGUID, AuraRemoveMode removeMode)\n{\n    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);)\n    {\n        Aura* aura = iter->second;\n        if ((aura->GetType() == UNIT_AURA_TYPE)\n            && (!casterGUID || aura->GetCasterGUID() == casterGUID))\n        {\n            aura->ModStackAmount(-1, removeMode);\n            return;\n        }\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::RemoveAurasDueToSpellByDispel(uint32 spellId, uint32 dispellerSpellId, uint64 casterGUID, Unit* dispeller, uint8 chargesRemoved/*= 1*/)\n{\n    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);)\n    {\n        Aura* aura = iter->second;\n        if (aura->GetCasterGUID() == casterGUID)\n        {\n            DispelInfo dispelInfo(dispeller, dispellerSpellId, chargesRemoved);\n\n            // Call OnDispel hook on AuraScript\n            aura->CallScriptDispel(&dispelInfo);\n\n            if (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES)\n                aura->ModCharges(-dispelInfo.GetRemovedCharges(), AURA_REMOVE_BY_ENEMY_SPELL);\n            else\n                aura->ModStackAmount(-dispelInfo.GetRemovedCharges(), AURA_REMOVE_BY_ENEMY_SPELL);\n\n            // Call AfterDispel hook on AuraScript\n            aura->CallScriptAfterDispel(&dispelInfo);\n\n            return;\n        }\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::RemoveAurasDueToSpellBySteal(uint32 spellId, uint64 casterGUID, Unit* stealer)\n{\n    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);)\n    {\n        Aura* aura = iter->second;\n        if (aura->GetCasterGUID() == casterGUID)\n        {\n            int32 damage[MAX_SPELL_EFFECTS];\n            int32 baseDamage[MAX_SPELL_EFFECTS];\n            uint8 effMask = 0;\n            uint8 recalculateMask = 0;\n            Unit* caster = aura->GetCaster();\n            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)\n            {\n                if (aura->GetEffect(i))\n                {\n                    baseDamage[i] = aura->GetEffect(i)->GetBaseAmount();\n                    damage[i] = aura->GetEffect(i)->GetAmount();\n                    effMask |= (1<<i);\n                    if (aura->GetEffect(i)->CanBeRecalculated())\n                        recalculateMask |= (1<<i);\n                }\n                else\n                {\n                    baseDamage[i] = 0;\n                    damage[i] = 0;\n                }\n            }\n\n            bool stealCharge = aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES;\n            // Cast duration to unsigned to prevent permanent aura's such as Righteous Fury being permanently added to caster\n            uint32 dur = std::min(2u * MINUTE * IN_MILLISECONDS, uint32(aura->GetDuration()));\n\n            if (Aura* oldAura = stealer->GetAura(aura->GetId(), aura->GetCasterGUID()))\n            {\n                if (stealCharge)\n                    oldAura->ModCharges(1);\n                else\n                    oldAura->ModStackAmount(1);\n                oldAura->SetDuration(int32(dur));\n            }\n            else\n            {\n                // single target state must be removed before aura creation to preserve existing single target aura\n                if (aura->IsSingleTarget())\n                    aura->UnregisterSingleTarget();\n\n                if (Aura* newAura = Aura::TryRefreshStackOrCreate(aura->GetSpellInfo(), effMask, stealer, NULL, &baseDamage[0], NULL, aura->GetCasterGUID()))\n                {\n                    // created aura must not be single target aura,, so stealer won't loose it on recast\n                    if (newAura->IsSingleTarget())\n                    {\n                        newAura->UnregisterSingleTarget();\n                        // bring back single target aura status to the old aura\n                        aura->SetIsSingleTarget(true);\n                        caster->GetSingleCastAuras().push_back(aura);\n                    }\n                    // FIXME: using aura->GetMaxDuration() maybe not blizzlike but it fixes stealing of spells like Innervate\n                    newAura->SetLoadedState(aura->GetMaxDuration(), int32(dur), stealCharge ? 1 : aura->GetCharges(), 1, recalculateMask, &damage[0]);\n                    newAura->ApplyForTargets();\n                }\n            }\n\n            if (stealCharge)\n                aura->ModCharges(-1, AURA_REMOVE_BY_ENEMY_SPELL);\n            else\n                aura->ModStackAmount(-1, AURA_REMOVE_BY_ENEMY_SPELL);\n\n            return;\n        }\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::RemoveAurasDueToItemSpell(Item* castItem, uint32 spellId)\n{\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)\n    {\n        if (!castItem || iter->second->GetBase()->GetCastItemGUID() == castItem->GetGUID())\n        {\n            RemoveAura(iter);\n            iter = m_appliedAuras.upper_bound(spellId);          // overwrite by more appropriate\n        }\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::RemoveAurasByType(AuraType auraType, uint64 casterGUID, Aura* except, bool negative, bool positive)\n{\n    for (AuraEffectList::iterator iter = m_modAuras[auraType].begin(); iter != m_modAuras[auraType].end();)\n    {\n        Aura* aura = (*iter)->GetBase();\n        AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID());\n\n        ++iter;\n        if (aura != except && (!casterGUID || aura->GetCasterGUID() == casterGUID)\n            && ((negative && !aurApp->IsPositive()) || (positive && aurApp->IsPositive())))\n        {\n            uint32 removedAuras = m_removedAurasCount;\n            RemoveAura(aurApp);\n            if (m_removedAurasCount > removedAuras + 1)\n                iter = m_modAuras[auraType].begin();\n        }\n    }\n}\n\nvoid Unit::RemoveAurasWithAttribute(uint32 flags)\n{\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)\n    {\n        SpellInfo const* spell = iter->second->GetBase()->GetSpellInfo();\n        if (spell->Attributes & flags)\n            RemoveAura(iter);\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::RemoveNotOwnSingleTargetAuras(uint32 newPhase)\n{\n    // single target auras from other casters\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)\n    {\n        AuraApplication const* aurApp = iter->second;\n        Aura const* aura = aurApp->GetBase();\n\n        if (aura->GetCasterGUID() != GetGUID() && aura->GetSpellInfo()->IsSingleTarget())\n        {\n            if (!newPhase)\n                RemoveAura(iter);\n            else\n            {\n                Unit* caster = aura->GetCaster();\n                if (!caster || !caster->InSamePhase(newPhase))\n                    RemoveAura(iter);\n                else\n                    ++iter;\n            }\n        }\n        else\n            ++iter;\n    }\n\n    // single target auras at other targets\n    AuraList& scAuras = GetSingleCastAuras();\n    for (AuraList::iterator iter = scAuras.begin(); iter != scAuras.end();)\n    {\n        Aura* aura = *iter;\n        if (aura->GetUnitOwner() != this && !aura->GetUnitOwner()->InSamePhase(newPhase))\n        {\n            aura->Remove();\n            iter = scAuras.begin();\n        }\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::RemoveAurasWithInterruptFlags(uint32 flag, uint32 except)\n{\n    if (!(m_interruptMask & flag))\n        return;\n\n    // interrupt auras\n    for (AuraApplicationList::iterator iter = m_interruptableAuras.begin(); iter != m_interruptableAuras.end();)\n    {\n        Aura* aura = (*iter)->GetBase();\n        ++iter;\n        if ((aura->GetSpellInfo()->AuraInterruptFlags & flag) && (!except || aura->GetId() != except))\n        {\n            uint32 removedAuras = m_removedAurasCount;\n            RemoveAura(aura);\n            if (m_removedAurasCount > removedAuras + 1)\n                iter = m_interruptableAuras.begin();\n        }\n    }\n\n    // interrupt channeled spell\n    if (Spell* spell = m_currentSpells[CURRENT_CHANNELED_SPELL])\n        if (spell->getState() == SPELL_STATE_CASTING\n            && (spell->m_spellInfo->ChannelInterruptFlags & flag)\n            && spell->m_spellInfo->Id != except)\n            InterruptNonMeleeSpells(false);\n\n    UpdateInterruptMask();\n}\n\nvoid Unit::RemoveAurasWithFamily(SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID)\n{\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)\n    {\n        Aura const* aura = iter->second->GetBase();\n        if (!casterGUID || aura->GetCasterGUID() == casterGUID)\n        {\n            SpellInfo const* spell = aura->GetSpellInfo();\n            if (spell->SpellFamilyName == uint32(family) && spell->SpellFamilyFlags.HasFlag(familyFlag1, familyFlag2, familyFlag3))\n            {\n                RemoveAura(iter);\n                continue;\n            }\n        }\n        ++iter;\n    }\n}\n\nvoid Unit::RemoveMovementImpairingAuras()\n{\n    RemoveAurasWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT));\n}\n\nvoid Unit::RemoveAurasWithMechanic(uint32 mechanic_mask, AuraRemoveMode removemode, uint32 except)\n{\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)\n    {\n        Aura const* aura = iter->second->GetBase();\n        if (!except || aura->GetId() != except)\n        {\n            if (aura->GetSpellInfo()->GetAllEffectsMechanicMask() & mechanic_mask)\n            {\n                RemoveAura(iter, removemode);\n                continue;\n            }\n        }\n        ++iter;\n    }\n}\n\nvoid Unit::RemoveAreaAurasDueToLeaveWorld()\n{\n    // make sure that all area auras not applied on self are removed - prevent access to deleted pointer later\n    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)\n    {\n        Aura* aura = iter->second;\n        ++iter;\n        Aura::ApplicationMap const& appMap = aura->GetApplicationMap();\n        for (Aura::ApplicationMap::const_iterator itr = appMap.begin(); itr!= appMap.end();)\n        {\n            AuraApplication * aurApp = itr->second;\n            ++itr;\n            Unit* target = aurApp->GetTarget();\n            if (target == this)\n                continue;\n            target->RemoveAura(aurApp);\n            // things linked on aura remove may apply new area aura - so start from the beginning\n            iter = m_ownedAuras.begin();\n        }\n    }\n\n    // remove area auras owned by others\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)\n    {\n        if (iter->second->GetBase()->GetOwner() != this)\n        {\n            RemoveAura(iter);\n        }\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::RemoveAllAuras()\n{\n    // this may be a dead loop if some events on aura remove will continiously apply aura on remove\n    // we want to have all auras removed, so use your brain when linking events\n    while (!m_appliedAuras.empty() || !m_ownedAuras.empty())\n    {\n        AuraApplicationMap::iterator aurAppIter;\n        for (aurAppIter = m_appliedAuras.begin(); aurAppIter != m_appliedAuras.end();)\n            _UnapplyAura(aurAppIter, AURA_REMOVE_BY_DEFAULT);\n\n        AuraMap::iterator aurIter;\n        for (aurIter = m_ownedAuras.begin(); aurIter != m_ownedAuras.end();)\n            RemoveOwnedAura(aurIter);\n    }\n}\n\nvoid Unit::RemoveArenaAuras()\n{\n    // in join, remove positive buffs, on end, remove negative\n    // used to remove positive visible auras in arenas\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)\n    {\n        AuraApplication const* aurApp = iter->second;\n        Aura const* aura = aurApp->GetBase();\n        if (!(aura->GetSpellInfo()->AttributesEx4 & SPELL_ATTR4_UNK21) // don't remove stances, shadowform, pally/hunter auras\n            && !aura->IsPassive()                               // don't remove passive auras\n            && (aurApp->IsPositive() || !(aura->GetSpellInfo()->AttributesEx3 & SPELL_ATTR3_DEATH_PERSISTENT))) // not negative death persistent auras\n            RemoveAura(iter);\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::RemoveAllAurasOnDeath()\n{\n    // used just after dieing to remove all visible auras\n    // and disable the mods for the passive ones\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)\n    {\n        Aura const* aura = iter->second->GetBase();\n        if (!aura->IsPassive() && !aura->IsDeathPersistent())\n            _UnapplyAura(iter, AURA_REMOVE_BY_DEATH);\n        else\n            ++iter;\n    }\n\n    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)\n    {\n        Aura* aura = iter->second;\n        if (!aura->IsPassive() && !aura->IsDeathPersistent())\n            RemoveOwnedAura(iter, AURA_REMOVE_BY_DEATH);\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::RemoveAllAurasRequiringDeadTarget()\n{\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)\n    {\n        Aura const* aura = iter->second->GetBase();\n        if (!aura->IsPassive() && aura->GetSpellInfo()->IsRequiringDeadTarget())\n            _UnapplyAura(iter, AURA_REMOVE_BY_DEFAULT);\n        else\n            ++iter;\n    }\n\n    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)\n    {\n        Aura* aura = iter->second;\n        if (!aura->IsPassive() && aura->GetSpellInfo()->IsRequiringDeadTarget())\n            RemoveOwnedAura(iter, AURA_REMOVE_BY_DEFAULT);\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::RemoveAllAurasExceptType(AuraType type)\n{\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)\n    {\n        Aura const* aura = iter->second->GetBase();\n        if (!aura->GetSpellInfo()->HasAura(type))\n            _UnapplyAura(iter, AURA_REMOVE_BY_DEFAULT);\n        else\n            ++iter;\n    }\n\n    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)\n    {\n        Aura* aura = iter->second;\n        if (!aura->GetSpellInfo()->HasAura(type))\n            RemoveOwnedAura(iter, AURA_REMOVE_BY_DEFAULT);\n        else\n            ++iter;\n    }\n}\n\nvoid Unit::DelayOwnedAuras(uint32 spellId, uint64 caster, int32 delaytime)\n{\n    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);++iter)\n    {\n        Aura* aura = iter->second;\n        if (!caster || aura->GetCasterGUID() == caster)\n        {\n            if (aura->GetDuration() < delaytime)\n                aura->SetDuration(0);\n            else\n                aura->SetDuration(aura->GetDuration() - delaytime);\n\n            // update for out of range group members (on 1 slot use)\n            aura->SetNeedClientUpdateForTargets();\n            sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"Aura %u partially interrupted on unit %u, new duration: %u ms\", aura->GetId(), GetGUIDLow(), aura->GetDuration());\n        }\n    }\n}\n\nvoid Unit::_RemoveAllAuraStatMods()\n{\n    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)\n        (*i).second->GetBase()->HandleAllEffects(i->second, AURA_EFFECT_HANDLE_STAT, false);\n}\n\nvoid Unit::_ApplyAllAuraStatMods()\n{\n    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)\n        (*i).second->GetBase()->HandleAllEffects(i->second, AURA_EFFECT_HANDLE_STAT, true);\n}\n\nAuraEffect* Unit::GetAuraEffect(uint32 spellId, uint8 effIndex, uint64 caster) const\n{\n    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)\n        if (itr->second->HasEffect(effIndex) && (!caster || itr->second->GetBase()->GetCasterGUID() == caster))\n            return itr->second->GetBase()->GetEffect(effIndex);\n    return NULL;\n}\n\nAuraEffect* Unit::GetAuraEffectOfRankedSpell(uint32 spellId, uint8 effIndex, uint64 caster) const\n{\n    uint32 rankSpell = sSpellMgr->GetFirstSpellInChain(spellId);\n    while (rankSpell)\n    {\n        if (AuraEffect* aurEff = GetAuraEffect(rankSpell, effIndex, caster))\n            return aurEff;\n        rankSpell = sSpellMgr->GetNextSpellInChain(rankSpell);\n    }\n    return NULL;\n}\n\nAuraEffect* Unit::GetAuraEffect(AuraType type, SpellFamilyNames name, uint32 iconId, uint8 effIndex) const\n{\n    AuraEffectList const& auras = GetAuraEffectsByType(type);\n    for (Unit::AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)\n    {\n        if (effIndex != (*itr)->GetEffIndex())\n            continue;\n        SpellInfo const* spell = (*itr)->GetSpellInfo();\n        if (spell->SpellIconID == iconId && spell->SpellFamilyName == uint32(name) && !spell->SpellFamilyFlags)\n            return *itr;\n    }\n    return NULL;\n}\n\nAuraEffect* Unit::GetAuraEffect(AuraType type, SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID)\n{\n    AuraEffectList const& auras = GetAuraEffectsByType(type);\n    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)\n    {\n        SpellInfo const* spell = (*i)->GetSpellInfo();\n        if (spell->SpellFamilyName == uint32(family) && spell->SpellFamilyFlags.HasFlag(familyFlag1, familyFlag2, familyFlag3))\n        {\n            if (casterGUID && (*i)->GetCasterGUID() != casterGUID)\n                continue;\n            return (*i);\n        }\n    }\n    return NULL;\n}\n\nAuraApplication * Unit::GetAuraApplication(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint8 reqEffMask, AuraApplication * except) const\n{\n    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)\n    {\n        Aura const* aura = itr->second->GetBase();\n        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask) && (!casterGUID || aura->GetCasterGUID() == casterGUID) && (!itemCasterGUID || aura->GetCastItemGUID() == itemCasterGUID) && (!except || except != itr->second))\n            return itr->second;\n    }\n    return NULL;\n}\n\nAura* Unit::GetAura(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint8 reqEffMask) const\n{\n    AuraApplication * aurApp = GetAuraApplication(spellId, casterGUID, itemCasterGUID, reqEffMask);\n    return aurApp ? aurApp->GetBase() : NULL;\n}\n\nAuraApplication * Unit::GetAuraApplicationOfRankedSpell(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint8 reqEffMask, AuraApplication* except) const\n{\n    uint32 rankSpell = sSpellMgr->GetFirstSpellInChain(spellId);\n    while (rankSpell)\n    {\n        if (AuraApplication * aurApp = GetAuraApplication(rankSpell, casterGUID, itemCasterGUID, reqEffMask, except))\n            return aurApp;\n        rankSpell = sSpellMgr->GetNextSpellInChain(rankSpell);\n    }\n    return NULL;\n}\n\nAura* Unit::GetAuraOfRankedSpell(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint8 reqEffMask) const\n{\n    AuraApplication * aurApp = GetAuraApplicationOfRankedSpell(spellId, casterGUID, itemCasterGUID, reqEffMask);\n    return aurApp ? aurApp->GetBase() : NULL;\n}\n\nvoid Unit::GetDispellableAuraList(Unit* caster, uint32 dispelMask, DispelChargesList& dispelList)\n{\n    // we should not be able to dispel diseases if the target is affected by unholy blight\n    if (dispelMask & (1 << DISPEL_DISEASE) && HasAura(50536))\n        dispelMask &= ~(1 << DISPEL_DISEASE);\n\n    AuraMap const& auras = GetOwnedAuras();\n    for (AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)\n    {\n        Aura* aura = itr->second;\n        AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID());\n        if (!aurApp)\n            continue;\n\n        // don't try to remove passive auras\n        if (aura->IsPassive())\n            continue;\n\n        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)\n        {\n            if (aura->GetSpellInfo()->Dispel == DISPEL_MAGIC)\n            {\n                // do not remove positive auras if friendly target\n                //               negative auras if non-friendly target\n                if (aurApp->IsPositive() == IsFriendlyTo(caster))\n                    continue;\n            }\n\n            // The charges / stack amounts don't count towards the total number of auras that can be dispelled.\n            // Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell\n            // Polymorph instead of 1 / (5 + 1) -> 16%.\n            bool dispel_charges = aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES;\n            uint8 charges = dispel_charges ? aura->GetCharges() : aura->GetStackAmount();\n            if (charges > 0)\n                dispelList.push_back(std::make_pair(aura, charges));\n        }\n    }\n}\n\nbool Unit::HasAuraEffect(uint32 spellId, uint8 effIndex, uint64 caster) const\n{\n    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)\n        if (itr->second->HasEffect(effIndex) && (!caster || itr->second->GetBase()->GetCasterGUID() == caster))\n            return true;\n    return false;\n}\n\nuint32 Unit::GetAuraCount(uint32 spellId) const\n{\n    uint32 count = 0;\n    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)\n    {\n        if (!itr->second->GetBase()->GetStackAmount())\n            count++;\n        else\n            count += (uint32)itr->second->GetBase()->GetStackAmount();\n    }\n    return count;\n}\n\nbool Unit::HasAura(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint8 reqEffMask) const\n{\n    if (GetAuraApplication(spellId, casterGUID, itemCasterGUID, reqEffMask))\n        return true;\n    return false;\n}\n\nbool Unit::HasAuraType(AuraType auraType) const\n{\n    return (!m_modAuras[auraType].empty());\n}\n\nbool Unit::HasAuraTypeWithCaster(AuraType auratype, uint64 caster) const\n{\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n        if (caster == (*i)->GetCasterGUID())\n            return true;\n    return false;\n}\n\nbool Unit::HasAuraTypeWithMiscvalue(AuraType auratype, int32 miscvalue) const\n{\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n        if (miscvalue == (*i)->GetMiscValue())\n            return true;\n    return false;\n}\n\nbool Unit::HasAuraTypeWithAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const\n{\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n        if ((*i)->IsAffectedOnSpell(affectedSpell))\n            return true;\n    return false;\n}\n\nbool Unit::HasAuraTypeWithValue(AuraType auratype, int32 value) const\n{\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n        if (value == (*i)->GetAmount())\n            return true;\n    return false;\n}\n\nbool Unit::HasNegativeAuraWithInterruptFlag(uint32 flag, uint64 guid)\n{\n    if (!(m_interruptMask & flag))\n        return false;\n    for (AuraApplicationList::iterator iter = m_interruptableAuras.begin(); iter != m_interruptableAuras.end(); ++iter)\n    {\n        if (!(*iter)->IsPositive() && (*iter)->GetBase()->GetSpellInfo()->AuraInterruptFlags & flag && (!guid || (*iter)->GetBase()->GetCasterGUID() == guid))\n            return true;\n    }\n    return false;\n}\n\nbool Unit::HasNegativeAuraWithAttribute(uint32 flag, uint64 guid)\n{\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end(); ++iter)\n    {\n        Aura const* aura = iter->second->GetBase();\n        if (!iter->second->IsPositive() && aura->GetSpellInfo()->Attributes & flag && (!guid || aura->GetCasterGUID() == guid))\n            return true;\n    }\n    return false;\n}\n\nbool Unit::HasAuraWithMechanic(uint32 mechanicMask)\n{\n    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end(); ++iter)\n    {\n        SpellInfo const* spellInfo  = iter->second->GetBase()->GetSpellInfo();\n        if (spellInfo->Mechanic && (mechanicMask & (1 << spellInfo->Mechanic)))\n            return true;\n\n        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)\n            if (iter->second->HasEffect(i) && spellInfo->Effects[i].Effect && spellInfo->Effects[i].Mechanic)\n                if (mechanicMask & (1 << spellInfo->Effects[i].Mechanic))\n                    return true;\n    }\n\n    return false;\n}\n\nAuraEffect* Unit::IsScriptOverriden(SpellInfo const* spell, int32 script) const\n{\n    AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);\n    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)\n    {\n        if ((*i)->GetMiscValue() == script)\n            if ((*i)->IsAffectedOnSpell(spell))\n                return (*i);\n    }\n    return NULL;\n}\n\nuint32 Unit::GetDiseasesByCaster(uint64 casterGUID, bool remove)\n{\n    static const AuraType diseaseAuraTypes[] =\n    {\n        SPELL_AURA_PERIODIC_DAMAGE, // Frost Fever and Blood Plague\n        SPELL_AURA_LINKED,          // Crypt Fever and Ebon Plague\n        SPELL_AURA_NONE\n    };\n\n    uint32 diseases = 0;\n    for (AuraType const* itr = &diseaseAuraTypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)\n    {\n        for (AuraEffectList::iterator i = m_modAuras[*itr].begin(); i != m_modAuras[*itr].end();)\n        {\n            // Get auras with disease dispel type by caster\n            if ((*i)->GetSpellInfo()->Dispel == DISPEL_DISEASE\n                && (*i)->GetCasterGUID() == casterGUID)\n            {\n                ++diseases;\n\n                if (remove)\n                {\n                    RemoveAura((*i)->GetId(), (*i)->GetCasterGUID());\n                    i = m_modAuras[*itr].begin();\n                    continue;\n                }\n            }\n            ++i;\n        }\n    }\n    return diseases;\n}\n\nuint32 Unit::GetDoTsByCaster(uint64 casterGUID) const\n{\n    static const AuraType diseaseAuraTypes[] =\n    {\n        SPELL_AURA_PERIODIC_DAMAGE,\n        SPELL_AURA_PERIODIC_DAMAGE_PERCENT,\n        SPELL_AURA_NONE\n    };\n\n    uint32 dots = 0;\n    for (AuraType const* itr = &diseaseAuraTypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)\n    {\n        Unit::AuraEffectList const& auras = GetAuraEffectsByType(*itr);\n        for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)\n        {\n            // Get auras by caster\n            if ((*i)->GetCasterGUID() == casterGUID)\n                ++dots;\n        }\n    }\n    return dots;\n}\n\nint32 Unit::GetTotalAuraModifier(AuraType auratype) const\n{\n    std::map<SpellGroup, int32> SameEffectSpellGroup;\n    int32 modifier = 0;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n        if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))\n            modifier += (*i)->GetAmount();\n\n    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)\n        modifier += itr->second;\n\n    return modifier;\n}\n\nfloat Unit::GetTotalAuraMultiplier(AuraType auratype) const\n{\n    float multiplier = 1.0f;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n        AddPctN(multiplier, (*i)->GetAmount());\n\n    return multiplier;\n}\n\nint32 Unit::GetMaxPositiveAuraModifier(AuraType auratype)\n{\n    int32 modifier = 0;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n    {\n        if ((*i)->GetAmount() > modifier)\n            modifier = (*i)->GetAmount();\n    }\n\n    return modifier;\n}\n\nint32 Unit::GetMaxNegativeAuraModifier(AuraType auratype) const\n{\n    int32 modifier = 0;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n        if ((*i)->GetAmount() < modifier)\n            modifier = (*i)->GetAmount();\n\n    return modifier;\n}\n\nint32 Unit::GetTotalAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const\n{\n    std::map<SpellGroup, int32> SameEffectSpellGroup;\n    int32 modifier = 0;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n        if ((*i)->GetMiscValue() & misc_mask)\n            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))\n                modifier += (*i)->GetAmount();\n\n    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)\n        modifier += itr->second;\n\n    return modifier;\n}\n\nfloat Unit::GetTotalAuraMultiplierByMiscMask(AuraType auratype, uint32 misc_mask) const\n{\n    std::map<SpellGroup, int32> SameEffectSpellGroup;\n    float multiplier = 1.0f;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n    {\n        if (((*i)->GetMiscValue() & misc_mask))\n        {\n            // Check if the Aura Effect has a the Same Effect Stack Rule and if so, use the highest amount of that SpellGroup\n            // If the Aura Effect does not have this Stack Rule, it returns false so we can add to the multiplier as usual\n            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))\n                AddPctN(multiplier, (*i)->GetAmount());\n        }\n    }\n    // Add the highest of the Same Effect Stack Rule SpellGroups to the multiplier\n    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)\n        AddPctN(multiplier, itr->second);\n\n    return multiplier;\n}\n\nint32 Unit::GetMaxPositiveAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask, const AuraEffect* except) const\n{\n    int32 modifier = 0;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n    {\n        if (except != (*i) && (*i)->GetMiscValue()& misc_mask && (*i)->GetAmount() > modifier)\n            modifier = (*i)->GetAmount();\n    }\n\n    return modifier;\n}\n\nint32 Unit::GetMaxNegativeAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const\n{\n    int32 modifier = 0;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n    {\n        if ((*i)->GetMiscValue()& misc_mask && (*i)->GetAmount() < modifier)\n            modifier = (*i)->GetAmount();\n    }\n\n    return modifier;\n}\n\nint32 Unit::GetTotalAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const\n{\n    std::map<SpellGroup, int32> SameEffectSpellGroup;\n    int32 modifier = 0;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n    {\n        if ((*i)->GetMiscValue() == misc_value)\n            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))\n                modifier += (*i)->GetAmount();\n    }\n\n    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)\n        modifier += itr->second;\n\n    return modifier;\n}\n\nfloat Unit::GetTotalAuraMultiplierByMiscValue(AuraType auratype, int32 misc_value) const\n{\n    std::map<SpellGroup, int32> SameEffectSpellGroup;\n    float multiplier = 1.0f;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n    {\n        if ((*i)->GetMiscValue() == misc_value)\n            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))\n                AddPctN(multiplier, (*i)->GetAmount());\n    }\n\n    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)\n        AddPctN(multiplier, itr->second);\n\n    return multiplier;\n}\n\nint32 Unit::GetMaxPositiveAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const\n{\n    int32 modifier = 0;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n    {\n        if ((*i)->GetMiscValue() == misc_value && (*i)->GetAmount() > modifier)\n            modifier = (*i)->GetAmount();\n    }\n\n    return modifier;\n}\n\nint32 Unit::GetMaxNegativeAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const\n{\n    int32 modifier = 0;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n    {\n        if ((*i)->GetMiscValue() == misc_value && (*i)->GetAmount() < modifier)\n            modifier = (*i)->GetAmount();\n    }\n\n    return modifier;\n}\n\nint32 Unit::GetTotalAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const\n{\n    std::map<SpellGroup, int32> SameEffectSpellGroup;\n    int32 modifier = 0;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n    {\n        if ((*i)->IsAffectedOnSpell(affectedSpell))\n            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))\n                modifier += (*i)->GetAmount();\n    }\n\n    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)\n        modifier += itr->second;\n\n    return modifier;\n}\n\nfloat Unit::GetTotalAuraMultiplierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const\n{\n    std::map<SpellGroup, int32> SameEffectSpellGroup;\n    float multiplier = 1.0f;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n    {\n        if ((*i)->IsAffectedOnSpell(affectedSpell))\n            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))\n                AddPctN(multiplier, (*i)->GetAmount());\n    }\n\n    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)\n        AddPctN(multiplier, itr->second);\n\n    return multiplier;\n}\n\nint32 Unit::GetMaxPositiveAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const\n{\n    int32 modifier = 0;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n    {\n        if ((*i)->IsAffectedOnSpell(affectedSpell) && (*i)->GetAmount() > modifier)\n            modifier = (*i)->GetAmount();\n    }\n\n    return modifier;\n}\n\nint32 Unit::GetMaxNegativeAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const\n{\n    int32 modifier = 0;\n\n    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);\n    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)\n    {\n        if ((*i)->IsAffectedOnSpell(affectedSpell) && (*i)->GetAmount() < modifier)\n            modifier = (*i)->GetAmount();\n    }\n\n    return modifier;\n}\n\nvoid Unit::_RegisterDynObject(DynamicObject* dynObj)\n{\n    m_dynObj.push_back(dynObj);\n}\n\nvoid Unit::_UnregisterDynObject(DynamicObject* dynObj)\n{\n    m_dynObj.remove(dynObj);\n}\n\nDynamicObject* Unit::GetDynObject(uint32 spellId)\n{\n    if (m_dynObj.empty())\n        return NULL;\n    for (DynObjectList::const_iterator i = m_dynObj.begin(); i != m_dynObj.end();++i)\n    {\n        DynamicObject* dynObj = *i;\n        if (dynObj->GetSpellId() == spellId)\n            return dynObj;\n    }\n    return NULL;\n}\n\nvoid Unit::RemoveDynObject(uint32 spellId)\n{\n    if (m_dynObj.empty())\n        return;\n    for (DynObjectList::iterator i = m_dynObj.begin(); i != m_dynObj.end();)\n    {\n        DynamicObject* dynObj = *i;\n        if (dynObj->GetSpellId() == spellId)\n        {\n            dynObj->Remove();\n            i = m_dynObj.begin();\n        }\n        else\n            ++i;\n    }\n}\n\nvoid Unit::RemoveAllDynObjects()\n{\n    while (!m_dynObj.empty())\n        m_dynObj.front()->Remove();\n}\n\nGameObject* Unit::GetGameObject(uint32 spellId) const\n{\n    for (GameObjectList::const_iterator i = m_gameObj.begin(); i != m_gameObj.end(); ++i)\n        if ((*i)->GetSpellId() == spellId)\n            return *i;\n\n    return NULL;\n}\n\nvoid Unit::AddGameObject(GameObject* gameObj)\n{\n    if (!gameObj || !gameObj->GetOwnerGUID() == 0)\n        return;\n\n    m_gameObj.push_back(gameObj);\n    gameObj->SetOwnerGUID(GetGUID());\n\n    if (GetTypeId() == TYPEID_PLAYER && gameObj->GetSpellId())\n    {\n        SpellInfo const* createBySpell = sSpellMgr->GetSpellInfo(gameObj->GetSpellId());\n        // Need disable spell use for owner\n        if (createBySpell && createBySpell->Attributes & SPELL_ATTR0_DISABLED_WHILE_ACTIVE)\n            // note: item based cooldowns and cooldown spell mods with charges ignored (unknown existing cases)\n            ToPlayer()->AddSpellAndCategoryCooldowns(createBySpell, 0, NULL, true);\n    }\n}\n\nvoid Unit::RemoveGameObject(GameObject* gameObj, bool del)\n{\n    if (!gameObj || gameObj->GetOwnerGUID() != GetGUID())\n        return;\n\n    gameObj->SetOwnerGUID(0);\n\n    for (uint8 i = 0; i < MAX_GAMEOBJECT_SLOT; ++i)\n    {\n        if (m_ObjectSlot[i] == gameObj->GetGUID())\n        {\n            m_ObjectSlot[i] = 0;\n            break;\n        }\n    }\n\n    // GO created by some spell\n    if (uint32 spellid = gameObj->GetSpellId())\n    {\n        RemoveAurasDueToSpell(spellid);\n\n        if (GetTypeId() == TYPEID_PLAYER)\n        {\n            SpellInfo const* createBySpell = sSpellMgr->GetSpellInfo(spellid);\n            // Need activate spell use for owner\n            if (createBySpell && createBySpell->Attributes & SPELL_ATTR0_DISABLED_WHILE_ACTIVE)\n                // note: item based cooldowns and cooldown spell mods with charges ignored (unknown existing cases)\n                ToPlayer()->SendCooldownEvent(createBySpell);\n        }\n    }\n\n    m_gameObj.remove(gameObj);\n\n    if (del)\n    {\n        gameObj->SetRespawnTime(0);\n        gameObj->Delete();\n    }\n}\n\nvoid Unit::RemoveGameObject(uint32 spellid, bool del)\n{\n    if (m_gameObj.empty())\n        return;\n    GameObjectList::iterator i, next;\n    for (i = m_gameObj.begin(); i != m_gameObj.end(); i = next)\n    {\n        next = i;\n        if (spellid == 0 || (*i)->GetSpellId() == spellid)\n        {\n            (*i)->SetOwnerGUID(0);\n            if (del)\n            {\n                (*i)->SetRespawnTime(0);\n                (*i)->Delete();\n            }\n\n            next = m_gameObj.erase(i);\n        }\n        else\n            ++next;\n    }\n}\n\nvoid Unit::RemoveAllGameObjects()\n{\n    // remove references to unit\n    while (!m_gameObj.empty())\n    {\n        GameObjectList::iterator i = m_gameObj.begin();\n        (*i)->SetOwnerGUID(0);\n        (*i)->SetRespawnTime(0);\n        (*i)->Delete();\n        m_gameObj.erase(i);\n    }\n}\n\nvoid Unit::SendSpellNonMeleeDamageLog(SpellNonMeleeDamage* log)\n{\n    WorldPacket data(SMSG_SPELLNONMELEEDAMAGELOG, (16+4+4+4+1+4+4+1+1+4+4+1)); // we guess size\n    data.append(log->target->GetPackGUID());\n    data.append(log->attacker->GetPackGUID());\n    data << uint32(log->SpellID);\n    data << uint32(log->damage);                            // damage amount\n    int32 overkill = log->damage - log->target->GetHealth();\n    data << uint32(overkill > 0 ? overkill : 0);            // overkill\n    data << uint8 (log->schoolMask);                        // damage school\n    data << uint32(log->absorb);                            // AbsorbedDamage\n    data << uint32(log->resist);                            // resist\n    data << uint8 (log->physicalLog);                       // if 1, then client show spell name (example: %s's ranged shot hit %s for %u school or %s suffers %u school damage from %s's spell_name\n    data << uint8 (log->unused);                            // unused\n    data << uint32(log->blocked);                           // blocked\n    data << uint32(log->HitInfo);\n    data << uint8 (0);                                      // flag to use extend data\n    SendMessageToSet(&data, true);\n}\n\nvoid Unit::SendSpellNonMeleeDamageLog(Unit* target, uint32 SpellID, uint32 Damage, SpellSchoolMask damageSchoolMask, uint32 AbsorbedDamage, uint32 Resist, bool PhysicalDamage, uint32 Blocked, bool CriticalHit)\n{\n    SpellNonMeleeDamage log(this, target, SpellID, damageSchoolMask);\n    log.damage = Damage - AbsorbedDamage - Resist - Blocked;\n    log.absorb = AbsorbedDamage;\n    log.resist = Resist;\n    log.physicalLog = PhysicalDamage;\n    log.blocked = Blocked;\n    log.HitInfo = SPELL_HIT_TYPE_UNK1 | SPELL_HIT_TYPE_UNK3 | SPELL_HIT_TYPE_UNK6;\n    if (CriticalHit)\n        log.HitInfo |= SPELL_HIT_TYPE_CRIT;\n    SendSpellNonMeleeDamageLog(&log);\n}\n\nvoid Unit::ProcDamageAndSpell(Unit* victim, uint32 procAttacker, uint32 procVictim, uint32 procExtra, uint32 amount, WeaponAttackType attType, SpellInfo const* procSpell, SpellInfo const* procAura)\n{\n     // Not much to do if no flags are set.\n    if (procAttacker)\n        ProcDamageAndSpellFor(false, victim, procAttacker, procExtra, attType, procSpell, amount, procAura);\n    // Now go on with a victim's events'n'auras\n    // Not much to do if no flags are set or there is no victim\n    if (victim && victim->isAlive() && procVictim)\n        victim->ProcDamageAndSpellFor(true, this, procVictim, procExtra, attType, procSpell, amount, procAura);\n}\n\nvoid Unit::SendPeriodicAuraLog(SpellPeriodicAuraLogInfo* pInfo)\n{\n    AuraEffect const* aura = pInfo->auraEff;\n\n    WorldPacket data(SMSG_PERIODICAURALOG, 30);\n    data.append(GetPackGUID());\n    data.appendPackGUID(aura->GetCasterGUID());\n    data << uint32(aura->GetId());                          // spellId\n    data << uint32(1);                                      // count\n    data << uint32(aura->GetAuraType());                    // auraId\n    switch (aura->GetAuraType())\n    {\n        case SPELL_AURA_PERIODIC_DAMAGE:\n        case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:\n            data << uint32(pInfo->damage);                  // damage\n            data << uint32(pInfo->overDamage);              // overkill?\n            data << uint32(aura->GetSpellInfo()->GetSchoolMask());\n            data << uint32(pInfo->absorb);                  // absorb\n            data << uint32(pInfo->resist);                  // resist\n            data << uint8(pInfo->critical);                 // new 3.1.2 critical tick\n            break;\n        case SPELL_AURA_PERIODIC_HEAL:\n        case SPELL_AURA_OBS_MOD_HEALTH:\n            data << uint32(pInfo->damage);                  // damage\n            data << uint32(pInfo->overDamage);              // overheal\n            data << uint32(pInfo->absorb);                  // absorb\n            data << uint8(pInfo->critical);                 // new 3.1.2 critical tick\n            break;\n        case SPELL_AURA_OBS_MOD_POWER:\n        case SPELL_AURA_PERIODIC_ENERGIZE:\n            data << uint32(aura->GetMiscValue());           // power type\n            data << uint32(pInfo->damage);                  // damage\n            break;\n        case SPELL_AURA_PERIODIC_MANA_LEECH:\n            data << uint32(aura->GetMiscValue());           // power type\n            data << uint32(pInfo->damage);                  // amount\n            data << float(pInfo->multiplier);               // gain multiplier\n            break;\n        default:\n            sLog->outError(LOG_FILTER_UNITS, \"Unit::SendPeriodicAuraLog: unknown aura %u\", uint32(aura->GetAuraType()));\n            return;\n    }\n\n    SendMessageToSet(&data, true);\n}\n\nvoid Unit::SendSpellMiss(Unit* target, uint32 spellID, SpellMissInfo missInfo)\n{\n    WorldPacket data(SMSG_SPELLLOGMISS, (4+8+1+4+8+1));\n    data << uint32(spellID);\n    data << uint64(GetGUID());\n    data << uint8(0);                                       // can be 0 or 1\n    data << uint32(1);                                      // target count\n    // for (i = 0; i < target count; ++i)\n    data << uint64(target->GetGUID());                      // target GUID\n    data << uint8(missInfo);\n    // end loop\n    SendMessageToSet(&data, true);\n}\n\nvoid Unit::SendSpellDamageResist(Unit* target, uint32 spellId)\n{\n    WorldPacket data(SMSG_PROCRESIST, 8+8+4+1);\n    data << uint64(GetGUID());\n    data << uint64(target->GetGUID());\n    data << uint32(spellId);\n    data << uint8(0); // bool - log format: 0-default, 1-debug\n    SendMessageToSet(&data, true);\n}\n\nvoid Unit::SendSpellDamageImmune(Unit* target, uint32 spellId)\n{\n    WorldPacket data(SMSG_SPELLORDAMAGE_IMMUNE, 8+8+4+1);\n    data << uint64(GetGUID());\n    data << uint64(target->GetGUID());\n    data << uint32(spellId);\n    data << uint8(0); // bool - log format: 0-default, 1-debug\n    SendMessageToSet(&data, true);\n}\n\nvoid Unit::SendAttackStateUpdate(CalcDamageInfo* damageInfo)\n{\n    sLog->outDebug(LOG_FILTER_UNITS, \"WORLD: Sending SMSG_ATTACKERSTATEUPDATE\");\n\n    uint32 count = 1;\n    size_t maxsize = 4+5+5+4+4+1+4+4+4+4+4+1+4+4+4+4+4*12;\n    WorldPacket data(SMSG_ATTACKERSTATEUPDATE, maxsize);    // we guess size\n    data << uint32(damageInfo->HitInfo);\n    data.append(damageInfo->attacker->GetPackGUID());\n    data.append(damageInfo->target->GetPackGUID());\n    data << uint32(damageInfo->damage);                     // Full damage\n    int32 overkill = damageInfo->damage - damageInfo->target->GetHealth();\n    data << uint32(overkill < 0 ? 0 : overkill);            // Overkill\n    data << uint8(count);                                   // Sub damage count\n\n    for (uint32 i = 0; i < count; ++i)\n    {\n        data << uint32(damageInfo->damageSchoolMask);       // School of sub damage\n        data << float(damageInfo->damage);                  // sub damage\n        data << uint32(damageInfo->damage);                 // Sub Damage\n    }\n\n    if (damageInfo->HitInfo & (HITINFO_FULL_ABSORB | HITINFO_PARTIAL_ABSORB))\n    {\n        for (uint32 i = 0; i < count; ++i)\n            data << uint32(damageInfo->absorb);             // Absorb\n    }\n\n    if (damageInfo->HitInfo & (HITINFO_FULL_RESIST | HITINFO_PARTIAL_RESIST))\n    {\n        for (uint32 i = 0; i < count; ++i)\n            data << uint32(damageInfo->resist);             // Resist\n    }\n\n    data << uint8(damageInfo->TargetState);\n    data << uint32(0);  // Unknown attackerstate\n    data << uint32(0);  // Melee spellid\n\n    if (damageInfo->HitInfo & HITINFO_BLOCK)\n        data << uint32(damageInfo->blocked_amount);\n\n    if (damageInfo->HitInfo & HITINFO_RAGE_GAIN)\n        data << uint32(0);\n\n    //! Probably used for debugging purposes, as it is not known to appear on retail servers\n    if (damageInfo->HitInfo & HITINFO_UNK1)\n    {\n        data << uint32(0);\n        data << float(0);\n        data << float(0);\n        data << float(0);\n        data << float(0);\n        data << float(0);\n        data << float(0);\n        data << float(0);\n        data << float(0);\n        data << float(0);       // Found in a loop with 1 iteration\n        data << float(0);       // ditto ^\n        data << uint32(0);\n    }\n\n    SendMessageToSet(&data, true);\n}\n\nvoid Unit::SendAttackStateUpdate(uint32 HitInfo, Unit* target, uint8 /*SwingType*/, SpellSchoolMask damageSchoolMask, uint32 Damage, uint32 AbsorbDamage, uint32 Resist, VictimState TargetState, uint32 BlockedAmount)\n{\n    CalcDamageInfo dmgInfo;\n    dmgInfo.HitInfo = HitInfo;\n    dmgInfo.attacker = this;\n    dmgInfo.target = target;\n    dmgInfo.damage = Damage - AbsorbDamage - Resist - BlockedAmount;\n    dmgInfo.damageSchoolMask = damageSchoolMask;\n    dmgInfo.absorb = AbsorbDamage;\n    dmgInfo.resist = Resist;\n    dmgInfo.TargetState = TargetState;\n    dmgInfo.blocked_amount = BlockedAmount;\n    SendAttackStateUpdate(&dmgInfo);\n}\n\nbool Unit::HandleHasteAuraProc(Unit* victim, uint32 damage, AuraEffect* triggeredByAura, SpellInfo const* /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)\n{\n    SpellInfo const* hasteSpell = triggeredByAura->GetSpellInfo();\n\n    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER\n        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;\n\n    uint32 triggered_spell_id = 0;\n    Unit* target = victim;\n    int32 basepoints0 = 0;\n\n    switch (hasteSpell->SpellFamilyName)\n    {\n        case SPELLFAMILY_ROGUE:\n        {\n            switch (hasteSpell->Id)\n            {\n                // Blade Flurry\n                case 13877:\n                case 33735:\n                {\n                    target = SelectNearbyTarget(victim);\n                    if (!target)\n                        return false;\n                    basepoints0 = damage;\n                    triggered_spell_id = 22482;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n\n    // processed charge only counting case\n    if (!triggered_spell_id)\n        return true;\n\n    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);\n\n    if (!triggerEntry)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleHasteAuraProc: Spell %u has non-existing triggered spell %u\", hasteSpell->Id, triggered_spell_id);\n        return false;\n    }\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(triggered_spell_id))\n        return false;\n\n    if (basepoints0)\n        CastCustomSpell(target, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);\n    else\n        CastSpell(target, triggered_spell_id, true, castItem, triggeredByAura);\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->AddSpellCooldown(triggered_spell_id, 0, time(NULL) + cooldown);\n\n    return true;\n}\n\nbool Unit::HandleSpellCritChanceAuraProc(Unit* victim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellInfo const* /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)\n{\n    SpellInfo const* triggeredByAuraSpell = triggeredByAura->GetSpellInfo();\n\n    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER\n        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;\n\n    uint32 triggered_spell_id = 0;\n    Unit* target = victim;\n    int32 basepoints0 = 0;\n\n    switch (triggeredByAuraSpell->SpellFamilyName)\n    {\n        case SPELLFAMILY_MAGE:\n        {\n            switch (triggeredByAuraSpell->Id)\n            {\n                // Focus Magic\n                case 54646:\n                {\n                    Unit* caster = triggeredByAura->GetCaster();\n                    if (!caster)\n                        return false;\n\n                    triggered_spell_id = 54648;\n                    target = caster;\n                    break;\n                }\n            }\n        }\n    }\n\n    // processed charge only counting case\n    if (!triggered_spell_id)\n        return true;\n\n    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);\n\n    if (!triggerEntry)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleHasteAuraProc: Spell %u has non-existing triggered spell %u\", triggeredByAuraSpell->Id, triggered_spell_id);\n        return false;\n    }\n\n    // default case\n    if (!target || (target != this && !target->isAlive()))\n        return false;\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(triggered_spell_id))\n        return false;\n\n    if (basepoints0)\n        CastCustomSpell(target, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);\n    else\n        CastSpell(target, triggered_spell_id, true, castItem, triggeredByAura);\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->AddSpellCooldown(triggered_spell_id, 0, time(NULL) + cooldown);\n\n    return true;\n}\n\n//victim may be NULL\nbool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown)\n{\n    SpellInfo const* dummySpell = triggeredByAura->GetSpellInfo();\n    uint32 effIndex = triggeredByAura->GetEffIndex();\n    int32  triggerAmount = triggeredByAura->GetAmount();\n\n    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER\n        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;\n\n    uint32 triggered_spell_id = 0;\n    uint32 cooldown_spell_id = 0; // for random trigger, will be one of the triggered spell to avoid repeatable triggers\n                                  // otherwise, it's the triggered_spell_id by default\n    Unit* target = victim;\n    int32 basepoints0 = 0;\n    uint64 originalCaster = 0;\n\n    switch (dummySpell->SpellFamilyName)\n    {\n        case SPELLFAMILY_GENERIC:\n        {\n            switch (dummySpell->Id)\n            {\n                // Bloodworms Health Leech\n                case 50453:\n                {\n                    if (Unit* owner = GetOwner())\n                    {\n                        basepoints0 = int32(damage * 1.50f);\n                        target = owner;\n                        triggered_spell_id = 50454;\n                        break;\n                    }\n                    return false;\n                }\n                // Eye for an Eye\n                case 9799:\n                case 25988:\n                {\n                    // return damage % to attacker but < 50% own total health\n                    basepoints0 = int32(std::min(CalculatePctN(damage, triggerAmount), CountPctFromMaxHealth(50)));\n                    triggered_spell_id = 25997;\n                    break;\n                }\n                // Sweeping Strikes\n                case 18765:\n                case 35429:\n                {\n                    target = SelectNearbyTarget(victim);\n                    if (!target)\n                        return false;\n\n                    triggered_spell_id = 26654;\n                    break;\n                }\n                // Unstable Power\n                case 24658:\n                {\n                    if (!procSpell || procSpell->Id == 24659)\n                        return false;\n                    // Need remove one 24659 aura\n                    RemoveAuraFromStack(24659);\n                    return true;\n                }\n                // Restless Strength\n                case 24661:\n                {\n                    // Need remove one 24662 aura\n                    RemoveAuraFromStack(24662);\n                    return true;\n                }\n                // Adaptive Warding (Frostfire Regalia set)\n                case 28764:\n                {\n                    if (!procSpell)\n                        return false;\n\n                    // find Mage Armor\n                    if (!GetAuraEffect(SPELL_AURA_MOD_MANA_REGEN_INTERRUPT, SPELLFAMILY_MAGE, 0x10000000, 0, 0))\n                        return false;\n\n                    switch (GetFirstSchoolInMask(procSpell->GetSchoolMask()))\n                    {\n                        case SPELL_SCHOOL_NORMAL:\n                        case SPELL_SCHOOL_HOLY:\n                            return false;                   // ignored\n                        case SPELL_SCHOOL_FIRE:   triggered_spell_id = 28765; break;\n                        case SPELL_SCHOOL_NATURE: triggered_spell_id = 28768; break;\n                        case SPELL_SCHOOL_FROST:  triggered_spell_id = 28766; break;\n                        case SPELL_SCHOOL_SHADOW: triggered_spell_id = 28769; break;\n                        case SPELL_SCHOOL_ARCANE: triggered_spell_id = 28770; break;\n                        default:\n                            return false;\n                    }\n\n                    target = this;\n                    break;\n                }\n                // Obsidian Armor (Justice Bearer`s Pauldrons shoulder)\n                case 27539:\n                {\n                    if (!procSpell)\n                        return false;\n\n                    switch (GetFirstSchoolInMask(procSpell->GetSchoolMask()))\n                    {\n                        case SPELL_SCHOOL_NORMAL:\n                            return false;                   // ignore\n                        case SPELL_SCHOOL_HOLY:   triggered_spell_id = 27536; break;\n                        case SPELL_SCHOOL_FIRE:   triggered_spell_id = 27533; break;\n                        case SPELL_SCHOOL_NATURE: triggered_spell_id = 27538; break;\n                        case SPELL_SCHOOL_FROST:  triggered_spell_id = 27534; break;\n                        case SPELL_SCHOOL_SHADOW: triggered_spell_id = 27535; break;\n                        case SPELL_SCHOOL_ARCANE: triggered_spell_id = 27540; break;\n                        default:\n                            return false;\n                    }\n\n                    target = this;\n                    break;\n                }\n                // Mana Leech (Passive) (Priest Pet Aura)\n                case 28305:\n                {\n                    // Cast on owner\n                    target = GetOwner();\n                    if (!target)\n                        return false;\n\n                    triggered_spell_id = 34650;\n                    break;\n                }\n                // Mark of Malice\n                case 33493:\n                {\n                    // Cast finish spell at last charge\n                    if (triggeredByAura->GetBase()->GetCharges() > 1)\n                        return false;\n\n                    target = this;\n                    triggered_spell_id = 33494;\n                    break;\n                }\n                // Twisted Reflection (boss spell)\n                case 21063:\n                    triggered_spell_id = 21064;\n                    break;\n                // Vampiric Aura (boss spell)\n                case 38196:\n                {\n                    basepoints0 = 3 * damage;               // 300%\n                    if (basepoints0 < 0)\n                        return false;\n\n                    triggered_spell_id = 31285;\n                    target = this;\n                    break;\n                }\n                // Aura of Madness (Darkmoon Card: Madness trinket)\n                //=====================================================\n                // 39511 Sociopath: +35 strength (Paladin, Rogue, Druid, Warrior)\n                // 40997 Delusional: +70 attack power (Rogue, Hunter, Paladin, Warrior, Druid)\n                // 40998 Kleptomania: +35 agility (Warrior, Rogue, Paladin, Hunter, Druid)\n                // 40999 Megalomania: +41 damage/healing (Druid, Shaman, Priest, Warlock, Mage, Paladin)\n                // 41002 Paranoia: +35 spell/melee/ranged crit strike rating (All classes)\n                // 41005 Manic: +35 haste (spell, melee and ranged) (All classes)\n                // 41009 Narcissism: +35 intellect (Druid, Shaman, Priest, Warlock, Mage, Paladin, Hunter)\n                // 41011 Martyr Complex: +35 stamina (All classes)\n                // 41406 Dementia: Every 5 seconds either gives you +5% damage/healing. (Druid, Shaman, Priest, Warlock, Mage, Paladin)\n                // 41409 Dementia: Every 5 seconds either gives you -5% damage/healing. (Druid, Shaman, Priest, Warlock, Mage, Paladin)\n                case 39446:\n                {\n                    if (GetTypeId() != TYPEID_PLAYER || !isAlive())\n                        return false;\n\n                    // Select class defined buff\n                    switch (getClass())\n                    {\n                        case CLASS_PALADIN:                 // 39511, 40997, 40998, 40999, 41002, 41005, 41009, 41011, 41409\n                        case CLASS_DRUID:                   // 39511, 40997, 40998, 40999, 41002, 41005, 41009, 41011, 41409\n                            triggered_spell_id = RAND(39511, 40997, 40998, 40999, 41002, 41005, 41009, 41011, 41409);\n                            cooldown_spell_id = 39511;\n                            break;\n                        case CLASS_ROGUE:                   // 39511, 40997, 40998, 41002, 41005, 41011\n                        case CLASS_WARRIOR:                 // 39511, 40997, 40998, 41002, 41005, 41011\n                        case CLASS_DEATH_KNIGHT:\n                            triggered_spell_id = RAND(39511, 40997, 40998, 41002, 41005, 41011);\n                            cooldown_spell_id = 39511;\n                            break;\n                        case CLASS_PRIEST:                  // 40999, 41002, 41005, 41009, 41011, 41406, 41409\n                        case CLASS_SHAMAN:                  // 40999, 41002, 41005, 41009, 41011, 41406, 41409\n                        case CLASS_MAGE:                    // 40999, 41002, 41005, 41009, 41011, 41406, 41409\n                        case CLASS_WARLOCK:                 // 40999, 41002, 41005, 41009, 41011, 41406, 41409\n                            triggered_spell_id = RAND(40999, 41002, 41005, 41009, 41011, 41406, 41409);\n                            cooldown_spell_id = 40999;\n                            break;\n                        case CLASS_HUNTER:                  // 40997, 40999, 41002, 41005, 41009, 41011, 41406, 41409\n                            triggered_spell_id = RAND(40997, 40999, 41002, 41005, 41009, 41011, 41406, 41409);\n                            cooldown_spell_id = 40997;\n                            break;\n                        default:\n                            return false;\n                    }\n\n                    target = this;\n                    if (roll_chance_i(10))\n                        ToPlayer()->Say(\"This is Madness!\", LANG_UNIVERSAL); // TODO: It should be moved to database, shouldn't it?\n                    break;\n                }\n                // Sunwell Exalted Caster Neck (??? neck)\n                // cast ??? Light's Wrath if Exalted by Aldor\n                // cast ??? Arcane Bolt if Exalted by Scryers\n                case 46569:\n                    return false;                           // old unused version\n                // Sunwell Exalted Caster Neck (Shattered Sun Pendant of Acumen neck)\n                // cast 45479 Light's Wrath if Exalted by Aldor\n                // cast 45429 Arcane Bolt if Exalted by Scryers\n                case 45481:\n                {\n                    if (GetTypeId() != TYPEID_PLAYER)\n                        return false;\n\n                    // Get Aldor reputation rank\n                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)\n                    {\n                        target = this;\n                        triggered_spell_id = 45479;\n                        break;\n                    }\n                    // Get Scryers reputation rank\n                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)\n                    {\n                        // triggered at positive/self casts also, current attack target used then\n                        if (target && IsFriendlyTo(target))\n                        {\n                            target = getVictim();\n                            if (!target)\n                            {\n                                uint64 selected_guid = ToPlayer()->GetSelection();\n                                target = ObjectAccessor::GetUnit(*this, selected_guid);\n                                if (!target)\n                                    return false;\n                            }\n                            if (IsFriendlyTo(target))\n                                return false;\n                        }\n\n                        triggered_spell_id = 45429;\n                        break;\n                    }\n                    return false;\n                }\n                // Sunwell Exalted Melee Neck (Shattered Sun Pendant of Might neck)\n                // cast 45480 Light's Strength if Exalted by Aldor\n                // cast 45428 Arcane Strike if Exalted by Scryers\n                case 45482:\n                {\n                    if (GetTypeId() != TYPEID_PLAYER)\n                        return false;\n\n                    // Get Aldor reputation rank\n                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)\n                    {\n                        target = this;\n                        triggered_spell_id = 45480;\n                        break;\n                    }\n                    // Get Scryers reputation rank\n                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)\n                    {\n                        triggered_spell_id = 45428;\n                        break;\n                    }\n                    return false;\n                }\n                // Sunwell Exalted Tank Neck (Shattered Sun Pendant of Resolve neck)\n                // cast 45431 Arcane Insight if Exalted by Aldor\n                // cast 45432 Light's Ward if Exalted by Scryers\n                case 45483:\n                {\n                    if (GetTypeId() != TYPEID_PLAYER)\n                        return false;\n\n                    // Get Aldor reputation rank\n                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)\n                    {\n                        target = this;\n                        triggered_spell_id = 45432;\n                        break;\n                    }\n                    // Get Scryers reputation rank\n                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)\n                    {\n                        target = this;\n                        triggered_spell_id = 45431;\n                        break;\n                    }\n                    return false;\n                }\n                // Sunwell Exalted Healer Neck (Shattered Sun Pendant of Restoration neck)\n                // cast 45478 Light's Salvation if Exalted by Aldor\n                // cast 45430 Arcane Surge if Exalted by Scryers\n                case 45484:\n                {\n                    if (GetTypeId() != TYPEID_PLAYER)\n                        return false;\n\n                    // Get Aldor reputation rank\n                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)\n                    {\n                        target = this;\n                        triggered_spell_id = 45478;\n                        break;\n                    }\n                    // Get Scryers reputation rank\n                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)\n                    {\n                        triggered_spell_id = 45430;\n                        break;\n                    }\n                    return false;\n                }\n                // Living Seed\n                case 48504:\n                {\n                    triggered_spell_id = 48503;\n                    basepoints0 = triggerAmount;\n                    target = this;\n                    break;\n                }\n                // Kill command\n                case 58914:\n                {\n                    // Remove aura stack from pet\n                    RemoveAuraFromStack(58914);\n                    Unit* owner = GetOwner();\n                    if (!owner)\n                        return true;\n                    // reduce the owner's aura stack\n                    owner->RemoveAuraFromStack(34027);\n                    return true;\n                }\n                // Vampiric Touch (generic, used by some boss)\n                case 52723:\n                case 60501:\n                {\n                    triggered_spell_id = 52724;\n                    basepoints0 = damage / 2;\n                    target = this;\n                    break;\n                }\n                // Shadowfiend Death (Gain mana if pet dies with Glyph of Shadowfiend)\n                case 57989:\n                {\n                    Unit* owner = GetOwner();\n                    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)\n                        return false;\n                    // Glyph of Shadowfiend (need cast as self cast for owner, no hidden cooldown)\n                    owner->CastSpell(owner, 58227, true, castItem, triggeredByAura);\n                    return true;\n                }\n                // Divine purpose\n                case 31871:\n                case 31872:\n                {\n                    // Roll chane\n                    if (!victim || !victim->isAlive() || !roll_chance_i(triggerAmount))\n                        return false;\n\n                    // Remove any stun effect on target\n                    victim->RemoveAurasWithMechanic(1<<MECHANIC_STUN, AURA_REMOVE_BY_ENEMY_SPELL);\n                    return true;\n                }\n                // Glyph of Scourge Strike\n                case 58642:\n                {\n                    triggered_spell_id = 69961; // Glyph of Scourge Strike\n                    break;\n                }\n                // Glyph of Life Tap\n                case 63320:\n                {\n                    triggered_spell_id = 63321; // Life Tap\n                    break;\n                }\n                // Purified Shard of the Scale - Onyxia 10 Caster Trinket\n                case 69755:\n                {\n                    triggered_spell_id = (procFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS) ? 69733 : 69729;\n                    break;\n                }\n                // Shiny Shard of the Scale - Onyxia 25 Caster Trinket\n                case 69739:\n                {\n                    triggered_spell_id = (procFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS) ? 69734 : 69730;\n                    break;\n                }\n                case 71519: // Deathbringer's Will Normal\n                {\n                    if (GetTypeId() != TYPEID_PLAYER)\n                        return false;\n\n                    std::vector<uint32> RandomSpells;\n                    switch (getClass())\n                    {\n                        case CLASS_WARRIOR:\n                        case CLASS_PALADIN:\n                        case CLASS_DEATH_KNIGHT:\n                            RandomSpells.push_back(71484);\n                            RandomSpells.push_back(71491);\n                            RandomSpells.push_back(71492);\n                            break;\n                        case CLASS_SHAMAN:\n                        case CLASS_ROGUE:\n                            RandomSpells.push_back(71486);\n                            RandomSpells.push_back(71485);\n                            RandomSpells.push_back(71492);\n                            break;\n                        case CLASS_DRUID:\n                            RandomSpells.push_back(71484);\n                            RandomSpells.push_back(71485);\n                            RandomSpells.push_back(71492);\n                            break;\n                        case CLASS_HUNTER:\n                            RandomSpells.push_back(71486);\n                            RandomSpells.push_back(71491);\n                            RandomSpells.push_back(71485);\n                            break;\n                        default:\n                            return false;\n                    }\n                    if (RandomSpells.empty()) // shouldn't happen\n                        return false;\n\n                    uint8 rand_spell = irand(0, (RandomSpells.size() - 1));\n                    CastSpell(target, RandomSpells[rand_spell], true, castItem, triggeredByAura, originalCaster);\n                    for (std::vector<uint32>::iterator itr = RandomSpells.begin(); itr != RandomSpells.end(); ++itr)\n                    {\n                        if (!ToPlayer()->HasSpellCooldown(*itr))\n                            ToPlayer()->AddSpellCooldown(*itr, 0, time(NULL) + cooldown);\n                    }\n                    break;\n                }\n                case 71562: // Deathbringer's Will Heroic\n                {\n                    if (GetTypeId() != TYPEID_PLAYER)\n                        return false;\n\n                    std::vector<uint32> RandomSpells;\n                    switch (getClass())\n                    {\n                        case CLASS_WARRIOR:\n                        case CLASS_PALADIN:\n                        case CLASS_DEATH_KNIGHT:\n                            RandomSpells.push_back(71561);\n                            RandomSpells.push_back(71559);\n                            RandomSpells.push_back(71560);\n                            break;\n                        case CLASS_SHAMAN:\n                        case CLASS_ROGUE:\n                            RandomSpells.push_back(71558);\n                            RandomSpells.push_back(71556);\n                            RandomSpells.push_back(71560);\n                            break;\n                        case CLASS_DRUID:\n                            RandomSpells.push_back(71561);\n                            RandomSpells.push_back(71556);\n                            RandomSpells.push_back(71560);\n                            break;\n                        case CLASS_HUNTER:\n                            RandomSpells.push_back(71558);\n                            RandomSpells.push_back(71559);\n                            RandomSpells.push_back(71556);\n                            break;\n                        default:\n                            return false;\n                    }\n                    if (RandomSpells.empty()) // shouldn't happen\n                        return false;\n\n                    uint8 rand_spell = irand(0, (RandomSpells.size() - 1));\n                    CastSpell(target, RandomSpells[rand_spell], true, castItem, triggeredByAura, originalCaster);\n                    for (std::vector<uint32>::iterator itr = RandomSpells.begin(); itr != RandomSpells.end(); ++itr)\n                    {\n                        if (!ToPlayer()->HasSpellCooldown(*itr))\n                            ToPlayer()->AddSpellCooldown(*itr, 0, time(NULL) + cooldown);\n                    }\n                    break;\n                }\n                case 71875: // Item - Black Bruise: Necrotic Touch Proc\n                case 71877:\n                {\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                    triggered_spell_id = 71879;\n                    break;\n                }\n                // Item - Shadowmourne Legendary\n                case 71903:\n                {\n                    if (!victim || !victim->isAlive() || HasAura(73422))  // cant collect shards while under effect of Chaos Bane buff\n                        return false;\n\n                    CastSpell(this, 71905, true, NULL, triggeredByAura);\n\n                    // this can't be handled in AuraScript because we need to know victim\n                    Aura const* dummy = GetAura(71905);\n                    if (!dummy || dummy->GetStackAmount() < 10)\n                        return false;\n\n                    RemoveAurasDueToSpell(71905);\n                    triggered_spell_id = 71904;\n                    target = victim;\n                    break;\n                }\n                // Shadow's Fate (Shadowmourne questline)\n                case 71169:\n                {\n                    target = triggeredByAura->GetCaster();\n                    if (!target)\n                        return false;\n                    Player* player = target->ToPlayer();\n                    if (!player)\n                        return false;\n                    // not checking Infusion auras because its in targetAuraSpell of credit spell\n                    if (player->GetQuestStatus(24749) == QUEST_STATUS_INCOMPLETE)       // Unholy Infusion\n                    {\n                        if (GetEntry() != 36678)                                        // Professor Putricide\n                            return false;\n                        CastSpell(target, 71518, true);                                 // Quest Credit\n                        return true;\n                    }\n                    else if (player->GetQuestStatus(24756) == QUEST_STATUS_INCOMPLETE)  // Blood Infusion\n                    {\n                        if (GetEntry() != 37955)                                        // Blood-Queen Lana'thel\n                            return false;\n                        CastSpell(target, 72934, true);                                 // Quest Credit\n                        return true;\n                    }\n                    else if (player->GetQuestStatus(24757) == QUEST_STATUS_INCOMPLETE)  // Frost Infusion\n                    {\n                        if (GetEntry() != 36853)                                        // Sindragosa\n                            return false;\n                        CastSpell(target, 72289, true);                                 // Quest Credit\n                        return true;\n                    }\n                    else if (player->GetQuestStatus(24547) == QUEST_STATUS_INCOMPLETE)  // A Feast of Souls\n                        triggered_spell_id = 71203;\n                    break;\n                }\n                // Essence of the Blood Queen\n                case 70871:\n                {\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                    CastCustomSpell(70872, SPELLVALUE_BASE_POINT0, basepoints0, this);\n                    return true;\n                }\n                case 65032: // Boom aura (321 Boombot)\n                {\n                    if (victim->GetEntry() != 33343)   // Scrapbot\n                        return false;\n\n                    InstanceScript* instance = GetInstanceScript();\n                    if (!instance)\n                        return false;\n\n                    instance->DoCastSpellOnPlayers(65037);  // Achievement criteria marker\n                    break;\n                }\n                // Dark Hunger (The Lich King encounter)\n                case 69383:\n                {\n                    basepoints0 = CalculatePctN(int32(damage), 50);\n                    triggered_spell_id = 69384;\n                    break;\n                }\n            }\n            break;\n        }\n        case SPELLFAMILY_MAGE:\n        {\n            // Magic Absorption\n            if (dummySpell->SpellIconID == 459)             // only this spell has SpellIconID == 459 and dummy aura\n            {\n                if (getPowerType() != POWER_MANA)\n                    return false;\n\n                // mana reward\n                basepoints0 = CalculatePctN(int32(GetMaxPower(POWER_MANA)), triggerAmount);\n                target = this;\n                triggered_spell_id = 29442;\n                break;\n            }\n            // Master of Elements\n            if (dummySpell->SpellIconID == 1920)\n            {\n                if (!procSpell)\n                    return false;\n\n                // mana cost save\n                int32 cost = int32(procSpell->ManaCost + CalculatePctU(GetCreateMana(), procSpell->ManaCostPercentage));\n                basepoints0 = CalculatePctN(cost, triggerAmount);\n                if (basepoints0 <= 0)\n                    return false;\n\n                target = this;\n                triggered_spell_id = 29077;\n                break;\n            }\n            // Arcane Potency\n            if (dummySpell->SpellIconID == 2120)\n            {\n                if (!procSpell)\n                    return false;\n\n                target = this;\n                switch (dummySpell->Id)\n                {\n                    case 31571: triggered_spell_id = 57529; break;\n                    case 31572: triggered_spell_id = 57531; break;\n                    default:\n                        sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleDummyAuraProc: non handled spell id: %u\", dummySpell->Id);\n                        return false;\n                }\n                break;\n            }\n\n            // Hot Streak\n            if (dummySpell->SpellIconID == 2999)\n            {\n                if (effIndex != 0)\n                    return false;\n                AuraEffect* counter = triggeredByAura->GetBase()->GetEffect(EFFECT_1);\n                if (!counter)\n                    return true;\n\n                // Count spell criticals in a row in second aura\n                if (procEx & PROC_EX_CRITICAL_HIT)\n                {\n                    counter->SetAmount(counter->GetAmount() * 2);\n                    if (counter->GetAmount() < 100) // not enough\n                        return true;\n                    // Crititcal counted -> roll chance\n                    if (roll_chance_i(triggerAmount))\n                        CastSpell(this, 48108, true, castItem, triggeredByAura);\n                }\n                counter->SetAmount(25);\n                return true;\n            }\n            // Burnout\n            if (dummySpell->SpellIconID == 2998)\n            {\n                if (!procSpell)\n                    return false;\n\n                int32 cost = int32(procSpell->ManaCost + CalculatePctU(GetCreateMana(), procSpell->ManaCostPercentage));\n                basepoints0 = CalculatePctN(cost, triggerAmount);\n                if (basepoints0 <= 0)\n                    return false;\n                triggered_spell_id = 44450;\n                target = this;\n                break;\n            }\n            // Incanter's Regalia set (add trigger chance to Mana Shield)\n            if (dummySpell->SpellFamilyFlags[0] & 0x8000)\n            {\n                if (GetTypeId() != TYPEID_PLAYER)\n                    return false;\n\n                target = this;\n                triggered_spell_id = 37436;\n                break;\n            }\n            switch (dummySpell->Id)\n            {\n                // Glyph of Polymorph\n                case 56375:\n                {\n                    if (!target)\n                        return false;\n                    target->RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE, 0, target->GetAura(32409)); // SW:D shall not be removed.\n                    target->RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE_PERCENT);\n                    target->RemoveAurasByType(SPELL_AURA_PERIODIC_LEECH);\n                    return true;\n                }\n                // Glyph of Icy Veins\n                case 56374:\n                {\n                    RemoveAurasByType(SPELL_AURA_HASTE_SPELLS, 0, 0, true, false);\n                    RemoveAurasByType(SPELL_AURA_MOD_DECREASE_SPEED);\n                    return true;\n                }\n                // Ignite\n                case 11119:\n                case 11120:\n                case 12846:\n                case 12847:\n                case 12848:\n                {\n                    switch (dummySpell->Id)\n                    {\n                        case 11119: basepoints0 = int32(0.04f * damage); break;\n                        case 11120: basepoints0 = int32(0.08f * damage); break;\n                        case 12846: basepoints0 = int32(0.12f * damage); break;\n                        case 12847: basepoints0 = int32(0.16f * damage); break;\n                        case 12848: basepoints0 = int32(0.20f * damage); break;\n                        default:\n                            sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleDummyAuraProc: non handled spell id: %u (IG)\", dummySpell->Id);\n                            return false;\n                    }\n\n                    triggered_spell_id = 12654;\n                    basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_DAMAGE);\n                    break;\n                }\n                // Glyph of Ice Block\n                case 56372:\n                {\n                    Player* player = ToPlayer();\n                    if (!player)\n                        return false;\n\n                    SpellCooldowns const cooldowns = player->GetSpellCooldowns();\n                    // remove cooldowns on all ranks of Frost Nova\n                    for (SpellCooldowns::const_iterator itr = cooldowns.begin(); itr != cooldowns.end(); ++itr)\n                    {\n                        SpellInfo const* cdSpell = sSpellMgr->GetSpellInfo(itr->first);\n                        // Frost Nova\n                        if (cdSpell && cdSpell->SpellFamilyName == SPELLFAMILY_MAGE\n                            && cdSpell->SpellFamilyFlags[0] & 0x00000040)\n                            player->RemoveSpellCooldown(cdSpell->Id, true);\n                    }\n                    break;\n                }\n                // Blessing of Ancient Kings (Val'anyr, Hammer of Ancient Kings)\n                case 64411:\n                {\n                    if (!victim)\n                        return false;\n                    basepoints0 = int32(CalculatePctN(damage, 15));\n                    if (AuraEffect* aurEff = victim->GetAuraEffect(64413, 0, GetGUID()))\n                    {\n                        // The shield can grow to a maximum size of 20, 000 damage absorbtion\n                        aurEff->SetAmount(std::min<int32>(aurEff->GetAmount() + basepoints0, 20000));\n\n                        // Refresh and return to prevent replacing the aura\n                        aurEff->GetBase()->RefreshDuration();\n                        return true;\n                    }\n                    target = victim;\n                    triggered_spell_id = 64413;\n                    break;\n                }\n                case 47020: // Enter vehicle XT-002 (Scrapbot)\n                {\n                    if (GetTypeId() != TYPEID_UNIT)\n                        return false;\n\n                    Unit* vehicleBase = GetVehicleBase();\n                    if (!vehicleBase)\n                        return false;\n\n                    // Todo: Check if this amount is blizzlike\n                    vehicleBase->ModifyHealth(int32(vehicleBase->CountPctFromMaxHealth(1)));\n                    break;\n                }\n            }\n            break;\n        }\n        case SPELLFAMILY_WARRIOR:\n        {\n            switch (dummySpell->Id)\n            {\n                // Sweeping Strikes\n                case 12328:\n                {\n                    target = SelectNearbyTarget(victim);\n                    if (!target)\n                        return false;\n\n                    triggered_spell_id = 26654;\n                    break;\n                }\n                // Victorious\n                case 32216:\n                {\n                    RemoveAura(dummySpell->Id);\n                    return false;\n                }\n                // Improved Spell Reflection\n                case 59088:\n                case 59089:\n                {\n                    triggered_spell_id = 59725;\n                    target = this;\n                    break;\n                }\n            }\n\n            // Retaliation\n            if (dummySpell->SpellFamilyFlags[1] & 0x8)\n            {\n                // check attack comes not from behind\n                if (!HasInArc(M_PI, victim))\n                    return false;\n\n                triggered_spell_id = 22858;\n                break;\n            }\n            // Second Wind\n            if (dummySpell->SpellIconID == 1697)\n            {\n                // only for spells and hit/crit (trigger start always) and not start from self casted spells (5530 Mace Stun Effect for example)\n                if (procSpell == 0 || !(procEx & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) || this == victim)\n                    return false;\n                // Need stun or root mechanic\n                if (!(procSpell->GetAllEffectsMechanicMask() & ((1<<MECHANIC_ROOT)|(1<<MECHANIC_STUN))))\n                    return false;\n\n                switch (dummySpell->Id)\n                {\n                    case 29838: triggered_spell_id=29842; break;\n                    case 29834: triggered_spell_id=29841; break;\n                    case 42770: triggered_spell_id=42771; break;\n                    default:\n                        sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleDummyAuraProc: non handled spell id: %u (SW)\", dummySpell->Id);\n                    return false;\n                }\n\n                target = this;\n                break;\n            }\n            // Damage Shield\n            if (dummySpell->SpellIconID == 3214)\n            {\n                triggered_spell_id = 59653;\n                // % of amount blocked\n                basepoints0 = CalculatePctN(int32(GetShieldBlockValue()), triggerAmount);\n                break;\n            }\n            // Glyph of Blocking\n            if (dummySpell->Id == 58375)\n            {\n                triggered_spell_id = 58374;\n                break;\n            }\n            // Glyph of Sunder Armor\n            if (dummySpell->Id == 58387)\n            {\n                if (!victim || !victim->isAlive() || !procSpell)\n                    return false;\n\n                target = SelectNearbyTarget(victim);\n                if (!target)\n                    return false;\n\n                triggered_spell_id = 58567;\n                break;\n            }\n            break;\n        }\n        case SPELLFAMILY_WARLOCK:\n        {\n            // Seed of Corruption\n            if (dummySpell->SpellFamilyFlags[1] & 0x00000010)\n            {\n                if (procSpell && procSpell->SpellFamilyFlags[1] & 0x8000)\n                    return false;\n                // if damage is more than need or target die from damage deal finish spell\n                if (triggeredByAura->GetAmount() <= int32(damage) || GetHealth() <= damage)\n                {\n                    // remember guid before aura delete\n                    uint64 casterGuid = triggeredByAura->GetCasterGUID();\n\n                    // Remove aura (before cast for prevent infinite loop handlers)\n                    RemoveAurasDueToSpell(triggeredByAura->GetId());\n\n                    uint32 spell = sSpellMgr->GetSpellWithRank(27285, dummySpell->GetRank());\n\n                    // Cast finish spell (triggeredByAura already not exist!)\n                    if (Unit* caster = GetUnit(*this, casterGuid))\n                        caster->CastSpell(this, spell, true, castItem);\n                    return true;                            // no hidden cooldown\n                }\n\n                // Damage counting\n                triggeredByAura->SetAmount(triggeredByAura->GetAmount() - damage);\n                return true;\n            }\n            // Seed of Corruption (Mobs cast) - no die req\n            if (dummySpell->SpellFamilyFlags.IsEqual(0, 0, 0) && dummySpell->SpellIconID == 1932)\n            {\n                // if damage is more than need deal finish spell\n                if (triggeredByAura->GetAmount() <= int32(damage))\n                {\n                    // remember guid before aura delete\n                    uint64 casterGuid = triggeredByAura->GetCasterGUID();\n\n                    // Remove aura (before cast for prevent infinite loop handlers)\n                    RemoveAurasDueToSpell(triggeredByAura->GetId());\n\n                    // Cast finish spell (triggeredByAura already not exist!)\n                    if (Unit* caster = GetUnit(*this, casterGuid))\n                        caster->CastSpell(this, 32865, true, castItem);\n                    return true;                            // no hidden cooldown\n                }\n                // Damage counting\n                triggeredByAura->SetAmount(triggeredByAura->GetAmount() - damage);\n                return true;\n            }\n            // Fel Synergy\n            if (dummySpell->SpellIconID == 3222)\n            {\n                target = GetGuardianPet();\n                if (!target)\n                    return false;\n                basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                triggered_spell_id = 54181;\n                break;\n            }\n            switch (dummySpell->Id)\n            {\n                // Siphon Life\n                case 63108:\n                {\n                    if (!damage)\n                        break;\n                    // Glyph of Siphon Life\n                    if (HasAura(56216))\n                        triggerAmount += triggerAmount / 4;\n                    triggered_spell_id = 63106;\n                    target = this;\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                    break;\n                }\n                // Glyph of Shadowflame\n                case 63310:\n                {\n                    triggered_spell_id = 63311;\n                    break;\n                }\n                // Nightfall\n                case 18094:\n                case 18095:\n                // Glyph of corruption\n                case 56218:\n                {\n                    target = this;\n                    triggered_spell_id = 17941;\n                    break;\n                }\n                // Soul Leech\n                case 30293:\n                case 30295:\n                case 30296:\n                {\n                    // Improved Soul Leech\n                    AuraEffectList const& SoulLeechAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);\n                    for (Unit::AuraEffectList::const_iterator i = SoulLeechAuras.begin(); i != SoulLeechAuras.end(); ++i)\n                    {\n                        if ((*i)->GetId() == 54117 || (*i)->GetId() == 54118)\n                        {\n                            if ((*i)->GetEffIndex() != 0)\n                                continue;\n                            basepoints0 = int32((*i)->GetAmount());\n                            target = GetGuardianPet();\n                            if (target)\n                            {\n                                // regen mana for pet\n                                CastCustomSpell(target, 54607, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);\n                            }\n                            // regen mana for caster\n                            CastCustomSpell(this, 59117, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);\n                            // Get second aura of spell for replenishment effect on party\n                            if (AuraEffect const* aurEff = (*i)->GetBase()->GetEffect(EFFECT_1))\n                            {\n                                // Replenishment - roll chance\n                                if (roll_chance_i(aurEff->GetAmount()))\n                                {\n                                    CastSpell(this, 57669, true, castItem, triggeredByAura);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    // health\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                    target = this;\n                    triggered_spell_id = 30294;\n                    break;\n                }\n                // Shadowflame (Voidheart Raiment set bonus)\n                case 37377:\n                {\n                    triggered_spell_id = 37379;\n                    break;\n                }\n                // Pet Healing (Corruptor Raiment or Rift Stalker Armor)\n                case 37381:\n                {\n                    target = GetGuardianPet();\n                    if (!target)\n                        return false;\n\n                    // heal amount\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                    triggered_spell_id = 37382;\n                    break;\n                }\n                // Shadowflame Hellfire (Voidheart Raiment set bonus)\n                case 39437:\n                {\n                    triggered_spell_id = 37378;\n                    break;\n                }\n                // Glyph of Succubus\n                case 56250:\n                {\n                    if (!target)\n                        return false;\n                    target->RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE, 0, target->GetAura(32409)); // SW:D shall not be removed.\n                    target->RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE_PERCENT);\n                    target->RemoveAurasByType(SPELL_AURA_PERIODIC_LEECH);\n                    return true;\n                }\n            }\n            break;\n        }\n        case SPELLFAMILY_PRIEST:\n        {\n            // Vampiric Touch\n            if (dummySpell->SpellFamilyFlags[1] & 0x00000400)\n            {\n                if (!victim || !victim->isAlive())\n                    return false;\n\n                if (effIndex != 0)\n                    return false;\n\n                // victim is caster of aura\n                if (triggeredByAura->GetCasterGUID() != victim->GetGUID())\n                    return false;\n\n                // Energize 0.25% of max. mana\n                victim->CastSpell(victim, 57669, true, castItem, triggeredByAura);\n                return true;                                // no hidden cooldown\n            }\n            // Divine Aegis\n            if (dummySpell->SpellIconID == 2820)\n            {\n                if (!target)\n                    return false;\n\n                // Multiple effects stack, so let's try to find this aura.\n                int32 bonus = 0;\n                if (AuraEffect const* aurEff = target->GetAuraEffect(47753, 0))\n                    bonus = aurEff->GetAmount();\n\n                basepoints0 = CalculatePctN(int32(damage), triggerAmount) + bonus;\n                if (basepoints0 > target->getLevel() * 125)\n                    basepoints0 = target->getLevel() * 125;\n\n                triggered_spell_id = 47753;\n                break;\n            }\n            // Body and Soul\n            if (dummySpell->SpellIconID == 2218)\n            {\n                // Proc only from Abolish desease on self cast\n                if (procSpell->Id != 552 || victim != this || !roll_chance_i(triggerAmount))\n                    return false;\n                triggered_spell_id = 64136;\n                target = this;\n                break;\n            }\n            switch (dummySpell->Id)\n            {\n                // Vampiric Embrace\n                case 15286:\n                {\n                    if (!victim || !victim->isAlive() || procSpell->SpellFamilyFlags[1] & 0x80000)\n                        return false;\n\n                    // heal amount\n                    int32 total = CalculatePctN(int32(damage), triggerAmount);\n                    int32 team = total / 5;\n                    int32 self = total - team;\n                    CastCustomSpell(this, 15290, &team, &self, NULL, true, castItem, triggeredByAura);\n                    return true;                                // no hidden cooldown\n                }\n                // Priest Tier 6 Trinket (Ashtongue Talisman of Acumen)\n                case 40438:\n                {\n                    // Shadow Word: Pain\n                    if (procSpell->SpellFamilyFlags[0] & 0x8000)\n                        triggered_spell_id = 40441;\n                    // Renew\n                    else if (procSpell->SpellFamilyFlags[0] & 0x40)\n                        triggered_spell_id = 40440;\n                    else\n                        return false;\n\n                    target = this;\n                    break;\n                }\n                // Glyph of Prayer of Healing\n                case 55680:\n                {\n                    triggered_spell_id = 56161;\n\n                    SpellInfo const* GoPoH = sSpellMgr->GetSpellInfo(triggered_spell_id);\n                    if (!GoPoH)\n                        return false;\n\n                    int EffIndex = 0;\n                    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; i++)\n                    {\n                        if (GoPoH->Effects[i].Effect == SPELL_EFFECT_APPLY_AURA)\n                        {\n                            EffIndex = i;\n                            break;\n                        }\n                    }\n                    int32 tickcount = GoPoH->GetMaxDuration() / GoPoH->Effects[EffIndex].Amplitude;\n                    if (!tickcount)\n                        return false;\n\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount) / tickcount;\n                    break;\n                }\n                // Improved Shadowform\n                case 47570:\n                case 47569:\n                {\n                    if (!roll_chance_i(triggerAmount))\n                        return false;\n\n                    RemoveMovementImpairingAuras();\n                    break;\n                }\n                // Glyph of Dispel Magic\n                case 55677:\n                {\n                    // Dispel Magic shares spellfamilyflag with abolish disease\n                    if (procSpell->SpellIconID != 74)\n                        return false;\n                    if (!target || !target->IsFriendlyTo(this))\n                        return false;\n\n                    basepoints0 = int32(target->CountPctFromMaxHealth(triggerAmount));\n                    triggered_spell_id = 56131;\n                    break;\n                }\n                // Oracle Healing Bonus (\"Garments of the Oracle\" set)\n                case 26169:\n                {\n                    // heal amount\n                    basepoints0 = int32(CalculatePctN(damage, 10));\n                    target = this;\n                    triggered_spell_id = 26170;\n                    break;\n                }\n                // Frozen Shadoweave (Shadow's Embrace set) warning! its not only priest set\n                case 39372:\n                {\n                    if (!procSpell || (procSpell->GetSchoolMask() & (SPELL_SCHOOL_MASK_FROST | SPELL_SCHOOL_MASK_SHADOW)) == 0)\n                        return false;\n\n                    // heal amount\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                    target = this;\n                    triggered_spell_id = 39373;\n                    break;\n                }\n                // Greater Heal (Vestments of Faith (Priest Tier 3) - 4 pieces bonus)\n                case 28809:\n                {\n                    triggered_spell_id = 28810;\n                    break;\n                }\n                // Priest T10 Healer 2P Bonus\n                case 70770:\n                    // Flash Heal\n                    if (procSpell->SpellFamilyFlags[0] & 0x800)\n                    {\n                        triggered_spell_id = 70772;\n                        SpellInfo const* blessHealing = sSpellMgr->GetSpellInfo(triggered_spell_id);\n                        if (!blessHealing)\n                            return false;\n                        basepoints0 = int32(CalculatePctN(damage, triggerAmount) / (blessHealing->GetMaxDuration() / blessHealing->Effects[0].Amplitude));\n                    }\n                    break;\n            }\n            break;\n        }\n        case SPELLFAMILY_DRUID:\n        {\n            switch (dummySpell->Id)\n            {\n                // Glyph of Innervate\n                case 54832:\n                {\n                    if (procSpell->SpellIconID != 62)\n                        return false;\n\n                    int32 mana_perc = triggeredByAura->GetSpellInfo()->Effects[triggeredByAura->GetEffIndex()].CalcValue();\n                    basepoints0 = int32(CalculatePctN(GetCreatePowers(POWER_MANA), mana_perc) / 10);\n                    triggered_spell_id = 54833;\n                    target = this;\n                    break;\n                }\n                // Glyph of Starfire\n                case 54845:\n                {\n                    triggered_spell_id = 54846;\n                    break;\n                }\n                // Glyph of Shred\n                case 54815:\n                {\n                    if (!target)\n                        return false;\n\n                    // try to find spell Rip on the target\n                    if (AuraEffect const* AurEff = target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x00800000, 0x0, 0x0, GetGUID()))\n                    {\n                        // Rip's max duration, note: spells which modifies Rip's duration also counted like Glyph of Rip\n                        uint32 CountMin = AurEff->GetBase()->GetMaxDuration();\n\n                        // just Rip's max duration without other spells\n                        uint32 CountMax = AurEff->GetSpellInfo()->GetMaxDuration();\n\n                        // add possible auras' and Glyph of Shred's max duration\n                        CountMax += 3 * triggerAmount * IN_MILLISECONDS;      // Glyph of Shred               -> +6 seconds\n                        CountMax += HasAura(54818) ? 4 * IN_MILLISECONDS : 0; // Glyph of Rip                 -> +4 seconds\n                        CountMax += HasAura(60141) ? 4 * IN_MILLISECONDS : 0; // Rip Duration/Lacerate Damage -> +4 seconds\n\n                        // if min < max -> that means caster didn't cast 3 shred yet\n                        // so set Rip's duration and max duration\n                        if (CountMin < CountMax)\n                        {\n                            AurEff->GetBase()->SetDuration(AurEff->GetBase()->GetDuration() + triggerAmount * IN_MILLISECONDS);\n                            AurEff->GetBase()->SetMaxDuration(CountMin + triggerAmount * IN_MILLISECONDS);\n                            return true;\n                        }\n                    }\n                    // if not found Rip\n                    return false;\n                }\n                // Glyph of Rake\n                case 54821:\n                {\n                    if (procSpell->SpellVisual[0] == 750 && procSpell->Effects[1].ApplyAuraName == 3)\n                    {\n                        if (target && target->GetTypeId() == TYPEID_UNIT)\n                        {\n                            triggered_spell_id = 54820;\n                            break;\n                        }\n                    }\n                    return false;\n                }\n                // Leader of the Pack\n                case 24932:\n                {\n                   if (triggerAmount <= 0)\n                        return false;\n                    basepoints0 = int32(CountPctFromMaxHealth(triggerAmount));\n                    target = this;\n                    triggered_spell_id = 34299;\n                    if (triggeredByAura->GetCasterGUID() != GetGUID())\n                        break;\n                    int32 basepoints1 = triggerAmount * 2;\n                    // Improved Leader of the Pack\n                    // Check cooldown of heal spell cooldown\n                    if (GetTypeId() == TYPEID_PLAYER && !ToPlayer()->HasSpellCooldown(34299))\n                        CastCustomSpell(this, 60889, &basepoints1, 0, 0, true, 0, triggeredByAura);\n                    break;\n                }\n                // Healing Touch (Dreamwalker Raiment set)\n                case 28719:\n                {\n                    // mana back\n                    basepoints0 = int32(CalculatePctN(procSpell->ManaCost, 30));\n                    target = this;\n                    triggered_spell_id = 28742;\n                    break;\n                }\n                // Glyph of Rejuvenation\n                case 54754:\n                {\n                    if (!victim || !victim->HealthBelowPct(uint32(triggerAmount)))\n                        return false;\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                    triggered_spell_id = 54755;\n                    break;\n                }\n                // Healing Touch Refund (Idol of Longevity trinket)\n                case 28847:\n                {\n                    target = this;\n                    triggered_spell_id = 28848;\n                    break;\n                }\n                // Mana Restore (Malorne Raiment set / Malorne Regalia set)\n                case 37288:\n                case 37295:\n                {\n                    target = this;\n                    triggered_spell_id = 37238;\n                    break;\n                }\n                // Druid Tier 6 Trinket\n                case 40442:\n                {\n                    float  chance;\n\n                    // Starfire\n                    if (procSpell->SpellFamilyFlags[0] & 0x4)\n                    {\n                        triggered_spell_id = 40445;\n                        chance = 25.0f;\n                    }\n                    // Rejuvenation\n                    else if (procSpell->SpellFamilyFlags[0] & 0x10)\n                    {\n                        triggered_spell_id = 40446;\n                        chance = 25.0f;\n                    }\n                    // Mangle (Bear) and Mangle (Cat)\n                    else if (procSpell->SpellFamilyFlags[1] & 0x00000440)\n                    {\n                        triggered_spell_id = 40452;\n                        chance = 40.0f;\n                    }\n                    else\n                        return false;\n\n                    if (!roll_chance_f(chance))\n                        return false;\n\n                    target = this;\n                    break;\n                }\n                // Maim Interrupt\n                case 44835:\n                {\n                    // Deadly Interrupt Effect\n                    triggered_spell_id = 32747;\n                    break;\n                }\n                // Item - Druid T10 Balance 4P Bonus\n                case 70723:\n                {\n                    // Wrath & Starfire\n                    if ((procSpell->SpellFamilyFlags[0] & 0x5) && (procEx & PROC_EX_CRITICAL_HIT))\n                    {\n                        triggered_spell_id = 71023;\n                        SpellInfo const* triggeredSpell = sSpellMgr->GetSpellInfo(triggered_spell_id);\n                        if (!triggeredSpell)\n                            return false;\n                        basepoints0 = CalculatePctN(int32(damage), triggerAmount) / (triggeredSpell->GetMaxDuration() / triggeredSpell->Effects[0].Amplitude);\n                        // Add remaining ticks to damage done\n                        basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_DAMAGE);\n                    }\n                    break;\n                }\n                // Item - Druid T10 Restoration 4P Bonus (Rejuvenation)\n                case 70664:\n                {\n                    // Proc only from normal Rejuvenation\n                    if (procSpell->SpellVisual[0] != 32)\n                        return false;\n\n                    Player* caster = ToPlayer();\n                    if (!caster)\n                        return false;\n                    if (!caster->GetGroup() && victim == this)\n                        return false;\n\n                    CastCustomSpell(70691, SPELLVALUE_BASE_POINT0, damage, victim, true);\n                    return true;\n                }\n            }\n            // Eclipse\n            if (dummySpell->SpellIconID == 2856 && GetTypeId() == TYPEID_PLAYER)\n            {\n                if (!procSpell || effIndex != 0)\n                    return false;\n\n                bool isWrathSpell = (procSpell->SpellFamilyFlags[0] & 1);\n\n                if (!roll_chance_f(dummySpell->ProcChance * (isWrathSpell ? 0.6f : 1.0f)))\n                    return false;\n\n                target = this;\n                if (target->HasAura(isWrathSpell ? 48517 : 48518))\n                    return false;\n\n                triggered_spell_id = isWrathSpell ? 48518 : 48517;\n                break;\n            }\n            // Living Seed\n            else if (dummySpell->SpellIconID == 2860)\n            {\n                triggered_spell_id = 48504;\n                basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                break;\n            }\n            break;\n        }\n        case SPELLFAMILY_ROGUE:\n        {\n            switch (dummySpell->Id)\n            {\n                case 56800: // Glyph of Backstab\n                {\n                    triggered_spell_id = 63975;\n                    break;\n                }\n                case 32748: // Deadly Throw Interrupt\n                {\n                    // Prevent cast Deadly Throw Interrupt on self from last effect (apply dummy) of Deadly Throw\n                    if (this == victim)\n                        return false;\n\n                    triggered_spell_id = 32747;\n                    break;\n                }\n                case 57934: // Tricks of the Trade\n                {\n                    Unit* redirectTarget = GetMisdirectionTarget();\n                    RemoveAura(57934);\n                    if (!redirectTarget)\n                        break;\n                    CastSpell(this,59628,true);\n                    CastSpell(redirectTarget,57933,true);\n                    break;\n                }\n            }\n\n            switch (dummySpell->SpellIconID)\n            {\n                case 2116: // Quick Recovery\n                {\n                    if (!procSpell)\n                        return false;\n\n                    // energy cost save\n                    basepoints0 = CalculatePctN(int32(procSpell->ManaCost), triggerAmount);\n                    if (basepoints0 <= 0)\n                        return false;\n\n                    target = this;\n                    triggered_spell_id = 31663;\n                    break;\n                }\n                case 2909: // Cut to the Chase\n                {\n                    // \"refresh your Slice and Dice duration to its 5 combo point maximum\"\n                    // lookup Slice and Dice\n                    if (AuraEffect const* aur = GetAuraEffect(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_ROGUE, 0x40000, 0, 0))\n                    {\n                        aur->GetBase()->SetDuration(aur->GetSpellInfo()->GetMaxDuration(), true);\n                        return true;\n                    }\n                    return false;\n                }\n                case 2963: // Deadly Brew\n                {\n                    triggered_spell_id = 3409;\n                    break;\n                }\n            }\n            break;\n        }\n        case SPELLFAMILY_HUNTER:\n        {\n            switch (dummySpell->SpellIconID)\n            {\n                case 267: // Improved Mend Pet\n                {\n                    int32 chance = triggeredByAura->GetSpellInfo()->Effects[triggeredByAura->GetEffIndex()].CalcValue();\n                    if (!roll_chance_i(chance))\n                        return false;\n\n                    triggered_spell_id = 24406;\n                    break;\n                }\n                case 2236: // Thrill of the Hunt\n                {\n                    if (!procSpell)\n                        return false;\n\n                    Spell* spell = ToPlayer()->m_spellModTakingSpell;\n\n                    // Disable charge drop because of Lock and Load\n                    ToPlayer()->SetSpellModTakingSpell(spell, false);\n\n                    // Explosive Shot\n                    if (procSpell->SpellFamilyFlags[2] & 0x200)\n                    {\n                        if (!victim)\n                            return false;\n                        if (AuraEffect const* pEff = victim->GetAuraEffect(SPELL_AURA_PERIODIC_DUMMY, SPELLFAMILY_HUNTER, 0x0, 0x80000000, 0x0, GetGUID()))\n                            basepoints0 = pEff->GetSpellInfo()->CalcPowerCost(this, SpellSchoolMask(pEff->GetSpellInfo()->SchoolMask)) * 4/10/3;\n                    }\n                    else\n                        basepoints0 = procSpell->CalcPowerCost(this, SpellSchoolMask(procSpell->SchoolMask)) * 4/10;\n\n                    ToPlayer()->SetSpellModTakingSpell(spell, true);\n\n                    if (basepoints0 <= 0)\n                        return false;\n\n                    target = this;\n                    triggered_spell_id = 34720;\n                    break;\n                }\n                case 3406: // Hunting Party\n                {\n                    triggered_spell_id = 57669;\n                    target = this;\n                    break;\n                }\n                case 3560: // Rapid Recuperation\n                {\n                    // This effect only from Rapid Killing (mana regen)\n                    if (!(procSpell->SpellFamilyFlags[1] & 0x01000000))\n                        return false;\n\n                    target = this;\n\n                    switch (dummySpell->Id)\n                    {\n                        case 53228:                             // Rank 1\n                            triggered_spell_id = 56654;\n                            break;\n                        case 53232:                             // Rank 2\n                            triggered_spell_id = 58882;\n                            break;\n                    }\n                    break;\n                }\n                case 3579: // Lock and Load\n                {\n                    // Proc only from periodic (from trap activation proc another aura of this spell)\n                    if (!(procFlag & PROC_FLAG_DONE_PERIODIC) || !roll_chance_i(triggerAmount))\n                        return false;\n                    triggered_spell_id = 56453;\n                    target = this;\n                    break;\n                }\n            }\n\n            switch (dummySpell->Id)\n            {\n                case 34477: // Misdirection\n                {\n                    if (!GetMisdirectionTarget())\n                        return false;\n                    triggered_spell_id = 35079; // 4 sec buff on self\n                    target = this;\n                    break;\n                }\n                case 57870: // Glyph of Mend Pet\n                {\n                    victim->CastSpell(victim, 57894, true, NULL, NULL, GetGUID());\n                    return true;\n                }\n            }\n            break;\n        }\n        case SPELLFAMILY_PALADIN:\n        {\n            // Seal of Righteousness - melee proc dummy (addition ${$MWS*(0.022*$AP+0.044*$SPH)} damage)\n            if (dummySpell->SpellFamilyFlags[0] & 0x8000000)\n            {\n                if (effIndex != 0)\n                    return false;\n                triggered_spell_id = 25742;\n                float ap = GetTotalAttackPowerValue(BASE_ATTACK);\n                int32 holy = SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_HOLY) +\n                             victim->SpellBaseDamageBonusTaken(SPELL_SCHOOL_MASK_HOLY);\n                basepoints0 = (int32)GetAttackTime(BASE_ATTACK) * int32(ap * 0.022f + 0.044f * holy) / 1000;\n                break;\n            }\n            // Light's Beacon - Beacon of Light\n            if (dummySpell->Id == 53651)\n            {\n                if (!victim)\n                    return false;\n                triggered_spell_id = 0;\n                Unit* beaconTarget = NULL;\n                if (this->GetTypeId() != TYPEID_PLAYER)\n                {\n                    beaconTarget = triggeredByAura->GetBase()->GetCaster();\n                    if (beaconTarget == this || !(beaconTarget->GetAura(53563, victim->GetGUID())))\n                        return false;\n                    basepoints0 = int32(damage);\n                    triggered_spell_id = procSpell->IsRankOf(sSpellMgr->GetSpellInfo(365)) ? 53652 : 53654;\n                }\n                else\n                {    // Check Party/Raid Group\n                    if (Group *group = this->ToPlayer()->GetGroup())\n                    {\n                        for (GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())\n                        {\n                            Player* Member = itr->getSource();\n\n                            // check if it was heal by paladin which casted this beacon of light\n                            if (Aura const * aura = Member->GetAura(53563, victim->GetGUID()))\n                            {\n                                // do not proc when target of beacon of light is healed\n                                if (Member == this)\n                                    return false;\n\n                                beaconTarget = Member;\n                                basepoints0 = int32(damage);\n                                triggered_spell_id = procSpell->IsRankOf(sSpellMgr->GetSpellInfo(365)) ? 53652 : 53654;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (triggered_spell_id && beaconTarget)\n                {\n                    victim->CastCustomSpell(beaconTarget, triggered_spell_id, &basepoints0, NULL, NULL, true, 0, triggeredByAura);\n                    return true;\n                } \n                else\n                    return false;\n            }\n            // Judgements of the Wise\n            if (dummySpell->SpellIconID == 3017)\n            {\n                target = this;\n                triggered_spell_id = 31930;\n                // replenishment\n                CastSpell(this, 57669, true, castItem, triggeredByAura);\n                break;\n            }\n            // Sanctified Wrath\n            if (dummySpell->SpellIconID == 3029)\n            {\n                triggered_spell_id = 57318;\n                target = this;\n                basepoints0 = triggerAmount;\n                CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints0, NULL, true, castItem, triggeredByAura);\n                return true;\n            }\n            // Righteous Vengeance\n            if (dummySpell->SpellIconID == 3025)\n            {\n                // 4 damage tick\n                basepoints0 = triggerAmount * damage / 400;\n                triggered_spell_id = 61840;\n                // Add remaining ticks to damage done\n                basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_DAMAGE);\n                break;\n            }\n            // Sheath of Light\n            if (dummySpell->SpellIconID == 3030)\n            {\n                // 4 healing tick\n                basepoints0 = triggerAmount * damage / 400;\n                triggered_spell_id = 54203;\n                break;\n            }\n            switch (dummySpell->Id)\n            {\n                // Sacred Shield\n                case 53601:\n                {\n                    if (procFlag & PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_POS)\n                        return false;\n\n                    if (damage > 0)\n                        triggered_spell_id = 58597;\n\n                    // Item - Paladin T8 Holy 4P Bonus\n                    if (Unit* caster = triggeredByAura->GetCaster())\n                        if (AuraEffect const* aurEff = caster->GetAuraEffect(64895, 0))\n                            cooldown = aurEff->GetAmount();\n\n                    target = this;\n                    break;\n                }\n                // Heart of the Crusader\n                case 20335: // rank 1\n                    triggered_spell_id = 21183;\n                    break;\n                case 20336: // rank 2\n                    triggered_spell_id = 54498;\n                    break;\n                case 20337: // rank 3\n                    triggered_spell_id = 54499;\n                    break;\n                // Judgement of Light\n                case 20185:\n                {\n                    if (!victim)\n                        return false;\n\n                    // 2% of maximum health\n                    basepoints0 = int32(victim->CountPctFromMaxHealth(2));\n                    victim->CastCustomSpell(victim, 20267, &basepoints0, 0, 0, true, 0, triggeredByAura);\n                    return true;\n                }\n                // Judgement of Wisdom\n                case 20186:\n                {\n                    if (victim && victim->isAlive() && victim->getPowerType() == POWER_MANA)\n                    {\n                        // 2% of base mana\n                        basepoints0 = int32(CalculatePctN(victim->GetCreateMana(), 2));\n                        victim->CastCustomSpell(victim, 20268, &basepoints0, NULL, NULL, true, 0, triggeredByAura);\n                    }\n                    return true;\n                }\n                // Holy Power (Redemption Armor set)\n                case 28789:\n                {\n                    if (!victim)\n                        return false;\n\n                    // Set class defined buff\n                    switch (victim->getClass())\n                    {\n                        case CLASS_PALADIN:\n                        case CLASS_PRIEST:\n                        case CLASS_SHAMAN:\n                        case CLASS_DRUID:\n                            triggered_spell_id = 28795;     // Increases the friendly target's mana regeneration by $s1 per 5 sec. for $d.\n                            break;\n                        case CLASS_MAGE:\n                        case CLASS_WARLOCK:\n                            triggered_spell_id = 28793;     // Increases the friendly target's spell damage and healing by up to $s1 for $d.\n                            break;\n                        case CLASS_HUNTER:\n                        case CLASS_ROGUE:\n                            triggered_spell_id = 28791;     // Increases the friendly target's attack power by $s1 for $d.\n                            break;\n                        case CLASS_WARRIOR:\n                            triggered_spell_id = 28790;     // Increases the friendly target's armor\n                            break;\n                        default:\n                            return false;\n                    }\n                    break;\n                }\n                case 25899:                                 // Greater Blessing of Sanctuary\n                case 20911:                                 // Blessing of Sanctuary\n                {\n                    target = this;\n                    switch (target->getPowerType())\n                    {\n                        case POWER_MANA:\n                            triggered_spell_id = 57319;\n                            break;\n                        default:\n                            return false;\n                    }\n                    break;\n                }\n                // Seal of Vengeance (damage calc on apply aura)\n                case 31801:\n                {\n                    if (effIndex != 0)                       // effect 1, 2 used by seal unleashing code\n                        return false;\n\n                    // At melee attack or Hammer of the Righteous spell damage considered as melee attack\n                    bool stacker = !procSpell || procSpell->Id == 53595;\n                    // spells with SPELL_DAMAGE_CLASS_MELEE excluding Judgements\n                    bool damager = procSpell && procSpell->EquippedItemClass != -1;\n\n                    if (!stacker && !damager)\n                        return false;\n\n                    triggered_spell_id = 31803;\n\n                    // On target with 5 stacks of Holy Vengeance direct damage is done\n                    if (Aura* aur = victim->GetAura(triggered_spell_id, GetGUID()))\n                    {\n                        if (aur->GetStackAmount() == 5)\n                        {\n                            if (stacker)\n                                aur->RefreshDuration();\n                            CastSpell(victim, 42463, true);\n                            return true;\n                        }\n                    }\n\n                    if (!stacker)\n                        return false;\n                    break;\n                }\n                // Seal of Corruption\n                case 53736:\n                {\n                    if (effIndex != 0)                       // effect 1, 2 used by seal unleashing code\n                        return false;\n\n                    // At melee attack or Hammer of the Righteous spell damage considered as melee attack\n                    bool stacker = !procSpell || procSpell->Id == 53595;\n                    // spells with SPELL_DAMAGE_CLASS_MELEE excluding Judgements\n                    bool damager = procSpell && procSpell->EquippedItemClass != -1;\n\n                    if (!stacker && !damager)\n                        return false;\n\n                    triggered_spell_id = 53742;\n\n                    // On target with 5 stacks of Blood Corruption direct damage is done\n                    if (Aura* aur = victim->GetAura(triggered_spell_id, GetGUID()))\n                    {\n                        if (aur->GetStackAmount() == 5)\n                        {\n                            if (stacker)\n                                aur->RefreshDuration();\n                            CastSpell(victim, 53739, true);\n                            return true;\n                        }\n                    }\n\n                    if (!stacker)\n                        return false;\n                    break;\n                }\n                // Spiritual Attunement\n                case 31785:\n                case 33776:\n                {\n                    // if healed by another unit (victim)\n                    if (this == victim)\n                        return false;\n\n                    // heal amount\n                    basepoints0 = int32(CalculatePctN(std::min(damage, GetMaxHealth() - GetHealth()), triggerAmount));\n                    target = this;\n\n                    if (basepoints0)\n                        triggered_spell_id = 31786;\n                    break;\n                }\n                // Paladin Tier 6 Trinket (Ashtongue Talisman of Zeal)\n                case 40470:\n                {\n                    if (!procSpell)\n                        return false;\n\n                    float  chance;\n\n                    // Flash of light/Holy light\n                    if (procSpell->SpellFamilyFlags[0] & 0xC0000000)\n                    {\n                        triggered_spell_id = 40471;\n                        chance = 15.0f;\n                    }\n                    // Judgement (any)\n                    else if (procSpell->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT)\n                    {\n                        triggered_spell_id = 40472;\n                        chance = 50.0f;\n                    }\n                    else\n                        return false;\n\n                    if (!roll_chance_f(chance))\n                        return false;\n\n                    break;\n                }\n                // Glyph of Holy Light\n                case 54937:\n                {\n                    triggered_spell_id = 54968;\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                    break;\n                }\n                // Item - Paladin T8 Holy 2P Bonus\n                case 64890:\n                {\n                    triggered_spell_id = 64891;\n                    basepoints0 = triggerAmount * damage / 300;\n                    break;\n                }\n                case 71406: // Tiny Abomination in a Jar\n                case 71545: // Tiny Abomination in a Jar (Heroic)\n                {\n                    if (!victim || !victim->isAlive())\n                        return false;\n\n                    CastSpell(this, 71432, true, NULL, triggeredByAura);\n\n                    Aura const* dummy = GetAura(71432);\n                    if (!dummy || dummy->GetStackAmount() < (dummySpell->Id == 71406 ? 8 : 7))\n                        return false;\n\n                    RemoveAurasDueToSpell(71432);\n                    triggered_spell_id = 71433;  // default main hand attack\n                    // roll if offhand\n                    if (Player const* player = ToPlayer())\n                        if (player->GetWeaponForAttack(OFF_ATTACK, true) && urand(0, 1))\n                            triggered_spell_id = 71434;\n                    target = victim;\n                    break;\n                }\n                // Item - Icecrown 25 Normal Dagger Proc\n                case 71880:\n                {\n                    switch (getPowerType())\n                    {\n                        case POWER_MANA:\n                            triggered_spell_id = 71881;\n                            break;\n                        case POWER_RAGE:\n                            triggered_spell_id = 71883;\n                            break;\n                        case POWER_ENERGY:\n                            triggered_spell_id = 71882;\n                            break;\n                        case POWER_RUNIC_POWER:\n                            triggered_spell_id = 71884;\n                            break;\n                        default:\n                            return false;\n                    }\n                    break;\n                }\n                // Item - Icecrown 25 Heroic Dagger Proc\n                case 71892:\n                {\n                    switch (getPowerType())\n                    {\n                        case POWER_MANA:\n                            triggered_spell_id = 71888;\n                            break;\n                        case POWER_RAGE:\n                            triggered_spell_id = 71886;\n                            break;\n                        case POWER_ENERGY:\n                            triggered_spell_id = 71887;\n                            break;\n                        case POWER_RUNIC_POWER:\n                            triggered_spell_id = 71885;\n                            break;\n                        default:\n                            return false;\n                    }\n                    break;\n                }\n            }\n            break;\n        }\n        case SPELLFAMILY_SHAMAN:\n        {\n            switch (dummySpell->Id)\n            {\n                // Tidal Force\n                case 55198:\n                {\n                    // Remove aura stack from  caster\n                    RemoveAuraFromStack(55166);\n                    // drop charges\n                    return false;\n                }\n                // Totemic Power (The Earthshatterer set)\n                case 28823:\n                {\n                    if (!victim)\n                        return false;\n\n                    // Set class defined buff\n                    switch (victim->getClass())\n                    {\n                        case CLASS_PALADIN:\n                        case CLASS_PRIEST:\n                        case CLASS_SHAMAN:\n                        case CLASS_DRUID:\n                            triggered_spell_id = 28824;     // Increases the friendly target's mana regeneration by $s1 per 5 sec. for $d.\n                            break;\n                        case CLASS_MAGE:\n                        case CLASS_WARLOCK:\n                            triggered_spell_id = 28825;     // Increases the friendly target's spell damage and healing by up to $s1 for $d.\n                            break;\n                        case CLASS_HUNTER:\n                        case CLASS_ROGUE:\n                            triggered_spell_id = 28826;     // Increases the friendly target's attack power by $s1 for $d.\n                            break;\n                        case CLASS_WARRIOR:\n                            triggered_spell_id = 28827;     // Increases the friendly target's armor\n                            break;\n                        default:\n                            return false;\n                    }\n                    break;\n                }\n                // Lesser Healing Wave (Totem of Flowing Water Relic)\n                case 28849:\n                {\n                    target = this;\n                    triggered_spell_id = 28850;\n                    break;\n                }\n                // Windfury Weapon (Passive) 1-8 Ranks\n                case 33757:\n                {\n                    Player* player = ToPlayer();\n                    if (!player || !castItem || !castItem->IsEquipped() || !victim || !victim->isAlive())\n                        return false;\n\n                    // custom cooldown processing case\n                    if (cooldown && player->HasSpellCooldown(dummySpell->Id))\n                        return false;\n\n                    if (triggeredByAura->GetBase() && castItem->GetGUID() != triggeredByAura->GetBase()->GetCastItemGUID())\n                        return false;\n\n                    WeaponAttackType attType = WeaponAttackType(player->GetAttackBySlot(castItem->GetSlot()));\n                    if ((attType != BASE_ATTACK && attType != OFF_ATTACK)\n                        || (attType == BASE_ATTACK && procFlag & PROC_FLAG_DONE_OFFHAND_ATTACK)\n                        || (attType == OFF_ATTACK && procFlag & PROC_FLAG_DONE_MAINHAND_ATTACK))\n                         return false;\n\n                    // Now compute real proc chance...\n                    uint32 chance = 20;\n                    player->ApplySpellMod(dummySpell->Id, SPELLMOD_CHANCE_OF_SUCCESS, chance);\n\n                    Item* addWeapon = player->GetWeaponForAttack(attType == BASE_ATTACK ? OFF_ATTACK : BASE_ATTACK, true);\n                    uint32 enchant_id_add = addWeapon ? addWeapon->GetEnchantmentId(EnchantmentSlot(TEMP_ENCHANTMENT_SLOT)) : 0;\n                    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id_add);\n                    if (pEnchant && pEnchant->spellid[0] == dummySpell->Id)\n                        chance += 14;\n\n                    if (!roll_chance_i(chance))\n                        return false;\n\n                    // Now amount of extra power stored in 1 effect of Enchant spell\n                    // Get it by item enchant id\n                    uint32 spellId;\n                    switch (castItem->GetEnchantmentId(EnchantmentSlot(TEMP_ENCHANTMENT_SLOT)))\n                    {\n                        case 283: spellId =  8232; break;   // 1 Rank\n                        case 284: spellId =  8235; break;   // 2 Rank\n                        case 525: spellId = 10486; break;   // 3 Rank\n                        case 1669:spellId = 16362; break;   // 4 Rank\n                        case 2636:spellId = 25505; break;   // 5 Rank\n                        case 3785:spellId = 58801; break;   // 6 Rank\n                        case 3786:spellId = 58803; break;   // 7 Rank\n                        case 3787:spellId = 58804; break;   // 8 Rank\n                        default:\n                        {\n                            sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleDummyAuraProc: non handled item enchantment (rank?) %u for spell id: %u (Windfury)\",\n                                castItem->GetEnchantmentId(EnchantmentSlot(TEMP_ENCHANTMENT_SLOT)), dummySpell->Id);\n                            return false;\n                        }\n                    }\n\n                    SpellInfo const* windfurySpellInfo = sSpellMgr->GetSpellInfo(spellId);\n                    if (!windfurySpellInfo)\n                    {\n                        sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleDummyAuraProc: non-existing spell id: %u (Windfury)\", spellId);\n                        return false;\n                    }\n\n                    int32 extra_attack_power = CalculateSpellDamage(victim, windfurySpellInfo, 1);\n\n                    // Value gained from additional AP\n                    basepoints0 = int32(extra_attack_power / 14.0f * GetAttackTime(attType) / 1000);\n\n                    if (procFlag & PROC_FLAG_DONE_MAINHAND_ATTACK)\n                        triggered_spell_id = 25504;\n\n                    if (procFlag & PROC_FLAG_DONE_OFFHAND_ATTACK)\n                        triggered_spell_id = 33750;\n\n                    // apply cooldown before cast to prevent processing itself\n                    if (cooldown)\n                        player->AddSpellCooldown(dummySpell->Id, 0, time(NULL) + cooldown);\n\n                    // Attack Twice\n                    for (uint32 i = 0; i < 2; ++i)\n                        CastCustomSpell(victim, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);\n\n                    return true;\n                }\n                // Shaman Tier 6 Trinket\n                case 40463:\n                {\n                    if (!procSpell)\n                        return false;\n\n                    float chance;\n                    if (procSpell->SpellFamilyFlags[0] & 0x1)\n                    {\n                        triggered_spell_id = 40465;         // Lightning Bolt\n                        chance = 15.0f;\n                    }\n                    else if (procSpell->SpellFamilyFlags[0] & 0x80)\n                    {\n                        triggered_spell_id = 40465;         // Lesser Healing Wave\n                        chance = 10.0f;\n                    }\n                    else if (procSpell->SpellFamilyFlags[1] & 0x00000010)\n                    {\n                        triggered_spell_id = 40466;         // Stormstrike\n                        chance = 50.0f;\n                    }\n                    else\n                        return false;\n\n                    if (!roll_chance_f(chance))\n                        return false;\n\n                    target = this;\n                    break;\n                }\n                // Glyph of Healing Wave\n                case 55440:\n                {\n                    // Not proc from self heals\n                    if (this == victim)\n                        return false;\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                    target = this;\n                    triggered_spell_id = 55533;\n                    break;\n                }\n                // Spirit Hunt\n                case 58877:\n                {\n                    // Cast on owner\n                    target = GetOwner();\n                    if (!target)\n                        return false;\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                    triggered_spell_id = 58879;\n                    // Cast on spirit wolf\n                    CastCustomSpell(this, triggered_spell_id, &basepoints0, NULL, NULL, true, NULL, triggeredByAura);\n                    break;\n                }\n                // Shaman T8 Elemental 4P Bonus\n                case 64928:\n                {\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                    triggered_spell_id = 64930;            // Electrified\n                    break;\n                }\n                // Shaman T9 Elemental 4P Bonus\n                case 67228:\n                {\n                    // Lava Burst\n                    if (procSpell->SpellFamilyFlags[1] & 0x1000)\n                    {\n                        triggered_spell_id = 71824;\n                        SpellInfo const* triggeredSpell = sSpellMgr->GetSpellInfo(triggered_spell_id);\n                        if (!triggeredSpell)\n                            return false;\n                        basepoints0 = CalculatePctN(int32(damage), triggerAmount) / (triggeredSpell->GetMaxDuration() / triggeredSpell->Effects[0].Amplitude);\n                    }\n                    break;\n                }\n                // Item - Shaman T10 Restoration 4P Bonus\n                case 70808:\n                {\n                    // Chain Heal\n                    if ((procSpell->SpellFamilyFlags[0] & 0x100) && (procEx & PROC_EX_CRITICAL_HIT))\n                    {\n                        triggered_spell_id = 70809;\n                        SpellInfo const* triggeredSpell = sSpellMgr->GetSpellInfo(triggered_spell_id);\n                        if (!triggeredSpell)\n                            return false;\n                        basepoints0 = CalculatePctN(int32(damage), triggerAmount) / (triggeredSpell->GetMaxDuration() / triggeredSpell->Effects[0].Amplitude);\n                        // Add remaining ticks to healing done\n                        basepoints0 += GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_HEAL);\n                    }\n                    break;\n                }\n                // Item - Shaman T10 Elemental 2P Bonus\n                case 70811:\n                {\n                    // Lightning Bolt & Chain Lightning\n                    if (procSpell->SpellFamilyFlags[0] & 0x3)\n                    {\n                        if (ToPlayer()->HasSpellCooldown(16166))\n                        {\n                            uint32 newCooldownDelay = ToPlayer()->GetSpellCooldownDelay(16166);\n                            if (newCooldownDelay < 3)\n                                newCooldownDelay = 0;\n                            else\n                                newCooldownDelay -= 2;\n                            ToPlayer()->AddSpellCooldown(16166, 0, uint32(time(NULL) + newCooldownDelay));\n\n                            WorldPacket data(SMSG_MODIFY_COOLDOWN, 4+8+4);\n                            data << uint32(16166);                  // Spell ID\n                            data << uint64(GetGUID());              // Player GUID\n                            data << int32(-2000);                   // Cooldown mod in milliseconds\n                            ToPlayer()->GetSession()->SendPacket(&data);\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n                // Item - Shaman T10 Elemental 4P Bonus\n                case 70817:\n                {\n                    if (!target)\n                        return false;\n                    // try to find spell Flame Shock on the target\n                    if (AuraEffect const* aurEff = target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_SHAMAN, 0x10000000, 0x0, 0x0, GetGUID()))\n                    {\n                        Aura* flameShock  = aurEff->GetBase();\n                        int32 maxDuration = flameShock->GetMaxDuration();\n                        int32 newDuration = flameShock->GetDuration() + 2 * aurEff->GetAmplitude();\n\n                        flameShock->SetDuration(newDuration);\n                        // is it blizzlike to change max duration for FS?\n                        if (newDuration > maxDuration)\n                            flameShock->SetMaxDuration(newDuration);\n\n                        return true;\n                    }\n                    // if not found Flame Shock\n                    return false;\n                }\n                case 63280: // Glyph of Totem of Wrath\n                {\n                    if (procSpell->SpellIconID != 2019)\n                        return false;\n\n                    if (Creature* totem = GetMap()->GetCreature(m_SummonSlot[1]))   // Fire totem summon slot\n                    {\n                        if (SpellInfo const* totemSpell = sSpellMgr->GetSpellInfo(totem->m_spells[0]))\n                        {\n                            int32 bp0 = CalculatePctN(totemSpell->Effects[EFFECT_0].CalcValue(), triggerAmount);\n                            int32 bp1 = CalculatePctN(totemSpell->Effects[EFFECT_1].CalcValue(), triggerAmount);\n                            CastCustomSpell(this, 63283, &bp0, &bp1, NULL, true);\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n                break;\n            }\n            // Frozen Power\n            if (dummySpell->SpellIconID == 3780)\n            {\n                if (!target)\n                    return false;\n                if (GetDistance(target) < 15.0f)\n                    return false;\n                float chance = (float)triggerAmount;\n                if (!roll_chance_f(chance))\n                    return false;\n\n                triggered_spell_id = 63685;\n                break;\n            }\n            // Ancestral Awakening\n            if (dummySpell->SpellIconID == 3065)\n            {\n                triggered_spell_id = 52759;\n                basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                target = this;\n                break;\n            }\n            // Earth Shield\n            if (dummySpell->SpellFamilyFlags[1] & 0x00000400)\n            {\n                // 3.0.8: Now correctly uses the Shaman's own spell critical strike chance to determine the chance of a critical heal.\n                originalCaster = triggeredByAura->GetCasterGUID();\n                target = this;\n                basepoints0 = triggerAmount;\n\n                // Glyph of Earth Shield\n                if (AuraEffect* aur = GetAuraEffect(63279, 0))\n                    AddPctN(basepoints0, aur->GetAmount());\n                triggered_spell_id = 379;\n                break;\n            }\n            // Flametongue Weapon (Passive)\n            if (dummySpell->SpellFamilyFlags[0] & 0x200000)\n            {\n                if (GetTypeId() != TYPEID_PLAYER  || !victim || !victim->isAlive() || !castItem || !castItem->IsEquipped())\n                    return false;\n\n                WeaponAttackType attType = WeaponAttackType(Player::GetAttackBySlot(castItem->GetSlot()));\n                if ((attType != BASE_ATTACK && attType != OFF_ATTACK)\n                    || (attType == BASE_ATTACK && procFlag & PROC_FLAG_DONE_OFFHAND_ATTACK)\n                    || (attType == OFF_ATTACK && procFlag & PROC_FLAG_DONE_MAINHAND_ATTACK))\n                    return false;\n\n                float fire_onhit = float(CalculatePctF(dummySpell->Effects[EFFECT_0]. CalcValue(), 1.0f));\n\n                float add_spellpower = (float)(SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_FIRE)\n                                     + victim->SpellBaseDamageBonusTaken(SPELL_SCHOOL_MASK_FIRE));\n\n                // 1.3speed = 5%, 2.6speed = 10%, 4.0 speed = 15%, so, 1.0speed = 3.84%\n                ApplyPctF(add_spellpower, 3.84f);\n\n                // Enchant on Off-Hand and ready?\n                if (castItem->GetSlot() == EQUIPMENT_SLOT_OFFHAND && procFlag & PROC_FLAG_DONE_OFFHAND_ATTACK)\n                {\n                    float BaseWeaponSpeed = GetAttackTime(OFF_ATTACK) / 1000.0f;\n\n                    // Value1: add the tooltip damage by swingspeed + Value2: add spelldmg by swingspeed\n                    basepoints0 = int32((fire_onhit * BaseWeaponSpeed) + (add_spellpower * BaseWeaponSpeed));\n                    triggered_spell_id = 10444;\n                }\n\n                // Enchant on Main-Hand and ready?\n                else if (castItem->GetSlot() == EQUIPMENT_SLOT_MAINHAND && procFlag & PROC_FLAG_DONE_MAINHAND_ATTACK)\n                {\n                    float BaseWeaponSpeed = GetAttackTime(BASE_ATTACK) / 1000.0f;\n\n                    // Value1: add the tooltip damage by swingspeed +  Value2: add spelldmg by swingspeed\n                    basepoints0 = int32((fire_onhit * BaseWeaponSpeed) + (add_spellpower * BaseWeaponSpeed));\n                    triggered_spell_id = 10444;\n                }\n\n                // If not ready, we should  return, shouldn't we?!\n                else\n                    return false;\n\n                CastCustomSpell(victim, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);\n                return true;\n            }\n            // Improved Water Shield\n            if (dummySpell->SpellIconID == 2287)\n            {\n                // Default chance for Healing Wave and Riptide\n                float chance = (float)triggeredByAura->GetAmount();\n\n                if (procSpell->SpellFamilyFlags[0] & 0x80)\n                    // Lesser Healing Wave - 0.6 of default\n                    chance *= 0.6f;\n                else if (procSpell->SpellFamilyFlags[0] & 0x100)\n                    // Chain heal - 0.3 of default\n                    chance *= 0.3f;\n\n                if (!roll_chance_f(chance))\n                    return false;\n\n                // Water Shield\n                if (AuraEffect const* aurEff = GetAuraEffect(SPELL_AURA_PROC_TRIGGER_SPELL, SPELLFAMILY_SHAMAN, 0, 0x00000020, 0))\n                {\n                    uint32 spell = aurEff->GetSpellInfo()->Effects[aurEff->GetEffIndex()].TriggerSpell;\n                    CastSpell(this, spell, true, castItem, triggeredByAura);\n                    return true;\n                }\n                return false;\n            }\n            // Lightning Overload\n            if (dummySpell->SpellIconID == 2018)            // only this spell has SpellFamily Shaman SpellIconID == 2018 and dummy aura\n            {\n                if (!procSpell || GetTypeId() != TYPEID_PLAYER || !victim)\n                    return false;\n\n                // custom cooldown processing case\n                if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(dummySpell->Id))\n                    return false;\n\n                uint32 spellId = 0;\n                // Every Lightning Bolt and Chain Lightning spell have duplicate vs half damage and zero cost\n                switch (procSpell->Id)\n                {\n                    // Lightning Bolt\n                    case   403: spellId = 45284; break;     // Rank  1\n                    case   529: spellId = 45286; break;     // Rank  2\n                    case   548: spellId = 45287; break;     // Rank  3\n                    case   915: spellId = 45288; break;     // Rank  4\n                    case   943: spellId = 45289; break;     // Rank  5\n                    case  6041: spellId = 45290; break;     // Rank  6\n                    case 10391: spellId = 45291; break;     // Rank  7\n                    case 10392: spellId = 45292; break;     // Rank  8\n                    case 15207: spellId = 45293; break;     // Rank  9\n                    case 15208: spellId = 45294; break;     // Rank 10\n                    case 25448: spellId = 45295; break;     // Rank 11\n                    case 25449: spellId = 45296; break;     // Rank 12\n                    case 49237: spellId = 49239; break;     // Rank 13\n                    case 49238: spellId = 49240; break;     // Rank 14\n                    // Chain Lightning\n                    case   421: spellId = 45297; break;     // Rank  1\n                    case   930: spellId = 45298; break;     // Rank  2\n                    case  2860: spellId = 45299; break;     // Rank  3\n                    case 10605: spellId = 45300; break;     // Rank  4\n                    case 25439: spellId = 45301; break;     // Rank  5\n                    case 25442: spellId = 45302; break;     // Rank  6\n                    case 49270: spellId = 49268; break;     // Rank  7\n                    case 49271: spellId = 49269; break;     // Rank  8\n                    default:\n                        sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleDummyAuraProc: non handled spell id: %u (LO)\", procSpell->Id);\n                        return false;\n                }\n\n                // Chain Lightning\n                if (procSpell->SpellFamilyFlags[0] & 0x2)\n                {\n                    // Chain lightning has [LightOverload_Proc_Chance] / [Max_Number_of_Targets] chance to proc of each individual target hit.\n                    // A maxed LO would have a 33% / 3 = 11% chance to proc of each target.\n                    // LO chance was already \"accounted\" at the proc chance roll, now need to divide the chance by [Max_Number_of_Targets]\n                    float chance = 100.0f / procSpell->Effects[effIndex].ChainTarget;\n                    if (!roll_chance_f(chance))\n                        return false;\n\n                    // Remove cooldown (Chain Lightning - has Category Recovery time)\n                    ToPlayer()->RemoveSpellCooldown(spellId);\n                }\n\n                CastSpell(victim, spellId, true, castItem, triggeredByAura);\n\n                if (cooldown && GetTypeId() == TYPEID_PLAYER)\n                    ToPlayer()->AddSpellCooldown(dummySpell->Id, 0, time(NULL) + cooldown);\n\n                return true;\n            }\n            // Static Shock\n            if (dummySpell->SpellIconID == 3059)\n            {\n                // Lightning Shield\n                if (AuraEffect const* aurEff = GetAuraEffect(SPELL_AURA_PROC_TRIGGER_SPELL, SPELLFAMILY_SHAMAN, 0x400, 0, 0))\n                {\n                    uint32 spell = sSpellMgr->GetSpellWithRank(26364, aurEff->GetSpellInfo()->GetRank());\n\n                    // custom cooldown processing case\n                    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(spell))\n                        ToPlayer()->RemoveSpellCooldown(spell);\n\n                    CastSpell(target, spell, true, castItem, triggeredByAura);\n                    aurEff->GetBase()->DropCharge();\n                    return true;\n                }\n                return false;\n            }\n            break;\n        }\n        case SPELLFAMILY_DEATHKNIGHT:\n        {\n            // Blood-Caked Strike - Blood-Caked Blade\n            if (dummySpell->SpellIconID == 138)\n            {\n                if (!target || !target->isAlive())\n                    return false;\n\n                triggered_spell_id = dummySpell->Effects[effIndex].TriggerSpell;\n                break;\n            }\n            // Improved Blood Presence\n            if (dummySpell->SpellIconID == 2636)\n            {\n                if (GetTypeId() != TYPEID_PLAYER)\n                    return false;\n                basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                break;\n            }\n            // Butchery\n            if (dummySpell->SpellIconID == 2664)\n            {\n                basepoints0 = triggerAmount;\n                triggered_spell_id = 50163;\n                target = this;\n                break;\n            }\n            // Dancing Rune Weapon\n            if (dummySpell->Id == 49028)\n            {\n                // 1 dummy aura for dismiss rune blade\n                if (effIndex != 1)\n                    return false;\n\n                Unit* pPet = NULL;\n                for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr) // Find Rune Weapon\n                    if ((*itr)->GetEntry() == 27893)\n                    {\n                        pPet = *itr;\n                        break;\n                    }\n\n                if (pPet && pPet->getVictim() && damage && procSpell)\n                {\n                    uint32 procDmg = damage / 2;\n                    pPet->SendSpellNonMeleeDamageLog(pPet->getVictim(), procSpell->Id, procDmg, procSpell->GetSchoolMask(), 0, 0, false, 0, false);\n                    pPet->DealDamage(pPet->getVictim(), procDmg, NULL, SPELL_DIRECT_DAMAGE, procSpell->GetSchoolMask(), procSpell, true);\n                    break;\n                }\n                else\n                    return false;\n            }\n            // Mark of Blood\n            if (dummySpell->Id == 49005)\n            {\n                // TODO: need more info (cooldowns/PPM)\n                triggered_spell_id = 61607;\n                break;\n            }\n            // Unholy Blight\n            if (dummySpell->Id == 49194)\n            {\n                basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                // Glyph of Unholy Blight\n                if (AuraEffect* glyph=GetAuraEffect(63332, 0))\n                    AddPctN(basepoints0, glyph->GetAmount());\n\n                triggered_spell_id = 50536;\n                basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_DAMAGE);\n                break;\n            }\n            // Vendetta\n            if (dummySpell->SpellFamilyFlags[0] & 0x10000)\n            {\n                basepoints0 = int32(CountPctFromMaxHealth(triggerAmount));\n                triggered_spell_id = 50181;\n                target = this;\n                break;\n            }\n            // Necrosis\n            if (dummySpell->SpellIconID == 2709)\n            {\n                basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                triggered_spell_id = 51460;\n                break;\n            }\n            // Threat of Thassarian\n            if (dummySpell->SpellIconID == 2023)\n            {\n                // Must Dual Wield\n                if (!procSpell || !haveOffhandWeapon())\n                    return false;\n                // Chance as basepoints for dummy aura\n                if (!roll_chance_i(triggerAmount))\n                    return false;\n\n                switch (procSpell->Id)\n                {\n                    // Obliterate\n                    case 49020: triggered_spell_id = 66198; break;                            // Rank 1\n                    case 51423: triggered_spell_id = 66972; break;                            // Rank 2\n                    case 51424: triggered_spell_id = 66973; break;                            // Rank 3\n                    case 51425: triggered_spell_id = 66974; break;                            // Rank 4\n\n                    // Frost Strike\n                    case 49143: triggered_spell_id = 66196; break;                            // Rank 1\n                    case 51416: triggered_spell_id = 66958; break;                            // Rank 2\n                    case 51417: triggered_spell_id = 66959; break;                            // Rank 3\n                    case 51418: triggered_spell_id = 66960; break;                            // Rank 4\n                    case 51419: triggered_spell_id = 66961; break;                            // Rank 5\n                    case 55268: triggered_spell_id = 66962; break;                            // Rank 6\n\n                    // Plague Strike\n                    case 45462: triggered_spell_id = 66216; break;                            // Rank 1\n                    case 49917: triggered_spell_id = 66988; break;                            // Rank 2\n                    case 49918: triggered_spell_id = 66989; break;                            // Rank 3\n                    case 49919: triggered_spell_id = 66990; break;                            // Rank 4\n                    case 49920: triggered_spell_id = 66991; break;                            // Rank 5\n                    case 49921: triggered_spell_id = 66992; break;                            // Rank 6\n\n                    // Death Strike\n                    case 49998: triggered_spell_id = 66188; break;                            // Rank 1\n                    case 49999: triggered_spell_id = 66950; break;                            // Rank 2\n                    case 45463: triggered_spell_id = 66951; break;                            // Rank 3\n                    case 49923: triggered_spell_id = 66952; break;                            // Rank 4\n                    case 49924: triggered_spell_id = 66953; break;                            // Rank 5\n\n                    // Rune Strike\n                    case 56815: triggered_spell_id = 66217; break;                            // Rank 1\n\n                    // Blood Strike\n                    case 45902: triggered_spell_id = 66215; break;                            // Rank 1\n                    case 49926: triggered_spell_id = 66975; break;                            // Rank 2\n                    case 49927: triggered_spell_id = 66976; break;                            // Rank 3\n                    case 49928: triggered_spell_id = 66977; break;                            // Rank 4\n                    case 49929: triggered_spell_id = 66978; break;                            // Rank 5\n                    case 49930: triggered_spell_id = 66979; break;                            // Rank 6\n                    default:\n                        return false;\n                }\n                break;\n            }\n            // Runic Power Back on Snare/Root\n            if (dummySpell->Id == 61257)\n            {\n                // only for spells and hit/crit (trigger start always) and not start from self casted spells\n                if (procSpell == 0 || !(procEx & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) || this == victim)\n                    return false;\n                // Need snare or root mechanic\n                if (!(procSpell->GetAllEffectsMechanicMask() & ((1<<MECHANIC_ROOT)|(1<<MECHANIC_SNARE))))\n                    return false;\n                triggered_spell_id = 61258;\n                target = this;\n                break;\n            }\n            // Wandering Plague\n            if (dummySpell->SpellIconID == 1614)\n            {\n                if (!roll_chance_f(GetUnitCriticalChance(BASE_ATTACK, victim)))\n                    return false;\n                basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                triggered_spell_id = 50526;\n                break;\n            }\n            // Sudden Doom\n            if (dummySpell->SpellIconID == 1939 && GetTypeId() == TYPEID_PLAYER)\n            {\n                SpellChainNode const* chain = NULL;\n                // get highest rank of the Death Coil spell\n                PlayerSpellMap const& sp_list = ToPlayer()->GetSpellMap();\n                for (PlayerSpellMap::const_iterator itr = sp_list.begin(); itr != sp_list.end(); ++itr)\n                {\n                    // check if shown in spell book\n                    if (!itr->second->active || itr->second->disabled || itr->second->state == PLAYERSPELL_REMOVED)\n                        continue;\n\n                    SpellInfo const* spellProto = sSpellMgr->GetSpellInfo(itr->first);\n                    if (!spellProto)\n                        continue;\n\n                    if (spellProto->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT\n                        && spellProto->SpellFamilyFlags[0] & 0x2000)\n                    {\n                        SpellChainNode const* newChain = sSpellMgr->GetSpellChainNode(itr->first);\n\n                        // No chain entry or entry lower than found entry\n                        if (!chain || !newChain || (chain->rank < newChain->rank))\n                        {\n                            triggered_spell_id = itr->first;\n                            chain = newChain;\n                        }\n                        else\n                            continue;\n                        // Found spell is last in chain - do not need to look more\n                        // Optimisation for most common case\n                        if (chain && chain->last->Id == itr->first)\n                            break;\n                    }\n                }\n            }\n            break;\n        }\n        case SPELLFAMILY_POTION:\n        {\n            // alchemist's stone\n            if (dummySpell->Id == 17619)\n            {\n                if (procSpell->SpellFamilyName == SPELLFAMILY_POTION)\n                {\n                    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; i++)\n                    {\n                        if (procSpell->Effects[i].Effect == SPELL_EFFECT_HEAL)\n                        {\n                            triggered_spell_id = 21399;\n                        }\n                        else if (procSpell->Effects[i].Effect == SPELL_EFFECT_ENERGIZE)\n                        {\n                            triggered_spell_id = 21400;\n                        }\n                        else\n                            continue;\n\n                        basepoints0 = int32(CalculateSpellDamage(this, procSpell, i) * 0.4f);\n                        CastCustomSpell(this, triggered_spell_id, &basepoints0, NULL, NULL, true, NULL, triggeredByAura);\n                    }\n                    return true;\n                }\n            }\n            break;\n        }\n        case SPELLFAMILY_PET:\n        {\n            switch (dummySpell->SpellIconID)\n            {\n                // Guard Dog\n                case 201:\n                {\n                    if (!victim)\n                        return false;\n\n                    triggered_spell_id = 54445;\n                    target = this;\n                    float addThreat = float(CalculatePctN(procSpell->Effects[0].CalcValue(this), triggerAmount));\n                    victim->AddThreat(this, addThreat);\n                    break;\n                }\n                // Silverback\n                case 1582:\n                    triggered_spell_id = dummySpell->Id == 62765 ? 62801 : 62800;\n                    target = this;\n                    break;\n            }\n            break;\n        }\n        default:\n            break;\n    }\n\n    // if not handled by custom case, get triggered spell from dummySpell proto\n    if (!triggered_spell_id)\n        triggered_spell_id = dummySpell->Effects[triggeredByAura->GetEffIndex()].TriggerSpell;\n\n    // processed charge only counting case\n    if (!triggered_spell_id)\n        return true;\n\n    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);\n    if (!triggerEntry)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleDummyAuraProc: Spell %u has non-existing triggered spell %u\", dummySpell->Id, triggered_spell_id);\n        return false;\n    }\n\n    if (cooldown_spell_id == 0)\n        cooldown_spell_id = triggered_spell_id;\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(cooldown_spell_id))\n        return false;\n\n    if (basepoints0)\n        CastCustomSpell(target, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura, originalCaster);\n    else\n        CastSpell(target, triggered_spell_id, true, castItem, triggeredByAura, originalCaster);\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->AddSpellCooldown(cooldown_spell_id, 0, time(NULL) + cooldown);\n\n    return true;\n}\nbool Unit::HandleObsModEnergyAuraProc(Unit* victim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellInfo const* /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)\n{\n    SpellInfo const* dummySpell = triggeredByAura->GetSpellInfo();\n    //uint32 effIndex = triggeredByAura->GetEffIndex();\n    //int32  triggerAmount = triggeredByAura->GetAmount();\n\n    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER\n        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;\n\n    uint32 triggered_spell_id = 0;\n    Unit* target = victim;\n    int32 basepoints0 = 0;\n\n    switch (dummySpell->SpellFamilyName)\n    {\n        case SPELLFAMILY_HUNTER:\n        {\n            // Aspect of the Viper\n            if (dummySpell->SpellFamilyFlags[1] & 0x40000)\n            {\n                uint32 maxmana = GetMaxPower(POWER_MANA);\n                basepoints0 = CalculatePctF(maxmana, GetAttackTime(RANGED_ATTACK) / 1000.0f);\n                target = this;\n                triggered_spell_id = 34075;\n                break;\n            }\n            break;\n        }\n    }\n    // processed charge only counting case\n    if (!triggered_spell_id)\n        return true;\n\n    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);\n\n    // Try handle unknown trigger spells\n    if (!triggerEntry)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleObsModEnergyAuraProc: Spell %u has non-existing triggered spell %u\", dummySpell->Id, triggered_spell_id);\n        return false;\n    }\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(triggered_spell_id))\n        return false;\n    if (basepoints0)\n        CastCustomSpell(target, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);\n    else\n        CastSpell(target, triggered_spell_id, true, castItem, triggeredByAura);\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->AddSpellCooldown(triggered_spell_id, 0, time(NULL) + cooldown);\n    return true;\n}\nbool Unit::HandleModDamagePctTakenAuraProc(Unit* victim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellInfo const* /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)\n{\n    SpellInfo const* dummySpell = triggeredByAura->GetSpellInfo();\n    //uint32 effIndex = triggeredByAura->GetEffIndex();\n    //int32  triggerAmount = triggeredByAura->GetAmount();\n\n    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER\n        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;\n\n    uint32 triggered_spell_id = 0;\n    Unit* target = victim;\n    int32 basepoints0 = 0;\n\n    switch (dummySpell->SpellFamilyName)\n    {\n        case SPELLFAMILY_PALADIN:\n        {\n            // Blessing of Sanctuary\n            if (dummySpell->SpellFamilyFlags[0] & 0x10000000)\n            {\n                switch (getPowerType())\n                {\n                    case POWER_MANA:   triggered_spell_id = 57319; break;\n                    default:\n                        return false;\n                }\n            }\n            break;\n        }\n    }\n    // processed charge only counting case\n    if (!triggered_spell_id)\n        return true;\n\n    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);\n\n    if (!triggerEntry)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleModDamagePctTakenAuraProc: Spell %u has non-existing triggered spell %u\", dummySpell->Id, triggered_spell_id);\n        return false;\n    }\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(triggered_spell_id))\n        return false;\n\n    if (basepoints0)\n        CastCustomSpell(target, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);\n    else\n        CastSpell(target, triggered_spell_id, true, castItem, triggeredByAura);\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->AddSpellCooldown(triggered_spell_id, 0, time(NULL) + cooldown);\n\n    return true;\n}\n\n// Used in case when access to whole aura is needed\n// All procs should be handled like this...\nbool Unit::HandleAuraProc(Unit* victim, uint32 damage, Aura* triggeredByAura, SpellInfo const* procSpell, uint32 /*procFlag*/, uint32 procEx, uint32 cooldown, bool * handled)\n{\n    SpellInfo const* dummySpell = triggeredByAura->GetSpellInfo();\n\n    switch (dummySpell->SpellFamilyName)\n    {\n        case SPELLFAMILY_GENERIC:\n            switch (dummySpell->Id)\n            {\n                // Nevermelting Ice Crystal\n                case 71564:\n                    RemoveAuraFromStack(71564);\n                    *handled = true;\n                    break;\n                // Gaseous Bloat\n                case 70672:\n                case 72455:\n                case 72832:\n                case 72833:\n                {\n                    *handled = true;\n                    uint32 stack = triggeredByAura->GetStackAmount();\n                    int32 const mod = (GetMap()->GetSpawnMode() & 1) ? 1500 : 1250;\n                    int32 dmg = 0;\n                    for (uint8 i = 1; i < stack; ++i)\n                        dmg += mod * stack;\n                    if (Unit* caster = triggeredByAura->GetCaster())\n                        caster->CastCustomSpell(70701, SPELLVALUE_BASE_POINT0, dmg);\n                    break;\n                }\n                // Ball of Flames Proc\n                case 71756:\n                case 72782:\n                case 72783:\n                case 72784:\n                    RemoveAuraFromStack(dummySpell->Id);\n                    *handled = true;\n                    break;\n                // Discerning Eye of the Beast\n                case 59915:\n                {\n                    CastSpell(this, 59914, true);   // 59914 already has correct basepoints in DBC, no need for custom bp\n                    *handled = true;\n                    break;\n                }\n                // Swift Hand of Justice\n                case 59906:\n                {\n                    int32 bp0 = CalculatePctN(GetMaxHealth(), dummySpell->Effects[EFFECT_0]. CalcValue());\n                    CastCustomSpell(this, 59913, &bp0, NULL, NULL, true);\n                    *handled = true;\n                    break;\n                }\n            }\n\n            break;\n        case SPELLFAMILY_PALADIN:\n        {\n            // Infusion of Light\n            if (dummySpell->SpellIconID == 3021)\n            {\n                // Flash of Light HoT on Flash of Light when Sacred Shield active\n                if (procSpell->SpellFamilyFlags[0] & 0x40000000 && procSpell->SpellIconID == 242)\n                {\n                    *handled = true;\n                    if (victim && victim->HasAura(53601))\n                    {\n                        int32 bp0 = CalculatePctN(int32(damage / 12), dummySpell->Effects[EFFECT_2].CalcValue());\n                        // Item - Paladin T9 Holy 4P Bonus\n                        if (AuraEffect const* aurEff = GetAuraEffect(67191, 0))\n                            AddPctN(bp0, aurEff->GetAmount());\n                        CastCustomSpell(victim, 66922, &bp0, NULL, NULL, true);\n                        return true;\n                    }\n                }\n                // but should not proc on non-critical Holy Shocks\n                else if ((procSpell->SpellFamilyFlags[0] & 0x200000 || procSpell->SpellFamilyFlags[1] & 0x10000) && !(procEx & PROC_EX_CRITICAL_HIT))\n                    *handled = true;\n                break;\n            }\n            // Judgements of the Just\n            else if (dummySpell->SpellIconID == 3015)\n            {\n                *handled = true;\n                CastSpell(victim, 68055, true);\n                return true;\n            }\n            // Glyph of Divinity\n            else if (dummySpell->Id == 54939)\n            {\n                *handled = true;\n                // Check if we are the target and prevent mana gain\n                if (victim && triggeredByAura->GetCasterGUID() == victim->GetGUID())\n                    return false;\n                // Lookup base amount mana restore\n                for (uint8 i = 0; i < MAX_SPELL_EFFECTS; i++)\n                {\n                    if (procSpell->Effects[i].Effect == SPELL_EFFECT_ENERGIZE)\n                    {\n                        // value multiplied by 2 because you should get twice amount\n                        int32 mana = procSpell->Effects[i].CalcValue() * 2;\n                        CastCustomSpell(this, 54986, 0, &mana, NULL, true);\n                    }\n                }\n                return true;\n            }\n            break;\n        }\n        case SPELLFAMILY_MAGE:\n        {\n            // Combustion\n            switch (dummySpell->Id)\n            {\n                case 11129:\n                {\n                    *handled = true;\n                    Unit* caster = triggeredByAura->GetCaster();\n                    if (!caster || !damage)\n                        return false;\n\n                    // last charge and crit\n                    if (triggeredByAura->GetCharges() <= 1 && (procEx & PROC_EX_CRITICAL_HIT))\n                        return true;                        // charge counting (will removed)\n\n                    CastSpell(this, 28682, true);\n\n                    return (procEx & PROC_EX_CRITICAL_HIT) ? true : false;\n                }\n                // Empowered Fire\n                case 31656:\n                case 31657:\n                case 31658:\n                {\n                    *handled = true;\n\n                    SpellInfo const* spInfo = sSpellMgr->GetSpellInfo(67545);\n                    if (!spInfo)\n                        return false;\n\n                    int32 bp0 = int32(CalculatePctN(GetCreateMana(), spInfo->Effects[0].CalcValue()));\n                    CastCustomSpell(this, 67545, &bp0, NULL, NULL, true, NULL, triggeredByAura->GetEffect(EFFECT_0), GetGUID());\n                    return true;\n                }\n            }\n            break;\n        }\n        case SPELLFAMILY_DEATHKNIGHT:\n        {\n            // Blood of the North\n            // Reaping\n            // Death Rune Mastery\n            if (dummySpell->SpellIconID == 3041 || dummySpell->SpellIconID == 22 || dummySpell->SpellIconID == 2622)\n            {\n                *handled = true;\n                // Convert recently used Blood Rune to Death Rune\n                if (Player* player = ToPlayer())\n                {\n                    if (player->getClass() != CLASS_DEATH_KNIGHT)\n                        return false;\n\n                    RuneType rune = ToPlayer()->GetLastUsedRune();\n                    // can't proc from death rune use\n                    if (rune == RUNE_DEATH)\n                        return false;\n                    AuraEffect* aurEff = triggeredByAura->GetEffect(EFFECT_0);\n                    if (!aurEff)\n                        return false;\n\n                    // Reset amplitude - set death rune remove timer to 30s\n                    aurEff->ResetPeriodic(true);\n                    uint32 runesLeft;\n\n                    if (dummySpell->SpellIconID == 2622)\n                        runesLeft = 2;\n                    else\n                        runesLeft = 1;\n\n                    for (uint8 i = 0; i < MAX_RUNES && runesLeft; ++i)\n                    {\n                        if (dummySpell->SpellIconID == 2622)\n                        {\n                            if (player->GetCurrentRune(i) == RUNE_DEATH ||\n                                player->GetBaseRune(i) == RUNE_BLOOD)\n                                continue;\n                        }\n                        else\n                        {\n                            if (player->GetCurrentRune(i) == RUNE_DEATH ||\n                                player->GetBaseRune(i) != RUNE_BLOOD)\n                                continue;\n                        }\n                        if (player->GetRuneCooldown(i) != player->GetRuneBaseCooldown(i))\n                            continue;\n\n                        --runesLeft;\n                        // Mark aura as used\n                        player->AddRuneByAuraEffect(i, RUNE_DEATH, aurEff);\n                    }\n                    return true;\n                }\n                return false;\n            }\n\n            switch (dummySpell->Id)\n            {\n                // Bone Shield cooldown\n                case 49222:\n                {\n                    *handled = true;\n                    if (cooldown && GetTypeId() == TYPEID_PLAYER)\n                    {\n                        if (ToPlayer()->HasSpellCooldown(100000))\n                            return false;\n                        ToPlayer()->AddSpellCooldown(100000, 0, time(NULL) + cooldown);\n                    }\n                    return true;\n                }\n                // Hungering Cold aura drop\n                case 51209:\n                    *handled = true;\n                    // Drop only in not disease case\n                    if (procSpell && procSpell->Dispel == DISPEL_DISEASE)\n                        return false;\n                    return true;\n            }\n            break;\n        }\n        case SPELLFAMILY_WARRIOR:\n        {\n            switch (dummySpell->Id)\n            {\n                // Item - Warrior T10 Protection 4P Bonus\n                case 70844:\n                {\n                    int32 basepoints0 = CalculatePctN(GetMaxHealth(), dummySpell->Effects[EFFECT_1]. CalcValue());\n                    CastCustomSpell(this, 70845, &basepoints0, NULL, NULL, true);\n                    break;\n                }\n                // Recklessness\n                case 1719:\n                {\n                    //! Possible hack alert\n                    //! Don't drop charges on proc, they will be dropped on SpellMod removal\n                    //! Before this change, it was dropping two charges per attack, one in ProcDamageAndSpellFor, and one in RemoveSpellMods.\n                    //! The reason of this behaviour is Recklessness having three auras, 2 of them can not proc (isTriggeredAura array) but the other one can, making the whole spell proc.\n                    *handled = true;\n                    break;\n                }\n                default:\n                    break;\n            }\n            break;\n        }\n    }\n    return false;\n}\n\nbool Unit::HandleProcTriggerSpell(Unit* victim, uint32 damage, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlags, uint32 procEx, uint32 cooldown)\n{\n    // Get triggered aura spell info\n    SpellInfo const* auraSpellInfo = triggeredByAura->GetSpellInfo();\n\n    // Basepoints of trigger aura\n    int32 triggerAmount = triggeredByAura->GetAmount();\n\n    // Set trigger spell id, target, custom basepoints\n    uint32 trigger_spell_id = auraSpellInfo->Effects[triggeredByAura->GetEffIndex()].TriggerSpell;\n\n    Unit*  target = NULL;\n    int32  basepoints0 = 0;\n\n    if (triggeredByAura->GetAuraType() == SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE)\n        basepoints0 = triggerAmount;\n\n    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER\n        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;\n\n    // Try handle unknown trigger spells\n    if (sSpellMgr->GetSpellInfo(trigger_spell_id) == NULL)\n    {\n        switch (auraSpellInfo->SpellFamilyName)\n        {\n            case SPELLFAMILY_GENERIC:\n                switch (auraSpellInfo->Id)\n                {\n                    case 23780:             // Aegis of Preservation (Aegis of Preservation trinket)\n                        trigger_spell_id = 23781;\n                        break;\n                    case 33896:             // Desperate Defense (Stonescythe Whelp, Stonescythe Alpha, Stonescythe Ambusher)\n                        trigger_spell_id = 33898;\n                        break;\n                    case 43820:             // Charm of the Witch Doctor (Amani Charm of the Witch Doctor trinket)\n                        // Pct value stored in dummy\n                        basepoints0 = victim->GetCreateHealth() * auraSpellInfo->Effects[1].CalcValue() / 100;\n                        target = victim;\n                        break;\n                    case 57345:             // Darkmoon Card: Greatness\n                    {\n                        float stat = 0.0f;\n                        // strength\n                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 60229;stat = GetStat(STAT_STRENGTH); }\n                        // agility\n                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 60233;stat = GetStat(STAT_AGILITY);  }\n                        // intellect\n                        if (GetStat(STAT_INTELLECT)> stat) { trigger_spell_id = 60234;stat = GetStat(STAT_INTELLECT);}\n                        // spirit\n                        if (GetStat(STAT_SPIRIT)   > stat) { trigger_spell_id = 60235;                               }\n                        break;\n                    }\n                    case 64568:             // Blood Reserve\n                    {\n                        if (HealthBelowPctDamaged(35, damage))\n                        {\n                            CastCustomSpell(this, 64569, &triggerAmount, NULL, NULL, true);\n                            RemoveAura(64568);\n                        }\n                        return false;\n                    }\n                    case 67702:             // Death's Choice, Item - Coliseum 25 Normal Melee Trinket\n                    {\n                        float stat = 0.0f;\n                        // strength\n                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 67708;stat = GetStat(STAT_STRENGTH); }\n                        // agility\n                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 67703;                               }\n                        break;\n                    }\n                    case 67771:             // Death's Choice (heroic), Item - Coliseum 25 Heroic Melee Trinket\n                    {\n                        float stat = 0.0f;\n                        // strength\n                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 67773;stat = GetStat(STAT_STRENGTH); }\n                        // agility\n                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 67772;                               }\n                        break;\n                    }\n                    // Mana Drain Trigger\n                    case 27522:\n                    case 40336:\n                    {\n                        // On successful melee or ranged attack gain $29471s1 mana and if possible drain $27526s1 mana from the target.\n                        if (this && isAlive())\n                            CastSpell(this, 29471, true, castItem, triggeredByAura);\n                        if (victim && victim->isAlive())\n                            CastSpell(victim, 27526, true, castItem, triggeredByAura);\n                        return true;\n                    }\n                    // Evasive Maneuvers\n                    case 50240:\n                    {\n                        // Remove a Evasive Charge\n                        Aura* charge = GetAura(50241);\n                        if (charge->ModStackAmount(-1, AURA_REMOVE_BY_ENEMY_SPELL))\n                            RemoveAurasDueToSpell(50240);\n                    }\n                }\n                break;\n            case SPELLFAMILY_MAGE:\n                if (auraSpellInfo->SpellIconID == 2127)     // Blazing Speed\n                {\n                    switch (auraSpellInfo->Id)\n                    {\n                        case 31641:  // Rank 1\n                        case 31642:  // Rank 2\n                            trigger_spell_id = 31643;\n                            break;\n                        default:\n                            sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleProcTriggerSpell: Spell %u miss posibly Blazing Speed\", auraSpellInfo->Id);\n                            return false;\n                    }\n                }\n                break;\n            case SPELLFAMILY_WARRIOR:\n                if (auraSpellInfo->Id == 50421)             // Scent of Blood\n                {\n                    CastSpell(this, 50422, true);\n                    RemoveAuraFromStack(auraSpellInfo->Id);\n                    return false;\n                }\n                if (auraSpellInfo->Id == 50720)\n                {\n                    target = triggeredByAura->GetCaster();\n                    if (!target)\n                        return false;\n                }\n                break;\n            case SPELLFAMILY_WARLOCK:\n            {\n                // Drain Soul\n                if (auraSpellInfo->SpellFamilyFlags[0] & 0x4000)\n                {\n                    // Improved Drain Soul\n                    Unit::AuraEffectList const& mAddFlatModifier = GetAuraEffectsByType(SPELL_AURA_DUMMY);\n                    for (Unit::AuraEffectList::const_iterator i = mAddFlatModifier.begin(); i != mAddFlatModifier.end(); ++i)\n                    {\n                        if ((*i)->GetMiscValue() == SPELLMOD_CHANCE_OF_SUCCESS && (*i)->GetSpellInfo()->SpellIconID == 113)\n                        {\n                            int32 value2 = CalculateSpellDamage(this, (*i)->GetSpellInfo(), 2);\n                            basepoints0 = int32(CalculatePctN(GetMaxPower(POWER_MANA), value2));\n                            // Drain Soul\n                            CastCustomSpell(this, 18371, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);\n                            break;\n                        }\n                    }\n                    // Not remove charge (aura removed on death in any cases)\n                    // Need for correct work Drain Soul SPELL_AURA_CHANNEL_DEATH_ITEM aura\n                    return false;\n                }\n                // Nether Protection\n                else if (auraSpellInfo->SpellIconID == 1985)\n                {\n                    if (!procSpell)\n                        return false;\n                    switch (GetFirstSchoolInMask(procSpell->GetSchoolMask()))\n                    {\n                        case SPELL_SCHOOL_NORMAL:\n                            return false;                   // ignore\n                        case SPELL_SCHOOL_HOLY:   trigger_spell_id = 54370; break;\n                        case SPELL_SCHOOL_FIRE:   trigger_spell_id = 54371; break;\n                        case SPELL_SCHOOL_NATURE: trigger_spell_id = 54375; break;\n                        case SPELL_SCHOOL_FROST:  trigger_spell_id = 54372; break;\n                        case SPELL_SCHOOL_SHADOW: trigger_spell_id = 54374; break;\n                        case SPELL_SCHOOL_ARCANE: trigger_spell_id = 54373; break;\n                        default:\n                            return false;\n                    }\n                }\n                break;\n            }\n            case SPELLFAMILY_PRIEST:\n            {\n                // Greater Heal Refund\n                if (auraSpellInfo->Id == 37594)\n                    trigger_spell_id = 37595;\n                // Blessed Recovery\n                else if (auraSpellInfo->SpellIconID == 1875)\n                {\n                    switch (auraSpellInfo->Id)\n                    {\n                        case 27811: trigger_spell_id = 27813; break;\n                        case 27815: trigger_spell_id = 27817; break;\n                        case 27816: trigger_spell_id = 27818; break;\n                        default:\n                            sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleProcTriggerSpell: Spell %u not handled in BR\", auraSpellInfo->Id);\n                        return false;\n                    }\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount) / 3;\n                    target = this;\n                    // Add remaining ticks to healing done\n                    basepoints0 += GetRemainingPeriodicAmount(GetGUID(), trigger_spell_id, SPELL_AURA_PERIODIC_HEAL);\n                }\n                break;\n            }\n            case SPELLFAMILY_DRUID:\n            {\n                switch (auraSpellInfo->Id)\n                {\n                    // Druid Forms Trinket\n                    case 37336:\n                    {\n                        switch (GetShapeshiftForm())\n                        {\n                            case FORM_NONE:     trigger_spell_id = 37344; break;\n                            case FORM_CAT:      trigger_spell_id = 37341; break;\n                            case FORM_BEAR:\n                            case FORM_DIREBEAR: trigger_spell_id = 37340; break;\n                            case FORM_TREE:     trigger_spell_id = 37342; break;\n                            case FORM_MOONKIN:  trigger_spell_id = 37343; break;\n                            default:\n                                return false;\n                        }\n                        break;\n                    }\n                    // Druid T9 Feral Relic (Lacerate, Swipe, Mangle, and Shred)\n                    case 67353:\n                    {\n                        switch (GetShapeshiftForm())\n                        {\n                            case FORM_CAT:      trigger_spell_id = 67355; break;\n                            case FORM_BEAR:\n                            case FORM_DIREBEAR: trigger_spell_id = 67354; break;\n                            default:\n                                return false;\n                        }\n                        break;\n                    }\n                    default:\n                        break;\n                }\n                break;\n            }\n            case SPELLFAMILY_HUNTER:\n            {\n                if (auraSpellInfo->SpellIconID == 3247)     // Piercing Shots\n                {\n                    switch (auraSpellInfo->Id)\n                    {\n                        case 53234:  // Rank 1\n                        case 53237:  // Rank 2\n                        case 53238:  // Rank 3\n                            trigger_spell_id = 63468;\n                            break;\n                        default:\n                            sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleProcTriggerSpell: Spell %u miss posibly Piercing Shots\", auraSpellInfo->Id);\n                            return false;\n                    }\n                    SpellInfo const* TriggerPS = sSpellMgr->GetSpellInfo(trigger_spell_id);\n                    if (!TriggerPS)\n                        return false;\n\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount) / (TriggerPS->GetMaxDuration() / TriggerPS->Effects[0].Amplitude);\n                    basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), trigger_spell_id, SPELL_AURA_PERIODIC_DAMAGE);\n                    break;\n                }\n                // Item - Hunter T9 4P Bonus\n                if (auraSpellInfo->Id == 67151)\n                {\n                    trigger_spell_id = 68130;\n                    target = this;\n                    break;\n                }\n                break;\n            }\n            case SPELLFAMILY_PALADIN:\n            {\n                switch (auraSpellInfo->Id)\n                {\n                    // Healing Discount\n                    case 37705:\n                    {\n                        trigger_spell_id = 37706;\n                        target = this;\n                        break;\n                    }\n                    // Soul Preserver\n                    case 60510:\n                    {\n                        switch (getClass())\n                        {\n                            case CLASS_DRUID:\n                                trigger_spell_id = 60512;\n                                break;\n                            case CLASS_PALADIN:\n                                trigger_spell_id = 60513;\n                                break;\n                            case CLASS_PRIEST:\n                                trigger_spell_id = 60514;\n                                break;\n                            case CLASS_SHAMAN:\n                                trigger_spell_id = 60515;\n                                break;\n                        }\n\n                        target = this;\n                        break;\n                    }\n                    case 37657: // Lightning Capacitor\n                    case 54841: // Thunder Capacitor\n                    case 67712: // Item - Coliseum 25 Normal Caster Trinket\n                    case 67758: // Item - Coliseum 25 Heroic Caster Trinket\n                    {\n                        if (!victim || !victim->isAlive() || GetTypeId() != TYPEID_PLAYER)\n                            return false;\n\n                        uint32 stack_spell_id = 0;\n                        switch (auraSpellInfo->Id)\n                        {\n                            case 37657:\n                                stack_spell_id = 37658;\n                                trigger_spell_id = 37661;\n                                break;\n                            case 54841:\n                                stack_spell_id = 54842;\n                                trigger_spell_id = 54843;\n                                break;\n                            case 67712:\n                                stack_spell_id = 67713;\n                                trigger_spell_id = 67714;\n                                break;\n                            case 67758:\n                                stack_spell_id = 67759;\n                                trigger_spell_id = 67760;\n                                break;\n                        }\n\n                        CastSpell(this, stack_spell_id, true, NULL, triggeredByAura);\n\n                        Aura* dummy = GetAura(stack_spell_id);\n                        if (!dummy || dummy->GetStackAmount() < triggerAmount)\n                            return false;\n\n                        RemoveAurasDueToSpell(stack_spell_id);\n                        target = victim;\n                        break;\n                    }\n                    default:\n                        // Illumination\n                        if (auraSpellInfo->SpellIconID == 241)\n                        {\n                            if (!procSpell)\n                                return false;\n                            // procspell is triggered spell but we need mana cost of original casted spell\n                            uint32 originalSpellId = procSpell->Id;\n                            // Holy Shock heal\n                            if (procSpell->SpellFamilyFlags[1] & 0x00010000)\n                            {\n                                switch (procSpell->Id)\n                                {\n                                    case 25914: originalSpellId = 20473; break;\n                                    case 25913: originalSpellId = 20929; break;\n                                    case 25903: originalSpellId = 20930; break;\n                                    case 27175: originalSpellId = 27174; break;\n                                    case 33074: originalSpellId = 33072; break;\n                                    case 48820: originalSpellId = 48824; break;\n                                    case 48821: originalSpellId = 48825; break;\n                                    default:\n                                        sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleProcTriggerSpell: Spell %u not handled in HShock\", procSpell->Id);\n                                       return false;\n                                }\n                            }\n                            SpellInfo const* originalSpell = sSpellMgr->GetSpellInfo(originalSpellId);\n                            if (!originalSpell)\n                            {\n                                sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleProcTriggerSpell: Spell %u unknown but selected as original in Illu\", originalSpellId);\n                                return false;\n                            }\n                            // percent stored in effect 1 (class scripts) base points\n                            int32 cost = int32(originalSpell->ManaCost + CalculatePctU(GetCreateMana(), originalSpell->ManaCostPercentage));\n                            basepoints0 = CalculatePctN(cost, auraSpellInfo->Effects[1].CalcValue());\n                            trigger_spell_id = 20272;\n                            target = this;\n                        }\n                        break;\n                }\n                break;\n            }\n            case SPELLFAMILY_SHAMAN:\n            {\n                switch (auraSpellInfo->Id)\n                {\n                    // Lightning Shield (The Ten Storms set)\n                    case 23551:\n                    {\n                        trigger_spell_id = 23552;\n                        target = victim;\n                        break;\n                    }\n                    // Damage from Lightning Shield (The Ten Storms set)\n                    case 23552:\n                    {\n                        trigger_spell_id = 27635;\n                        break;\n                    }\n                    // Mana Surge (The Earthfury set)\n                    case 23572:\n                    {\n                        if (!procSpell)\n                            return false;\n                        basepoints0 = int32(CalculatePctN(procSpell->ManaCost, 35));\n                        trigger_spell_id = 23571;\n                        target = this;\n                        break;\n                    }\n                    case 30881: // Nature's Guardian Rank 1\n                    case 30883: // Nature's Guardian Rank 2\n                    case 30884: // Nature's Guardian Rank 3\n                    case 30885: // Nature's Guardian Rank 4\n                    case 30886: // Nature's Guardian Rank 5\n                    {\n                        if (HealthBelowPct(30))\n                        {\n                            basepoints0 = int32(auraSpellInfo->Effects[EFFECT_0].CalcValue() * GetMaxHealth() / 100.0f);\n                            target = this;\n                            trigger_spell_id = 31616;\n                            // TODO: Threat part\n                        }\n                        else\n                            return false;\n                        break;\n                    }\n                    default:\n                    {\n                        // Lightning Shield (overwrite non existing triggered spell call in spell.dbc\n                        if (auraSpellInfo->SpellFamilyFlags[0] & 0x400)\n                        {\n                            trigger_spell_id = sSpellMgr->GetSpellWithRank(26364, auraSpellInfo->GetRank());\n                        }\n                        // Nature's Guardian\n                        else if (auraSpellInfo->SpellIconID == 2013)\n                        {\n                            // Check health condition - should drop to less 30% (damage deal after this!)\n                            if (!HealthBelowPctDamaged(30, damage))\n                                return false;\n\n                             if (victim && victim->isAlive())\n                                 victim->getThreatManager().modifyThreatPercent(this, -10);\n\n                            basepoints0 = int32(CountPctFromMaxHealth(triggerAmount));\n                            trigger_spell_id = 31616;\n                            target = this;\n                        }\n                    }\n                }\n                break;\n            }\n            case SPELLFAMILY_DEATHKNIGHT:\n            {\n                // Acclimation\n                if (auraSpellInfo->SpellIconID == 1930)\n                {\n                    if (!procSpell)\n                        return false;\n                    switch (GetFirstSchoolInMask(procSpell->GetSchoolMask()))\n                    {\n                        case SPELL_SCHOOL_NORMAL:\n                            return false;                   // ignore\n                        case SPELL_SCHOOL_HOLY:   trigger_spell_id = 50490; break;\n                        case SPELL_SCHOOL_FIRE:   trigger_spell_id = 50362; break;\n                        case SPELL_SCHOOL_NATURE: trigger_spell_id = 50488; break;\n                        case SPELL_SCHOOL_FROST:  trigger_spell_id = 50485; break;\n                        case SPELL_SCHOOL_SHADOW: trigger_spell_id = 50489; break;\n                        case SPELL_SCHOOL_ARCANE: trigger_spell_id = 50486; break;\n                        default:\n                            return false;\n                    }\n                }\n                // Blood Presence (Improved)\n                else if (auraSpellInfo->Id == 63611)\n                {\n                    if (GetTypeId() != TYPEID_PLAYER)\n                        return false;\n\n                    trigger_spell_id = 50475;\n                    basepoints0 = CalculatePctN(int32(damage), triggerAmount);\n                }\n                // Item - Death Knight T10 Melee 4P Bonus\n                else if (auraSpellInfo->Id == 70656)\n                {\n                    if (GetTypeId() != TYPEID_PLAYER || getClass() != CLASS_DEATH_KNIGHT)\n                        return false;\n\n                    for (uint8 i = 0; i < MAX_RUNES; ++i)\n                        if (ToPlayer()->GetRuneCooldown(i) == 0)\n                            return false;\n                }\n                break;\n            }\n            case SPELLFAMILY_ROGUE:\n            {\n                switch (auraSpellInfo->Id)\n                {\n                    // Rogue T10 2P bonus, should only proc on caster\n                    case 70805:\n                    {\n                        if (victim != this)\n                            return false;\n                        break;\n                    }\n                    // Rogue T10 4P bonus, should proc on victim\n                    case 70803:\n                    {\n                        target = victim;\n                        break;\n                    }\n                }\n                break;\n            }\n            default:\n                 break;\n        }\n    }\n\n    // All ok. Check current trigger spell\n    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(trigger_spell_id);\n    if (triggerEntry == NULL)\n    {\n        // Don't cast unknown spell\n        // sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleProcTriggerSpell: Spell %u has 0 in EffectTriggered[%d]. Unhandled custom case?\", auraSpellInfo->Id, triggeredByAura->GetEffIndex());\n        return false;\n    }\n\n    // not allow proc extra attack spell at extra attack\n    if (m_extraAttacks && triggerEntry->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))\n        return false;\n\n    // Custom requirements (not listed in procEx) Warning! damage dealing after this\n    // Custom triggered spells\n    switch (auraSpellInfo->Id)\n    {\n        // Deep Wounds\n        case 12834:\n        case 12849:\n        case 12867:\n        {\n            if (GetTypeId() != TYPEID_PLAYER)\n                return false;\n\n            // now compute approximate weapon damage by formula from wowwiki.com\n            Item* item = NULL;\n            if (procFlags & PROC_FLAG_DONE_OFFHAND_ATTACK)\n                item = ToPlayer()->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);\n            else\n                item = ToPlayer()->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);\n\n            // dunno if it's really needed but will prevent any possible crashes\n            if (!item)\n                return false;\n\n            ItemTemplate const* weapon = item->GetTemplate();\n\n            float weaponDPS = weapon->getDPS();\n            float attackPower = GetTotalAttackPowerValue(BASE_ATTACK) / 14.0f;\n            float weaponSpeed = float(weapon->Delay) / 1000.0f;\n            basepoints0 = int32((weaponDPS + attackPower) * weaponSpeed);\n            break;\n        }\n        // Persistent Shield (Scarab Brooch trinket)\n        // This spell originally trigger 13567 - Dummy Trigger (vs dummy efect)\n        case 26467:\n        {\n            basepoints0 = int32(CalculatePctN(damage, 15));\n            target = victim;\n            trigger_spell_id = 26470;\n            break;\n        }\n        // Unyielding Knights (item exploit 29108\\29109)\n        case 38164:\n        {\n            if (!victim || victim->GetEntry() != 19457)  // Proc only if your target is Grillok\n                return false;\n            break;\n        }\n        // Deflection\n        case 52420:\n        {\n            if (!HealthBelowPct(35))\n                return false;\n            break;\n        }\n\n        // Cheat Death\n        case 28845:\n        {\n            // When your health drops below 20%\n            if (HealthBelowPctDamaged(20, damage) || HealthBelowPct(20))\n                return false;\n            break;\n        }\n        // Deadly Swiftness (Rank 1)\n        case 31255:\n        {\n            // whenever you deal damage to a target who is below 20% health.\n            if (!victim || !victim->isAlive() || victim->HealthAbovePct(20))\n                return false;\n\n            target = this;\n            trigger_spell_id = 22588;\n        }\n        // Greater Heal Refund (Avatar Raiment set)\n        case 37594:\n        {\n            if (!victim || !victim->isAlive())\n                return false;\n\n            // Doesn't proc if target already has full health\n            if (victim->IsFullHealth())\n                return false;\n            // If your Greater Heal brings the target to full health, you gain $37595s1 mana.\n            if (victim->GetHealth() + damage < victim->GetMaxHealth())\n                return false;\n            break;\n        }\n        // Bonus Healing (Crystal Spire of Karabor mace)\n        case 40971:\n        {\n            // If your target is below $s1% health\n            if (!victim || !victim->isAlive() || victim->HealthAbovePct(triggerAmount))\n                return false;\n            break;\n        }\n        // Rapid Recuperation\n        case 53228:\n        case 53232:\n        {\n            // This effect only from Rapid Fire (ability cast)\n            if (!(procSpell->SpellFamilyFlags[0] & 0x20))\n                return false;\n            break;\n        }\n        // Decimation\n        case 63156:\n        case 63158:\n            // Can proc only if target has hp below 35%\n            if (!victim || !victim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, procSpell, this))\n                return false;\n            break;\n        // Deathbringer Saurfang - Blood Beast's Blood Link\n        case 72176:\n            basepoints0 = 3;\n            break;\n        case 15337: // Improved Spirit Tap (Rank 1)\n        case 15338: // Improved Spirit Tap (Rank 2)\n        {\n            if (procSpell->SpellFamilyFlags[0] & 0x800000)\n                if ((procSpell->Id != 58381) || !roll_chance_i(50))\n                    return false;\n\n            target = victim;\n            break;\n        }\n        // Professor Putricide - Ooze Spell Tank Protection\n        case 71770:\n            if (victim)\n                victim->CastSpell(victim, trigger_spell_id, true);    // EffectImplicitTarget is self\n            return true;\n        case 45057: // Evasive Maneuvers (Commendation of Kael`thas trinket)\n        case 71634: // Item - Icecrown 25 Normal Tank Trinket 1\n        case 71640: // Item - Icecrown 25 Heroic Tank Trinket 1\n        case 75475: // Item - Chamber of Aspects 25 Normal Tank Trinket\n        case 75481: // Item - Chamber of Aspects 25 Heroic Tank Trinket\n        {\n            // Procs only if damage takes health below $s1%\n            if (!HealthBelowPctDamaged(triggerAmount, damage))\n                return false;\n            break;\n        }\n        default:\n            break;\n    }\n\n    // Blade Barrier\n    if (auraSpellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && auraSpellInfo->SpellIconID == 85 && procSpell)\n    {\n        Player* player = ToPlayer();\n        if (!player || player->getClass() != CLASS_DEATH_KNIGHT)\n            return false;\n\n        if (!player->IsBaseRuneSlotsOnCooldown(RUNE_BLOOD))\n            return false;\n    }\n\n    // Rime\n    else if (auraSpellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && auraSpellInfo->SpellIconID == 56)\n    {\n        if (GetTypeId() != TYPEID_PLAYER)\n            return false;\n\n        // Howling Blast\n        ToPlayer()->RemoveSpellCategoryCooldown(1248, true);\n    }\n\n    // Custom basepoints/target for exist spell\n    // dummy basepoints or other customs\n    switch (trigger_spell_id)\n    {\n        // Auras which should proc on area aura source (caster in this case):\n        // Turn the Tables\n        case 52914:\n        case 52915:\n        case 52910:\n        // Honor Among Thieves\n        case 52916:\n        {\n            target = triggeredByAura->GetBase()->GetCaster();\n            if (!target)\n                return false;\n\n            if (cooldown && target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->HasSpellCooldown(trigger_spell_id))\n                return false;\n\n            target->CastSpell(target, trigger_spell_id, true, castItem, triggeredByAura);\n\n            if (cooldown && GetTypeId() == TYPEID_PLAYER)\n                ToPlayer()->AddSpellCooldown(trigger_spell_id, 0, time(NULL) + cooldown);\n            return true;\n        }\n        // Cast positive spell on enemy target\n        case 7099:  // Curse of Mending\n        case 39703: // Curse of Mending\n        case 29494: // Temptation\n        case 20233: // Improved Lay on Hands (cast on target)\n        {\n            target = victim;\n            break;\n        }\n        // Combo points add triggers (need add combopoint only for main target, and after possible combopoints reset)\n        case 15250: // Rogue Setup\n        {\n            // applied only for main target\n            if (!victim || (GetTypeId() == TYPEID_PLAYER && victim != ToPlayer()->GetSelectedUnit()))\n                return false;\n            break;                                   // continue normal case\n        }\n        // Finish movies that add combo\n        case 14189: // Seal Fate (Netherblade set)\n        case 14157: // Ruthlessness\n        {\n            if (!victim || victim == this)\n                return false;\n            // Need add combopoint AFTER finish movie (or they dropped in finish phase)\n            break;\n        }\n        // Item - Druid T10 Balance 2P Bonus\n        case 16870:\n        {\n            if (HasAura(70718))\n                CastSpell(this, 70721, true);\n            break;\n        }\n        // Shamanistic Rage triggered spell\n        case 30824:\n        {\n            basepoints0 = int32(CalculatePctN(GetTotalAttackPowerValue(BASE_ATTACK), triggerAmount));\n            break;\n        }\n        // Enlightenment (trigger only from mana cost spells)\n        case 35095:\n        {\n            if (!procSpell || procSpell->PowerType != POWER_MANA || (procSpell->ManaCost == 0 && procSpell->ManaCostPercentage == 0 && procSpell->ManaCostPerlevel == 0))\n                return false;\n            break;\n        }\n        // Demonic Pact\n        case 48090:\n        {\n            // Get talent aura from owner\n            if (isPet())\n                if (Unit* owner = GetOwner())\n                {\n                    if (AuraEffect* aurEff = owner->GetDummyAuraEffect(SPELLFAMILY_WARLOCK, 3220, 0))\n                    {\n                        basepoints0 = int32((aurEff->GetAmount() * owner->SpellBaseDamageBonusDone(SpellSchoolMask(SPELL_SCHOOL_MASK_MAGIC)) + 100.0f) / 100.0f); // TODO: Is it right?\n                        CastCustomSpell(this, trigger_spell_id, &basepoints0, &basepoints0, NULL, true, castItem, triggeredByAura);\n                        return true;\n                    }\n                }\n            break;\n        }\n        case 46916:  // Slam! (Bloodsurge proc)\n        case 52437:  // Sudden Death\n        {\n            // Item - Warrior T10 Melee 4P Bonus\n            if (AuraEffect const* aurEff = GetAuraEffect(70847, 0))\n            {\n                if (!roll_chance_i(aurEff->GetAmount()))\n                    break;\n                CastSpell(this, 70849, true, castItem, triggeredByAura); // Extra Charge!\n                CastSpell(this, 71072, true, castItem, triggeredByAura); // Slam GCD Reduced\n                CastSpell(this, 71069, true, castItem, triggeredByAura); // Execute GCD Reduced\n            }\n            break;\n        }\n        // Sword and Board\n        case 50227:\n        {\n            // Remove cooldown on Shield Slam\n            if (GetTypeId() == TYPEID_PLAYER)\n                ToPlayer()->RemoveSpellCategoryCooldown(1209, true);\n            break;\n        }\n        // Maelstrom Weapon\n        case 53817:\n        {\n            // has rank dependant proc chance, ignore too often cases\n            // PPM = 2.5 * (rank of talent),\n            uint32 rank = auraSpellInfo->GetRank();\n            // 5 rank -> 100% 4 rank -> 80% and etc from full rate\n            if (!roll_chance_i(20*rank))\n                return false;\n            // Item - Shaman T10 Enhancement 4P Bonus\n            if (AuraEffect const* aurEff = GetAuraEffect(70832, 0))\n                if (Aura const* maelstrom = GetAura(53817))\n                    if ((maelstrom->GetStackAmount() == maelstrom->GetSpellInfo()->StackAmount - 1) && roll_chance_i(aurEff->GetAmount()))\n                        CastSpell(this, 70831, true, castItem, triggeredByAura);\n            break;\n        }\n        // Astral Shift\n        case 52179:\n        {\n            if (procSpell == 0 || !(procEx & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) || this == victim)\n                return false;\n\n            // Need stun, fear or silence mechanic\n            if (!(procSpell->GetAllEffectsMechanicMask() & ((1<<MECHANIC_SILENCE)|(1<<MECHANIC_STUN)|(1<<MECHANIC_FEAR))))\n                return false;\n            break;\n        }\n        // Burning Determination\n        case 54748:\n        {\n            if (!procSpell)\n                return false;\n            // Need Interrupt or Silenced mechanic\n            if (!(procSpell->GetAllEffectsMechanicMask() & ((1<<MECHANIC_INTERRUPT)|(1<<MECHANIC_SILENCE))))\n                return false;\n            break;\n        }\n        // Lock and Load\n        case 56453:\n        {\n            // Proc only from Frost/Freezing trap activation or from Freezing Arrow (the periodic dmg proc handled elsewhere)\n            if (!(procFlags & PROC_FLAG_DONE_TRAP_ACTIVATION) || !procSpell || !(procSpell->SchoolMask & SPELL_SCHOOL_MASK_FROST) || !roll_chance_i(triggerAmount))\n                return false;\n            break;\n        }\n        // Glyph of Death's Embrace\n        case 58679:\n        {\n            // Proc only from healing part of Death Coil. Check is essential as all Death Coil spells have 0x2000 mask in SpellFamilyFlags\n            if (!procSpell || !(procSpell->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && procSpell->SpellFamilyFlags[0] == 0x80002000))\n                return false;\n            break;\n        }\n        // Glyph of Death Grip\n        case 58628:\n        {\n            // remove cooldown of Death Grip\n            if (GetTypeId() == TYPEID_PLAYER)\n                ToPlayer()->RemoveSpellCooldown(49576, true);\n            return true;\n        }\n        // Savage Defense\n        case 62606:\n        {\n            basepoints0 = CalculatePctF(triggerAmount, GetTotalAttackPowerValue(BASE_ATTACK));\n            break;\n        }\n        // Body and Soul\n        case 64128:\n        case 65081:\n        {\n            // Proc only from PW:S cast\n            if (!(procSpell->SpellFamilyFlags[0] & 0x00000001))\n                return false;\n            break;\n        }\n        // Culling the Herd\n        case 70893:\n        {\n            // check if we're doing a critical hit\n            if (!(procSpell->SpellFamilyFlags[1] & 0x10000000) && (procEx != PROC_EX_CRITICAL_HIT))\n                return false;\n            // check if we're procced by Claw, Bite or Smack (need to use the spell icon ID to detect it)\n            if (!(procSpell->SpellIconID == 262 || procSpell->SpellIconID == 1680 || procSpell->SpellIconID == 473))\n                return false;\n            break;\n        }\n        // Shadow's Fate (Shadowmourne questline)\n        case 71169:\n        {\n            if (GetTypeId() != TYPEID_PLAYER)\n                return false;\n\n            Player* player = ToPlayer();\n            if (player->GetQuestStatus(24749) == QUEST_STATUS_INCOMPLETE)       // Unholy Infusion\n            {\n                if (!player->HasAura(71516) || victim->GetEntry() != 36678)    // Shadow Infusion && Professor Putricide\n                    return false;\n            }\n            else if (player->GetQuestStatus(24756) == QUEST_STATUS_INCOMPLETE)  // Blood Infusion\n            {\n                if (!player->HasAura(72154) || victim->GetEntry() != 37955)    // Thirst Quenched && Blood-Queen Lana'thel\n                    return false;\n            }\n            else if (player->GetQuestStatus(24757) == QUEST_STATUS_INCOMPLETE)  // Frost Infusion\n            {\n                if (!player->HasAura(72290) || victim->GetEntry() != 36853)    // Frost-Imbued Blade && Sindragosa\n                    return false;\n            }\n            else if (player->GetQuestStatus(24547) != QUEST_STATUS_INCOMPLETE)  // A Feast of Souls\n                return false;\n\n            if (victim->GetTypeId() != TYPEID_UNIT)\n                return false;\n            // critters are not allowed\n            if (victim->GetCreatureType() == CREATURE_TYPE_CRITTER)\n                return false;\n            break;\n        }\n    }\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(trigger_spell_id))\n        return false;\n\n    // try detect target manually if not set\n    if (target == NULL)\n        target = !(procFlags & (PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS | PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS)) && triggerEntry && triggerEntry->IsPositive() ? this : victim;\n\n    if (basepoints0)\n        CastCustomSpell(target, trigger_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);\n    else\n        CastSpell(target, trigger_spell_id, true, castItem, triggeredByAura);\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->AddSpellCooldown(trigger_spell_id, 0, time(NULL) + cooldown);\n\n    return true;\n}\n\nbool Unit::HandleOverrideClassScriptAuraProc(Unit* victim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 cooldown)\n{\n    int32 scriptId = triggeredByAura->GetMiscValue();\n\n    if (!victim || !victim->isAlive())\n        return false;\n\n    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER\n        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;\n\n    uint32 triggered_spell_id = 0;\n\n    switch (scriptId)\n    {\n        case 836:                                           // Improved Blizzard (Rank 1)\n        {\n            if (!procSpell || procSpell->SpellVisual[0] != 9487)\n                return false;\n            triggered_spell_id = 12484;\n            break;\n        }\n        case 988:                                           // Improved Blizzard (Rank 2)\n        {\n            if (!procSpell || procSpell->SpellVisual[0] != 9487)\n                return false;\n            triggered_spell_id = 12485;\n            break;\n        }\n        case 989:                                           // Improved Blizzard (Rank 3)\n        {\n            if (!procSpell || procSpell->SpellVisual[0] != 9487)\n                return false;\n            triggered_spell_id = 12486;\n            break;\n        }\n        case 4533:                                          // Dreamwalker Raiment 2 pieces bonus\n        {\n            // Chance 50%\n            if (!roll_chance_i(50))\n                return false;\n\n            switch (victim->getPowerType())\n            {\n                case POWER_MANA:   triggered_spell_id = 28722; break;\n                case POWER_RAGE:   triggered_spell_id = 28723; break;\n                case POWER_ENERGY: triggered_spell_id = 28724; break;\n                default:\n                    return false;\n            }\n            break;\n        }\n        case 4537:                                          // Dreamwalker Raiment 6 pieces bonus\n            triggered_spell_id = 28750;                     // Blessing of the Claw\n            break;\n        case 5497:                                          // Improved Mana Gems\n            triggered_spell_id = 37445;                     // Mana Surge\n            break;\n        case 7010:  // Revitalize - can proc on full hp target\n        case 7011:\n        case 7012:\n        {\n            if (!roll_chance_i(triggeredByAura->GetAmount()))\n                return false;\n            switch (victim->getPowerType())\n            {\n                case POWER_MANA:   triggered_spell_id = 48542; break;\n                case POWER_RAGE:   triggered_spell_id = 48541; break;\n                case POWER_ENERGY: triggered_spell_id = 48540; break;\n                case POWER_RUNIC_POWER: triggered_spell_id = 48543; break;\n                default:\n                    break;\n            }\n            break;\n        }\n        default:\n            break;\n    }\n\n    // not processed\n    if (!triggered_spell_id)\n        return false;\n\n    // standard non-dummy case\n    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);\n\n    if (!triggerEntry)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleOverrideClassScriptAuraProc: Spell %u triggering for class script id %u\", triggered_spell_id, scriptId);\n        return false;\n    }\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(triggered_spell_id))\n        return false;\n\n    CastSpell(victim, triggered_spell_id, true, castItem, triggeredByAura);\n\n    if (cooldown && GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->AddSpellCooldown(triggered_spell_id, 0, time(NULL) + cooldown);\n\n    return true;\n}\n\nvoid Unit::setPowerType(Powers new_powertype)\n{\n    SetByteValue(UNIT_FIELD_BYTES_0, 3, new_powertype);\n\n    if (GetTypeId() == TYPEID_PLAYER)\n    {\n        if (ToPlayer()->GetGroup())\n            ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_POWER_TYPE);\n    }\n    else if (Pet* pet = ToCreature()->ToPet())\n    {\n        if (pet->isControlled())\n        {\n            Unit* owner = GetOwner();\n            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())\n                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_POWER_TYPE);\n        }\n    }\n\n    switch (new_powertype)\n    {\n        default:\n        case POWER_MANA:\n            break;\n        case POWER_RAGE:\n            SetMaxPower(POWER_RAGE, GetCreatePowers(POWER_RAGE));\n            SetPower(POWER_RAGE, 0);\n            break;\n        case POWER_FOCUS:\n            SetMaxPower(POWER_FOCUS, GetCreatePowers(POWER_FOCUS));\n            SetPower(POWER_FOCUS, GetCreatePowers(POWER_FOCUS));\n            break;\n        case POWER_ENERGY:\n            SetMaxPower(POWER_ENERGY, GetCreatePowers(POWER_ENERGY));\n            break;\n        case POWER_HAPPINESS:\n            SetMaxPower(POWER_HAPPINESS, GetCreatePowers(POWER_HAPPINESS));\n            SetPower(POWER_HAPPINESS, GetCreatePowers(POWER_HAPPINESS));\n            break;\n    }\n}\n\nFactionTemplateEntry const* Unit::getFactionTemplateEntry() const\n{\n    FactionTemplateEntry const* entry = sFactionTemplateStore.LookupEntry(getFaction());\n    if (!entry)\n    {\n        static uint64 guid = 0;                             // prevent repeating spam same faction problem\n\n        if (GetGUID() != guid)\n        {\n            if (Player const* player = ToPlayer())\n                sLog->outError(LOG_FILTER_UNITS, \"Player %s has invalid faction (faction template id) #%u\", player->GetName(), getFaction());\n            else if (Creature const* creature = ToCreature())\n                sLog->outError(LOG_FILTER_UNITS, \"Creature (template id: %u) has invalid faction (faction template id) #%u\", creature->GetCreatureTemplate()->Entry, getFaction());\n            else\n                sLog->outError(LOG_FILTER_UNITS, \"Unit (name=%s, type=%u) has invalid faction (faction template id) #%u\", GetName(), uint32(GetTypeId()), getFaction());\n\n            guid = GetGUID();\n        }\n    }\n    return entry;\n}\n\n// function based on function Unit::UnitReaction from 13850 client\nReputationRank Unit::GetReactionTo(Unit const* target) const\n{\n    // always friendly to self\n    if (this == target)\n        return REP_FRIENDLY;\n\n    // always friendly to charmer or owner\n    if (GetCharmerOrOwnerOrSelf() == target->GetCharmerOrOwnerOrSelf())\n        return REP_FRIENDLY;\n\n    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))\n    {\n        if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))\n        {\n            Player const* selfPlayerOwner = GetAffectingPlayer();\n            Player const* targetPlayerOwner = target->GetAffectingPlayer();\n\n            if (selfPlayerOwner && targetPlayerOwner)\n            {\n                // always friendly to other unit controlled by player, or to the player himself\n                if (selfPlayerOwner == targetPlayerOwner)\n                    return REP_FRIENDLY;\n\n                // duel - always hostile to opponent\n                if (selfPlayerOwner->duel && selfPlayerOwner->duel->opponent == targetPlayerOwner && selfPlayerOwner->duel->startTime != 0)\n                    return REP_HOSTILE;\n\n                // same group - checks dependant only on our faction - skip FFA_PVP for example\n                if (selfPlayerOwner->IsInRaidWith(targetPlayerOwner))\n                    return REP_FRIENDLY; // return true to allow config option AllowTwoSide.Interaction.Group to work\n                    // however client seems to allow mixed group parties, because in 13850 client it works like:\n                    // return GetFactionReactionTo(getFactionTemplateEntry(), target);\n            }\n\n            // check FFA_PVP\n            if (GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_FFA_PVP\n                && target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_FFA_PVP)\n                return REP_HOSTILE;\n\n            if (selfPlayerOwner)\n            {\n                if (FactionTemplateEntry const* targetFactionTemplateEntry = target->getFactionTemplateEntry())\n                {\n                    if (ReputationRank const* repRank = selfPlayerOwner->GetReputationMgr().GetForcedRankIfAny(targetFactionTemplateEntry))\n                        return *repRank;\n                    if (!selfPlayerOwner->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_IGNORE_REPUTATION))\n                    {\n                        if (FactionEntry const* targetFactionEntry = sFactionStore.LookupEntry(targetFactionTemplateEntry->faction))\n                        {\n                            if (targetFactionEntry->CanHaveReputation())\n                            {\n                                // check contested flags\n                                if (targetFactionTemplateEntry->factionFlags & FACTION_TEMPLATE_FLAG_CONTESTED_GUARD\n                                    && selfPlayerOwner->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP))\n                                    return REP_HOSTILE;\n\n                                // if faction has reputation, hostile state depends only from AtWar state\n                                if (selfPlayerOwner->GetReputationMgr().IsAtWar(targetFactionEntry))\n                                    return REP_HOSTILE;\n                                return REP_FRIENDLY;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // do checks dependant only on our faction\n    return GetFactionReactionTo(getFactionTemplateEntry(), target);\n}\n\nReputationRank Unit::GetFactionReactionTo(FactionTemplateEntry const* factionTemplateEntry, Unit const* target)\n{\n    // always neutral when no template entry found\n    if (!factionTemplateEntry)\n        return REP_NEUTRAL;\n\n    FactionTemplateEntry const* targetFactionTemplateEntry = target->getFactionTemplateEntry();\n    if (!targetFactionTemplateEntry)\n        return REP_NEUTRAL;\n\n    if (Player const* targetPlayerOwner = target->GetAffectingPlayer())\n    {\n        // check contested flags\n        if (factionTemplateEntry->factionFlags & FACTION_TEMPLATE_FLAG_CONTESTED_GUARD\n            && targetPlayerOwner->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP))\n            return REP_HOSTILE;\n        if (ReputationRank const* repRank = targetPlayerOwner->GetReputationMgr().GetForcedRankIfAny(factionTemplateEntry))\n            return *repRank;\n        if (!target->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_IGNORE_REPUTATION))\n        {\n            if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(factionTemplateEntry->faction))\n            {\n                if (factionEntry->CanHaveReputation())\n                {\n                    // CvP case - check reputation, don't allow state higher than neutral when at war\n                    ReputationRank repRank = targetPlayerOwner->GetReputationMgr().GetRank(factionEntry);\n                    if (targetPlayerOwner->GetReputationMgr().IsAtWar(factionEntry))\n                        repRank = std::min(REP_NEUTRAL, repRank);\n                    return repRank;\n                }\n            }\n        }\n    }\n\n    // common faction based check\n    if (factionTemplateEntry->IsHostileTo(*targetFactionTemplateEntry))\n        return REP_HOSTILE;\n    if (factionTemplateEntry->IsFriendlyTo(*targetFactionTemplateEntry))\n        return REP_FRIENDLY;\n    if (targetFactionTemplateEntry->IsFriendlyTo(*factionTemplateEntry))\n        return REP_FRIENDLY;\n    if (factionTemplateEntry->factionFlags & FACTION_TEMPLATE_FLAG_HOSTILE_BY_DEFAULT)\n        return REP_HOSTILE;\n    // neutral by default\n    return REP_NEUTRAL;\n}\n\nbool Unit::IsHostileTo(Unit const* unit) const\n{\n    return GetReactionTo(unit) <= REP_HOSTILE;\n}\n\nbool Unit::IsFriendlyTo(Unit const* unit) const\n{\n    return GetReactionTo(unit) >= REP_FRIENDLY;\n}\n\nbool Unit::IsHostileToPlayers() const\n{\n    FactionTemplateEntry const* my_faction = getFactionTemplateEntry();\n    if (!my_faction || !my_faction->faction)\n        return false;\n\n    FactionEntry const* raw_faction = sFactionStore.LookupEntry(my_faction->faction);\n    if (raw_faction && raw_faction->reputationListID >= 0)\n        return false;\n\n    return my_faction->IsHostileToPlayers();\n}\n\nbool Unit::IsNeutralToAll() const\n{\n    FactionTemplateEntry const* my_faction = getFactionTemplateEntry();\n    if (!my_faction || !my_faction->faction)\n        return true;\n\n    FactionEntry const* raw_faction = sFactionStore.LookupEntry(my_faction->faction);\n    if (raw_faction && raw_faction->reputationListID >= 0)\n        return false;\n\n    return my_faction->IsNeutralToAll();\n}\n\nbool Unit::Attack(Unit* victim, bool meleeAttack)\n{\n    if (!victim || victim == this)\n        return false;\n\n    // dead units can neither attack nor be attacked\n    if (!isAlive() || !victim->IsInWorld() || !victim->isAlive())\n        return false;\n\n    // player cannot attack in mount state\n    if (GetTypeId() == TYPEID_PLAYER && IsMounted())\n        return false;\n\n    // nobody can attack GM in GM-mode\n    if (victim->GetTypeId() == TYPEID_PLAYER)\n    {\n        if (victim->ToPlayer()->isGameMaster())\n            return false;\n    }\n    else\n    {\n        if (victim->ToCreature()->IsInEvadeMode())\n            return false;\n    }\n\n    // remove SPELL_AURA_MOD_UNATTACKABLE at attack (in case non-interruptible spells stun aura applied also that not let attack)\n    if (HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))\n        RemoveAurasByType(SPELL_AURA_MOD_UNATTACKABLE);\n\n    if (m_attacking)\n    {\n        if (m_attacking == victim)\n        {\n            // switch to melee attack from ranged/magic\n            if (meleeAttack)\n            {\n                if (!HasUnitState(UNIT_STATE_MELEE_ATTACKING))\n                {\n                    AddUnitState(UNIT_STATE_MELEE_ATTACKING);\n                    SendMeleeAttackStart(victim);\n                    return true;\n                }\n            }\n            else if (HasUnitState(UNIT_STATE_MELEE_ATTACKING))\n            {\n                ClearUnitState(UNIT_STATE_MELEE_ATTACKING);\n                SendMeleeAttackStop(victim);\n                return true;\n            }\n            return false;\n        }\n\n        // switch target\n        InterruptSpell(CURRENT_MELEE_SPELL);\n        if (!meleeAttack)\n            ClearUnitState(UNIT_STATE_MELEE_ATTACKING);\n    }\n\n    if (m_attacking)\n        m_attacking->_removeAttacker(this);\n\n    m_attacking = victim;\n    m_attacking->_addAttacker(this);\n\n    // Set our target\n    SetTarget(victim->GetGUID());\n\n    if (meleeAttack)\n        AddUnitState(UNIT_STATE_MELEE_ATTACKING);\n\n    // set position before any AI calls/assistance\n    //if (GetTypeId() == TYPEID_UNIT)\n    //    ToCreature()->SetCombatStartPosition(GetPositionX(), GetPositionY(), GetPositionZ());\n\n    if (GetTypeId() == TYPEID_UNIT && !ToCreature()->isPet())\n    {\n        // should not let player enter combat by right clicking target - doesn't helps\n        SetInCombatWith(victim);\n        if (victim->GetTypeId() == TYPEID_PLAYER)\n            victim->SetInCombatWith(this);\n        AddThreat(victim, 0.0f);\n\n        ToCreature()->SendAIReaction(AI_REACTION_HOSTILE);\n        ToCreature()->CallAssistance();\n    }\n\n    // delay offhand weapon attack to next attack time\n    if (haveOffhandWeapon())\n        resetAttackTimer(OFF_ATTACK);\n\n    if (meleeAttack)\n        SendMeleeAttackStart(victim);\n\n    // Let the pet know we've started attacking someting. Handles melee attacks only\n    // Spells such as auto-shot and others handled in WorldSession::HandleCastSpellOpcode\n    if (this->GetTypeId() == TYPEID_PLAYER)\n    {\n        Pet* playerPet = this->ToPlayer()->GetPet();\n\n        if (playerPet && playerPet->isAlive())\n            playerPet->AI()->OwnerAttacked(victim);\n    }\n\n    return true;\n}\n\nbool Unit::AttackStop()\n{\n    if (!m_attacking)\n        return false;\n\n    Unit* victim = m_attacking;\n\n    m_attacking->_removeAttacker(this);\n    m_attacking = NULL;\n\n    // Clear our target\n    SetTarget(0);\n\n    ClearUnitState(UNIT_STATE_MELEE_ATTACKING);\n\n    InterruptSpell(CURRENT_MELEE_SPELL);\n\n    // reset only at real combat stop\n    if (Creature* creature = ToCreature())\n    {\n        creature->SetNoCallAssistance(false);\n\n        if (creature->HasSearchedAssistance())\n        {\n            creature->SetNoSearchAssistance(false);\n            UpdateSpeed(MOVE_RUN, false);\n        }\n    }\n\n    SendMeleeAttackStop(victim);\n\n    return true;\n}\n\nvoid Unit::CombatStop(bool includingCast)\n{\n    if (includingCast && IsNonMeleeSpellCasted(false))\n        InterruptNonMeleeSpells(false);\n\n    AttackStop();\n    RemoveAllAttackers();\n    if (GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->SendAttackSwingCancelAttack();     // melee and ranged forced attack cancel\n    ClearInCombat();\n}\n\nvoid Unit::CombatStopWithPets(bool includingCast)\n{\n    CombatStop(includingCast);\n\n    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)\n        (*itr)->CombatStop(includingCast);\n}\n\nbool Unit::isAttackingPlayer() const\n{\n    if (HasUnitState(UNIT_STATE_ATTACK_PLAYER))\n        return true;\n\n    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)\n        if ((*itr)->isAttackingPlayer())\n            return true;\n\n    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)\n        if (m_SummonSlot[i])\n            if (Creature* summon = GetMap()->GetCreature(m_SummonSlot[i]))\n                if (summon->isAttackingPlayer())\n                    return true;\n\n    return false;\n}\n\nvoid Unit::RemoveAllAttackers()\n{\n    while (!m_attackers.empty())\n    {\n        AttackerSet::iterator iter = m_attackers.begin();\n        if (!(*iter)->AttackStop())\n        {\n            sLog->outError(LOG_FILTER_UNITS, \"WORLD: Unit has an attacker that isn't attacking it!\");\n            m_attackers.erase(iter);\n        }\n    }\n}\n\nvoid Unit::ModifyAuraState(AuraStateType flag, bool apply)\n{\n    if (apply)\n    {\n        if (!HasFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1)))\n        {\n            SetFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1));\n            if (GetTypeId() == TYPEID_PLAYER)\n            {\n                PlayerSpellMap const& sp_list = ToPlayer()->GetSpellMap();\n                for (PlayerSpellMap::const_iterator itr = sp_list.begin(); itr != sp_list.end(); ++itr)\n                {\n                    if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)\n                        continue;\n                    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itr->first);\n                    if (!spellInfo || !spellInfo->IsPassive())\n                        continue;\n                    if (spellInfo->CasterAuraState == uint32(flag))\n                        CastSpell(this, itr->first, true, NULL);\n                }\n            }\n            else if (Pet* pet = ToCreature()->ToPet())\n            {\n                for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)\n                {\n                    if (itr->second.state == PETSPELL_REMOVED)\n                        continue;\n                    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itr->first);\n                    if (!spellInfo || !spellInfo->IsPassive())\n                        continue;\n                    if (spellInfo->CasterAuraState == uint32(flag))\n                        CastSpell(this, itr->first, true, NULL);\n                }\n            }\n        }\n    }\n    else\n    {\n        if (HasFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1)))\n        {\n            RemoveFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1));\n\n            if (flag != AURA_STATE_ENRAGE)                  // enrage aura state triggering continues auras\n            {\n                Unit::AuraApplicationMap& tAuras = GetAppliedAuras();\n                for (Unit::AuraApplicationMap::iterator itr = tAuras.begin(); itr != tAuras.end();)\n                {\n                    SpellInfo const* spellProto = (*itr).second->GetBase()->GetSpellInfo();\n                    if (spellProto->CasterAuraState == uint32(flag))\n                        RemoveAura(itr);\n                    else\n                        ++itr;\n                }\n            }\n        }\n    }\n}\n\nuint32 Unit::BuildAuraStateUpdateForTarget(Unit* target) const\n{\n    uint32 auraStates = GetUInt32Value(UNIT_FIELD_AURASTATE) &~(PER_CASTER_AURA_STATE_MASK);\n    for (AuraStateAurasMap::const_iterator itr = m_auraStateAuras.begin(); itr != m_auraStateAuras.end(); ++itr)\n        if ((1<<(itr->first-1)) & PER_CASTER_AURA_STATE_MASK)\n            if (itr->second->GetBase()->GetCasterGUID() == target->GetGUID())\n                auraStates |= (1<<(itr->first-1));\n\n    return auraStates;\n}\n\nbool Unit::HasAuraState(AuraStateType flag, SpellInfo const* spellProto, Unit const* Caster) const\n{\n    if (Caster)\n    {\n        if (spellProto)\n        {\n            AuraEffectList const& stateAuras = Caster->GetAuraEffectsByType(SPELL_AURA_ABILITY_IGNORE_AURASTATE);\n            for (AuraEffectList::const_iterator j = stateAuras.begin(); j != stateAuras.end(); ++j)\n                if ((*j)->IsAffectedOnSpell(spellProto))\n                    return true;\n        }\n        // Check per caster aura state\n        // If aura with aurastate by caster not found return false\n        if ((1<<(flag-1)) & PER_CASTER_AURA_STATE_MASK)\n        {\n            for (AuraStateAurasMap::const_iterator itr = m_auraStateAuras.lower_bound(flag); itr != m_auraStateAuras.upper_bound(flag); ++itr)\n                if (itr->second->GetBase()->GetCasterGUID() == Caster->GetGUID())\n                    return true;\n            return false;\n        }\n    }\n\n    return HasFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1));\n}\n\nvoid Unit::SetOwnerGUID(uint64 owner)\n{\n    if (GetOwnerGUID() == owner)\n        return;\n\n    SetUInt64Value(UNIT_FIELD_SUMMONEDBY, owner);\n    if (!owner)\n        return;\n\n    // Update owner dependent fields\n    Player* player = ObjectAccessor::GetPlayer(*this, owner);\n    if (!player || !player->HaveAtClient(this)) // if player cannot see this unit yet, he will receive needed data with create object\n        return;\n\n    SetFieldNotifyFlag(UF_FLAG_OWNER);\n\n    UpdateData udata;\n    WorldPacket packet;\n    BuildValuesUpdateBlockForPlayer(&udata, player);\n    udata.BuildPacket(&packet);\n    player->SendDirectMessage(&packet);\n\n    RemoveFieldNotifyFlag(UF_FLAG_OWNER);\n}\n\nUnit* Unit::GetOwner() const\n{\n    if (uint64 ownerid = GetOwnerGUID())\n    {\n        return ObjectAccessor::GetUnit(*this, ownerid);\n    }\n    return NULL;\n}\n\nUnit* Unit::GetCharmer() const\n{\n    if (uint64 charmerid = GetCharmerGUID())\n        return ObjectAccessor::GetUnit(*this, charmerid);\n    return NULL;\n}\n\nPlayer* Unit::GetCharmerOrOwnerPlayerOrPlayerItself() const\n{\n    uint64 guid = GetCharmerOrOwnerGUID();\n    if (IS_PLAYER_GUID(guid))\n        return ObjectAccessor::GetPlayer(*this, guid);\n\n    return GetTypeId() == TYPEID_PLAYER ? (Player*)this : NULL;\n}\n\nPlayer* Unit::GetAffectingPlayer() const\n{\n    if (!GetCharmerOrOwnerGUID())\n        return GetTypeId() == TYPEID_PLAYER ? (Player*)this : NULL;\n\n    if (Unit* owner = GetCharmerOrOwner())\n        return owner->GetCharmerOrOwnerPlayerOrPlayerItself();\n    return NULL;\n}\n\nMinion *Unit::GetFirstMinion() const\n{\n    if (uint64 pet_guid = GetMinionGUID())\n    {\n        if (Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, pet_guid))\n            if (pet->HasUnitTypeMask(UNIT_MASK_MINION))\n                return (Minion*)pet;\n\n        sLog->outError(LOG_FILTER_UNITS, \"Unit::GetFirstMinion: Minion %u not exist.\", GUID_LOPART(pet_guid));\n        const_cast<Unit*>(this)->SetMinionGUID(0);\n    }\n\n    return NULL;\n}\n\nGuardian* Unit::GetGuardianPet() const\n{\n    if (uint64 pet_guid = GetPetGUID())\n    {\n        if (Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, pet_guid))\n            if (pet->HasUnitTypeMask(UNIT_MASK_GUARDIAN))\n                return (Guardian*)pet;\n\n        sLog->outFatal(LOG_FILTER_UNITS, \"Unit::GetGuardianPet: Guardian \" UI64FMTD \" not exist.\", pet_guid);\n        const_cast<Unit*>(this)->SetPetGUID(0);\n    }\n\n    return NULL;\n}\n\nUnit* Unit::GetCharm() const\n{\n    if (uint64 charm_guid = GetCharmGUID())\n    {\n        if (Unit* pet = ObjectAccessor::GetUnit(*this, charm_guid))\n            return pet;\n\n        sLog->outError(LOG_FILTER_UNITS, \"Unit::GetCharm: Charmed creature %u not exist.\", GUID_LOPART(charm_guid));\n        const_cast<Unit*>(this)->SetUInt64Value(UNIT_FIELD_CHARM, 0);\n    }\n\n    return NULL;\n}\n\nvoid Unit::SetMinion(Minion *minion, bool apply)\n{\n    sLog->outDebug(LOG_FILTER_UNITS, \"SetMinion %u for %u, apply %u\", minion->GetEntry(), GetEntry(), apply);\n\n    if (apply)\n    {\n        if (minion->GetOwnerGUID())\n        {\n            sLog->outFatal(LOG_FILTER_UNITS, \"SetMinion: Minion %u is not the minion of owner %u\", minion->GetEntry(), GetEntry());\n            return;\n        }\n\n        minion->SetOwnerGUID(GetGUID());\n\n        m_Controlled.insert(minion);\n\n        if (GetTypeId() == TYPEID_PLAYER)\n        {\n            minion->m_ControlledByPlayer = true;\n            minion->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);\n        }\n\n        // Can only have one pet. If a new one is summoned, dismiss the old one.\n        if (minion->IsGuardianPet())\n        {\n            if (Guardian* oldPet = GetGuardianPet())\n            {\n                if (oldPet != minion && (oldPet->isPet() || minion->isPet() || oldPet->GetEntry() != minion->GetEntry()))\n                {\n                    // remove existing minion pet\n                    if (oldPet->isPet())\n                        ((Pet*)oldPet)->Remove(PET_SAVE_AS_CURRENT);\n                    else\n                        oldPet->UnSummon();\n                    SetPetGUID(minion->GetGUID());\n                    SetMinionGUID(0);\n                }\n            }\n            else\n            {\n                SetPetGUID(minion->GetGUID());\n                SetMinionGUID(0);\n            }\n        }\n\n        if (minion->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))\n        {\n            if (AddUInt64Value(UNIT_FIELD_SUMMON, minion->GetGUID()))\n            {\n            }\n        }\n\n        if (minion->m_Properties && minion->m_Properties->Type == SUMMON_TYPE_MINIPET)\n        {\n            SetCritterGUID(minion->GetGUID());\n        }\n\n        // PvP, FFAPvP\n        minion->SetByteValue(UNIT_FIELD_BYTES_2, 1, GetByteValue(UNIT_FIELD_BYTES_2, 1));\n\n        // FIXME: hack, speed must be set only at follow\n        if (GetTypeId() == TYPEID_PLAYER && minion->isPet())\n            for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)\n                minion->SetSpeed(UnitMoveType(i), m_speed_rate[i], true);\n\n        // Ghoul pets have energy instead of mana (is anywhere better place for this code?)\n        if (minion->IsPetGhoul())\n            minion->setPowerType(POWER_ENERGY);\n\n        if (GetTypeId() == TYPEID_PLAYER)\n        {\n            // Send infinity cooldown - client does that automatically but after relog cooldown needs to be set again\n            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(minion->GetUInt32Value(UNIT_CREATED_BY_SPELL));\n\n            if (spellInfo && (spellInfo->Attributes & SPELL_ATTR0_DISABLED_WHILE_ACTIVE))\n                ToPlayer()->AddSpellAndCategoryCooldowns(spellInfo, 0, NULL, true);\n        }\n    }\n    else\n    {\n        if (minion->GetOwnerGUID() != GetGUID())\n        {\n            sLog->outFatal(LOG_FILTER_UNITS, \"SetMinion: Minion %u is not the minion of owner %u\", minion->GetEntry(), GetEntry());\n            return;\n        }\n\n        m_Controlled.erase(minion);\n\n        if (minion->m_Properties && minion->m_Properties->Type == SUMMON_TYPE_MINIPET)\n        {\n            if (GetCritterGUID() == minion->GetGUID())\n                SetCritterGUID(0);\n        }\n\n        if (minion->IsGuardianPet())\n        {\n            if (GetPetGUID() == minion->GetGUID())\n                SetPetGUID(0);\n        }\n        else if (minion->isTotem())\n        {\n            // All summoned by totem minions must disappear when it is removed.\n        if (SpellInfo const* spInfo = sSpellMgr->GetSpellInfo(minion->ToTotem()->GetSpell()))\n            for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)\n            {\n                if (spInfo->Effects[i].Effect != SPELL_EFFECT_SUMMON)\n                    continue;\n\n                RemoveAllMinionsByEntry(spInfo->Effects[i].MiscValue);\n            }\n        }\n\n        if (GetTypeId() == TYPEID_PLAYER)\n        {\n            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(minion->GetUInt32Value(UNIT_CREATED_BY_SPELL));\n            // Remove infinity cooldown\n            if (spellInfo && (spellInfo->Attributes & SPELL_ATTR0_DISABLED_WHILE_ACTIVE))\n                ToPlayer()->SendCooldownEvent(spellInfo);\n        }\n\n        //if (minion->HasUnitTypeMask(UNIT_MASK_GUARDIAN))\n        {\n            if (RemoveUInt64Value(UNIT_FIELD_SUMMON, minion->GetGUID()))\n            {\n                // Check if there is another minion\n                for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)\n                {\n                    // do not use this check, creature do not have charm guid\n                    //if (GetCharmGUID() == (*itr)->GetGUID())\n                    if (GetGUID() == (*itr)->GetCharmerGUID())\n                        continue;\n\n                    //ASSERT((*itr)->GetOwnerGUID() == GetGUID());\n                    if ((*itr)->GetOwnerGUID() != GetGUID())\n                    {\n                        OutDebugInfo();\n                        (*itr)->OutDebugInfo();\n                        ASSERT(false);\n                    }\n                    ASSERT((*itr)->GetTypeId() == TYPEID_UNIT);\n\n                    if (!(*itr)->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))\n                        continue;\n\n                    if (AddUInt64Value(UNIT_FIELD_SUMMON, (*itr)->GetGUID()))\n                    {\n                        // show another pet bar if there is no charm bar\n                        if (GetTypeId() == TYPEID_PLAYER && !GetCharmGUID())\n                        {\n                            if ((*itr)->isPet())\n                                ToPlayer()->PetSpellInitialize();\n                            else\n                                ToPlayer()->CharmSpellInitialize();\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvoid Unit::GetAllMinionsByEntry(std::list<Creature*>& Minions, uint32 entry)\n{\n    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end();)\n    {\n        Unit* unit = *itr;\n        ++itr;\n        if (unit->GetEntry() == entry && unit->GetTypeId() == TYPEID_UNIT\n            && unit->ToCreature()->isSummon()) // minion, actually\n            Minions.push_back(unit->ToCreature());\n    }\n}\n\nvoid Unit::RemoveAllMinionsByEntry(uint32 entry)\n{\n    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end();)\n    {\n        Unit* unit = *itr;\n        ++itr;\n        if (unit->GetEntry() == entry && unit->GetTypeId() == TYPEID_UNIT\n            && unit->ToCreature()->isSummon()) // minion, actually\n            unit->ToTempSummon()->UnSummon();\n        // i think this is safe because i have never heard that a despawned minion will trigger a same minion\n    }\n}\n\nvoid Unit::SetCharm(Unit* charm, bool apply)\n{\n    if (apply)\n    {\n        if (GetTypeId() == TYPEID_PLAYER)\n        {\n            if (!AddUInt64Value(UNIT_FIELD_CHARM, charm->GetGUID()))\n                sLog->outFatal(LOG_FILTER_UNITS, \"Player %s is trying to charm unit %u, but it already has a charmed unit \" UI64FMTD \"\", GetName(), charm->GetEntry(), GetCharmGUID());\n\n            charm->m_ControlledByPlayer = true;\n            // TODO: maybe we can use this flag to check if controlled by player\n            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);\n        }\n        else\n            charm->m_ControlledByPlayer = false;\n\n        // PvP, FFAPvP\n        charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, GetByteValue(UNIT_FIELD_BYTES_2, 1));\n\n        if (!charm->AddUInt64Value(UNIT_FIELD_CHARMEDBY, GetGUID()))\n            sLog->outFatal(LOG_FILTER_UNITS, \"Unit %u is being charmed, but it already has a charmer \" UI64FMTD \"\", charm->GetEntry(), charm->GetCharmerGUID());\n\n        _isWalkingBeforeCharm = charm->IsWalking();\n        if (_isWalkingBeforeCharm)\n        {\n            charm->SetWalk(false);\n            charm->SendMovementFlagUpdate();\n        }\n\n        m_Controlled.insert(charm);\n    }\n    else\n    {\n        if (GetTypeId() == TYPEID_PLAYER)\n        {\n            if (!RemoveUInt64Value(UNIT_FIELD_CHARM, charm->GetGUID()))\n                sLog->outFatal(LOG_FILTER_UNITS, \"Player %s is trying to uncharm unit %u, but it has another charmed unit \" UI64FMTD \"\", GetName(), charm->GetEntry(), GetCharmGUID());\n        }\n\n        if (!charm->RemoveUInt64Value(UNIT_FIELD_CHARMEDBY, GetGUID()))\n            sLog->outFatal(LOG_FILTER_UNITS, \"Unit %u is being uncharmed, but it has another charmer \" UI64FMTD \"\", charm->GetEntry(), charm->GetCharmerGUID());\n\n        if (charm->GetTypeId() == TYPEID_PLAYER)\n        {\n            charm->m_ControlledByPlayer = true;\n            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);\n            charm->ToPlayer()->UpdatePvPState();\n        }\n        else if (Player* player = charm->GetCharmerOrOwnerPlayerOrPlayerItself())\n        {\n            charm->m_ControlledByPlayer = true;\n            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);\n            charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, player->GetByteValue(UNIT_FIELD_BYTES_2, 1));\n        }\n        else\n        {\n            charm->m_ControlledByPlayer = false;\n            charm->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);\n            charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, 0);\n        }\n\n        if (charm->IsWalking() != _isWalkingBeforeCharm)\n        {\n            charm->SetWalk(_isWalkingBeforeCharm);\n            charm->SendMovementFlagUpdate(true); // send packet to self, to update movement state on player.\n        }\n\n        if (charm->GetTypeId() == TYPEID_PLAYER\n            || !charm->ToCreature()->HasUnitTypeMask(UNIT_MASK_MINION)\n            || charm->GetOwnerGUID() != GetGUID())\n            m_Controlled.erase(charm);\n    }\n}\n\nint32 Unit::DealHeal(Unit* victim, uint32 addhealth)\n{\n    int32 gain = 0;\n\n    if (victim->IsAIEnabled)\n        victim->GetAI()->HealReceived(this, addhealth);\n\n    if (IsAIEnabled)\n        GetAI()->HealDone(victim, addhealth);\n\n    if (addhealth)\n        gain = victim->ModifyHealth(int32(addhealth));\n\n    Unit* unit = this;\n\n    if (GetTypeId() == TYPEID_UNIT && ToCreature()->isTotem())\n        unit = GetOwner();\n\n    if (Player* player = unit->ToPlayer())\n    {\n        if (Battleground* bg = player->GetBattleground())\n            bg->UpdatePlayerScore(player, SCORE_HEALING_DONE, gain);\n\n        // use the actual gain, as the overheal shall not be counted, skip gain 0 (it ignored anyway in to criteria)\n        if (gain)\n            player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HEALING_DONE, gain, 0, victim);\n\n        player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HEAL_CASTED, addhealth);\n    }\n\n    if (Player* player = victim->ToPlayer())\n    {\n        player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_HEALING_RECEIVED, gain);\n        player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HEALING_RECEIVED, addhealth);\n    }\n\n    return gain;\n}\n\nUnit* Unit::GetMagicHitRedirectTarget(Unit* victim, SpellInfo const* spellInfo)\n{\n    // Patch 1.2 notes: Spell Reflection no longer reflects abilities\n    if (spellInfo->Attributes & SPELL_ATTR0_ABILITY || spellInfo->AttributesEx & SPELL_ATTR1_CANT_BE_REDIRECTED || spellInfo->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)\n        return victim;\n\n    Unit::AuraEffectList const& magnetAuras = victim->GetAuraEffectsByType(SPELL_AURA_SPELL_MAGNET);\n    for (Unit::AuraEffectList::const_iterator itr = magnetAuras.begin(); itr != magnetAuras.end(); ++itr)\n    {\n        if (Unit* magnet = (*itr)->GetBase()->GetCaster())\n            if (spellInfo->CheckExplicitTarget(this, magnet) == SPELL_CAST_OK\n                && spellInfo->CheckTarget(this, magnet, false) == SPELL_CAST_OK\n                && _IsValidAttackTarget(magnet, spellInfo)\n                && IsWithinLOSInMap(magnet))\n            {\n                // TODO: handle this charge drop by proc in cast phase on explicit target\n                (*itr)->GetBase()->DropCharge(AURA_REMOVE_BY_EXPIRE);\n                return magnet;\n            }\n    }\n    return victim;\n}\n\nUnit* Unit::GetMeleeHitRedirectTarget(Unit* victim, SpellInfo const* spellInfo)\n{\n    AuraEffectList const& hitTriggerAuras = victim->GetAuraEffectsByType(SPELL_AURA_ADD_CASTER_HIT_TRIGGER);\n    for (AuraEffectList::const_iterator i = hitTriggerAuras.begin(); i != hitTriggerAuras.end(); ++i)\n    {\n        if (Unit* magnet = (*i)->GetBase()->GetCaster())\n            if (_IsValidAttackTarget(magnet, spellInfo) && magnet->IsWithinLOSInMap(this)\n                && (!spellInfo || (spellInfo->CheckExplicitTarget(this, magnet) == SPELL_CAST_OK\n                && spellInfo->CheckTarget(this, magnet, false) == SPELL_CAST_OK)))\n                if (roll_chance_i((*i)->GetAmount()))\n                {\n                    (*i)->GetBase()->DropCharge(AURA_REMOVE_BY_EXPIRE);\n                    return magnet;\n                }\n    }\n    return victim;\n}\n\nUnit* Unit::GetFirstControlled() const\n{\n    // Sequence: charmed, pet, other guardians\n    Unit* unit = GetCharm();\n    if (!unit)\n        if (uint64 guid = GetMinionGUID())\n            unit = ObjectAccessor::GetUnit(*this, guid);\n\n    return unit;\n}\n\nvoid Unit::RemoveAllControlled()\n{\n    // possessed pet and vehicle\n    if (GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->StopCastingCharm();\n\n    while (!m_Controlled.empty())\n    {\n        Unit* target = *m_Controlled.begin();\n        m_Controlled.erase(m_Controlled.begin());\n        if (target->GetCharmerGUID() == GetGUID())\n            target->RemoveCharmAuras();\n        else if (target->GetOwnerGUID() == GetGUID() && target->isSummon())\n            target->ToTempSummon()->UnSummon();\n        else\n            sLog->outError(LOG_FILTER_UNITS, \"Unit %u is trying to release unit %u which is neither charmed nor owned by it\", GetEntry(), target->GetEntry());\n    }\n    if (GetPetGUID())\n        sLog->outFatal(LOG_FILTER_UNITS, \"Unit %u is not able to release its pet \" UI64FMTD, GetEntry(), GetPetGUID());\n    if (GetMinionGUID())\n        sLog->outFatal(LOG_FILTER_UNITS, \"Unit %u is not able to release its minion \" UI64FMTD, GetEntry(), GetMinionGUID());\n    if (GetCharmGUID())\n        sLog->outFatal(LOG_FILTER_UNITS, \"Unit %u is not able to release its charm \" UI64FMTD, GetEntry(), GetCharmGUID());\n}\n\nUnit* Unit::GetNextRandomRaidMemberOrPet(float radius)\n{\n    Player* player = NULL;\n    if (GetTypeId() == TYPEID_PLAYER)\n        player = ToPlayer();\n    // Should we enable this also for charmed units?\n    else if (GetTypeId() == TYPEID_UNIT && ToCreature()->isPet())\n        player = GetOwner()->ToPlayer();\n\n    if (!player)\n        return NULL;\n    Group* group = player->GetGroup();\n    // When there is no group check pet presence\n    if (!group)\n    {\n        // We are pet now, return owner\n        if (player != this)\n            return IsWithinDistInMap(player, radius) ? player : NULL;\n        Unit* pet = GetGuardianPet();\n        // No pet, no group, nothing to return\n        if (!pet)\n            return NULL;\n        // We are owner now, return pet\n        return IsWithinDistInMap(pet, radius) ? pet : NULL;\n    }\n\n    std::vector<Unit*> nearMembers;\n    // reserve place for players and pets because resizing vector every unit push is unefficient (vector is reallocated then)\n    nearMembers.reserve(group->GetMembersCount() * 2);\n\n    for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())\n        if (Player* Target = itr->getSource())\n        {\n            // IsHostileTo check duel and controlled by enemy\n            if (Target != this && Target->isAlive() && IsWithinDistInMap(Target, radius) && !IsHostileTo(Target))\n                nearMembers.push_back(Target);\n\n        // Push player's pet to vector\n        if (Unit* pet = Target->GetGuardianPet())\n            if (pet != this && pet->isAlive() && IsWithinDistInMap(pet, radius) && !IsHostileTo(pet))\n                nearMembers.push_back(pet);\n        }\n\n    if (nearMembers.empty())\n        return NULL;\n\n    uint32 randTarget = urand(0, nearMembers.size()-1);\n    return nearMembers[randTarget];\n}\n\n// only called in Player::SetSeer\n// so move it to Player?\nvoid Unit::AddPlayerToVision(Player* player)\n{\n    if (m_sharedVision.empty())\n    {\n        setActive(true);\n        SetWorldObject(true);\n    }\n    m_sharedVision.push_back(player);\n}\n\n// only called in Player::SetSeer\nvoid Unit::RemovePlayerFromVision(Player* player)\n{\n    m_sharedVision.remove(player);\n    if (m_sharedVision.empty())\n    {\n        setActive(false);\n        SetWorldObject(false);\n    }\n}\n\nvoid Unit::RemoveBindSightAuras()\n{\n    RemoveAurasByType(SPELL_AURA_BIND_SIGHT);\n}\n\nvoid Unit::RemoveCharmAuras()\n{\n    RemoveAurasByType(SPELL_AURA_MOD_CHARM);\n    RemoveAurasByType(SPELL_AURA_MOD_POSSESS_PET);\n    RemoveAurasByType(SPELL_AURA_MOD_POSSESS);\n    RemoveAurasByType(SPELL_AURA_AOE_CHARM);\n}\n\nvoid Unit::UnsummonAllTotems()\n{\n    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)\n    {\n        if (!m_SummonSlot[i])\n            continue;\n\n        if (Creature* OldTotem = GetMap()->GetCreature(m_SummonSlot[i]))\n            if (OldTotem->isSummon())\n                OldTotem->ToTempSummon()->UnSummon();\n    }\n}\n\nvoid Unit::SendHealSpellLog(Unit* victim, uint32 SpellID, uint32 Damage, uint32 OverHeal, uint32 Absorb, bool critical)\n{\n    // we guess size\n    WorldPacket data(SMSG_SPELLHEALLOG, (8+8+4+4+4+4+1+1));\n    data.append(victim->GetPackGUID());\n    data.append(GetPackGUID());\n    data << uint32(SpellID);\n    data << uint32(Damage);\n    data << uint32(OverHeal);\n    data << uint32(Absorb); // Absorb amount\n    data << uint8(critical ? 1 : 0);\n    data << uint8(0); // unused\n    SendMessageToSet(&data, true);\n}\n\nint32 Unit::HealBySpell(Unit* victim, SpellInfo const* spellInfo, uint32 addHealth, bool critical)\n{\n    uint32 absorb = 0;\n    // calculate heal absorb and reduce healing\n    CalcHealAbsorb(victim, spellInfo, addHealth, absorb);\n\n    int32 gain = DealHeal(victim, addHealth);\n    SendHealSpellLog(victim, spellInfo->Id, addHealth, uint32(addHealth - gain), absorb, critical);\n    return gain;\n}\n\nvoid Unit::SendEnergizeSpellLog(Unit* victim, uint32 spellID, uint32 damage, Powers powerType)\n{\n    WorldPacket data(SMSG_SPELLENERGIZELOG, (8+8+4+4+4+1));\n    data.append(victim->GetPackGUID());\n    data.append(GetPackGUID());\n    data << uint32(spellID);\n    data << uint32(powerType);\n    data << uint32(damage);\n    SendMessageToSet(&data, true);\n}\n\nvoid Unit::EnergizeBySpell(Unit* victim, uint32 spellID, uint32 damage, Powers powerType)\n{\n    SendEnergizeSpellLog(victim, spellID, damage, powerType);\n    // needs to be called after sending spell log\n    victim->ModifyPower(powerType, damage);\n\n    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellID);\n    victim->getHostileRefManager().threatAssist(this, float(damage) * 0.5f, spellInfo);\n}\n\nuint32 Unit::SpellDamageBonusDone(Unit* victim, SpellInfo const* spellProto, uint32 pdamage, DamageEffectType damagetype, uint32 stack)\n{\n    if (!spellProto || !victim || damagetype == DIRECT_DAMAGE)\n        return pdamage;\n\n    // Some spells don't benefit from done mods\n    if (spellProto->AttributesEx3 & SPELL_ATTR3_NO_DONE_BONUS)\n        return pdamage;\n\n    // small exception for Deep Wounds, can't find any general rule\n    // should ignore ALL damage mods, they already calculated in trigger spell\n    if (spellProto->Id == 12721) // Deep Wounds\n        return pdamage;\n\n    // For totems get damage bonus from owner\n    if (GetTypeId() == TYPEID_UNIT && ToCreature()->isTotem())\n        if (Unit* owner = GetOwner())\n            return owner->SpellDamageBonusDone(victim, spellProto, pdamage, damagetype);\n\n    // Done total percent damage auras\n    float DoneTotalMod = 1.0f;\n    float ApCoeffMod = 1.0f;\n    int32 DoneTotal = 0;\n\n    // Pet damage?\n    if (GetTypeId() == TYPEID_UNIT && !ToCreature()->isPet())\n        DoneTotalMod *= ToCreature()->GetSpellDamageMod(ToCreature()->GetCreatureTemplate()->rank);\n\n    // Some spells don't benefit from pct done mods\n    if (!(spellProto->AttributesEx6 & SPELL_ATTR6_NO_DONE_PCT_DAMAGE_MODS) && !spellProto->IsRankOf(sSpellMgr->GetSpellInfo(12162)))\n    {\n        AuraEffectList const& mModDamagePercentDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);\n        for (AuraEffectList::const_iterator i = mModDamagePercentDone.begin(); i != mModDamagePercentDone.end(); ++i)\n        {\n            if (spellProto->EquippedItemClass == -1 && (*i)->GetSpellInfo()->EquippedItemClass != -1)    //prevent apply mods from weapon specific case to non weapon specific spells (Example: thunder clap and two-handed weapon specialization)\n                continue;\n\n            if ((*i)->GetMiscValue() & spellProto->GetSchoolMask())\n            {\n                if ((*i)->GetSpellInfo()->EquippedItemClass == -1)\n                    AddPctN(DoneTotalMod, (*i)->GetAmount());\n                else if (!((*i)->GetSpellInfo()->AttributesEx5 & SPELL_ATTR5_SPECIAL_ITEM_CLASS_CHECK) && ((*i)->GetSpellInfo()->EquippedItemSubClassMask == 0))\n                    AddPctN(DoneTotalMod, (*i)->GetAmount());\n                else if (ToPlayer() && ToPlayer()->HasItemFitToSpellRequirements((*i)->GetSpellInfo()))\n                    AddPctN(DoneTotalMod, (*i)->GetAmount());\n            }\n        }\n    }\n\n    uint32 creatureTypeMask = victim->GetCreatureTypeMask();\n    // Add flat bonus from spell damage versus\n    DoneTotal += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_FLAT_SPELL_DAMAGE_VERSUS, creatureTypeMask);\n    AuraEffectList const& mDamageDoneVersus = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);\n    for (AuraEffectList::const_iterator i = mDamageDoneVersus.begin(); i != mDamageDoneVersus.end(); ++i)\n        if (creatureTypeMask & uint32((*i)->GetMiscValue()))\n            AddPctN(DoneTotalMod, (*i)->GetAmount());\n\n    // bonus against aurastate\n    AuraEffectList const& mDamageDoneVersusAurastate = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS_AURASTATE);\n    for (AuraEffectList::const_iterator i = mDamageDoneVersusAurastate.begin(); i != mDamageDoneVersusAurastate.end(); ++i)\n        if (victim->HasAuraState(AuraStateType((*i)->GetMiscValue())))\n            AddPctN(DoneTotalMod, (*i)->GetAmount());\n\n    // done scripted mod (take it from owner)\n    Unit* owner = GetOwner() ? GetOwner() : this;\n    AuraEffectList const& mOverrideClassScript= owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);\n    for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)\n    {\n        if (!(*i)->IsAffectedOnSpell(spellProto))\n            continue;\n\n        switch ((*i)->GetMiscValue())\n        {\n            case 4920: // Molten Fury\n            case 4919:\n            case 6917: // Death's Embrace\n            case 6926:\n            case 6928:\n            {\n                if (victim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, spellProto, this))\n                    AddPctN(DoneTotalMod, (*i)->GetAmount());\n                break;\n            }\n            // Soul Siphon\n            case 4992:\n            case 4993:\n            {\n                // effect 1 m_amount\n                int32 maxPercent = (*i)->GetAmount();\n                // effect 0 m_amount\n                int32 stepPercent = CalculateSpellDamage(this, (*i)->GetSpellInfo(), 0);\n                // count affliction effects and calc additional damage in percentage\n                int32 modPercent = 0;\n                AuraApplicationMap const& victimAuras = victim->GetAppliedAuras();\n                for (AuraApplicationMap::const_iterator itr = victimAuras.begin(); itr != victimAuras.end(); ++itr)\n                {\n                    Aura const* aura = itr->second->GetBase();\n                    SpellInfo const* m_spell = aura->GetSpellInfo();\n                    if (m_spell->SpellFamilyName != SPELLFAMILY_WARLOCK || !(m_spell->SpellFamilyFlags[1] & 0x0004071B || m_spell->SpellFamilyFlags[0] & 0x8044C402))\n                        continue;\n                    modPercent += stepPercent * aura->GetStackAmount();\n                    if (modPercent >= maxPercent)\n                    {\n                        modPercent = maxPercent;\n                        break;\n                    }\n                }\n                AddPctN(DoneTotalMod, modPercent);\n                break;\n            }\n            case 6916: // Death's Embrace\n            case 6925:\n            case 6927:\n                if (HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, spellProto, this))\n                    AddPctN(DoneTotalMod, (*i)->GetAmount());\n                break;\n            case 5481: // Starfire Bonus\n            {\n                if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x200002, 0, 0))\n                    AddPctN(DoneTotalMod, (*i)->GetAmount());\n                break;\n            }\n            case 4418: // Increased Shock Damage\n            case 4554: // Increased Lightning Damage\n            case 4555: // Improved Moonfire\n            case 5142: // Increased Lightning Damage\n            case 5147: // Improved Consecration / Libram of Resurgence\n            case 5148: // Idol of the Shooting Star\n            case 6008: // Increased Lightning Damage\n            case 8627: // Totem of Hex\n            {\n                DoneTotal += (*i)->GetAmount();\n                break;\n            }\n            // Tundra Stalker\n            // Merciless Combat\n            case 7277:\n            {\n                // Merciless Combat\n                if ((*i)->GetSpellInfo()->SpellIconID == 2656)\n                {\n                    if (!victim->HealthAbovePct(35))\n                        AddPctN(DoneTotalMod, (*i)->GetAmount());\n                }\n                // Tundra Stalker\n                else\n                {\n                    // Frost Fever (target debuff)\n                    if (victim->HasAura(55095))\n                        AddPctN(DoneTotalMod, (*i)->GetAmount());\n                    break;\n                }\n                break;\n            }\n            // Rage of Rivendare\n            case 7293:\n            {\n                if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0, 0x02000000, 0))\n                    AddPctF(DoneTotalMod, (*i)->GetSpellInfo()->GetRank() * 2.0f);\n                break;\n            }\n            // Twisted Faith\n            case 7377:\n            {\n                if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0, 0, GetGUID()))\n                    AddPctN(DoneTotalMod, (*i)->GetAmount());\n                break;\n            }\n            // Marked for Death\n            case 7598:\n            case 7599:\n            case 7600:\n            case 7601:\n            case 7602:\n            {\n                if (victim->GetAuraEffect(SPELL_AURA_MOD_STALKED, SPELLFAMILY_HUNTER, 0x400, 0, 0))\n                    AddPctN(DoneTotalMod, (*i)->GetAmount());\n                break;\n            }\n            // Dirty Deeds\n            case 6427:\n            case 6428:\n            case 6579:\n            case 6580:\n            {\n                if (victim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, spellProto, this))\n                {\n                    // effect 0 has expected value but in negative state\n                    int32 bonus = -(*i)->GetBase()->GetEffect(0)->GetAmount();\n                    AddPctN(DoneTotalMod, bonus);\n                }\n                break;\n            }\n        }\n    }\n\n    // Custom scripted damage\n    switch (spellProto->SpellFamilyName)\n    {\n        case SPELLFAMILY_MAGE:\n            // Ice Lance\n            if (spellProto->SpellIconID == 186)\n            {\n                if (victim->HasAuraState(AURA_STATE_FROZEN, spellProto, this))\n                {\n                    // Glyph of Ice Lance\n                    if (owner->HasAura(56377) && victim->getLevel() > owner->getLevel())\n                        DoneTotalMod *= 4.0f;\n                    else\n                        DoneTotalMod *= 3.0f;\n                }\n            }\n\n            // Torment the weak\n            if (spellProto->SpellFamilyFlags[0] & 0x20600021 || spellProto->SpellFamilyFlags[1] & 0x9000)\n                if (victim->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_SLOW_ATTACK)))\n                {\n                    AuraEffectList const& mDumyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);\n                    for (AuraEffectList::const_iterator i = mDumyAuras.begin(); i != mDumyAuras.end(); ++i)\n                        if ((*i)->GetSpellInfo()->SpellIconID == 3263)\n                        {\n                            AddPctN(DoneTotalMod, (*i)->GetAmount());\n                            break;\n                        }\n                }\n            break;\n        case SPELLFAMILY_PRIEST:\n            // Mind Flay\n            if (spellProto->SpellFamilyFlags[0] & 0x800000)\n            {\n                // Glyph of Shadow Word: Pain\n                if (AuraEffect* aurEff = GetAuraEffect(55687, 0))\n                    // Increase Mind Flay damage if Shadow Word: Pain present on target\n                    if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0, 0, GetGUID()))\n                        AddPctN(DoneTotalMod, aurEff->GetAmount());\n\n                // Twisted Faith - Mind Flay part\n                if (AuraEffect* aurEff = GetAuraEffect(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS, SPELLFAMILY_PRIEST, 2848, 1))\n                    // Increase Mind Flay damage if Shadow Word: Pain present on target\n                    if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0, 0, GetGUID()))\n                        AddPctN(DoneTotalMod, aurEff->GetAmount());\n            }\n            // Smite\n            else if (spellProto->SpellFamilyFlags[0] & 0x80)\n            {\n                // Glyph of Smite\n                if (AuraEffect* aurEff = GetAuraEffect(55692, 0))\n                    if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x100000, 0, 0, GetGUID()))\n                        AddPctN(DoneTotalMod, aurEff->GetAmount());\n            }\n            // Shadow Word: Death\n            else if (spellProto->SpellFamilyFlags[1] & 0x2)\n            {\n                // Glyph of Shadow Word: Death\n                if (AuraEffect* aurEff = GetAuraEffect(55682, 1))\n                    if (victim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))\n                        AddPctN(DoneTotalMod, aurEff->GetAmount());\n            }\n            break;\n        case SPELLFAMILY_PALADIN:\n            // Judgement of Vengeance/Judgement of Corruption\n            if ((spellProto->SpellFamilyFlags[1] & 0x400000) && spellProto->SpellIconID == 2292)\n            {\n                // Get stack of Holy Vengeance/Blood Corruption on the target added by caster\n                uint32 stacks = 0;\n                Unit::AuraEffectList const& auras = victim->GetAuraEffectsByType(SPELL_AURA_PERIODIC_DAMAGE);\n                for (Unit::AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)\n                    if (((*itr)->GetId() == 31803 || (*itr)->GetId() == 53742) && (*itr)->GetCasterGUID() == GetGUID())\n                    {\n                        stacks = (*itr)->GetBase()->GetStackAmount();\n                        break;\n                    }\n                // + 10% for each application of Holy Vengeance/Blood Corruption on the target\n                if (stacks)\n                    AddPctU(DoneTotalMod, 10 * stacks);\n            }\n            break;\n        case SPELLFAMILY_DRUID:\n            // Thorns\n            if (spellProto->SpellFamilyFlags[0] & 0x100)\n            {\n                // Brambles\n                if (AuraEffect* aurEff = GetAuraEffectOfRankedSpell(16836, 0))\n                    AddPctN(DoneTotalMod, aurEff->GetAmount());\n            }\n            break;\n        case SPELLFAMILY_WARLOCK:\n            // Fire and Brimstone\n            if (spellProto->SpellFamilyFlags[1] & 0x00020040)\n                if (victim->HasAuraState(AURA_STATE_CONFLAGRATE))\n                {\n                    AuraEffectList const& mDumyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);\n                    for (AuraEffectList::const_iterator i = mDumyAuras.begin(); i != mDumyAuras.end(); ++i)\n                        if ((*i)->GetSpellInfo()->SpellIconID == 3173)\n                        {\n                            AddPctN(DoneTotalMod, (*i)->GetAmount());\n                            break;\n                        }\n                }\n            // Drain Soul - increased damage for targets under 25 % HP\n            if (spellProto->SpellFamilyFlags[0] & 0x00004000)\n                if (HasAura(100001))\n                    DoneTotalMod *= 4;\n            // Shadow Bite (15% increase from each dot)\n            if (spellProto->SpellFamilyFlags[1] & 0x00400000 && isPet())\n                if (uint8 count = victim->GetDoTsByCaster(GetOwnerGUID()))\n                    AddPctN(DoneTotalMod, 15 * count);\n            break;\n        case SPELLFAMILY_HUNTER:\n            // Steady Shot\n            if (spellProto->SpellFamilyFlags[1] & 0x1)\n                if (AuraEffect* aurEff = GetAuraEffect(56826, 0))  // Glyph of Steady Shot\n                    if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_HUNTER, 0x00004000, 0, 0, GetGUID()))\n                        AddPctN(DoneTotalMod, aurEff->GetAmount());\n            break;\n        case SPELLFAMILY_DEATHKNIGHT:\n            // Improved Icy Touch\n            if (spellProto->SpellFamilyFlags[0] & 0x2)\n                if (AuraEffect* aurEff = GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 2721, 0))\n                    AddPctN(DoneTotalMod, aurEff->GetAmount());\n\n            // Sigil of the Vengeful Heart\n            if (spellProto->SpellFamilyFlags[0] & 0x2000)\n                if (AuraEffect* aurEff = GetAuraEffect(64962, EFFECT_1))\n                    AddPctN(DoneTotal, aurEff->GetAmount());\n\n            // Glacier Rot\n            if (spellProto->SpellFamilyFlags[0] & 0x2 || spellProto->SpellFamilyFlags[1] & 0x6)\n                if (AuraEffect* aurEff = GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 196, 0))\n                    if (victim->GetDiseasesByCaster(owner->GetGUID()) > 0)\n                        AddPctN(DoneTotalMod, aurEff->GetAmount());\n\n            // Impurity (dummy effect)\n            if (GetTypeId() == TYPEID_PLAYER)\n            {\n                PlayerSpellMap playerSpells = ToPlayer()->GetSpellMap();\n                for (PlayerSpellMap::const_iterator itr = playerSpells.begin(); itr != playerSpells.end(); ++itr)\n                {\n                    if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)\n                        continue;\n                    switch (itr->first)\n                    {\n                        case 49220:\n                        case 49633:\n                        case 49635:\n                        case 49636:\n                        case 49638:\n                        {\n                            if (SpellInfo const* proto = sSpellMgr->GetSpellInfo(itr->first))\n                                AddPctN(ApCoeffMod, proto->Effects[0].CalcValue());\n                        }\n                        break;\n                    }\n                }\n            }\n            break;\n    }\n\n    // Done fixed damage bonus auras\n    int32 DoneAdvertisedBenefit  = SpellBaseDamageBonusDone(spellProto->GetSchoolMask());\n    // Pets just add their bonus damage to their spell damage\n    // note that their spell damage is just gain of their own auras\n    if (HasUnitTypeMask(UNIT_MASK_GUARDIAN))\n        DoneAdvertisedBenefit += ((Guardian*)this)->GetBonusDamage();\n\n    // Check for table values\n    float coeff = 0;\n    SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellProto->Id);\n    if (bonus)\n    {\n        if (damagetype == DOT)\n        {\n            coeff = bonus->dot_damage;\n            if (bonus->ap_dot_bonus > 0)\n            {\n                WeaponAttackType attType = (spellProto->IsRangedWeaponSpell() && spellProto->DmgClass != SPELL_DAMAGE_CLASS_MELEE) ? RANGED_ATTACK : BASE_ATTACK;\n                float APbonus = float(victim->GetTotalAuraModifier(attType == BASE_ATTACK ? SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS : SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS));\n                APbonus += GetTotalAttackPowerValue(attType);\n                DoneTotal += int32(bonus->ap_dot_bonus * stack * ApCoeffMod * APbonus);\n            }\n        }\n        else\n        {\n            coeff = bonus->direct_damage;\n            if (bonus->ap_bonus > 0)\n            {\n                WeaponAttackType attType = (spellProto->IsRangedWeaponSpell() && spellProto->DmgClass != SPELL_DAMAGE_CLASS_MELEE) ? RANGED_ATTACK : BASE_ATTACK;\n                float APbonus = float(victim->GetTotalAuraModifier(attType == BASE_ATTACK ? SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS : SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS));\n                APbonus += GetTotalAttackPowerValue(attType);\n                DoneTotal += int32(bonus->ap_bonus * stack * ApCoeffMod * APbonus);\n            }\n        }\n    }\n    // Default calculation\n    if (DoneAdvertisedBenefit)\n    {\n        if (!bonus || coeff < 0)\n            coeff = CalculateDefaultCoefficient(spellProto, damagetype) * int32(stack);\n\n        float factorMod = CalculateLevelPenalty(spellProto) * stack;\n\n        if (Player* modOwner = GetSpellModOwner())\n        {\n            coeff *= 100.0f;\n            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff);\n            coeff /= 100.0f;\n        }\n        DoneTotal += int32(DoneAdvertisedBenefit * coeff * factorMod);\n    }\n\n    float tmpDamage = (int32(pdamage) + DoneTotal) * DoneTotalMod;\n    // apply spellmod to Done damage (flat and pct)\n    if (Player* modOwner = GetSpellModOwner())\n        modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, tmpDamage);\n\n    return uint32(std::max(tmpDamage, 0.0f));\n}\n\nuint32 Unit::SpellDamageBonusTaken(Unit* caster, SpellInfo const* spellProto, uint32 pdamage, DamageEffectType damagetype, uint32 stack)\n{\n    if (!spellProto || damagetype == DIRECT_DAMAGE)\n        return pdamage;\n\n    int32 TakenTotal = 0;\n    float TakenTotalMod = 1.0f;\n    float TakenTotalCasterMod = 0.0f;\n\n    // get all auras from caster that allow the spell to ignore resistance (sanctified wrath)\n    AuraEffectList const& IgnoreResistAuras = caster->GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);\n    for (AuraEffectList::const_iterator i = IgnoreResistAuras.begin(); i != IgnoreResistAuras.end(); ++i)\n    {\n        if ((*i)->GetMiscValue() & spellProto->GetSchoolMask())\n            TakenTotalCasterMod += (float((*i)->GetAmount()));\n    }\n\n    // from positive and negative SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN\n    // multiplicative bonus, for example Dispersion + Shadowform (0.10*0.85=0.085)\n    TakenTotalMod *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, spellProto->GetSchoolMask());\n\n    //.. taken pct: dummy auras\n    AuraEffectList const& mDummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);\n    for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)\n    {\n        switch ((*i)->GetSpellInfo()->SpellIconID)\n        {\n            // Cheat Death\n            case 2109:\n                if ((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)\n                {\n                    if (GetTypeId() != TYPEID_PLAYER)\n                        continue;\n                    float mod = ToPlayer()->GetRatingBonusValue(CR_CRIT_TAKEN_MELEE) * (-8.0f);\n                    AddPctF(TakenTotalMod, std::max(mod, float((*i)->GetAmount())));\n                }\n                break;\n        }\n    }\n\n    // From caster spells\n    AuraEffectList const& mOwnerTaken = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_FROM_CASTER);\n    for (AuraEffectList::const_iterator i = mOwnerTaken.begin(); i != mOwnerTaken.end(); ++i)\n        if ((*i)->GetCasterGUID() == caster->GetGUID() && (*i)->IsAffectedOnSpell(spellProto))\n            AddPctN(TakenTotalMod, (*i)->GetAmount());\n\n    // Mod damage from spell mechanic\n    if (uint32 mechanicMask = spellProto->GetAllEffectsMechanicMask())\n    {\n        AuraEffectList const& mDamageDoneMechanic = GetAuraEffectsByType(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT);\n        for (AuraEffectList::const_iterator i = mDamageDoneMechanic.begin(); i != mDamageDoneMechanic.end(); ++i)\n            if (mechanicMask & uint32(1<<((*i)->GetMiscValue())))\n                AddPctN(TakenTotalMod, (*i)->GetAmount());\n    }\n\n    int32 TakenAdvertisedBenefit = SpellBaseDamageBonusTaken(spellProto->GetSchoolMask());\n\n    // Check for table values\n    float coeff = 0;\n    SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellProto->Id);\n    if (bonus)\n        coeff = (damagetype == DOT) ? bonus->dot_damage : bonus->direct_damage;\n\n    // Default calculation\n    if (TakenAdvertisedBenefit)\n    {\n        if (!bonus || coeff < 0)\n            coeff = CalculateDefaultCoefficient(spellProto, damagetype) * int32(stack);\n\n        float factorMod = CalculateLevelPenalty(spellProto) * stack;\n        // level penalty still applied on Taken bonus - is it blizzlike?\n        if (Player* modOwner = GetSpellModOwner())\n        {\n            coeff *= 100.0f;\n            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff);\n            coeff /= 100.0f;\n        }\n        TakenTotal+= int32(TakenAdvertisedBenefit * coeff * factorMod);\n    }\n\n    float tmpDamage = 0.0f;\n\n    if (TakenTotalCasterMod)\n    {\n        if (TakenTotal < 0)\n        {\n            if (TakenTotalMod < 1)\n                tmpDamage = ((float(CalculatePctF(pdamage, TakenTotalCasterMod) + TakenTotal) * TakenTotalMod) + CalculatePctF(pdamage, TakenTotalCasterMod));\n            else\n                tmpDamage = ((float(CalculatePctF(pdamage, TakenTotalCasterMod) + TakenTotal) + CalculatePctF(pdamage, TakenTotalCasterMod)) * TakenTotalMod);\n        }\n        else if (TakenTotalMod < 1)\n            tmpDamage = ((CalculatePctF(float(pdamage) + TakenTotal, TakenTotalCasterMod) * TakenTotalMod) + CalculatePctF(float(pdamage) + TakenTotal, TakenTotalCasterMod));\n    }\n    if (!tmpDamage)\n        tmpDamage = (float(pdamage) + TakenTotal) * TakenTotalMod;\n\n    return uint32(std::max(tmpDamage, 0.0f));\n}\n\nint32 Unit::SpellBaseDamageBonusDone(SpellSchoolMask schoolMask)\n{\n    int32 DoneAdvertisedBenefit = 0;\n\n    AuraEffectList const& mDamageDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);\n    for (AuraEffectList::const_iterator i = mDamageDone.begin(); i != mDamageDone.end(); ++i)\n        if (((*i)->GetMiscValue() & schoolMask) != 0 &&\n        (*i)->GetSpellInfo()->EquippedItemClass == -1 &&\n                                                            // -1 == any item class (not wand then)\n        (*i)->GetSpellInfo()->EquippedItemInventoryTypeMask == 0)\n                                                            // 0 == any inventory type (not wand then)\n            DoneAdvertisedBenefit += (*i)->GetAmount();\n\n    if (GetTypeId() == TYPEID_PLAYER)\n    {\n        // Base value\n        DoneAdvertisedBenefit += ToPlayer()->GetBaseSpellPowerBonus();\n\n        // Damage bonus from stats\n        AuraEffectList const& mDamageDoneOfStatPercent = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT);\n        for (AuraEffectList::const_iterator i = mDamageDoneOfStatPercent.begin(); i != mDamageDoneOfStatPercent.end(); ++i)\n        {\n            if ((*i)->GetMiscValue() & schoolMask)\n            {\n                // stat used stored in miscValueB for this aura\n                Stats usedStat = Stats((*i)->GetMiscValueB());\n                DoneAdvertisedBenefit += int32(CalculatePctN(GetStat(usedStat), (*i)->GetAmount()));\n            }\n        }\n        // ... and attack power\n        AuraEffectList const& mDamageDonebyAP = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_ATTACK_POWER);\n        for (AuraEffectList::const_iterator i =mDamageDonebyAP.begin(); i != mDamageDonebyAP.end(); ++i)\n            if ((*i)->GetMiscValue() & schoolMask)\n                DoneAdvertisedBenefit += int32(CalculatePctN(GetTotalAttackPowerValue(BASE_ATTACK), (*i)->GetAmount()));\n\n    }\n    return DoneAdvertisedBenefit;\n}\n\nint32 Unit::SpellBaseDamageBonusTaken(SpellSchoolMask schoolMask)\n{\n    int32 TakenAdvertisedBenefit = 0;\n\n    AuraEffectList const& mDamageTaken = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_TAKEN);\n    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)\n        if (((*i)->GetMiscValue() & schoolMask) != 0)\n            TakenAdvertisedBenefit += (*i)->GetAmount();\n\n    return TakenAdvertisedBenefit;\n}\n\nbool Unit::isSpellCrit(Unit* victim, SpellInfo const* spellProto, SpellSchoolMask schoolMask, WeaponAttackType attackType) const\n{\n    //! Mobs can't crit with spells. Player Totems can\n    //! Fire Elemental (from totem) can too - but this part is a hack and needs more research\n    if (IS_CREATURE_GUID(GetGUID()) && !(isTotem() && IS_PLAYER_GUID(GetOwnerGUID())) && GetEntry() != 15438)\n        return false;\n\n    // not critting spell\n    if ((spellProto->AttributesEx2 & SPELL_ATTR2_CANT_CRIT))\n        return false;\n\n    float crit_chance = 0.0f;\n    switch (spellProto->DmgClass)\n    {\n        case SPELL_DAMAGE_CLASS_NONE:\n            // We need more spells to find a general way (if there is any)\n            switch (spellProto->Id)\n            {\n                case 379:   // Earth Shield\n                case 33778: // Lifebloom Final Bloom\n                case 64844: // Divine Hymn\n                case 71607: // Item - Bauble of True Blood 10m\n                case 71646: // Item - Bauble of True Blood 25m\n                    break;\n                default:\n                    return false;\n            }\n        case SPELL_DAMAGE_CLASS_MAGIC:\n        {\n            if (schoolMask & SPELL_SCHOOL_MASK_NORMAL)\n                crit_chance = 0.0f;\n            // For other schools\n            else if (GetTypeId() == TYPEID_PLAYER)\n                crit_chance = GetFloatValue(PLAYER_SPELL_CRIT_PERCENTAGE1 + GetFirstSchoolInMask(schoolMask));\n            else\n            {\n                crit_chance = (float)m_baseSpellCritChance;\n                crit_chance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL, schoolMask);\n            }\n            // taken\n            if (victim)\n            {\n                if (!spellProto->IsPositive())\n                {\n                    // Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE\n                    crit_chance += victim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE, schoolMask);\n                    // Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE\n                    crit_chance += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE);\n                    ApplyResilience(victim, &crit_chance, NULL, false, CR_CRIT_TAKEN_SPELL);\n                }\n                // scripted (increase crit chance ... against ... target by x%\n                AuraEffectList const& mOverrideClassScript = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);\n                for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)\n                {\n                    if (!((*i)->IsAffectedOnSpell(spellProto)))\n                        continue;\n                    int32 modChance = 0;\n                    switch ((*i)->GetMiscValue())\n                    {\n                        // Shatter\n                        case  911: modChance+= 16;\n                        case  910: modChance+= 17;\n                        case  849: modChance+= 17;\n                            if (!victim->HasAuraState(AURA_STATE_FROZEN, spellProto, this))\n                                break;\n                            crit_chance+=modChance;\n                            break;\n                        case 7917: // Glyph of Shadowburn\n                            if (victim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, spellProto, this))\n                                crit_chance+=(*i)->GetAmount();\n                            break;\n                        case 7997: // Renewed Hope\n                        case 7998:\n                            if (victim->HasAura(6788))\n                                crit_chance+=(*i)->GetAmount();\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                // Custom crit by class\n                switch (spellProto->SpellFamilyName)\n                {\n                    case SPELLFAMILY_MAGE:\n                        // Glyph of Fire Blast\n                        if (spellProto->SpellFamilyFlags[0] == 0x2 && spellProto->SpellIconID == 12)\n                            if (victim->HasAuraWithMechanic((1<<MECHANIC_STUN) | (1<<MECHANIC_KNOCKOUT)))\n                                if (AuraEffect const* aurEff = GetAuraEffect(56369, EFFECT_0))\n                                    crit_chance += aurEff->GetAmount();\n                        break;\n                    case SPELLFAMILY_DRUID:\n                        // Improved Faerie Fire\n                        if (victim->HasAuraState(AURA_STATE_FAERIE_FIRE))\n                            if (AuraEffect const* aurEff = GetDummyAuraEffect(SPELLFAMILY_DRUID, 109, 0))\n                                crit_chance += aurEff->GetAmount();\n\n                        // cumulative effect - don't break\n\n                        // Starfire\n                        if (spellProto->SpellFamilyFlags[0] & 0x4 && spellProto->SpellIconID == 1485)\n                        {\n                            // Improved Insect Swarm\n                            if (AuraEffect const* aurEff = GetDummyAuraEffect(SPELLFAMILY_DRUID, 1771, 0))\n                                if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x00000002, 0, 0))\n                                    crit_chance += aurEff->GetAmount();\n                           break;\n                        }\n                    break;\n                    case SPELLFAMILY_ROGUE:\n                        // Shiv-applied poisons can't crit\n                        if (FindCurrentSpellBySpellId(5938))\n                            crit_chance = 0.0f;\n                        break;\n                    case SPELLFAMILY_PALADIN:\n                        // Flash of light\n                        if (spellProto->SpellFamilyFlags[0] & 0x40000000)\n                        {\n                            // Sacred Shield\n                            if (AuraEffect const* aura = victim->GetAuraEffect(58597, 1, GetGUID()))\n                                crit_chance += aura->GetAmount();\n                            break;\n                        }\n                        // Exorcism\n                        else if (spellProto->Category == 19)\n                        {\n                            if (victim->GetCreatureTypeMask() & CREATURE_TYPEMASK_DEMON_OR_UNDEAD)\n                                return true;\n                            break;\n                        }\n                    break;\n                    case SPELLFAMILY_SHAMAN:\n                        // Lava Burst\n                        if (spellProto->SpellFamilyFlags[1] & 0x00001000)\n                        {\n                            if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_SHAMAN, 0x10000000, 0, 0, GetGUID()))\n                                if (victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE) > -100)\n                                    return true;\n                            break;\n                        }\n                    break;\n                }\n            }\n            break;\n        }\n        case SPELL_DAMAGE_CLASS_MELEE:\n            if (victim)\n            {\n                // Custom crit by class\n                switch (spellProto->SpellFamilyName)\n                {\n                    case SPELLFAMILY_DRUID:\n                        // Rend and Tear - bonus crit chance for Ferocious Bite on bleeding targets\n                        if (spellProto->SpellFamilyFlags[0] & 0x00800000\n                            && spellProto->SpellIconID == 1680\n                            && victim->HasAuraState(AURA_STATE_BLEEDING))\n                        {\n                            if (AuraEffect const* rendAndTear = GetDummyAuraEffect(SPELLFAMILY_DRUID, 2859, 1))\n                                crit_chance += rendAndTear->GetAmount();\n                            break;\n                        }\n                    break;\n                    case SPELLFAMILY_WARRIOR:\n                       // Victory Rush\n                       if (spellProto->SpellFamilyFlags[1] & 0x100)\n                       {\n                           // Glyph of Victory Rush\n                           if (AuraEffect const* aurEff = GetAuraEffect(58382, 0))\n                               crit_chance += aurEff->GetAmount();\n                           break;\n                       }\n                    break;\n                }\n            }\n        case SPELL_DAMAGE_CLASS_RANGED:\n        {\n            if (victim)\n            {\n                crit_chance += GetUnitCriticalChance(attackType, victim);\n                crit_chance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL, schoolMask);\n            }\n            break;\n        }\n        default:\n            return false;\n    }\n    // percent done\n    // only players use intelligence for critical chance computations\n    if (Player* modOwner = GetSpellModOwner())\n        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CRITICAL_CHANCE, crit_chance);\n\n    crit_chance = crit_chance > 0.0f ? crit_chance : 0.0f;\n    if (roll_chance_f(crit_chance))\n        return true;\n    return false;\n}\n\nuint32 Unit::SpellCriticalDamageBonus(SpellInfo const* spellProto, uint32 damage, Unit* victim)\n{\n    // Calculate critical bonus\n    int32 crit_bonus = damage;\n    float crit_mod = 0.0f;\n\n    switch (spellProto->DmgClass)\n    {\n        case SPELL_DAMAGE_CLASS_MELEE:                      // for melee based spells is 100%\n        case SPELL_DAMAGE_CLASS_RANGED:\n            // TODO: write here full calculation for melee/ranged spells\n            crit_bonus += damage;\n            break;\n        default:\n            crit_bonus += damage / 2;                       // for spells is 50%\n            break;\n    }\n\n    crit_mod += (GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS, spellProto->GetSchoolMask()) - 1.0f) * 100;\n\n    if (victim)\n        crit_mod += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, victim->GetCreatureTypeMask());\n\n    if (crit_bonus != 0)\n        AddPctF(crit_bonus, crit_mod);\n\n    crit_bonus -= damage;\n\n    if (damage > uint32(crit_bonus))\n    {\n        // adds additional damage to critBonus (from talents)\n        if (Player* modOwner = GetSpellModOwner())\n            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CRIT_DAMAGE_BONUS, crit_bonus);\n    }\n\n    crit_bonus += damage;\n\n    return crit_bonus;\n}\n\nuint32 Unit::SpellCriticalHealingBonus(SpellInfo const* spellProto, uint32 damage, Unit* victim)\n{\n    // Calculate critical bonus\n    int32 crit_bonus;\n    switch (spellProto->DmgClass)\n    {\n        case SPELL_DAMAGE_CLASS_MELEE:                      // for melee based spells is 100%\n        case SPELL_DAMAGE_CLASS_RANGED:\n            // TODO: write here full calculation for melee/ranged spells\n            crit_bonus = damage;\n            break;\n        default:\n            crit_bonus = damage / 2;                        // for spells is 50%\n            break;\n    }\n\n    if (victim)\n    {\n        uint32 creatureTypeMask = victim->GetCreatureTypeMask();\n        crit_bonus = int32(crit_bonus * GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, creatureTypeMask));\n    }\n\n    if (crit_bonus > 0)\n        damage += crit_bonus;\n\n    damage = int32(float(damage) * GetTotalAuraMultiplier(SPELL_AURA_MOD_CRITICAL_HEALING_AMOUNT));\n\n    return damage;\n}\n\nuint32 Unit::SpellHealingBonusDone(Unit* victim, SpellInfo const* spellProto, uint32 healamount, DamageEffectType damagetype, uint32 stack)\n{\n    // For totems get healing bonus from owner (statue isn't totem in fact)\n    if (GetTypeId() == TYPEID_UNIT && isTotem())\n        if (Unit* owner = GetOwner())\n            return owner->SpellHealingBonusDone(victim, spellProto, healamount, damagetype, stack);\n\n    // No bonus healing for potion spells\n    if (spellProto->SpellFamilyName == SPELLFAMILY_POTION)\n        return healamount;\n\n    float DoneTotalMod = 1.0f;\n    int32 DoneTotal = 0;\n\n    // Healing done percent\n    AuraEffectList const& mHealingDonePct = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE_PERCENT);\n    for (AuraEffectList::const_iterator i = mHealingDonePct.begin(); i != mHealingDonePct.end(); ++i)\n        AddPctN(DoneTotalMod, (*i)->GetAmount());\n\n    // done scripted mod (take it from owner)\n    Unit* owner = GetOwner() ? GetOwner() : this;\n    AuraEffectList const& mOverrideClassScript= owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);\n    for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)\n    {\n        if (!(*i)->IsAffectedOnSpell(spellProto))\n            continue;\n        switch ((*i)->GetMiscValue())\n        {\n            case 4415: // Increased Rejuvenation Healing\n            case 4953:\n            case 3736: // Hateful Totem of the Third Wind / Increased Lesser Healing Wave / LK Arena (4/5/6) Totem of the Third Wind / Savage Totem of the Third Wind\n                DoneTotal += (*i)->GetAmount();\n                break;\n            case   21: // Test of Faith\n            case 6935:\n            case 6918:\n                if (victim->HealthBelowPct(50))\n                    AddPctN(DoneTotalMod, (*i)->GetAmount());\n                break;\n            case 7798: // Glyph of Regrowth\n            {\n                if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x40, 0, 0))\n                    AddPctN(DoneTotalMod, (*i)->GetAmount());\n                break;\n            }\n            case 8477: // Nourish Heal Boost\n            {\n                int32 stepPercent = (*i)->GetAmount();\n                int32 modPercent = 0;\n                AuraApplicationMap const& victimAuras = victim->GetAppliedAuras();\n                for (AuraApplicationMap::const_iterator itr = victimAuras.begin(); itr != victimAuras.end(); ++itr)\n                {\n                    Aura const* aura = itr->second->GetBase();\n                    if (aura->GetCasterGUID() != GetGUID())\n                        continue;\n                    SpellInfo const* m_spell = aura->GetSpellInfo();\n                    if (m_spell->SpellFamilyName != SPELLFAMILY_DRUID ||\n                        !(m_spell->SpellFamilyFlags[1] & 0x00000010 || m_spell->SpellFamilyFlags[0] & 0x50))\n                        continue;\n                    modPercent += stepPercent * aura->GetStackAmount();\n                }\n                AddPctN(DoneTotalMod, modPercent);\n                break;\n            }\n            case 7871: // Glyph of Lesser Healing Wave\n            {\n                if (victim->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 0, 0x00000400, 0, GetGUID()))\n                    AddPctN(DoneTotalMod, (*i)->GetAmount());\n                break;\n            }\n            default:\n                break;\n        }\n    }\n\n    // Done fixed damage bonus auras\n    int32 DoneAdvertisedBenefit = SpellBaseHealingBonusDone(spellProto->GetSchoolMask());\n\n    // Check for table values\n    SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellProto->Id);\n    float coeff = 0;\n    float factorMod = 1.0f;\n    if (bonus)\n    {\n        if (damagetype == DOT)\n        {\n            coeff = bonus->dot_damage;\n            if (bonus->ap_dot_bonus > 0)\n                DoneTotal += int32(bonus->ap_dot_bonus * stack * GetTotalAttackPowerValue(\n                    (spellProto->IsRangedWeaponSpell() && spellProto->DmgClass !=SPELL_DAMAGE_CLASS_MELEE) ? RANGED_ATTACK : BASE_ATTACK));\n        }\n        else\n        {\n            coeff = bonus->direct_damage;\n            if (bonus->ap_bonus > 0)\n                DoneTotal += int32(bonus->ap_bonus * stack * GetTotalAttackPowerValue(\n                    (spellProto->IsRangedWeaponSpell() && spellProto->DmgClass !=SPELL_DAMAGE_CLASS_MELEE) ? RANGED_ATTACK : BASE_ATTACK));\n        }\n    }\n    else\n    {\n        // No bonus healing for SPELL_DAMAGE_CLASS_NONE class spells by default\n        if (spellProto->DmgClass == SPELL_DAMAGE_CLASS_NONE)\n            return healamount;\n    }\n\n    // Default calculation\n    if (DoneAdvertisedBenefit)\n    {\n        if (!bonus || coeff < 0)\n            coeff = CalculateDefaultCoefficient(spellProto, damagetype) * int32(stack) * 1.88f;  // As wowwiki says: C = (Cast Time / 3.5) * 1.88 (for healing spells)\n\n        factorMod *= CalculateLevelPenalty(spellProto) * stack;\n\n        if (Player* modOwner = GetSpellModOwner())\n        {\n            coeff *= 100.0f;\n            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff);\n            coeff /= 100.0f;\n        }\n\n        // Earthliving - 0.45% of normal hot coeff\n        if (spellProto->SpellFamilyName == SPELLFAMILY_SHAMAN && spellProto->SpellFamilyFlags[1] & 0x80000)\n            factorMod *= 0.45f;\n\n        DoneTotal += int32(DoneAdvertisedBenefit * coeff * factorMod);\n    }\n\n    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)\n    {\n        switch (spellProto->Effects[i].ApplyAuraName)\n        {\n            // Bonus healing does not apply to these spells\n            case SPELL_AURA_PERIODIC_LEECH:\n            case SPELL_AURA_PERIODIC_HEALTH_FUNNEL:\n                DoneTotal = 0;\n                break;\n        }\n        if (spellProto->Effects[i].Effect == SPELL_EFFECT_HEALTH_LEECH)\n            DoneTotal = 0;\n    }\n\n    // use float as more appropriate for negative values and percent applying\n    float heal = float(int32(healamount) + DoneTotal) * DoneTotalMod;\n    // apply spellmod to Done amount\n    if (Player* modOwner = GetSpellModOwner())\n        modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, heal);\n\n    return uint32(std::max(heal, 0.0f));\n}\n\nuint32 Unit::SpellHealingBonusTaken(Unit* caster, SpellInfo const* spellProto, uint32 healamount, DamageEffectType damagetype, uint32 stack)\n{\n    float TakenTotalMod = 1.0f;\n\n    // Healing taken percent\n    float minval = float(GetMaxNegativeAuraModifier(SPELL_AURA_MOD_HEALING_PCT));\n    if (minval)\n        AddPctF(TakenTotalMod, minval);\n\n    float maxval = float(GetMaxPositiveAuraModifier(SPELL_AURA_MOD_HEALING_PCT));\n    if (maxval)\n        AddPctF(TakenTotalMod, maxval);\n\n    // Tenacity increase healing % taken\n    if (AuraEffect const* Tenacity = GetAuraEffect(58549, 0))\n        AddPctN(TakenTotalMod, Tenacity->GetAmount());\n\n    // Healing Done\n    int32 TakenTotal = 0;\n\n    // Taken fixed damage bonus auras\n    int32 TakenAdvertisedBenefit = SpellBaseHealingBonusTaken(spellProto->GetSchoolMask());\n\n    // Nourish cast\n    if (spellProto->SpellFamilyName == SPELLFAMILY_DRUID && spellProto->SpellFamilyFlags[1] & 0x2000000)\n    {\n        // Rejuvenation, Regrowth, Lifebloom, or Wild Growth\n        if (GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x50, 0x4000010, 0))\n            // increase healing by 20%\n            TakenTotalMod *= 1.2f;\n    }\n\n    if (damagetype == DOT)\n    {\n        // Healing over time taken percent\n        float minval_hot = float(GetMaxNegativeAuraModifier(SPELL_AURA_MOD_HOT_PCT));\n        if (minval_hot)\n            AddPctF(TakenTotalMod, minval_hot);\n\n        float maxval_hot = float(GetMaxPositiveAuraModifier(SPELL_AURA_MOD_HOT_PCT));\n        if (maxval_hot)\n            AddPctF(TakenTotalMod, maxval_hot);\n    }\n\n    // Check for table values\n    SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellProto->Id);\n    float coeff = 0;\n    float factorMod = 1.0f;\n    if (bonus)\n        coeff = (damagetype == DOT) ? bonus->dot_damage : bonus->direct_damage;\n    else\n    {\n        // No bonus healing for SPELL_DAMAGE_CLASS_NONE class spells by default\n        if (spellProto->DmgClass == SPELL_DAMAGE_CLASS_NONE)\n        {\n            healamount = uint32(std::max((float(healamount) * TakenTotalMod), 0.0f));\n            return healamount;\n        }\n    }\n\n    // Default calculation\n    if (TakenAdvertisedBenefit)\n    {\n        if (!bonus || coeff < 0)\n            coeff = CalculateDefaultCoefficient(spellProto, damagetype) * int32(stack) * 1.88f;  // As wowwiki says: C = (Cast Time / 3.5) * 1.88 (for healing spells)\n\n        factorMod *= CalculateLevelPenalty(spellProto) * int32(stack);\n        if (Player* modOwner = GetSpellModOwner())\n        {\n            coeff *= 100.0f;\n            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff);\n            coeff /= 100.0f;\n        }\n\n        // Earthliving - 0.45% of normal hot coeff\n        if (spellProto->SpellFamilyName == SPELLFAMILY_SHAMAN && spellProto->SpellFamilyFlags[1] & 0x80000)\n            factorMod *= 0.45f;\n\n        TakenTotal += int32(TakenAdvertisedBenefit * coeff * factorMod);\n    }\n\n    AuraEffectList const& mHealingGet= GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_RECEIVED);\n    for (AuraEffectList::const_iterator i = mHealingGet.begin(); i != mHealingGet.end(); ++i)\n        if (caster->GetGUID() == (*i)->GetCasterGUID() && (*i)->IsAffectedOnSpell(spellProto))\n            AddPctN(TakenTotalMod, (*i)->GetAmount());\n\n    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)\n    {\n        switch (spellProto->Effects[i].ApplyAuraName)\n        {\n            // Bonus healing does not apply to these spells\n            case SPELL_AURA_PERIODIC_LEECH:\n            case SPELL_AURA_PERIODIC_HEALTH_FUNNEL:\n                TakenTotal = 0;\n                break;\n        }\n        if (spellProto->Effects[i].Effect == SPELL_EFFECT_HEALTH_LEECH)\n            TakenTotal = 0;\n    }\n\n    float heal = float(int32(healamount) + TakenTotal) * TakenTotalMod;\n\n    return uint32(std::max(heal, 0.0f));\n}\n\nint32 Unit::SpellBaseHealingBonusDone(SpellSchoolMask schoolMask)\n{\n    int32 AdvertisedBenefit = 0;\n\n    AuraEffectList const& mHealingDone = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE);\n    for (AuraEffectList::const_iterator i = mHealingDone.begin(); i != mHealingDone.end(); ++i)\n        if (!(*i)->GetMiscValue() || ((*i)->GetMiscValue() & schoolMask) != 0)\n            AdvertisedBenefit += (*i)->GetAmount();\n\n    // Healing bonus of spirit, intellect and strength\n    if (GetTypeId() == TYPEID_PLAYER)\n    {\n        // Base value\n        AdvertisedBenefit += ToPlayer()->GetBaseSpellPowerBonus();\n\n        // Healing bonus from stats\n        AuraEffectList const& mHealingDoneOfStatPercent = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT);\n        for (AuraEffectList::const_iterator i = mHealingDoneOfStatPercent.begin(); i != mHealingDoneOfStatPercent.end(); ++i)\n        {\n            // stat used dependent from misc value (stat index)\n            Stats usedStat = Stats((*i)->GetSpellInfo()->Effects[(*i)->GetEffIndex()].MiscValue);\n            AdvertisedBenefit += int32(CalculatePctN(GetStat(usedStat), (*i)->GetAmount()));\n        }\n\n        // ... and attack power\n        AuraEffectList const& mHealingDonebyAP = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER);\n        for (AuraEffectList::const_iterator i = mHealingDonebyAP.begin(); i != mHealingDonebyAP.end(); ++i)\n            if ((*i)->GetMiscValue() & schoolMask)\n                AdvertisedBenefit += int32(CalculatePctN(GetTotalAttackPowerValue(BASE_ATTACK), (*i)->GetAmount()));\n    }\n    return AdvertisedBenefit;\n}\n\nint32 Unit::SpellBaseHealingBonusTaken(SpellSchoolMask schoolMask)\n{\n    int32 AdvertisedBenefit = 0;\n\n    AuraEffectList const& mDamageTaken = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING);\n    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)\n        if (((*i)->GetMiscValue() & schoolMask) != 0)\n            AdvertisedBenefit += (*i)->GetAmount();\n\n    return AdvertisedBenefit;\n}\n\nbool Unit::IsImmunedToDamage(SpellSchoolMask shoolMask)\n{\n    // If m_immuneToSchool type contain this school type, IMMUNE damage.\n    SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];\n    for (SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)\n        if (itr->type & shoolMask)\n            return true;\n\n    // If m_immuneToDamage type contain magic, IMMUNE damage.\n    SpellImmuneList const& damageList = m_spellImmune[IMMUNITY_DAMAGE];\n    for (SpellImmuneList::const_iterator itr = damageList.begin(); itr != damageList.end(); ++itr)\n        if (itr->type & shoolMask)\n            return true;\n\n    return false;\n}\n\nbool Unit::IsImmunedToDamage(SpellInfo const* spellInfo)\n{\n    if (spellInfo->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)\n        return false;\n\n    uint32 shoolMask = spellInfo->GetSchoolMask();\n    if (spellInfo->Id != 42292 && spellInfo->Id != 59752)\n    {\n        // If m_immuneToSchool type contain this school type, IMMUNE damage.\n        SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];\n        for (SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)\n            if (itr->type & shoolMask && !spellInfo->CanPierceImmuneAura(sSpellMgr->GetSpellInfo(itr->spellId)))\n                return true;\n    }\n\n    // If m_immuneToDamage type contain magic, IMMUNE damage.\n    SpellImmuneList const& damageList = m_spellImmune[IMMUNITY_DAMAGE];\n    for (SpellImmuneList::const_iterator itr = damageList.begin(); itr != damageList.end(); ++itr)\n        if (itr->type & shoolMask)\n            return true;\n\n    return false;\n}\n\nbool Unit::IsImmunedToSpell(SpellInfo const* spellInfo)\n{\n    if (!spellInfo)\n        return false;\n\n    // Single spell immunity.\n    SpellImmuneList const& idList = m_spellImmune[IMMUNITY_ID];\n    for (SpellImmuneList::const_iterator itr = idList.begin(); itr != idList.end(); ++itr)\n        if (itr->type == spellInfo->Id)\n            return true;\n\n    if (spellInfo->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)\n        return false;\n\n    if (spellInfo->Dispel)\n    {\n        SpellImmuneList const& dispelList = m_spellImmune[IMMUNITY_DISPEL];\n        for (SpellImmuneList::const_iterator itr = dispelList.begin(); itr != dispelList.end(); ++itr)\n            if (itr->type == spellInfo->Dispel)\n                return true;\n    }\n\n    // Spells that don't have effectMechanics.\n    if (spellInfo->Mechanic)\n    {\n        SpellImmuneList const& mechanicList = m_spellImmune[IMMUNITY_MECHANIC];\n        for (SpellImmuneList::const_iterator itr = mechanicList.begin(); itr != mechanicList.end(); ++itr)\n            if (itr->type == spellInfo->Mechanic)\n                return true;\n    }\n\n    bool immuneToAllEffects = true;\n    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)\n    {\n        // State/effect immunities applied by aura expect full spell immunity\n        // Ignore effects with mechanic, they are supposed to be checked separately\n        if (!spellInfo->Effects[i].IsEffect())\n            continue;\n        if (!IsImmunedToSpellEffect(spellInfo, i))\n        {\n            immuneToAllEffects = false;\n            break;\n        }\n    }\n\n    if (immuneToAllEffects) //Return immune only if the target is immune to all spell effects.\n        return true;\n\n    if (spellInfo->Id != 42292 && spellInfo->Id != 59752)\n    {\n        SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];\n        for (SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)\n        {\n            SpellInfo const* immuneSpellInfo = sSpellMgr->GetSpellInfo(itr->spellId);\n            if ((itr->type & spellInfo->GetSchoolMask())\n                && !(immuneSpellInfo && immuneSpellInfo->IsPositive() && spellInfo->IsPositive())\n                && !spellInfo->CanPierceImmuneAura(immuneSpellInfo))\n                return true;\n        }\n    }\n\n    return false;\n}\n\nbool Unit::IsImmunedToSpellEffect(SpellInfo const* spellInfo, uint32 index) const\n{\n    if (!spellInfo || !spellInfo->Effects[index].IsEffect())\n        return false;\n\n    // If m_immuneToEffect type contain this effect type, IMMUNE effect.\n    uint32 effect = spellInfo->Effects[index].Effect;\n    SpellImmuneList const& effectList = m_spellImmune[IMMUNITY_EFFECT];\n    for (SpellImmuneList::const_iterator itr = effectList.begin(); itr != effectList.end(); ++itr)\n        if (itr->type == effect)\n            return true;\n\n    if (uint32 mechanic = spellInfo->Effects[index].Mechanic)\n    {\n        SpellImmuneList const& mechanicList = m_spellImmune[IMMUNITY_MECHANIC];\n        for (SpellImmuneList::const_iterator itr = mechanicList.begin(); itr != mechanicList.end(); ++itr)\n            if (itr->type == mechanic)\n                return true;\n    }\n\n    if (uint32 aura = spellInfo->Effects[index].ApplyAuraName)\n    {\n        SpellImmuneList const& list = m_spellImmune[IMMUNITY_STATE];\n        for (SpellImmuneList::const_iterator itr = list.begin(); itr != list.end(); ++itr)\n            if (itr->type == aura)\n                return true;\n        // Check for immune to application of harmful magical effects\n        AuraEffectList const& immuneAuraApply = GetAuraEffectsByType(SPELL_AURA_MOD_IMMUNE_AURA_APPLY_SCHOOL);\n        for (AuraEffectList::const_iterator iter = immuneAuraApply.begin(); iter != immuneAuraApply.end(); ++iter)\n            if (spellInfo->Dispel == DISPEL_MAGIC &&                                      // Magic debuff\n                ((*iter)->GetMiscValue() & spellInfo->GetSchoolMask()) &&  // Check school\n                !spellInfo->IsPositiveEffect(index))                                  // Harmful\n                return true;\n    }\n\n    return false;\n}\n\nuint32 Unit::MeleeDamageBonusDone(Unit* victim, uint32 pdamage, WeaponAttackType attType, SpellInfo const* spellProto)\n{\n    if (!victim || pdamage == 0)\n        return 0;\n\n    uint32 creatureTypeMask = victim->GetCreatureTypeMask();\n\n    // Done fixed damage bonus auras\n    int32 DoneFlatBenefit = 0;\n\n    // ..done\n    AuraEffectList const& mDamageDoneCreature = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);\n    for (AuraEffectList::const_iterator i = mDamageDoneCreature.begin(); i != mDamageDoneCreature.end(); ++i)\n        if (creatureTypeMask & uint32((*i)->GetMiscValue()))\n            DoneFlatBenefit += (*i)->GetAmount();\n\n    // ..done\n    // SPELL_AURA_MOD_DAMAGE_DONE included in weapon damage\n\n    // ..done (base at attack power for marked target and base at attack power for creature type)\n    int32 APbonus = 0;\n\n    if (attType == RANGED_ATTACK)\n    {\n        APbonus += victim->GetTotalAuraModifier(SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS);\n\n        // ..done (base at attack power and creature type)\n        AuraEffectList const& mCreatureAttackPower = GetAuraEffectsByType(SPELL_AURA_MOD_RANGED_ATTACK_POWER_VERSUS);\n        for (AuraEffectList::const_iterator i = mCreatureAttackPower.begin(); i != mCreatureAttackPower.end(); ++i)\n            if (creatureTypeMask & uint32((*i)->GetMiscValue()))\n                APbonus += (*i)->GetAmount();\n    }\n    else\n    {\n        APbonus += victim->GetTotalAuraModifier(SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS);\n\n        // ..done (base at attack power and creature type)\n        AuraEffectList const& mCreatureAttackPower = GetAuraEffectsByType(SPELL_AURA_MOD_MELEE_ATTACK_POWER_VERSUS);\n        for (AuraEffectList::const_iterator i = mCreatureAttackPower.begin(); i != mCreatureAttackPower.end(); ++i)\n            if (creatureTypeMask & uint32((*i)->GetMiscValue()))\n                APbonus += (*i)->GetAmount();\n    }\n\n    if (APbonus != 0)                                       // Can be negative\n    {\n        bool normalized = false;\n        if (spellProto)\n            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)\n                if (spellProto->Effects[i].Effect == SPELL_EFFECT_NORMALIZED_WEAPON_DMG)\n                {\n                    normalized = true;\n                    break;\n                }\n        DoneFlatBenefit += int32(APbonus/14.0f * GetAPMultiplier(attType, normalized));\n    }\n\n    // Done total percent damage auras\n    float DoneTotalMod = 1.0f;\n\n    // Some spells don't benefit from pct done mods\n    if (spellProto)\n        if (!(spellProto->AttributesEx6 & SPELL_ATTR6_NO_DONE_PCT_DAMAGE_MODS) && !spellProto->IsRankOf(sSpellMgr->GetSpellInfo(12162)))\n        {\n            AuraEffectList const& mModDamagePercentDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);\n            for (AuraEffectList::const_iterator i = mModDamagePercentDone.begin(); i != mModDamagePercentDone.end(); ++i)\n            {\n                if ((*i)->GetMiscValue() & spellProto->GetSchoolMask() && !(spellProto->GetSchoolMask() & SPELL_SCHOOL_MASK_NORMAL))\n                {\n                    if ((*i)->GetSpellInfo()->EquippedItemClass == -1)\n                        AddPctN(DoneTotalMod, (*i)->GetAmount());\n                    else if (!((*i)->GetSpellInfo()->AttributesEx5 & SPELL_ATTR5_SPECIAL_ITEM_CLASS_CHECK) && ((*i)->GetSpellInfo()->EquippedItemSubClassMask == 0))\n                        AddPctN(DoneTotalMod, (*i)->GetAmount());\n                    else if (ToPlayer() && ToPlayer()->HasItemFitToSpellRequirements((*i)->GetSpellInfo()))\n                        AddPctN(DoneTotalMod, (*i)->GetAmount());\n                }\n            }\n        }\n\n    AuraEffectList const& mDamageDoneVersus = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);\n    for (AuraEffectList::const_iterator i = mDamageDoneVersus.begin(); i != mDamageDoneVersus.end(); ++i)\n        if (creatureTypeMask & uint32((*i)->GetMiscValue()))\n            AddPctN(DoneTotalMod, (*i)->GetAmount());\n\n    // bonus against aurastate\n    AuraEffectList const& mDamageDoneVersusAurastate = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS_AURASTATE);\n    for (AuraEffectList::const_iterator i = mDamageDoneVersusAurastate.begin(); i != mDamageDoneVersusAurastate.end(); ++i)\n        if (victim->HasAuraState(AuraStateType((*i)->GetMiscValue())))\n            AddPctN(DoneTotalMod, (*i)->GetAmount());\n\n    // done scripted mod (take it from owner)\n    Unit* owner = GetOwner() ? GetOwner() : this;\n    AuraEffectList const& mOverrideClassScript = owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);\n    for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)\n    {\n        if (!(*i)->IsAffectedOnSpell(spellProto))\n            continue;\n\n        switch ((*i)->GetMiscValue())\n        {\n            // Tundra Stalker\n            // Merciless Combat\n            case 7277:\n            {\n                // Merciless Combat\n                if ((*i)->GetSpellInfo()->SpellIconID == 2656)\n                {\n                    if (!victim->HealthAbovePct(35))\n                        AddPctN(DoneTotalMod, (*i)->GetAmount());\n                }\n                // Tundra Stalker\n                else\n                {\n                    // Frost Fever (target debuff)\n                    if (victim->HasAura(55095))\n                        AddPctN(DoneTotalMod, (*i)->GetAmount());\n                }\n                break;\n            }\n            // Rage of Rivendare\n            case 7293:\n            {\n                if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0, 0x02000000, 0))\n                    AddPctF(DoneTotalMod, (*i)->GetSpellInfo()->GetRank() * 2.0f);\n                break;\n            }\n            // Marked for Death\n            case 7598:\n            case 7599:\n            case 7600:\n            case 7601:\n            case 7602:\n            {\n                if (victim->GetAuraEffect(SPELL_AURA_MOD_STALKED, SPELLFAMILY_HUNTER, 0x400, 0, 0))\n                    AddPctN(DoneTotalMod, (*i)->GetAmount());\n                break;\n            }\n            // Dirty Deeds\n            case 6427:\n            case 6428:\n            {\n                if (victim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, spellProto, this))\n                {\n                    // effect 0 has expected value but in negative state\n                    int32 bonus = -(*i)->GetBase()->GetEffect(0)->GetAmount();\n                    AddPctN(DoneTotalMod, bonus);\n                }\n                break;\n            }\n        }\n    }\n\n    // Custom scripted damage\n    if (spellProto)\n        switch (spellProto->SpellFamilyName)\n        {\n            case SPELLFAMILY_DEATHKNIGHT:\n                // Glacier Rot\n                if (spellProto->SpellFamilyFlags[0] & 0x2 || spellProto->SpellFamilyFlags[1] & 0x6)\n                    if (AuraEffect* aurEff = GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 196, 0))\n                        if (victim->GetDiseasesByCaster(owner->GetGUID()) > 0)\n                            AddPctN(DoneTotalMod, aurEff->GetAmount());\n            break;\n        }\n\n    float tmpDamage = float(int32(pdamage) + DoneFlatBenefit) * DoneTotalMod;\n\n    // apply spellmod to Done damage\n    if (spellProto)\n        if (Player* modOwner = GetSpellModOwner())\n            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_DAMAGE, tmpDamage);\n\n    // bonus result can be negative\n    return uint32(std::max(tmpDamage, 0.0f));\n}\n\nuint32 Unit::MeleeDamageBonusTaken(Unit* attacker, uint32 pdamage, WeaponAttackType attType, SpellInfo const* spellProto)\n{\n    if (pdamage == 0)\n        return 0;\n\n    int32 TakenFlatBenefit = 0;\n    float TakenTotalCasterMod = 0.0f;\n\n    // get all auras from caster that allow the spell to ignore resistance (sanctified wrath)\n    SpellSchoolMask attackSchoolMask = spellProto ? spellProto->GetSchoolMask() : SPELL_SCHOOL_MASK_NORMAL;\n    AuraEffectList const& IgnoreResistAuras = attacker->GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);\n    for (AuraEffectList::const_iterator i = IgnoreResistAuras.begin(); i != IgnoreResistAuras.end(); ++i)\n    {\n        if ((*i)->GetMiscValue() & attackSchoolMask)\n            TakenTotalCasterMod += (float((*i)->GetAmount()));\n    }\n\n    // ..taken\n    AuraEffectList const& mDamageTaken = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_TAKEN);\n    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)\n        if ((*i)->GetMiscValue() & GetMeleeDamageSchoolMask())\n            TakenFlatBenefit += (*i)->GetAmount();\n\n    if (attType != RANGED_ATTACK)\n        TakenFlatBenefit += GetTotalAuraModifier(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN);\n    else\n        TakenFlatBenefit += GetTotalAuraModifier(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN);\n\n    // Taken total percent damage auras\n    float TakenTotalMod = 1.0f;\n\n    // ..taken\n    TakenTotalMod *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, GetMeleeDamageSchoolMask());\n\n    // .. taken pct (special attacks)\n    if (spellProto)\n    {\n        // From caster spells\n        AuraEffectList const& mOwnerTaken = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_FROM_CASTER);\n        for (AuraEffectList::const_iterator i = mOwnerTaken.begin(); i != mOwnerTaken.end(); ++i)\n            if ((*i)->GetCasterGUID() == attacker->GetGUID() && (*i)->IsAffectedOnSpell(spellProto))\n                AddPctN(TakenTotalMod, (*i)->GetAmount());\n\n        // Mod damage from spell mechanic\n        uint32 mechanicMask = spellProto->GetAllEffectsMechanicMask();\n\n        // Shred, Maul - \"Effects which increase Bleed damage also increase Shred damage\"\n        if (spellProto->SpellFamilyName == SPELLFAMILY_DRUID && spellProto->SpellFamilyFlags[0] & 0x00008800)\n            mechanicMask |= (1<<MECHANIC_BLEED);\n\n        if (mechanicMask)\n        {\n            AuraEffectList const& mDamageDoneMechanic = GetAuraEffectsByType(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT);\n            for (AuraEffectList::const_iterator i = mDamageDoneMechanic.begin(); i != mDamageDoneMechanic.end(); ++i)\n                if (mechanicMask & uint32(1<<((*i)->GetMiscValue())))\n                    AddPctN(TakenTotalMod, (*i)->GetAmount());\n        }\n    }\n\n    // .. taken pct: dummy auras\n    AuraEffectList const& mDummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);\n    for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)\n    {\n        switch ((*i)->GetSpellInfo()->SpellIconID)\n        {\n            // Cheat Death\n            case 2109:\n                if ((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)\n                {\n                    if (GetTypeId() != TYPEID_PLAYER)\n                        continue;\n                    float mod = ToPlayer()->GetRatingBonusValue(CR_CRIT_TAKEN_MELEE) * (-8.0f);\n                    AddPctF(TakenTotalMod, std::max(mod, float((*i)->GetAmount())));\n                }\n                break;\n        }\n    }\n\n    // .. taken pct: class scripts\n    //*AuraEffectList const& mclassScritAuras = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);\n    //for (AuraEffectList::const_iterator i = mclassScritAuras.begin(); i != mclassScritAuras.end(); ++i)\n    //{\n    //    switch ((*i)->GetMiscValue())\n    //    {\n    //    }\n    //}*/\n\n    if (attType != RANGED_ATTACK)\n    {\n        AuraEffectList const& mModMeleeDamageTakenPercent = GetAuraEffectsByType(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN_PCT);\n        for (AuraEffectList::const_iterator i = mModMeleeDamageTakenPercent.begin(); i != mModMeleeDamageTakenPercent.end(); ++i)\n            AddPctN(TakenTotalMod, (*i)->GetAmount());\n    }\n    else\n    {\n        AuraEffectList const& mModRangedDamageTakenPercent = GetAuraEffectsByType(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN_PCT);\n        for (AuraEffectList::const_iterator i = mModRangedDamageTakenPercent.begin(); i != mModRangedDamageTakenPercent.end(); ++i)\n            AddPctN(TakenTotalMod, (*i)->GetAmount());\n    }\n\n    float tmpDamage = 0.0f;\n\n    if (TakenTotalCasterMod)\n    {\n        if (TakenFlatBenefit < 0)\n        {\n            if (TakenTotalMod < 1)\n                tmpDamage = ((float(CalculatePctF(pdamage, TakenTotalCasterMod) + TakenFlatBenefit) * TakenTotalMod) + CalculatePctF(pdamage, TakenTotalCasterMod));\n            else\n                tmpDamage = ((float(CalculatePctF(pdamage, TakenTotalCasterMod) + TakenFlatBenefit) + CalculatePctF(pdamage, TakenTotalCasterMod)) * TakenTotalMod);\n        }\n        else if (TakenTotalMod < 1)\n            tmpDamage = ((CalculatePctF(float(pdamage) + TakenFlatBenefit, TakenTotalCasterMod) * TakenTotalMod) + CalculatePctF(float(pdamage) + TakenFlatBenefit, TakenTotalCasterMod));\n    }\n    if (!tmpDamage)\n        tmpDamage = (float(pdamage) + TakenFlatBenefit) * TakenTotalMod;\n\n    // bonus result can be negative\n    return uint32(std::max(tmpDamage, 0.0f));\n}\n\nvoid Unit::ApplySpellImmune(uint32 spellId, uint32 op, uint32 type, bool apply)\n{\n    if (apply)\n    {\n        for (SpellImmuneList::iterator itr = m_spellImmune[op].begin(), next; itr != m_spellImmune[op].end(); itr = next)\n        {\n            next = itr; ++next;\n            if (itr->type == type)\n            {\n                m_spellImmune[op].erase(itr);\n                next = m_spellImmune[op].begin();\n            }\n        }\n        SpellImmune Immune;\n        Immune.spellId = spellId;\n        Immune.type = type;\n        m_spellImmune[op].push_back(Immune);\n    }\n    else\n    {\n        for (SpellImmuneList::iterator itr = m_spellImmune[op].begin(); itr != m_spellImmune[op].end(); ++itr)\n        {\n            if (itr->spellId == spellId && itr->type == type)\n            {\n                m_spellImmune[op].erase(itr);\n                break;\n            }\n        }\n    }\n}\n\nvoid Unit::ApplySpellDispelImmunity(const SpellInfo* spellProto, DispelType type, bool apply)\n{\n    ApplySpellImmune(spellProto->Id, IMMUNITY_DISPEL, type, apply);\n\n    if (apply && spellProto->AttributesEx & SPELL_ATTR1_DISPEL_AURAS_ON_IMMUNITY)\n    {\n        // Create dispel mask by dispel type\n        uint32 dispelMask = SpellInfo::GetDispelMask(type);\n        // Dispel all existing auras vs current dispel type\n        AuraApplicationMap& auras = GetAppliedAuras();\n        for (AuraApplicationMap::iterator itr = auras.begin(); itr != auras.end();)\n        {\n            SpellInfo const* spell = itr->second->GetBase()->GetSpellInfo();\n            if (spell->GetDispelMask() & dispelMask)\n            {\n                // Dispel aura\n                RemoveAura(itr);\n            }\n            else\n                ++itr;\n        }\n    }\n}\n\nfloat Unit::GetWeaponProcChance() const\n{\n    // normalized proc chance for weapon attack speed\n    // (odd formula...)\n    if (isAttackReady(BASE_ATTACK))\n        return (GetAttackTime(BASE_ATTACK) * 1.8f / 1000.0f);\n    else if (haveOffhandWeapon() && isAttackReady(OFF_ATTACK))\n        return (GetAttackTime(OFF_ATTACK) * 1.6f / 1000.0f);\n    return 0;\n}\n\nfloat Unit::GetPPMProcChance(uint32 WeaponSpeed, float PPM, const SpellInfo* spellProto) const\n{\n    // proc per minute chance calculation\n    if (PPM <= 0)\n        return 0.0f;\n\n    // Apply chance modifer aura\n    if (spellProto)\n        if (Player* modOwner = GetSpellModOwner())\n            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_PROC_PER_MINUTE, PPM);\n\n    return floor((WeaponSpeed * PPM) / 600.0f);   // result is chance in percents (probability = Speed_in_sec * (PPM / 60))\n}\n\nvoid Unit::Mount(uint32 mount, uint32 VehicleId, uint32 creatureEntry)\n{\n    if (mount)\n        SetUInt32Value(UNIT_FIELD_MOUNTDISPLAYID, mount);\n\n    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_MOUNT);\n\n    if (Player* player = ToPlayer())\n    {\n        // mount as a vehicle\n        if (VehicleId)\n        {\n            if (CreateVehicleKit(VehicleId, creatureEntry))\n            {\n                GetVehicleKit()->Reset();\n\n                // Send others that we now have a vehicle\n                WorldPacket data(SMSG_PLAYER_VEHICLE_DATA, GetPackGUID().size()+4);\n                data.appendPackGUID(GetGUID());\n                data << uint32(VehicleId);\n                SendMessageToSet(&data, true);\n\n                data.Initialize(SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA, 0);\n                player->GetSession()->SendPacket(&data);\n\n                // mounts can also have accessories\n                GetVehicleKit()->InstallAllAccessories(false);\n            }\n        }\n\n        // unsummon pet\n        Pet* pet = player->GetPet();\n        if (pet)\n        {\n            Battleground* bg = ToPlayer()->GetBattleground();\n            // don't unsummon pet in arena but SetFlag UNIT_FLAG_STUNNED to disable pet's interface\n            if (bg && bg->isArena())\n                pet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);\n            else\n                player->UnsummonPetTemporaryIfAny();\n        }\n\n        WorldPacket data(SMSG_MOVE_SET_COLLISION_HGT, GetPackGUID().size() + 4 + 4);\n        data.append(GetPackGUID());\n        data << uint32(sWorld->GetGameTime());   // Packet counter\n        data << player->GetCollisionHeight(true);\n        player->GetSession()->SendPacket(&data);\n    }\n\n    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOUNT);\n}\n\nvoid Unit::Dismount()\n{\n    if (!IsMounted())\n        return;\n\n    SetUInt32Value(UNIT_FIELD_MOUNTDISPLAYID, 0);\n    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_MOUNT);\n\n    if (Player* thisPlayer = ToPlayer())\n    {\n        WorldPacket data(SMSG_MOVE_SET_COLLISION_HGT, GetPackGUID().size() + 4 + 4);\n        data.append(GetPackGUID());\n        data << uint32(sWorld->GetGameTime());   // Packet counter\n        data << thisPlayer->GetCollisionHeight(false);\n        thisPlayer->GetSession()->SendPacket(&data);\n    }\n\n    WorldPacket data(SMSG_DISMOUNT, 8);\n    data.appendPackGUID(GetGUID());\n    SendMessageToSet(&data, true);\n\n    // dismount as a vehicle\n    if (GetTypeId() == TYPEID_PLAYER && GetVehicleKit())\n    {\n        // Send other players that we are no longer a vehicle\n        data.Initialize(SMSG_PLAYER_VEHICLE_DATA, 8+4);\n        data.appendPackGUID(GetGUID());\n        data << uint32(0);\n        ToPlayer()->SendMessageToSet(&data, true);\n        // Remove vehicle from player\n        RemoveVehicleKit();\n    }\n\n    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_MOUNTED);\n\n    // only resummon old pet if the player is already added to a map\n    // this prevents adding a pet to a not created map which would otherwise cause a crash\n    // (it could probably happen when logging in after a previous crash)\n    if (Player* player = ToPlayer())\n    {\n        if (Pet* pPet = player->GetPet())\n        {\n            if (pPet->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED) && !pPet->HasUnitState(UNIT_STATE_STUNNED))\n                pPet->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);\n        }\n        else\n            player->ResummonPetTemporaryUnSummonedIfAny();\n    }\n}\n\nvoid Unit::SetInCombatWith(Unit* enemy)\n{\n    Unit* eOwner = enemy->GetCharmerOrOwnerOrSelf();\n    if (eOwner->IsPvP())\n    {\n        SetInCombatState(true, enemy);\n        return;\n    }\n\n    // check for duel\n    if (eOwner->GetTypeId() == TYPEID_PLAYER && eOwner->ToPlayer()->duel)\n    {\n        Unit const* myOwner = GetCharmerOrOwnerOrSelf();\n        if (((Player const*)eOwner)->duel->opponent == myOwner)\n        {\n            SetInCombatState(true, enemy);\n            return;\n        }\n    }\n    SetInCombatState(false, enemy);\n}\n\nvoid Unit::CombatStart(Unit* target, bool initialAggro)\n{\n    if (initialAggro)\n    {\n        if (!target->IsStandState())\n            target->SetStandState(UNIT_STAND_STATE_STAND);\n\n        if (!target->isInCombat() && target->GetTypeId() != TYPEID_PLAYER\n            && !target->ToCreature()->HasReactState(REACT_PASSIVE) && target->ToCreature()->IsAIEnabled)\n        {\n            target->ToCreature()->AI()->AttackStart(this);\n        }\n\n        SetInCombatWith(target);\n        target->SetInCombatWith(this);\n    }\n    Unit* who = target->GetCharmerOrOwnerOrSelf();\n    if (who->GetTypeId() == TYPEID_PLAYER)\n      SetContestedPvP(who->ToPlayer());\n\n    Player* me = GetCharmerOrOwnerPlayerOrPlayerItself();\n    if (me && who->IsPvP()\n        && (who->GetTypeId() != TYPEID_PLAYER\n        || !me->duel || me->duel->opponent != who))\n    {\n        me->UpdatePvP(true);\n        me->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT);\n    }\n}\n\nvoid Unit::SetInCombatState(bool PvP, Unit* enemy)\n{\n    // only alive units can be in combat\n    if (!isAlive())\n        return;\n\n    if (PvP)\n        m_CombatTimer = 5000;\n\n    if (isInCombat() || HasUnitState(UNIT_STATE_EVADE))\n        return;\n\n    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);\n\n    if (Creature* creature = ToCreature())\n    {\n        // Set home position at place of engaging combat for escorted creatures\n        if ((IsAIEnabled && creature->AI()->IsEscorted()) ||\n            GetMotionMaster()->GetCurrentMovementGeneratorType() == WAYPOINT_MOTION_TYPE ||\n            GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)\n            creature->SetHomePosition(GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());\n\n        if (enemy)\n        {\n            if (IsAIEnabled)\n            {\n                creature->AI()->EnterCombat(enemy);\n                RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC); // unit has engaged in combat, remove immunity so players can fight back\n            }\n            if (creature->GetFormation())\n                creature->GetFormation()->MemberAttackStart(creature, enemy);\n        }\n\n        if (isPet())\n        {\n            UpdateSpeed(MOVE_RUN, true);\n            UpdateSpeed(MOVE_SWIM, true);\n            UpdateSpeed(MOVE_FLIGHT, true);\n        }\n\n        if (!(creature->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_MOUNTED_COMBAT))\n            Dismount();\n    }\n\n    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)\n    {\n        (*itr)->SetInCombatState(PvP, enemy);\n        (*itr)->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);\n    }\n}\n\nvoid Unit::ClearInCombat()\n{\n    m_CombatTimer = 0;\n    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);\n\n    // Player's state will be cleared in Player::UpdateContestedPvP\n    if (Creature* creature = ToCreature())\n    {\n        if (creature->GetCreatureTemplate() && creature->GetCreatureTemplate()->unit_flags & UNIT_FLAG_IMMUNE_TO_PC)\n            SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC); // set immunity state to the one from db on evade\n\n        ClearUnitState(UNIT_STATE_ATTACK_PLAYER);\n        if (HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_TAPPED))\n            SetUInt32Value(UNIT_DYNAMIC_FLAGS, creature->GetCreatureTemplate()->dynamicflags);\n\n        if (creature->isPet())\n        {\n            if (Unit* owner = GetOwner())\n                for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)\n                    if (owner->GetSpeedRate(UnitMoveType(i)) > GetSpeedRate(UnitMoveType(i)))\n                        SetSpeed(UnitMoveType(i), owner->GetSpeedRate(UnitMoveType(i)), true);\n        }\n        else if (!isCharmed())\n            return;\n    }\n    else\n        ToPlayer()->UpdatePotionCooldown();\n\n    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);\n}\n\nbool Unit::isTargetableForAttack(bool checkFakeDeath) const\n{\n    if (!isAlive())\n        return false;\n\n    if (HasFlag(UNIT_FIELD_FLAGS,\n        UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_IMMUNE_TO_PC))\n        return false;\n\n    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->isGameMaster())\n        return false;\n\n    return !HasUnitState(UNIT_STATE_UNATTACKABLE) && (!checkFakeDeath || !HasUnitState(UNIT_STATE_DIED));\n}\n\nbool Unit::IsValidAttackTarget(Unit const* target) const\n{\n    return _IsValidAttackTarget(target, NULL);\n}\n\n// function based on function Unit::CanAttack from 13850 client\nbool Unit::_IsValidAttackTarget(Unit const* target, SpellInfo const* bySpell, WorldObject const* obj) const\n{\n    ASSERT(target);\n\n    // can't attack self\n    if (this == target)\n        return false;\n\n    // can't attack unattackable units or GMs\n    if (target->HasUnitState(UNIT_STATE_UNATTACKABLE)\n        || (target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->isGameMaster()))\n        return false;\n\n    // can't attack own vehicle or passenger\n    if (m_vehicle)\n        if (IsOnVehicle(target) || m_vehicle->GetBase()->IsOnVehicle(target))\n            return false;\n\n    // can't attack invisible (ignore stealth for aoe spells) also if the area being looked at is from a spell use the dynamic object created instead of the casting unit.\n    if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_INVISIBLE)) && (obj ? !obj->canSeeOrDetect(target, bySpell && bySpell->IsAffectingArea()) : !canSeeOrDetect(target, bySpell && bySpell->IsAffectingArea())))\n        return false;\n\n    // can't attack dead\n    if ((!bySpell || !bySpell->IsAllowingDeadTarget()) && !target->isAlive())\n       return false;\n\n    // can't attack untargetable\n    if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_UNTARGETABLE))\n        && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))\n        return false;\n\n    if (Player const* playerAttacker = ToPlayer())\n    {\n        if (playerAttacker->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_UNK19))\n            return false;\n    }\n    // check flags\n    if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_TAXI_FLIGHT | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_UNK_16)\n        || (!HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC))\n        || (!target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC))\n        || (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC))\n        // check if this is a world trigger cast - GOs are using world triggers to cast their spells, so we need to ignore their immunity flag here, this is a temp workaround, needs removal when go cast is implemented properly\n        || (GetEntry() != WORLD_TRIGGER && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC)))\n        return false;\n\n    // CvC case - can attack each other only when one of them is hostile\n    if (!HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && !target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))\n        return GetReactionTo(target) <= REP_HOSTILE || target->GetReactionTo(this) <= REP_HOSTILE;\n\n    // PvP, PvC, CvP case\n    // can't attack friendly targets\n    if ( GetReactionTo(target) > REP_NEUTRAL\n        || target->GetReactionTo(this) > REP_NEUTRAL)\n        return false;\n\n    // Not all neutral creatures can be attacked\n    if (GetReactionTo(target) == REP_NEUTRAL &&\n        target->GetReactionTo(this) == REP_NEUTRAL)\n    {\n        if  (!(target->GetTypeId() == TYPEID_PLAYER && GetTypeId() == TYPEID_PLAYER) &&\n            !(target->GetTypeId() == TYPEID_UNIT && GetTypeId() == TYPEID_UNIT))\n        {\n            Player const* player = target->GetTypeId() == TYPEID_PLAYER ? target->ToPlayer() : ToPlayer();\n            Unit const* creature = target->GetTypeId() == TYPEID_UNIT ? target : this;\n\n            if (FactionTemplateEntry const* factionTemplate = creature->getFactionTemplateEntry())\n            {\n                if (!(player->GetReputationMgr().GetForcedRankIfAny(factionTemplate)))\n                    if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(factionTemplate->faction))\n                        if (FactionState const* repState = player->GetReputationMgr().GetState(factionEntry))\n                            if (!(repState->Flags & FACTION_FLAG_AT_WAR))\n                                return false;\n\n            }\n        }\n    }\n\n    Creature const* creatureAttacker = ToCreature();\n    if (creatureAttacker && creatureAttacker->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER)\n        return false;\n\n    Player const* playerAffectingAttacker = HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) ? GetAffectingPlayer() : NULL;\n    Player const* playerAffectingTarget = target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) ? target->GetAffectingPlayer() : NULL;\n\n    // check duel - before sanctuary checks\n    if (playerAffectingAttacker && playerAffectingTarget)\n        if (playerAffectingAttacker->duel && playerAffectingAttacker->duel->opponent == playerAffectingTarget && playerAffectingAttacker->duel->startTime != 0)\n            return true;\n\n    // PvP case - can't attack when attacker or target are in sanctuary\n    // however, 13850 client doesn't allow to attack when one of the unit's has sanctuary flag and is pvp\n    if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE)\n        && ((target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_SANCTUARY) || (GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_SANCTUARY)))\n        return false;\n\n    // additional checks - only PvP case\n    if (playerAffectingAttacker && playerAffectingTarget)\n    {\n        if (target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_PVP)\n            return true;\n\n        if (GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_FFA_PVP\n            && target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_FFA_PVP)\n            return true;\n\n        return (GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_UNK1)\n            || (target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_UNK1);\n    }\n    return true;\n}\n\nbool Unit::IsValidAssistTarget(Unit const* target) const\n{\n    return _IsValidAssistTarget(target, NULL);\n}\n\n// function based on function Unit::CanAssist from 13850 client\nbool Unit::_IsValidAssistTarget(Unit const* target, SpellInfo const* bySpell) const\n{\n    ASSERT(target);\n\n    // can assist to self\n    if (this == target)\n        return true;\n\n    // can't assist unattackable units or GMs\n    if (target->HasUnitState(UNIT_STATE_UNATTACKABLE)\n        || (target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->isGameMaster()))\n        return false;\n\n    // can't assist own vehicle or passenger\n    if (m_vehicle)\n        if (IsOnVehicle(target) || m_vehicle->GetBase()->IsOnVehicle(target))\n            return false;\n\n    // can't assist invisible\n    if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_INVISIBLE)) && !canSeeOrDetect(target, bySpell && bySpell->IsAffectingArea()))\n        return false;\n\n    // can't assist dead\n    if ((!bySpell || !bySpell->IsAllowingDeadTarget()) && !target->isAlive())\n       return false;\n\n    // can't assist untargetable\n    if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_UNTARGETABLE))\n        && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))\n        return false;\n\n    if (!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_UNK3))\n    {\n        if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))\n        {\n            if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC))\n                return false;\n        }\n        else\n        {\n            if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC))\n                return false;\n        }\n    }\n\n    // can't assist non-friendly targets\n    if (GetReactionTo(target) <= REP_NEUTRAL\n        && target->GetReactionTo(this) <= REP_NEUTRAL\n        && (!ToCreature() || !(ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER)))\n        return false;\n\n    // PvP case\n    if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))\n    {\n        Player const* targetPlayerOwner = target->GetAffectingPlayer();\n        if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))\n        {\n            Player const* selfPlayerOwner = GetAffectingPlayer();\n            if (selfPlayerOwner && targetPlayerOwner)\n            {\n                // can't assist player which is dueling someone\n                if (selfPlayerOwner != targetPlayerOwner\n                    && targetPlayerOwner->duel)\n                    return false;\n            }\n            // can't assist player in ffa_pvp zone from outside\n            if ((target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_FFA_PVP)\n                && !(GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_FFA_PVP))\n                return false;\n            // can't assist player out of sanctuary from sanctuary if has pvp enabled\n            if (target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_PVP)\n                if ((GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_SANCTUARY) && !(target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_SANCTUARY))\n                    return false;\n        }\n    }\n    // PvC case - player can assist creature only if has specific type flags\n    // !target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) &&\n    else if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE)\n        && (!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_UNK3))\n        && !((target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_PVP)))\n    {\n        if (Creature const* creatureTarget = target->ToCreature())\n            return creatureTarget->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER || creatureTarget->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_AID_PLAYERS;\n    }\n    return true;\n}\n\nint32 Unit::ModifyHealth(int32 dVal)\n{\n    int32 gain = 0;\n\n    if (dVal == 0)\n        return 0;\n\n    // Part of Evade mechanics. Only track health lost, not gained.\n    if (dVal < 0 && GetTypeId() != TYPEID_PLAYER && !isPet())\n        SetLastDamagedTime(time(NULL));\n\n    int32 curHealth = (int32)GetHealth();\n\n    int32 val = dVal + curHealth;\n    if (val <= 0)\n    {\n        SetHealth(0);\n        return -curHealth;\n    }\n\n    int32 maxHealth = (int32)GetMaxHealth();\n\n    if (val < maxHealth)\n    {\n        SetHealth(val);\n        gain = val - curHealth;\n    }\n    else if (curHealth != maxHealth)\n    {\n        SetHealth(maxHealth);\n        gain = maxHealth - curHealth;\n    }\n\n    return gain;\n}\n\nint32 Unit::GetHealthGain(int32 dVal)\n{\n    int32 gain = 0;\n\n    if (dVal == 0)\n        return 0;\n\n    int32 curHealth = (int32)GetHealth();\n\n    int32 val = dVal + curHealth;\n    if (val <= 0)\n    {\n        return -curHealth;\n    }\n\n    int32 maxHealth = (int32)GetMaxHealth();\n\n    if (val < maxHealth)\n        gain = dVal;\n    else if (curHealth != maxHealth)\n        gain = maxHealth - curHealth;\n\n    return gain;\n}\n\n// returns negative amount on power reduction\nint32 Unit::ModifyPower(Powers power, int32 dVal)\n{\n    int32 gain = 0;\n\n    if (dVal == 0)\n        return 0;\n\n    int32 curPower = (int32)GetPower(power);\n\n    int32 val = dVal + curPower;\n    if (val <= 0)\n    {\n        SetPower(power, 0);\n        return -curPower;\n    }\n\n    int32 maxPower = (int32)GetMaxPower(power);\n\n    if (val < maxPower)\n    {\n        SetPower(power, val);\n        gain = val - curPower;\n    }\n    else if (curPower != maxPower)\n    {\n        SetPower(power, maxPower);\n        gain = maxPower - curPower;\n    }\n\n    return gain;\n}\n\n// returns negative amount on power reduction\nint32 Unit::ModifyPowerPct(Powers power, float pct, bool apply)\n{\n    float amount = (float)GetMaxPower(power);\n    ApplyPercentModFloatVar(amount, pct, apply);\n\n    return ModifyPower(power, (int32)amount - (int32)GetMaxPower(power));\n}\n\nbool Unit::IsAlwaysVisibleFor(WorldObject const* seer) const\n{\n    if (WorldObject::IsAlwaysVisibleFor(seer))\n        return true;\n\n    // Always seen by owner\n    if (uint64 guid = GetCharmerOrOwnerGUID())\n        if (seer->GetGUID() == guid)\n            return true;\n\n    if (Player const* seerPlayer = seer->ToPlayer())\n        if (Unit* owner =  GetOwner())\n            if (Player* ownerPlayer = owner->ToPlayer())\n                if (ownerPlayer->IsGroupVisibleFor(seerPlayer))\n                    return true;\n\n    return false;\n}\n\nbool Unit::IsAlwaysDetectableFor(WorldObject const* seer) const\n{\n    if (WorldObject::IsAlwaysDetectableFor(seer))\n        return true;\n\n    if (HasAuraTypeWithCaster(SPELL_AURA_MOD_STALKED, seer->GetGUID()))\n        return true;\n\n    return false;\n}\n\nvoid Unit::SetVisible(bool x)\n{\n    if (!x)\n        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_GAMEMASTER);\n    else\n        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);\n\n    UpdateObjectVisibility();\n}\n\nvoid Unit::UpdateSpeed(UnitMoveType mtype, bool forced)\n{\n    int32 main_speed_mod  = 0;\n    float stack_bonus     = 1.0f;\n    float non_stack_bonus = 1.0f;\n\n    switch (mtype)\n    {\n        // Only apply debuffs\n        case MOVE_FLIGHT_BACK:\n        case MOVE_RUN_BACK:\n        case MOVE_SWIM_BACK:\n            break;\n        case MOVE_WALK:\n            return;\n        case MOVE_RUN:\n        {\n            if (IsMounted()) // Use on mount auras\n            {\n                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED);\n                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_SPEED_ALWAYS);\n                non_stack_bonus += GetMaxPositiveAuraModifier(SPELL_AURA_MOD_MOUNTED_SPEED_NOT_STACK) / 100.0f;\n            }\n            else\n            {\n                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_SPEED);\n                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_SPEED_ALWAYS);\n                non_stack_bonus += GetMaxPositiveAuraModifier(SPELL_AURA_MOD_SPEED_NOT_STACK) / 100.0f;\n            }\n            break;\n        }\n        case MOVE_SWIM:\n        {\n            main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_SWIM_SPEED);\n            break;\n        }\n        case MOVE_FLIGHT:\n        {\n            if (GetTypeId() == TYPEID_UNIT && IsControlledByPlayer()) // not sure if good for pet\n            {\n                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);\n                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_VEHICLE_SPEED_ALWAYS);\n\n                // for some spells this mod is applied on vehicle owner\n                int32 owner_speed_mod = 0;\n\n                if (Unit* owner = GetCharmer())\n                    owner_speed_mod = owner->GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);\n\n                main_speed_mod = std::max(main_speed_mod, owner_speed_mod);\n            }\n            else if (IsMounted())\n            {\n                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);\n                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS);\n            }\n            else             // Use not mount (shapeshift for example) auras (should stack)\n                main_speed_mod  = GetTotalAuraModifier(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED) + GetTotalAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);\n\n            non_stack_bonus += GetMaxPositiveAuraModifier(SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK) / 100.0f;\n\n            // Update speed for vehicle if available\n            if (GetTypeId() == TYPEID_PLAYER && GetVehicle())\n                GetVehicleBase()->UpdateSpeed(MOVE_FLIGHT, true);\n            break;\n        }\n        default:\n            sLog->outError(LOG_FILTER_UNITS, \"Unit::UpdateSpeed: Unsupported move type (%d)\", mtype);\n            return;\n    }\n\n    // now we ready for speed calculation\n    float speed = std::max(non_stack_bonus, stack_bonus);\n    if (main_speed_mod)\n        AddPctN(speed, main_speed_mod);\n\n    switch (mtype)\n    {\n        case MOVE_RUN:\n        case MOVE_SWIM:\n        case MOVE_FLIGHT:\n        {\n            // Set creature speed rate from CreatureInfo\n            if (GetTypeId() == TYPEID_UNIT)\n                speed *= ToCreature()->GetCreatureTemplate()->speed_run;    // at this point, MOVE_WALK is never reached\n\n            // Normalize speed by 191 aura SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED if need\n            // TODO: possible affect only on MOVE_RUN\n            if (int32 normalization = GetMaxPositiveAuraModifier(SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED))\n            {\n                // Use speed from aura\n                float max_speed = normalization / (IsControlledByPlayer() ? playerBaseMoveSpeed[mtype] : baseMoveSpeed[mtype]);\n                if (speed > max_speed)\n                    speed = max_speed;\n            }\n            break;\n        }\n        default:\n            break;\n    }\n\n    // for creature case, we check explicit if mob searched for assistance\n    if (GetTypeId() == TYPEID_UNIT)\n    {\n        if (ToCreature()->HasSearchedAssistance())\n            speed *= 0.66f;                                 // best guessed value, so this will be 33% reduction. Based off initial speed, mob can then \"run\", \"walk fast\" or \"walk\".\n    }\n\n    // Apply strongest slow aura mod to speed\n    int32 slow = GetMaxNegativeAuraModifier(SPELL_AURA_MOD_DECREASE_SPEED);\n    if (slow)\n    {\n        AddPctN(speed, slow);\n        if (float minSpeedMod = (float)GetMaxPositiveAuraModifier(SPELL_AURA_MOD_MINIMUM_SPEED))\n        {\n            float min_speed = minSpeedMod / 100.0f;\n            if (speed < min_speed)\n                speed = min_speed;\n        }\n    }\n    SetSpeed(mtype, speed, forced);\n}\n\nfloat Unit::GetSpeed(UnitMoveType mtype) const\n{\n    return m_speed_rate[mtype]*(IsControlledByPlayer() ? playerBaseMoveSpeed[mtype] : baseMoveSpeed[mtype]);\n}\n\nvoid Unit::SetSpeed(UnitMoveType mtype, float rate, bool forced)\n{\n    if (rate < 0)\n        rate = 0.0f;\n\n    // Update speed only on change\n    if (m_speed_rate[mtype] == rate)\n        return;\n\n    m_speed_rate[mtype] = rate;\n\n    propagateSpeedChange();\n\n    WorldPacket data;\n    if (!forced)\n    {\n        switch (mtype)\n        {\n            case MOVE_WALK:\n                data.Initialize(MSG_MOVE_SET_WALK_SPEED, 8+4+2+4+4+4+4+4+4+4);\n                break;\n            case MOVE_RUN:\n                data.Initialize(MSG_MOVE_SET_RUN_SPEED, 8+4+2+4+4+4+4+4+4+4);\n                break;\n            case MOVE_RUN_BACK:\n                data.Initialize(MSG_MOVE_SET_RUN_BACK_SPEED, 8+4+2+4+4+4+4+4+4+4);\n                break;\n            case MOVE_SWIM:\n                data.Initialize(MSG_MOVE_SET_SWIM_SPEED, 8+4+2+4+4+4+4+4+4+4);\n                break;\n            case MOVE_SWIM_BACK:\n                data.Initialize(MSG_MOVE_SET_SWIM_BACK_SPEED, 8+4+2+4+4+4+4+4+4+4);\n                break;\n            case MOVE_TURN_RATE:\n                data.Initialize(MSG_MOVE_SET_TURN_RATE, 8+4+2+4+4+4+4+4+4+4);\n                break;\n            case MOVE_FLIGHT:\n                data.Initialize(MSG_MOVE_SET_FLIGHT_SPEED, 8+4+2+4+4+4+4+4+4+4);\n                break;\n            case MOVE_FLIGHT_BACK:\n                data.Initialize(MSG_MOVE_SET_FLIGHT_BACK_SPEED, 8+4+2+4+4+4+4+4+4+4);\n                break;\n            case MOVE_PITCH_RATE:\n                data.Initialize(MSG_MOVE_SET_PITCH_RATE, 8+4+2+4+4+4+4+4+4+4);\n                break;\n            default:\n                sLog->outError(LOG_FILTER_UNITS, \"Unit::SetSpeed: Unsupported move type (%d), data not sent to client.\", mtype);\n                return;\n        }\n\n        BuildMovementPacket(&data);\n        data << float(GetSpeed(mtype));\n        SendMessageToSet(&data, true);\n    }\n    else\n    {\n        if (GetTypeId() == TYPEID_PLAYER)\n        {\n            // register forced speed changes for WorldSession::HandleForceSpeedChangeAck\n            // and do it only for real sent packets and use run for run/mounted as client expected\n            ++ToPlayer()->m_forced_speed_changes[mtype];\n\n            if (!isInCombat())\n                if (Pet* pet = ToPlayer()->GetPet())\n                    pet->SetSpeed(mtype, m_speed_rate[mtype], forced);\n        }\n\n        switch (mtype)\n        {\n            case MOVE_WALK:\n                data.Initialize(SMSG_FORCE_WALK_SPEED_CHANGE, 16);\n                break;\n            case MOVE_RUN:\n                data.Initialize(SMSG_FORCE_RUN_SPEED_CHANGE, 17);\n                break;\n            case MOVE_RUN_BACK:\n                data.Initialize(SMSG_FORCE_RUN_BACK_SPEED_CHANGE, 16);\n                break;\n            case MOVE_SWIM:\n                data.Initialize(SMSG_FORCE_SWIM_SPEED_CHANGE, 16);\n                break;\n            case MOVE_SWIM_BACK:\n                data.Initialize(SMSG_FORCE_SWIM_BACK_SPEED_CHANGE, 16);\n                break;\n            case MOVE_TURN_RATE:\n                data.Initialize(SMSG_FORCE_TURN_RATE_CHANGE, 16);\n                break;\n            case MOVE_FLIGHT:\n                data.Initialize(SMSG_FORCE_FLIGHT_SPEED_CHANGE, 16);\n                break;\n            case MOVE_FLIGHT_BACK:\n                data.Initialize(SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE, 16);\n                break;\n            case MOVE_PITCH_RATE:\n                data.Initialize(SMSG_FORCE_PITCH_RATE_CHANGE, 16);\n                break;\n            default:\n                sLog->outError(LOG_FILTER_UNITS, \"Unit::SetSpeed: Unsupported move type (%d), data not sent to client.\", mtype);\n                return;\n        }\n        data.append(GetPackGUID());\n        data << (uint32)0;                                  // moveEvent, NUM_PMOVE_EVTS = 0x39\n        if (mtype == MOVE_RUN)\n            data << uint8(0);                               // new 2.1.0\n        data << float(GetSpeed(mtype));\n        SendMessageToSet(&data, true);\n    }\n}\n\nvoid Unit::setDeathState(DeathState s)\n{\n    if (s != ALIVE && s != JUST_RESPAWNED)\n    {\n        CombatStop();\n        DeleteThreatList();\n        getHostileRefManager().deleteReferences();\n        ClearComboPointHolders();                           // any combo points pointed to unit lost at it death\n\n        if (IsNonMeleeSpellCasted(false))\n            InterruptNonMeleeSpells(false);\n\n        UnsummonAllTotems();\n        RemoveAllControlled();\n        RemoveAllAurasOnDeath();\n    }\n\n    if (s == JUST_DIED)\n    {\n        ModifyAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, false);\n        ModifyAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, false);\n        // remove aurastates allowing special moves\n        ClearAllReactives();\n        ClearDiminishings();\n        if (IsInWorld())\n        {\n            // Only clear MotionMaster for entities that exists in world\n            // Avoids crashes in the following conditions :\n            //  * Using 'call pet' on dead pets\n            //  * Using 'call stabled pet'\n            //  * Logging in with dead pets\n            GetMotionMaster()->Clear(false);\n            GetMotionMaster()->MoveIdle();\n        }\n        StopMoving();\n        DisableSpline();\n        // without this when removing IncreaseMaxHealth aura player may stuck with 1 hp\n        // do not why since in IncreaseMaxHealth currenthealth is checked\n        SetHealth(0);\n        SetPower(getPowerType(), 0);\n\n        // players in instance don't have ZoneScript, but they have InstanceScript\n        if (ZoneScript* zoneScript = GetZoneScript() ? GetZoneScript() : (ZoneScript*)GetInstanceScript())\n            zoneScript->OnUnitDeath(this);\n    }\n    else if (s == JUST_RESPAWNED)\n        RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE); // clear skinnable for creature and player (at battleground)\n\n    m_deathState = s;\n}\n\n/*########################################\n########                          ########\n########       AGGRO SYSTEM       ########\n########                          ########\n########################################*/\nbool Unit::CanHaveThreatList() const\n{\n    // only creatures can have threat list\n    if (GetTypeId() != TYPEID_UNIT)\n        return false;\n\n    // only alive units can have threat list\n    if (!isAlive() || isDying())\n        return false;\n\n    // totems can not have threat list\n    if (ToCreature()->isTotem())\n        return false;\n\n    // vehicles can not have threat list\n    //if (ToCreature()->IsVehicle())\n    //    return false;\n\n    // summons can not have a threat list, unless they are controlled by a creature\n    if (HasUnitTypeMask(UNIT_MASK_MINION | UNIT_MASK_GUARDIAN | UNIT_MASK_CONTROLABLE_GUARDIAN) && IS_PLAYER_GUID(((Pet*)this)->GetOwnerGUID()))\n        return false;\n\n    return true;\n}\n\n//======================================================================\n\nfloat Unit::ApplyTotalThreatModifier(float fThreat, SpellSchoolMask schoolMask)\n{\n    if (!HasAuraType(SPELL_AURA_MOD_THREAT) || fThreat < 0)\n        return fThreat;\n\n    SpellSchools school = GetFirstSchoolInMask(schoolMask);\n\n    return fThreat * m_threatModifier[school];\n}\n\n//======================================================================\n\nvoid Unit::AddThreat(Unit* victim, float fThreat, SpellSchoolMask schoolMask, SpellInfo const* threatSpell)\n{\n    // Only mobs can manage threat lists\n    if (CanHaveThreatList())\n        m_ThreatManager.addThreat(victim, fThreat, schoolMask, threatSpell);\n}\n\n//======================================================================\n\nvoid Unit::DeleteThreatList()\n{\n    if (CanHaveThreatList() && !m_ThreatManager.isThreatListEmpty())\n        SendClearThreatListOpcode();\n    m_ThreatManager.clearReferences();\n}\n\n//======================================================================\n\nvoid Unit::TauntApply(Unit* taunter)\n{\n    ASSERT(GetTypeId() == TYPEID_UNIT);\n\n    if (!taunter || (taunter->GetTypeId() == TYPEID_PLAYER && taunter->ToPlayer()->isGameMaster()))\n        return;\n\n    if (!CanHaveThreatList())\n        return;\n\n    Creature* creature = ToCreature();\n\n    if (creature->HasReactState(REACT_PASSIVE))\n        return;\n\n    Unit* target = getVictim();\n    if (target && target == taunter)\n        return;\n\n    SetInFront(taunter);\n    if (creature->IsAIEnabled)\n        creature->AI()->AttackStart(taunter);\n\n    //m_ThreatManager.tauntApply(taunter);\n}\n\n//======================================================================\n\nvoid Unit::TauntFadeOut(Unit* taunter)\n{\n    ASSERT(GetTypeId() == TYPEID_UNIT);\n\n    if (!taunter || (taunter->GetTypeId() == TYPEID_PLAYER && taunter->ToPlayer()->isGameMaster()))\n        return;\n\n    if (!CanHaveThreatList())\n        return;\n\n    Creature* creature = ToCreature();\n\n    if (creature->HasReactState(REACT_PASSIVE))\n        return;\n\n    Unit* target = getVictim();\n    if (!target || target != taunter)\n        return;\n\n    if (m_ThreatManager.isThreatListEmpty())\n    {\n        if (creature->IsAIEnabled)\n            creature->AI()->EnterEvadeMode();\n        return;\n    }\n\n    target = creature->SelectVictim();  // might have more taunt auras remaining\n\n    if (target && target != taunter)\n    {\n        SetInFront(target);\n        if (creature->IsAIEnabled)\n            creature->AI()->AttackStart(target);\n    }\n}\n\n//======================================================================\n\nUnit* Creature::SelectVictim()\n{\n    // function provides main threat functionality\n    // next-victim-selection algorithm and evade mode are called\n    // threat list sorting etc.\n\n    Unit* target = NULL;\n    // First checking if we have some taunt on us\n    AuraEffectList const& tauntAuras = GetAuraEffectsByType(SPELL_AURA_MOD_TAUNT);\n    if (!tauntAuras.empty())\n    {\n        Unit* caster = tauntAuras.back()->GetCaster();\n\n        // The last taunt aura caster is alive an we are happy to attack him\n        if (caster && caster->isAlive())\n            return getVictim();\n        else if (tauntAuras.size() > 1)\n        {\n            // We do not have last taunt aura caster but we have more taunt auras,\n            // so find first available target\n\n            // Auras are pushed_back, last caster will be on the end\n            AuraEffectList::const_iterator aura = --tauntAuras.end();\n            do\n            {\n                --aura;\n                caster = (*aura)->GetCaster();\n                if (caster && canSeeOrDetect(caster, true) && IsValidAttackTarget(caster) && caster->isInAccessiblePlaceFor(ToCreature()))\n                {\n                    target = caster;\n                    break;\n                }\n            } while (aura != tauntAuras.begin());\n        }\n        else\n            target = getVictim();\n    }\n\n    if (CanHaveThreatList())\n    {\n        if (!target && !m_ThreatManager.isThreatListEmpty())\n            // No taunt aura or taunt aura caster is dead standard target selection\n            target = m_ThreatManager.getHostilTarget();\n    }\n    else if (!HasReactState(REACT_PASSIVE))\n    {\n        // We have player pet probably\n        target = getAttackerForHelper();\n        if (!target && isSummon())\n        {\n            if (Unit* owner = ToTempSummon()->GetOwner())\n            {\n                if (owner->isInCombat())\n                    target = owner->getAttackerForHelper();\n                if (!target)\n                {\n                    for (ControlList::const_iterator itr = owner->m_Controlled.begin(); itr != owner->m_Controlled.end(); ++itr)\n                    {\n                        if ((*itr)->isInCombat())\n                        {\n                            target = (*itr)->getAttackerForHelper();\n                            if (target)\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else\n        return NULL;\n\n    if (target && _IsTargetAcceptable(target) && canCreatureAttack(target))\n    {\n        SetInFront(target);\n        return target;\n    }\n\n    // Case where mob is being kited.\n    // Mob may not be in range to attack or may have dropped target. In any case,\n    //  don't evade if damage received within the last 10 seconds\n    // Does not apply to world bosses to prevent kiting to cities\n    if (!isWorldBoss() && !GetInstanceId())\n        if (time(NULL) - GetLastDamagedTime() <= MAX_AGGRO_RESET_TIME)\n            return target;\n\n    // last case when creature must not go to evade mode:\n    // it in combat but attacker not make any damage and not enter to aggro radius to have record in threat list\n    // for example at owner command to pet attack some far away creature\n    // Note: creature does not have targeted movement generator but has attacker in this case\n    for (AttackerSet::const_iterator itr = m_attackers.begin(); itr != m_attackers.end(); ++itr)\n    {\n        if ((*itr) && !canCreatureAttack(*itr) && (*itr)->GetTypeId() != TYPEID_PLAYER\n        && !(*itr)->ToCreature()->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))\n            return NULL;\n    }\n\n    // TODO: a vehicle may eat some mob, so mob should not evade\n    if (GetVehicle())\n        return NULL;\n\n    // search nearby enemy before enter evade mode\n    if (HasReactState(REACT_AGGRESSIVE))\n    {\n        target = SelectNearestTargetInAttackDistance(m_CombatDistance ? m_CombatDistance : ATTACK_DISTANCE);\n\n        if (target && _IsTargetAcceptable(target) && canCreatureAttack(target))\n            return target;\n    }\n\n    Unit::AuraEffectList const& iAuras = GetAuraEffectsByType(SPELL_AURA_MOD_INVISIBILITY);\n    if (!iAuras.empty())\n    {\n        for (Unit::AuraEffectList::const_iterator itr = iAuras.begin(); itr != iAuras.end(); ++itr)\n        {\n            if ((*itr)->GetBase()->IsPermanent())\n            {\n                AI()->EnterEvadeMode();\n                break;\n            }\n        }\n        return NULL;\n    }\n\n    // enter in evade mode in other case\n    AI()->EnterEvadeMode();\n\n    return NULL;\n}\n\n//======================================================================\n//======================================================================\n//======================================================================\n\nfloat Unit::ApplyEffectModifiers(SpellInfo const* spellProto, uint8 effect_index, float value) const\n{\n    if (Player* modOwner = GetSpellModOwner())\n    {\n        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_ALL_EFFECTS, value);\n        switch (effect_index)\n        {\n            case 0:\n                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_EFFECT1, value);\n                break;\n            case 1:\n                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_EFFECT2, value);\n                break;\n            case 2:\n                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_EFFECT3, value);\n                break;\n        }\n    }\n    return value;\n}\n\n// function uses real base points (typically value - 1)\nint32 Unit::CalculateSpellDamage(Unit const* target, SpellInfo const* spellProto, uint8 effect_index, int32 const* basePoints) const\n{\n    return spellProto->Effects[effect_index].CalcValue(this, basePoints, target);\n}\n\nint32 Unit::CalcSpellDuration(SpellInfo const* spellProto)\n{\n    uint8 comboPoints = m_movedPlayer ? m_movedPlayer->GetComboPoints() : 0;\n\n    int32 minduration = spellProto->GetDuration();\n    int32 maxduration = spellProto->GetMaxDuration();\n\n    int32 duration;\n\n    if (comboPoints && minduration != -1 && minduration != maxduration)\n        duration = minduration + int32((maxduration - minduration) * comboPoints / 5);\n    else\n        duration = minduration;\n\n    return duration;\n}\n\nint32 Unit::ModSpellDuration(SpellInfo const* spellProto, Unit const* target, int32 duration, bool positive, uint32 effectMask)\n{\n    // don't mod permanent auras duration\n    if (duration < 0)\n        return duration;\n\n    // cut duration only of negative effects\n    if (!positive)\n    {\n        int32 mechanic = spellProto->GetSpellMechanicMaskByEffectMask(effectMask);\n\n        int32 durationMod;\n        int32 durationMod_always = 0;\n        int32 durationMod_not_stack = 0;\n\n        for (uint8 i = 1; i <= MECHANIC_ENRAGED; ++i)\n        {\n            if (!(mechanic & 1<<i))\n                continue;\n            // Find total mod value (negative bonus)\n            int32 new_durationMod_always = target->GetTotalAuraModifierByMiscValue(SPELL_AURA_MECHANIC_DURATION_MOD, i);\n            // Find max mod (negative bonus)\n            int32 new_durationMod_not_stack = target->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MECHANIC_DURATION_MOD_NOT_STACK, i);\n            // Check if mods applied before were weaker\n            if (new_durationMod_always < durationMod_always)\n                durationMod_always = new_durationMod_always;\n            if (new_durationMod_not_stack < durationMod_not_stack)\n                durationMod_not_stack = new_durationMod_not_stack;\n        }\n\n        // Select strongest negative mod\n        if (durationMod_always > durationMod_not_stack)\n            durationMod = durationMod_not_stack;\n        else\n            durationMod = durationMod_always;\n\n        if (durationMod != 0)\n            AddPctN(duration, durationMod);\n\n        // there are only negative mods currently\n        durationMod_always = target->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL, spellProto->Dispel);\n        durationMod_not_stack = target->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL_NOT_STACK, spellProto->Dispel);\n\n        durationMod = 0;\n        if (durationMod_always > durationMod_not_stack)\n            durationMod += durationMod_not_stack;\n        else\n            durationMod += durationMod_always;\n\n        if (durationMod != 0)\n            AddPctN(duration, durationMod);\n    }\n    else\n    {\n        // else positive mods here, there are no currently\n        // when there will be, change GetTotalAuraModifierByMiscValue to GetTotalPositiveAuraModifierByMiscValue\n\n        // Mixology - duration boost\n        if (target->GetTypeId() == TYPEID_PLAYER)\n        {\n            if (spellProto->SpellFamilyName == SPELLFAMILY_POTION && (\n                sSpellMgr->IsSpellMemberOfSpellGroup(spellProto->Id, SPELL_GROUP_ELIXIR_BATTLE) ||\n                sSpellMgr->IsSpellMemberOfSpellGroup(spellProto->Id, SPELL_GROUP_ELIXIR_GUARDIAN)))\n            {\n                if (target->HasAura(53042) && target->HasSpell(spellProto->Effects[0].TriggerSpell))\n                    duration *= 2;\n            }\n        }\n    }\n\n    // Glyphs which increase duration of selfcasted buffs\n    if (target == this)\n    {\n        switch (spellProto->SpellFamilyName)\n        {\n            case SPELLFAMILY_DRUID:\n                if (spellProto->SpellFamilyFlags[0] & 0x100)\n                {\n                    // Glyph of Thorns\n                    if (AuraEffect* aurEff = GetAuraEffect(57862, 0))\n                        duration += aurEff->GetAmount() * MINUTE * IN_MILLISECONDS;\n                }\n                break;\n            case SPELLFAMILY_PALADIN:\n                if ((spellProto->SpellFamilyFlags[0] & 0x00000002) && spellProto->SpellIconID == 298)\n                {\n                    // Glyph of Blessing of Might\n                    if (AuraEffect* aurEff = GetAuraEffect(57958, 0))\n                        duration += aurEff->GetAmount() * MINUTE * IN_MILLISECONDS;\n                }\n                else if ((spellProto->SpellFamilyFlags[0] & 0x00010000) && spellProto->SpellIconID == 306)\n                {\n                    // Glyph of Blessing of Wisdom\n                    if (AuraEffect* aurEff = GetAuraEffect(57979, 0))\n                        duration += aurEff->GetAmount() * MINUTE * IN_MILLISECONDS;\n                }\n                break;\n        }\n    }\n    return std::max(duration, 0);\n}\n\nvoid Unit::ModSpellCastTime(SpellInfo const* spellProto, int32 & castTime, Spell* spell)\n{\n    if (!spellProto || castTime < 0)\n        return;\n    // called from caster\n    if (Player* modOwner = GetSpellModOwner())\n        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CASTING_TIME, castTime, spell);\n\n    if (!(spellProto->Attributes & (SPELL_ATTR0_ABILITY|SPELL_ATTR0_TRADESPELL)) && ((GetTypeId() == TYPEID_PLAYER && spellProto->SpellFamilyName) || GetTypeId() == TYPEID_UNIT))\n        castTime = int32(float(castTime) * GetFloatValue(UNIT_MOD_CAST_SPEED));\n    else if (spellProto->Attributes & SPELL_ATTR0_REQ_AMMO && !(spellProto->AttributesEx2 & SPELL_ATTR2_AUTOREPEAT_FLAG))\n        castTime = int32(float(castTime) * m_modAttackSpeedPct[RANGED_ATTACK]);\n    else if (spellProto->SpellVisual[0] == 3881 && HasAura(67556)) // cooking with Chef Hat.\n        castTime = 500;\n}\n\nDiminishingLevels Unit::GetDiminishing(DiminishingGroup group)\n{\n    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)\n    {\n        if (i->DRGroup != group)\n            continue;\n\n        if (!i->hitCount)\n            return DIMINISHING_LEVEL_1;\n\n        if (!i->hitTime)\n            return DIMINISHING_LEVEL_1;\n\n        // If last spell was casted more than 15 seconds ago - reset the count.\n        if (i->stack == 0 && getMSTimeDiff(i->hitTime, getMSTime()) > 15000)\n        {\n            i->hitCount = DIMINISHING_LEVEL_1;\n            return DIMINISHING_LEVEL_1;\n        }\n        // or else increase the count.\n        else\n            return DiminishingLevels(i->hitCount);\n    }\n    return DIMINISHING_LEVEL_1;\n}\n\nvoid Unit::IncrDiminishing(DiminishingGroup group)\n{\n    // Checking for existing in the table\n    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)\n    {\n        if (i->DRGroup != group)\n            continue;\n        if (int32(i->hitCount) < GetDiminishingReturnsMaxLevel(group))\n            i->hitCount += 1;\n        return;\n    }\n    m_Diminishing.push_back(DiminishingReturn(group, getMSTime(), DIMINISHING_LEVEL_2));\n}\n\nfloat Unit::ApplyDiminishingToDuration(DiminishingGroup group, int32 &duration, Unit* caster, DiminishingLevels Level, int32 limitduration)\n{\n    if (duration == -1 || group == DIMINISHING_NONE)\n        return 1.0f;\n\n    // test pet/charm masters instead pets/charmeds\n    Unit const* targetOwner = GetCharmerOrOwner();\n    Unit const* casterOwner = caster->GetCharmerOrOwner();\n\n    // Duration of crowd control abilities on pvp target is limited by 10 sec. (2.2.0)\n    if (limitduration > 0 && duration > limitduration)\n    {\n        Unit const* target = targetOwner ? targetOwner : this;\n        Unit const* source = casterOwner ? casterOwner : caster;\n\n        if ((target->GetTypeId() == TYPEID_PLAYER\n            || ((Creature*)target)->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_ALL_DIMINISH)\n            && source->GetTypeId() == TYPEID_PLAYER)\n            duration = limitduration;\n    }\n\n    float mod = 1.0f;\n\n    if (group == DIMINISHING_TAUNT)\n    {\n        if (GetTypeId() == TYPEID_UNIT && (ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_TAUNT_DIMINISH))\n        {\n            DiminishingLevels diminish = Level;\n            switch (diminish)\n            {\n                case DIMINISHING_LEVEL_1: break;\n                case DIMINISHING_LEVEL_2: mod = 0.65f; break;\n                case DIMINISHING_LEVEL_3: mod = 0.4225f; break;\n                case DIMINISHING_LEVEL_4: mod = 0.274625f; break;\n                case DIMINISHING_LEVEL_TAUNT_IMMUNE: mod = 0.0f; break;\n                default: break;\n            }\n        }\n    }\n    // Some diminishings applies to mobs too (for example, Stun)\n    else if ((GetDiminishingReturnsGroupType(group) == DRTYPE_PLAYER\n        && ((targetOwner ? (targetOwner->GetTypeId() == TYPEID_PLAYER) : (GetTypeId() == TYPEID_PLAYER))\n        || (GetTypeId() == TYPEID_UNIT && ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_ALL_DIMINISH)))\n        || GetDiminishingReturnsGroupType(group) == DRTYPE_ALL)\n    {\n        DiminishingLevels diminish = Level;\n        switch (diminish)\n        {\n            case DIMINISHING_LEVEL_1: break;\n            case DIMINISHING_LEVEL_2: mod = 0.5f; break;\n            case DIMINISHING_LEVEL_3: mod = 0.25f; break;\n            case DIMINISHING_LEVEL_IMMUNE: mod = 0.0f; break;\n            default: break;\n        }\n    }\n\n    duration = int32(duration * mod);\n    return mod;\n}\n\nvoid Unit::ApplyDiminishingAura(DiminishingGroup group, bool apply)\n{\n    // Checking for existing in the table\n    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)\n    {\n        if (i->DRGroup != group)\n            continue;\n\n        if (apply)\n            i->stack += 1;\n        else if (i->stack)\n        {\n            i->stack -= 1;\n            // Remember time after last aura from group removed\n            if (i->stack == 0)\n                i->hitTime = getMSTime();\n        }\n        break;\n    }\n}\n\nfloat Unit::GetSpellMaxRangeForTarget(Unit const* target, SpellInfo const* spellInfo) const\n{\n    if (!spellInfo->RangeEntry)\n        return 0;\n    if (spellInfo->RangeEntry->maxRangeFriend == spellInfo->RangeEntry->maxRangeHostile)\n        return spellInfo->GetMaxRange();\n    return spellInfo->GetMaxRange(!IsHostileTo(target));\n}\n\nfloat Unit::GetSpellMinRangeForTarget(Unit const* target, SpellInfo const* spellInfo) const\n{\n    if (!spellInfo->RangeEntry)\n        return 0;\n    if (spellInfo->RangeEntry->minRangeFriend == spellInfo->RangeEntry->minRangeHostile)\n        return spellInfo->GetMinRange();\n    return spellInfo->GetMinRange(!IsHostileTo(target));\n}\n\nUnit* Unit::GetUnit(WorldObject& object, uint64 guid)\n{\n    return ObjectAccessor::GetUnit(object, guid);\n}\n\nPlayer* Unit::GetPlayer(WorldObject& object, uint64 guid)\n{\n    return ObjectAccessor::GetPlayer(object, guid);\n}\n\nCreature* Unit::GetCreature(WorldObject& object, uint64 guid)\n{\n    return object.GetMap()->GetCreature(guid);\n}\n\nuint32 Unit::GetCreatureType() const\n{\n    if (GetTypeId() == TYPEID_PLAYER)\n    {\n        ShapeshiftForm form = GetShapeshiftForm();\n        SpellShapeshiftEntry const* ssEntry = sSpellShapeshiftStore.LookupEntry(form);\n        if (ssEntry && ssEntry->creatureType > 0)\n            return ssEntry->creatureType;\n        else\n            return CREATURE_TYPE_HUMANOID;\n    }\n    else\n        return ToCreature()->GetCreatureTemplate()->type;\n}\n\n/*#######################################\n########                         ########\n########       STAT SYSTEM       ########\n########                         ########\n#######################################*/\n\nbool Unit::HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, float amount, bool apply)\n{\n    if (unitMod >= UNIT_MOD_END || modifierType >= MODIFIER_TYPE_END)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"ERROR in HandleStatModifier(): non-existing UnitMods or wrong UnitModifierType!\");\n        return false;\n    }\n\n    switch (modifierType)\n    {\n        case BASE_VALUE:\n        case TOTAL_VALUE:\n            m_auraModifiersGroup[unitMod][modifierType] += apply ? amount : -amount;\n            break;\n        case BASE_PCT:\n        case TOTAL_PCT:\n            ApplyPercentModFloatVar(m_auraModifiersGroup[unitMod][modifierType], amount, apply);\n            break;\n        default:\n            break;\n    }\n\n    if (!CanModifyStats())\n        return false;\n\n    switch (unitMod)\n    {\n        case UNIT_MOD_STAT_STRENGTH:\n        case UNIT_MOD_STAT_AGILITY:\n        case UNIT_MOD_STAT_STAMINA:\n        case UNIT_MOD_STAT_INTELLECT:\n        case UNIT_MOD_STAT_SPIRIT:         UpdateStats(GetStatByAuraGroup(unitMod));  break;\n\n        case UNIT_MOD_ARMOR:               UpdateArmor();           break;\n        case UNIT_MOD_HEALTH:              UpdateMaxHealth();       break;\n\n        case UNIT_MOD_MANA:\n        case UNIT_MOD_RAGE:\n        case UNIT_MOD_FOCUS:\n        case UNIT_MOD_ENERGY:\n        case UNIT_MOD_HAPPINESS:\n        case UNIT_MOD_RUNE:\n        case UNIT_MOD_RUNIC_POWER:          UpdateMaxPower(GetPowerTypeByAuraGroup(unitMod));          break;\n\n        case UNIT_MOD_RESISTANCE_HOLY:\n        case UNIT_MOD_RESISTANCE_FIRE:\n        case UNIT_MOD_RESISTANCE_NATURE:\n        case UNIT_MOD_RESISTANCE_FROST:\n        case UNIT_MOD_RESISTANCE_SHADOW:\n        case UNIT_MOD_RESISTANCE_ARCANE:   UpdateResistances(GetSpellSchoolByAuraGroup(unitMod));      break;\n\n        case UNIT_MOD_ATTACK_POWER:        UpdateAttackPowerAndDamage();         break;\n        case UNIT_MOD_ATTACK_POWER_RANGED: UpdateAttackPowerAndDamage(true);     break;\n\n        case UNIT_MOD_DAMAGE_MAINHAND:     UpdateDamagePhysical(BASE_ATTACK);    break;\n        case UNIT_MOD_DAMAGE_OFFHAND:      UpdateDamagePhysical(OFF_ATTACK);     break;\n        case UNIT_MOD_DAMAGE_RANGED:       UpdateDamagePhysical(RANGED_ATTACK);  break;\n\n        default:\n            break;\n    }\n\n    return true;\n}\n\nfloat Unit::GetModifierValue(UnitMods unitMod, UnitModifierType modifierType) const\n{\n    if (unitMod >= UNIT_MOD_END || modifierType >= MODIFIER_TYPE_END)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"attempt to access non-existing modifier value from UnitMods!\");\n        return 0.0f;\n    }\n\n    if (modifierType == TOTAL_PCT && m_auraModifiersGroup[unitMod][modifierType] <= 0.0f)\n        return 0.0f;\n\n    return m_auraModifiersGroup[unitMod][modifierType];\n}\n\nfloat Unit::GetTotalStatValue(Stats stat) const\n{\n    UnitMods unitMod = UnitMods(UNIT_MOD_STAT_START + stat);\n\n    if (m_auraModifiersGroup[unitMod][TOTAL_PCT] <= 0.0f)\n        return 0.0f;\n\n    // value = ((base_value * base_pct) + total_value) * total_pct\n    float value  = m_auraModifiersGroup[unitMod][BASE_VALUE] + GetCreateStat(stat);\n    value *= m_auraModifiersGroup[unitMod][BASE_PCT];\n    value += m_auraModifiersGroup[unitMod][TOTAL_VALUE];\n    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT];\n\n    return value;\n}\n\nfloat Unit::GetTotalAuraModValue(UnitMods unitMod) const\n{\n    if (unitMod >= UNIT_MOD_END)\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"attempt to access non-existing UnitMods in GetTotalAuraModValue()!\");\n        return 0.0f;\n    }\n\n    if (m_auraModifiersGroup[unitMod][TOTAL_PCT] <= 0.0f)\n        return 0.0f;\n\n    float value = m_auraModifiersGroup[unitMod][BASE_VALUE];\n    value *= m_auraModifiersGroup[unitMod][BASE_PCT];\n    value += m_auraModifiersGroup[unitMod][TOTAL_VALUE];\n    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT];\n\n    return value;\n}\n\nSpellSchools Unit::GetSpellSchoolByAuraGroup(UnitMods unitMod) const\n{\n    SpellSchools school = SPELL_SCHOOL_NORMAL;\n\n    switch (unitMod)\n    {\n        case UNIT_MOD_RESISTANCE_HOLY:     school = SPELL_SCHOOL_HOLY;          break;\n        case UNIT_MOD_RESISTANCE_FIRE:     school = SPELL_SCHOOL_FIRE;          break;\n        case UNIT_MOD_RESISTANCE_NATURE:   school = SPELL_SCHOOL_NATURE;        break;\n        case UNIT_MOD_RESISTANCE_FROST:    school = SPELL_SCHOOL_FROST;         break;\n        case UNIT_MOD_RESISTANCE_SHADOW:   school = SPELL_SCHOOL_SHADOW;        break;\n        case UNIT_MOD_RESISTANCE_ARCANE:   school = SPELL_SCHOOL_ARCANE;        break;\n\n        default:\n            break;\n    }\n\n    return school;\n}\n\nStats Unit::GetStatByAuraGroup(UnitMods unitMod) const\n{\n    Stats stat = STAT_STRENGTH;\n\n    switch (unitMod)\n    {\n        case UNIT_MOD_STAT_STRENGTH:    stat = STAT_STRENGTH;      break;\n        case UNIT_MOD_STAT_AGILITY:     stat = STAT_AGILITY;       break;\n        case UNIT_MOD_STAT_STAMINA:     stat = STAT_STAMINA;       break;\n        case UNIT_MOD_STAT_INTELLECT:   stat = STAT_INTELLECT;     break;\n        case UNIT_MOD_STAT_SPIRIT:      stat = STAT_SPIRIT;        break;\n\n        default:\n            break;\n    }\n\n    return stat;\n}\n\nPowers Unit::GetPowerTypeByAuraGroup(UnitMods unitMod) const\n{\n    switch (unitMod)\n    {\n        case UNIT_MOD_RAGE:        return POWER_RAGE;\n        case UNIT_MOD_FOCUS:       return POWER_FOCUS;\n        case UNIT_MOD_ENERGY:      return POWER_ENERGY;\n        case UNIT_MOD_HAPPINESS:   return POWER_HAPPINESS;\n        case UNIT_MOD_RUNE:        return POWER_RUNE;\n        case UNIT_MOD_RUNIC_POWER: return POWER_RUNIC_POWER;\n        default:\n        case UNIT_MOD_MANA:        return POWER_MANA;\n    }\n}\n\nfloat Unit::GetTotalAttackPowerValue(WeaponAttackType attType) const\n{\n    if (attType == RANGED_ATTACK)\n    {\n        int32 ap = GetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER) + GetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER_MODS);\n        if (ap < 0)\n            return 0.0f;\n        return ap * (1.0f + GetFloatValue(UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER));\n    }\n    else\n    {\n        int32 ap = GetInt32Value(UNIT_FIELD_ATTACK_POWER) + GetInt32Value(UNIT_FIELD_ATTACK_POWER_MODS);\n        if (ap < 0)\n            return 0.0f;\n        return ap * (1.0f + GetFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER));\n    }\n}\n\nfloat Unit::GetWeaponDamageRange(WeaponAttackType attType, WeaponDamageRange type) const\n{\n    if (attType == OFF_ATTACK && !haveOffhandWeapon())\n        return 0.0f;\n\n    return m_weaponDamage[attType][type];\n}\n\nvoid Unit::SetLevel(uint8 lvl)\n{\n    SetUInt32Value(UNIT_FIELD_LEVEL, lvl);\n\n    // group update\n    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->GetGroup())\n        ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_LEVEL);\n}\n\nvoid Unit::SetHealth(uint32 val)\n{\n    if (getDeathState() == JUST_DIED)\n        val = 0;\n    else if (GetTypeId() == TYPEID_PLAYER && getDeathState() == DEAD)\n        val = 1;\n    else\n    {\n        uint32 maxHealth = GetMaxHealth();\n        if (maxHealth < val)\n            val = maxHealth;\n    }\n\n    SetUInt32Value(UNIT_FIELD_HEALTH, val);\n\n    // group update\n    if (Player* player = ToPlayer())\n    {\n        if (player->GetGroup())\n            player->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_HP);\n    }\n    else if (Pet* pet = ToCreature()->ToPet())\n    {\n        if (pet->isControlled())\n        {\n            Unit* owner = GetOwner();\n            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())\n                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_HP);\n        }\n    }\n}\n\nvoid Unit::SetMaxHealth(uint32 val)\n{\n    if (!val)\n        val = 1;\n\n    uint32 health = GetHealth();\n    SetUInt32Value(UNIT_FIELD_MAXHEALTH, val);\n\n    // group update\n    if (GetTypeId() == TYPEID_PLAYER)\n    {\n        if (ToPlayer()->GetGroup())\n            ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_HP);\n    }\n    else if (Pet* pet = ToCreature()->ToPet())\n    {\n        if (pet->isControlled())\n        {\n            Unit* owner = GetOwner();\n            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())\n                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_HP);\n        }\n    }\n\n    if (val < health)\n        SetHealth(val);\n}\n\nvoid Unit::SetPower(Powers power, uint32 val)\n{\n    if (GetPower(power) == val)\n        return;\n\n    uint32 maxPower = GetMaxPower(power);\n    if (maxPower < val)\n        val = maxPower;\n\n    SetStatInt32Value(UNIT_FIELD_POWER1 + power, val);\n\n    WorldPacket data(SMSG_POWER_UPDATE);\n    data.append(GetPackGUID());\n    data << uint8(power);\n    data << uint32(val);\n    SendMessageToSet(&data, GetTypeId() == TYPEID_PLAYER ? true : false);\n\n    // group update\n    if (Player* player = ToPlayer())\n    {\n        if (player->GetGroup())\n            player->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_POWER);\n    }\n    else if (Pet* pet = ToCreature()->ToPet())\n    {\n        if (pet->isControlled())\n        {\n            Unit* owner = GetOwner();\n            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())\n                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_POWER);\n        }\n\n        // Update the pet's character sheet with happiness damage bonus\n        if (pet->getPetType() == HUNTER_PET && power == POWER_HAPPINESS)\n            pet->UpdateDamagePhysical(BASE_ATTACK);\n    }\n}\n\nvoid Unit::SetMaxPower(Powers power, uint32 val)\n{\n    uint32 cur_power = GetPower(power);\n    SetStatInt32Value(UNIT_FIELD_MAXPOWER1 + power, val);\n\n    // group update\n    if (GetTypeId() == TYPEID_PLAYER)\n    {\n        if (ToPlayer()->GetGroup())\n            ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_POWER);\n    }\n    else if (Pet* pet = ToCreature()->ToPet())\n    {\n        if (pet->isControlled())\n        {\n            Unit* owner = GetOwner();\n            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())\n                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_POWER);\n        }\n    }\n\n    if (val < cur_power)\n        SetPower(power, val);\n}\n\nuint32 Unit::GetCreatePowers(Powers power) const\n{\n    // Only hunter pets have POWER_FOCUS and POWER_HAPPINESS\n    switch (power)\n    {\n        case POWER_MANA:      return GetCreateMana();\n        case POWER_RAGE:      return 1000;\n        case POWER_FOCUS:     return (GetTypeId() == TYPEID_PLAYER || !((Creature const*)this)->isPet() || ((Pet const*)this)->getPetType() != HUNTER_PET ? 0 : 100);\n        case POWER_ENERGY:    return 100;\n        case POWER_HAPPINESS: return (GetTypeId() == TYPEID_PLAYER || !((Creature const*)this)->isPet() || ((Pet const*)this)->getPetType() != HUNTER_PET ? 0 : 1050000);\n        case POWER_RUNIC_POWER: return 1000;\n        case POWER_RUNE:      return 0;\n        case POWER_HEALTH:    return 0;\n        default:\n            break;\n    }\n\n    return 0;\n}\n\nvoid Unit::AddToWorld()\n{\n    if (!IsInWorld())\n    {\n        WorldObject::AddToWorld();\n    }\n}\n\nvoid Unit::RemoveFromWorld()\n{\n    // cleanup\n    ASSERT(GetGUID());\n\n    if (IsInWorld())\n    {\n        m_duringRemoveFromWorld = true;\n        if (IsVehicle())\n            RemoveVehicleKit();\n\n        RemoveCharmAuras();\n        RemoveBindSightAuras();\n        RemoveNotOwnSingleTargetAuras();\n\n        RemoveAllGameObjects();\n        RemoveAllDynObjects();\n\n        ExitVehicle();  // Remove applied auras with SPELL_AURA_CONTROL_VEHICLE\n        UnsummonAllTotems();\n        RemoveAllControlled();\n\n        RemoveAreaAurasDueToLeaveWorld();\n\n        if (GetCharmerGUID())\n        {\n            sLog->outFatal(LOG_FILTER_UNITS, \"Unit %u has charmer guid when removed from world\", GetEntry());\n            ASSERT(false);\n        }\n\n        if (Unit* owner = GetOwner())\n        {\n            if (owner->m_Controlled.find(this) != owner->m_Controlled.end())\n            {\n                sLog->outFatal(LOG_FILTER_UNITS, \"Unit %u is in controlled list of %u when removed from world\", GetEntry(), owner->GetEntry());\n                ASSERT(false);\n            }\n        }\n\n        WorldObject::RemoveFromWorld();\n        m_duringRemoveFromWorld = false;\n    }\n}\n\nvoid Unit::CleanupBeforeRemoveFromMap(bool finalCleanup)\n{\n    // This needs to be before RemoveFromWorld to make GetCaster() return a valid pointer on aura removal\n    InterruptNonMeleeSpells(true);\n\n    if (IsInWorld())\n        RemoveFromWorld();\n\n    ASSERT(GetGUID());\n\n    // A unit may be in removelist and not in world, but it is still in grid\n    // and may have some references during delete\n    RemoveAllAuras();\n    RemoveAllGameObjects();\n\n    if (finalCleanup)\n        m_cleanupDone = true;\n\n    m_Events.KillAllEvents(false);                      // non-delatable (currently casted spells) will not deleted now but it will deleted at call in Map::RemoveAllObjectsInRemoveList\n    CombatStop();\n    ClearComboPointHolders();\n    DeleteThreatList();\n    getHostileRefManager().setOnlineOfflineState(false);\n    GetMotionMaster()->Clear(false);                    // remove different non-standard movement generators.\n}\n\nvoid Unit::CleanupsBeforeDelete(bool finalCleanup)\n{\n    CleanupBeforeRemoveFromMap(finalCleanup);\n\n    if (Creature* thisCreature = ToCreature())\n        if (GetTransport())\n            GetTransport()->RemovePassenger(thisCreature);\n}\n\nvoid Unit::UpdateCharmAI()\n{\n    if (GetTypeId() == TYPEID_PLAYER)\n        return;\n\n    if (i_disabledAI) // disabled AI must be primary AI\n    {\n        if (!isCharmed())\n        {\n            delete i_AI;\n            i_AI = i_disabledAI;\n            i_disabledAI = NULL;\n        }\n    }\n    else\n    {\n        if (isCharmed())\n        {\n            i_disabledAI = i_AI;\n            if (isPossessed() || IsVehicle())\n                i_AI = new PossessedAI(ToCreature());\n            else\n                i_AI = new PetAI(ToCreature());\n        }\n    }\n}\n\nCharmInfo* Unit::InitCharmInfo()\n{\n    if (!m_charmInfo)\n        m_charmInfo = new CharmInfo(this);\n\n    return m_charmInfo;\n}\n\nvoid Unit::DeleteCharmInfo()\n{\n    if (!m_charmInfo)\n        return;\n\n    m_charmInfo->RestoreState();\n    delete m_charmInfo;\n    m_charmInfo = NULL;\n}\n\nCharmInfo::CharmInfo(Unit* unit)\n: m_unit(unit), m_CommandState(COMMAND_FOLLOW), m_petnumber(0), m_barInit(false),\n  m_isCommandAttack(false), m_isAtStay(false), m_isFollowing(false), m_isReturning(false),\n  m_stayX(0.0f), m_stayY(0.0f), m_stayZ(0.0f)\n{\n    for (uint8 i = 0; i < MAX_SPELL_CHARM; ++i)\n        m_charmspells[i].SetActionAndType(0, ACT_DISABLED);\n\n    if (m_unit->GetTypeId() == TYPEID_UNIT)\n    {\n        m_oldReactState = m_unit->ToCreature()->GetReactState();\n        m_unit->ToCreature()->SetReactState(REACT_PASSIVE);\n    }\n}\n\nCharmInfo::~CharmInfo()\n{\n}\n\nvoid CharmInfo::RestoreState()\n{\n    if (m_unit->GetTypeId() == TYPEID_UNIT)\n        if (Creature* creature = m_unit->ToCreature())\n            creature->SetReactState(m_oldReactState);\n}\n\nvoid CharmInfo::InitPetActionBar()\n{\n    // the first 3 SpellOrActions are attack, follow and stay\n    for (uint32 i = 0; i < ACTION_BAR_INDEX_PET_SPELL_START - ACTION_BAR_INDEX_START; ++i)\n        SetActionBar(ACTION_BAR_INDEX_START + i, COMMAND_ATTACK - i, ACT_COMMAND);\n\n    // middle 4 SpellOrActions are spells/special attacks/abilities\n    for (uint32 i = 0; i < ACTION_BAR_INDEX_PET_SPELL_END-ACTION_BAR_INDEX_PET_SPELL_START; ++i)\n        SetActionBar(ACTION_BAR_INDEX_PET_SPELL_START + i, 0, ACT_PASSIVE);\n\n    // last 3 SpellOrActions are reactions\n    for (uint32 i = 0; i < ACTION_BAR_INDEX_END - ACTION_BAR_INDEX_PET_SPELL_END; ++i)\n        SetActionBar(ACTION_BAR_INDEX_PET_SPELL_END + i, COMMAND_ATTACK - i, ACT_REACTION);\n}\n\nvoid CharmInfo::InitEmptyActionBar(bool withAttack)\n{\n    if (withAttack)\n        SetActionBar(ACTION_BAR_INDEX_START, COMMAND_ATTACK, ACT_COMMAND);\n    else\n        SetActionBar(ACTION_BAR_INDEX_START, 0, ACT_PASSIVE);\n    for (uint32 x = ACTION_BAR_INDEX_START+1; x < ACTION_BAR_INDEX_END; ++x)\n        SetActionBar(x, 0, ACT_PASSIVE);\n}\n\nvoid CharmInfo::InitPossessCreateSpells()\n{\n    InitEmptyActionBar();\n    if (m_unit->GetTypeId() == TYPEID_UNIT)\n    {\n        for (uint32 i = 0; i < CREATURE_MAX_SPELLS; ++i)\n        {\n            uint32 spellId = m_unit->ToCreature()->m_spells[i];\n            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);\n            if (spellInfo && !(spellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_DEAD))\n            {\n                if (spellInfo->IsPassive())\n                    m_unit->CastSpell(m_unit, spellInfo, true);\n                else\n                    AddSpellToActionBar(spellInfo, ACT_PASSIVE);\n            }\n        }\n    }\n}\n\nvoid CharmInfo::InitCharmCreateSpells()\n{\n    if (m_unit->GetTypeId() == TYPEID_PLAYER)                // charmed players don't have spells\n    {\n        InitEmptyActionBar();\n        return;\n    }\n\n    InitPetActionBar();\n\n    for (uint32 x = 0; x < MAX_SPELL_CHARM; ++x)\n    {\n        uint32 spellId = m_unit->ToCreature()->m_spells[x];\n        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);\n\n        if (!spellInfo || spellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_DEAD)\n        {\n            m_charmspells[x].SetActionAndType(spellId, ACT_DISABLED);\n            continue;\n        }\n\n        if (spellInfo->IsPassive())\n        {\n            m_unit->CastSpell(m_unit, spellInfo, true);\n            m_charmspells[x].SetActionAndType(spellId, ACT_PASSIVE);\n        }\n        else\n        {\n            m_charmspells[x].SetActionAndType(spellId, ACT_DISABLED);\n\n            ActiveStates newstate = ACT_PASSIVE;\n\n            if (!spellInfo->IsAutocastable())\n                newstate = ACT_PASSIVE;\n            else\n            {\n                if (spellInfo->NeedsExplicitUnitTarget())\n                {\n                    newstate = ACT_ENABLED;\n                    ToggleCreatureAutocast(spellInfo, true);\n                }\n                else\n                    newstate = ACT_DISABLED;\n            }\n\n            AddSpellToActionBar(spellInfo, newstate);\n        }\n    }\n}\n\nbool CharmInfo::AddSpellToActionBar(SpellInfo const* spellInfo, ActiveStates newstate)\n{\n    uint32 spell_id = spellInfo->Id;\n    uint32 first_id = spellInfo->GetFirstRankSpell()->Id;\n\n    // new spell rank can be already listed\n    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)\n    {\n        if (uint32 action = PetActionBar[i].GetAction())\n        {\n            if (PetActionBar[i].IsActionBarForSpell() && sSpellMgr->GetFirstSpellInChain(action) == first_id)\n            {\n                PetActionBar[i].SetAction(spell_id);\n                return true;\n            }\n        }\n    }\n\n    // or use empty slot in other case\n    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)\n    {\n        if (!PetActionBar[i].GetAction() && PetActionBar[i].IsActionBarForSpell())\n        {\n            SetActionBar(i, spell_id, newstate == ACT_DECIDE ? spellInfo->IsAutocastable() ? ACT_DISABLED : ACT_PASSIVE : newstate);\n            return true;\n        }\n    }\n    return false;\n}\n\nbool CharmInfo::RemoveSpellFromActionBar(uint32 spell_id)\n{\n    uint32 first_id = sSpellMgr->GetFirstSpellInChain(spell_id);\n\n    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)\n    {\n        if (uint32 action = PetActionBar[i].GetAction())\n        {\n            if (PetActionBar[i].IsActionBarForSpell() && sSpellMgr->GetFirstSpellInChain(action) == first_id)\n            {\n                SetActionBar(i, 0, ACT_PASSIVE);\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid CharmInfo::ToggleCreatureAutocast(SpellInfo const* spellInfo, bool apply)\n{\n    if (spellInfo->IsPassive())\n        return;\n\n    for (uint32 x = 0; x < MAX_SPELL_CHARM; ++x)\n        if (spellInfo->Id == m_charmspells[x].GetAction())\n            m_charmspells[x].SetType(apply ? ACT_ENABLED : ACT_DISABLED);\n}\n\nvoid CharmInfo::SetPetNumber(uint32 petnumber, bool statwindow)\n{\n    m_petnumber = petnumber;\n    if (statwindow)\n        m_unit->SetUInt32Value(UNIT_FIELD_PETNUMBER, m_petnumber);\n    else\n        m_unit->SetUInt32Value(UNIT_FIELD_PETNUMBER, 0);\n}\n\nvoid CharmInfo::LoadPetActionBar(const std::string& data)\n{\n    InitPetActionBar();\n\n    Tokens tokens(data, ' ');\n\n    if (tokens.size() != (ACTION_BAR_INDEX_END-ACTION_BAR_INDEX_START) * 2)\n        return;                                             // non critical, will reset to default\n\n    uint8 index;\n    Tokens::iterator iter;\n    for (iter = tokens.begin(), index = ACTION_BAR_INDEX_START; index < ACTION_BAR_INDEX_END; ++iter, ++index)\n    {\n        // use unsigned cast to avoid sign negative format use at long-> ActiveStates (int) conversion\n        ActiveStates type  = ActiveStates(atol(*iter));\n        ++iter;\n        uint32 action = uint32(atol(*iter));\n\n        PetActionBar[index].SetActionAndType(action, type);\n\n        // check correctness\n        if (PetActionBar[index].IsActionBarForSpell())\n        {\n            SpellInfo const* spelInfo = sSpellMgr->GetSpellInfo(PetActionBar[index].GetAction());\n            if (!spelInfo)\n                SetActionBar(index, 0, ACT_PASSIVE);\n            else if (!spelInfo->IsAutocastable())\n                SetActionBar(index, PetActionBar[index].GetAction(), ACT_PASSIVE);\n        }\n    }\n}\n\nvoid CharmInfo::BuildActionBar(WorldPacket* data)\n{\n    for (uint32 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)\n        *data << uint32(PetActionBar[i].packedData);\n}\n\nvoid CharmInfo::SetSpellAutocast(SpellInfo const* spellInfo, bool state)\n{\n    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)\n    {\n        if (spellInfo->Id == PetActionBar[i].GetAction() && PetActionBar[i].IsActionBarForSpell())\n        {\n            PetActionBar[i].SetType(state ? ACT_ENABLED : ACT_DISABLED);\n            break;\n        }\n    }\n}\n\nbool Unit::isFrozen() const\n{\n    return HasAuraState(AURA_STATE_FROZEN);\n}\n\nstruct ProcTriggeredData\n{\n    ProcTriggeredData(Aura* _aura)\n        : aura(_aura)\n    {\n        effMask = 0;\n        spellProcEvent = NULL;\n    }\n    SpellProcEventEntry const* spellProcEvent;\n    Aura* aura;\n    uint32 effMask;\n};\n\ntypedef std::list< ProcTriggeredData > ProcTriggeredList;\n\n// List of auras that CAN be trigger but may not exist in spell_proc_event\n// in most case need for drop charges\n// in some types of aura need do additional check\n// for example SPELL_AURA_MECHANIC_IMMUNITY - need check for mechanic\nbool InitTriggerAuraData()\n{\n    for (uint16 i = 0; i < TOTAL_AURAS; ++i)\n    {\n        isTriggerAura[i] = false;\n        isNonTriggerAura[i] = false;\n        isAlwaysTriggeredAura[i] = false;\n    }\n    isTriggerAura[SPELL_AURA_DUMMY] = true;\n    isTriggerAura[SPELL_AURA_MOD_CONFUSE] = true;\n    isTriggerAura[SPELL_AURA_MOD_THREAT] = true;\n    isTriggerAura[SPELL_AURA_MOD_STUN] = true; // Aura does not have charges but needs to be removed on trigger\n    isTriggerAura[SPELL_AURA_MOD_DAMAGE_DONE] = true;\n    isTriggerAura[SPELL_AURA_MOD_DAMAGE_TAKEN] = true;\n    isTriggerAura[SPELL_AURA_MOD_RESISTANCE] = true;\n    isTriggerAura[SPELL_AURA_MOD_STEALTH] = true;\n    isTriggerAura[SPELL_AURA_MOD_FEAR] = true; // Aura does not have charges but needs to be removed on trigger\n    isTriggerAura[SPELL_AURA_MOD_ROOT] = true;\n    isTriggerAura[SPELL_AURA_TRANSFORM] = true;\n    isTriggerAura[SPELL_AURA_REFLECT_SPELLS] = true;\n    isTriggerAura[SPELL_AURA_DAMAGE_IMMUNITY] = true;\n    isTriggerAura[SPELL_AURA_PROC_TRIGGER_SPELL] = true;\n    isTriggerAura[SPELL_AURA_PROC_TRIGGER_DAMAGE] = true;\n    isTriggerAura[SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK] = true;\n    isTriggerAura[SPELL_AURA_SCHOOL_ABSORB] = true; // Savage Defense untested\n    isTriggerAura[SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT] = true;\n    isTriggerAura[SPELL_AURA_MOD_POWER_COST_SCHOOL] = true;\n    isTriggerAura[SPELL_AURA_REFLECT_SPELLS_SCHOOL] = true;\n    isTriggerAura[SPELL_AURA_MECHANIC_IMMUNITY] = true;\n    isTriggerAura[SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN] = true;\n    isTriggerAura[SPELL_AURA_SPELL_MAGNET] = true;\n    isTriggerAura[SPELL_AURA_MOD_ATTACK_POWER] = true;\n    isTriggerAura[SPELL_AURA_ADD_CASTER_HIT_TRIGGER] = true;\n    isTriggerAura[SPELL_AURA_OVERRIDE_CLASS_SCRIPTS] = true;\n    isTriggerAura[SPELL_AURA_MOD_MECHANIC_RESISTANCE] = true;\n    isTriggerAura[SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS] = true;\n    isTriggerAura[SPELL_AURA_MOD_MELEE_HASTE] = true;\n    isTriggerAura[SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE] = true;\n    isTriggerAura[SPELL_AURA_RAID_PROC_FROM_CHARGE] = true;\n    isTriggerAura[SPELL_AURA_RAID_PROC_FROM_CHARGE_WITH_VALUE] = true;\n    isTriggerAura[SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE] = true;\n    isTriggerAura[SPELL_AURA_MOD_DAMAGE_FROM_CASTER] = true;\n    isTriggerAura[SPELL_AURA_MOD_SPELL_CRIT_CHANCE] = true;\n    isTriggerAura[SPELL_AURA_ABILITY_IGNORE_AURASTATE] = true;\n\n    isNonTriggerAura[SPELL_AURA_MOD_POWER_REGEN] = true;\n    isNonTriggerAura[SPELL_AURA_REDUCE_PUSHBACK] = true;\n\n    isAlwaysTriggeredAura[SPELL_AURA_OVERRIDE_CLASS_SCRIPTS] = true;\n    isAlwaysTriggeredAura[SPELL_AURA_MOD_FEAR] = true;\n    isAlwaysTriggeredAura[SPELL_AURA_MOD_ROOT] = true;\n    isAlwaysTriggeredAura[SPELL_AURA_MOD_STUN] = true;\n    isAlwaysTriggeredAura[SPELL_AURA_TRANSFORM] = true;\n    isAlwaysTriggeredAura[SPELL_AURA_SPELL_MAGNET] = true;\n    isAlwaysTriggeredAura[SPELL_AURA_SCHOOL_ABSORB] = true;\n    isAlwaysTriggeredAura[SPELL_AURA_MOD_STEALTH] = true;\n\n    return true;\n}\n\nuint32 createProcExtendMask(SpellNonMeleeDamage* damageInfo, SpellMissInfo missCondition)\n{\n    uint32 procEx = PROC_EX_NONE;\n    // Check victim state\n    if (missCondition != SPELL_MISS_NONE)\n        switch (missCondition)\n        {\n            case SPELL_MISS_MISS:    procEx|=PROC_EX_MISS;   break;\n            case SPELL_MISS_RESIST:  procEx|=PROC_EX_RESIST; break;\n            case SPELL_MISS_DODGE:   procEx|=PROC_EX_DODGE;  break;\n            case SPELL_MISS_PARRY:   procEx|=PROC_EX_PARRY;  break;\n            case SPELL_MISS_BLOCK:   procEx|=PROC_EX_BLOCK;  break;\n            case SPELL_MISS_EVADE:   procEx|=PROC_EX_EVADE;  break;\n            case SPELL_MISS_IMMUNE:  procEx|=PROC_EX_IMMUNE; break;\n            case SPELL_MISS_IMMUNE2: procEx|=PROC_EX_IMMUNE; break;\n            case SPELL_MISS_DEFLECT: procEx|=PROC_EX_DEFLECT;break;\n            case SPELL_MISS_ABSORB:  procEx|=PROC_EX_ABSORB; break;\n            case SPELL_MISS_REFLECT: procEx|=PROC_EX_REFLECT;break;\n            default:\n                break;\n        }\n    else\n    {\n        // On block\n        if (damageInfo->blocked)\n            procEx|=PROC_EX_BLOCK;\n        // On absorb\n        if (damageInfo->absorb)\n            procEx|=PROC_EX_ABSORB;\n        // On crit\n        if (damageInfo->HitInfo & SPELL_HIT_TYPE_CRIT)\n            procEx|=PROC_EX_CRITICAL_HIT;\n        else\n            procEx|=PROC_EX_NORMAL_HIT;\n    }\n    return procEx;\n}\n\nvoid Unit::ProcDamageAndSpellFor(bool isVictim, Unit* target, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, SpellInfo const* procSpell, uint32 damage, SpellInfo const* procAura)\n{\n    // Player is loaded now - do not allow passive spell casts to proc\n    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->GetSession()->PlayerLoading())\n        return;\n    // For melee/ranged based attack need update skills and set some Aura states if victim present\n    if (procFlag & MELEE_BASED_TRIGGER_MASK && target)\n    {\n        // Update skills here for players\n        if (GetTypeId() == TYPEID_PLAYER)\n        {\n            // On melee based hit/miss/resist need update skill (for victim and attacker)\n            if (procExtra & (PROC_EX_NORMAL_HIT|PROC_EX_MISS|PROC_EX_RESIST))\n            {\n                if (target->GetTypeId() != TYPEID_PLAYER && target->GetCreatureType() != CREATURE_TYPE_CRITTER)\n                    ToPlayer()->UpdateCombatSkills(target, attType, isVictim);\n            }\n            // Update defence if player is victim and parry/dodge/block\n            else if (isVictim && procExtra & (PROC_EX_DODGE|PROC_EX_PARRY|PROC_EX_BLOCK))\n                ToPlayer()->UpdateCombatSkills(target, attType, true);\n        }\n        // If exist crit/parry/dodge/block need update aura state (for victim and attacker)\n        if (procExtra & (PROC_EX_CRITICAL_HIT|PROC_EX_PARRY|PROC_EX_DODGE|PROC_EX_BLOCK))\n        {\n            // for victim\n            if (isVictim)\n            {\n                // if victim and dodge attack\n                if (procExtra & PROC_EX_DODGE)\n                {\n                    // Update AURA_STATE on dodge\n                    if (getClass() != CLASS_ROGUE) // skip Rogue Riposte\n                    {\n                        ModifyAuraState(AURA_STATE_DEFENSE, true);\n                        StartReactiveTimer(REACTIVE_DEFENSE);\n                    }\n                }\n                // if victim and parry attack\n                if (procExtra & PROC_EX_PARRY)\n                {\n                    // For Hunters only Counterattack (skip Mongoose bite)\n                    if (getClass() == CLASS_HUNTER)\n                    {\n                        ModifyAuraState(AURA_STATE_HUNTER_PARRY, true);\n                        StartReactiveTimer(REACTIVE_HUNTER_PARRY);\n                    }\n                    else\n                    {\n                        ModifyAuraState(AURA_STATE_DEFENSE, true);\n                        StartReactiveTimer(REACTIVE_DEFENSE);\n                    }\n                }\n                // if and victim block attack\n                if (procExtra & PROC_EX_BLOCK)\n                {\n                    ModifyAuraState(AURA_STATE_DEFENSE, true);\n                    StartReactiveTimer(REACTIVE_DEFENSE);\n                }\n            }\n            else // For attacker\n            {\n                // Overpower on victim dodge\n                if (procExtra & PROC_EX_DODGE && GetTypeId() == TYPEID_PLAYER && getClass() == CLASS_WARRIOR)\n                {\n                    ToPlayer()->AddComboPoints(target, 1);\n                    StartReactiveTimer(REACTIVE_OVERPOWER);\n                }\n            }\n        }\n    }\n\n    ProcTriggeredList procTriggered;\n    // Fill procTriggered list\n    for (AuraApplicationMap::const_iterator itr = GetAppliedAuras().begin(); itr!= GetAppliedAuras().end(); ++itr)\n    {\n        // Do not allow auras to proc from effect triggered by itself\n        if (procAura && procAura->Id == itr->first)\n            continue;\n        ProcTriggeredData triggerData(itr->second->GetBase());\n        // Defensive procs are active on absorbs (so absorption effects are not a hindrance)\n        bool active = damage || (procExtra & PROC_EX_BLOCK && isVictim);\n        if (isVictim)\n            procExtra &= ~PROC_EX_INTERNAL_REQ_FAMILY;\n\n        SpellInfo const* spellProto = itr->second->GetBase()->GetSpellInfo();\n\n        // only auras that has triggered spell should proc from fully absorbed damage\n        if (procExtra & PROC_EX_ABSORB && isVictim)\n            if (damage || spellProto->Effects[EFFECT_0].TriggerSpell || spellProto->Effects[EFFECT_1].TriggerSpell || spellProto->Effects[EFFECT_2].TriggerSpell)\n                active = true;\n\n        if (!IsTriggeredAtSpellProcEvent(target, triggerData.aura, procSpell, procFlag, procExtra, attType, isVictim, active, triggerData.spellProcEvent))\n            continue;\n\n        // Triggered spells not triggering additional spells\n        bool triggered = !(spellProto->AttributesEx3 & SPELL_ATTR3_CAN_PROC_WITH_TRIGGERED) ?\n            (procExtra & PROC_EX_INTERNAL_TRIGGERED && !(procFlag & PROC_FLAG_DONE_TRAP_ACTIVATION)) : false;\n\n        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)\n        {\n            if (itr->second->HasEffect(i))\n            {\n                AuraEffect* aurEff = itr->second->GetBase()->GetEffect(i);\n                // Skip this auras\n                if (isNonTriggerAura[aurEff->GetAuraType()])\n                    continue;\n                // If not trigger by default and spellProcEvent == NULL - skip\n                if (!isTriggerAura[aurEff->GetAuraType()] && triggerData.spellProcEvent == NULL)\n                    continue;\n                // Some spells must always trigger\n                if (!triggered || isAlwaysTriggeredAura[aurEff->GetAuraType()])\n                    triggerData.effMask |= 1<<i;\n            }\n        }\n        if (triggerData.effMask)\n            procTriggered.push_front(triggerData);\n    }\n\n    // Nothing found\n    if (procTriggered.empty())\n        return;\n\n    // Note: must SetCantProc(false) before return\n    if (procExtra & (PROC_EX_INTERNAL_TRIGGERED | PROC_EX_INTERNAL_CANT_PROC))\n        SetCantProc(true);\n\n    // Handle effects proceed this time\n    for (ProcTriggeredList::const_iterator i = procTriggered.begin(); i != procTriggered.end(); ++i)\n    {\n        // look for aura in auras list, it may be removed while proc event processing\n        if (i->aura->IsRemoved())\n            continue;\n\n        bool useCharges  = i->aura->IsUsingCharges();\n        // no more charges to use, prevent proc\n        if (useCharges && !i->aura->GetCharges())\n            continue;\n\n        bool takeCharges = false;\n        SpellInfo const* spellInfo = i->aura->GetSpellInfo();\n        uint32 Id = i->aura->GetId();\n\n        // For players set spell cooldown if need\n        uint32 cooldown = 0;\n        if (GetTypeId() == TYPEID_PLAYER && i->spellProcEvent && i->spellProcEvent->cooldown)\n            cooldown = i->spellProcEvent->cooldown;\n\n        // Note: must SetCantProc(false) before return\n        if (spellInfo->AttributesEx3 & SPELL_ATTR3_DISABLE_PROC)\n            SetCantProc(true);\n\n        // This bool is needed till separate aura effect procs are still here\n        bool handled = false;\n        if (HandleAuraProc(target, damage, i->aura, procSpell, procFlag, procExtra, cooldown, &handled))\n        {\n            sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"ProcDamageAndSpell: casting spell %u (triggered with value by %s aura of spell %u)\", spellInfo->Id, (isVictim?\"a victim's\":\"an attacker's\"), Id);\n            takeCharges = true;\n        }\n\n        if (!handled)\n        {\n            for (uint8 effIndex = 0; effIndex < MAX_SPELL_EFFECTS; ++effIndex)\n            {\n                if (!(i->effMask & (1<<effIndex)))\n                    continue;\n\n                AuraEffect* triggeredByAura = i->aura->GetEffect(effIndex);\n                ASSERT(triggeredByAura);\n\n                switch (triggeredByAura->GetAuraType())\n                {\n                    case SPELL_AURA_PROC_TRIGGER_SPELL:\n                    {\n                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"ProcDamageAndSpell: casting spell %u (triggered by %s aura of spell %u)\", spellInfo->Id, (isVictim?\"a victim's\":\"an attacker's\"), triggeredByAura->GetId());\n                        // Don`t drop charge or add cooldown for not started trigger\n                        if (HandleProcTriggerSpell(target, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))\n                            takeCharges = true;\n                        break;\n                    }\n                    case SPELL_AURA_PROC_TRIGGER_DAMAGE:\n                    {\n                        // target has to be valid\n                        if (!target)\n                            break;\n\n                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"ProcDamageAndSpell: doing %u damage from spell id %u (triggered by %s aura of spell %u)\", triggeredByAura->GetAmount(), spellInfo->Id, (isVictim?\"a victim's\":\"an attacker's\"), triggeredByAura->GetId());\n                        SpellNonMeleeDamage damageInfo(this, target, spellInfo->Id, spellInfo->SchoolMask);\n                        uint32 newDamage = SpellDamageBonusDone(target, spellInfo, triggeredByAura->GetAmount(), SPELL_DIRECT_DAMAGE);\n                        newDamage = target->SpellDamageBonusTaken(this, spellInfo, newDamage, SPELL_DIRECT_DAMAGE);\n                        CalculateSpellDamageTaken(&damageInfo, newDamage, spellInfo);\n                        DealDamageMods(damageInfo.target, damageInfo.damage, &damageInfo.absorb);\n                        SendSpellNonMeleeDamageLog(&damageInfo);\n                        DealSpellDamage(&damageInfo, true);\n                        takeCharges = true;\n                        break;\n                    }\n                    case SPELL_AURA_MANA_SHIELD:\n                    case SPELL_AURA_DUMMY:\n                    {\n                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"ProcDamageAndSpell: casting spell id %u (triggered by %s dummy aura of spell %u)\", spellInfo->Id, (isVictim?\"a victim's\":\"an attacker's\"), triggeredByAura->GetId());\n                        if (HandleDummyAuraProc(target, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))\n                            takeCharges = true;\n                        break;\n                    }\n                    case SPELL_AURA_OBS_MOD_POWER:\n                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"ProcDamageAndSpell: casting spell id %u (triggered by %s aura of spell %u)\", spellInfo->Id, (isVictim?\"a victim's\":\"an attacker's\"), triggeredByAura->GetId());\n                        if (HandleObsModEnergyAuraProc(target, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))\n                            takeCharges = true;\n                        break;\n                    case SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN:\n                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"ProcDamageAndSpell: casting spell id %u (triggered by %s aura of spell %u)\", spellInfo->Id, (isVictim?\"a victim's\":\"an attacker's\"), triggeredByAura->GetId());\n                        if (HandleModDamagePctTakenAuraProc(target, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))\n                            takeCharges = true;\n                        break;\n                    case SPELL_AURA_MOD_MELEE_HASTE:\n                    {\n                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"ProcDamageAndSpell: casting spell id %u (triggered by %s haste aura of spell %u)\", spellInfo->Id, (isVictim?\"a victim's\":\"an attacker's\"), triggeredByAura->GetId());\n                        if (HandleHasteAuraProc(target, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))\n                            takeCharges = true;\n                        break;\n                    }\n                    case SPELL_AURA_OVERRIDE_CLASS_SCRIPTS:\n                    {\n                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"ProcDamageAndSpell: casting spell id %u (triggered by %s aura of spell %u)\", spellInfo->Id, (isVictim?\"a victim's\":\"an attacker's\"), triggeredByAura->GetId());\n                        if (HandleOverrideClassScriptAuraProc(target, damage, triggeredByAura, procSpell, cooldown))\n                            takeCharges = true;\n                        break;\n                    }\n                    case SPELL_AURA_RAID_PROC_FROM_CHARGE_WITH_VALUE:\n                    {\n                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"ProcDamageAndSpell: casting mending (triggered by %s dummy aura of spell %u)\",\n                            (isVictim?\"a victim's\":\"an attacker's\"), triggeredByAura->GetId());\n\n                        HandleAuraRaidProcFromChargeWithValue(triggeredByAura);\n                        takeCharges = true;\n                        break;\n                    }\n                    case SPELL_AURA_RAID_PROC_FROM_CHARGE:\n                    {\n                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"ProcDamageAndSpell: casting mending (triggered by %s dummy aura of spell %u)\",\n                            (isVictim?\"a victim's\":\"an attacker's\"), triggeredByAura->GetId());\n\n                        HandleAuraRaidProcFromCharge(triggeredByAura);\n                        takeCharges = true;\n                        break;\n                    }\n                    case SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE:\n                    {\n                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"ProcDamageAndSpell: casting spell %u (triggered with value by %s aura of spell %u)\", spellInfo->Id, (isVictim?\"a victim's\":\"an attacker's\"), triggeredByAura->GetId());\n\n                        if (HandleProcTriggerSpell(target, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))\n                            takeCharges = true;\n                        break;\n                    }\n                    case SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK:\n                        // Skip melee hits or instant cast spells\n                        if (procSpell && procSpell->CalcCastTime() != 0)\n                            takeCharges = true;\n                        break;\n                    case SPELL_AURA_REFLECT_SPELLS_SCHOOL:\n                        // Skip Melee hits and spells ws wrong school\n                        if (procSpell && (triggeredByAura->GetMiscValue() & procSpell->SchoolMask))         // School check\n                            takeCharges = true;\n                        break;\n                    case SPELL_AURA_SPELL_MAGNET:\n                        // Skip Melee hits and targets with magnet aura\n                        if (procSpell && (triggeredByAura->GetBase()->GetUnitOwner()->ToUnit() == ToUnit()))         // Magnet\n                            takeCharges = true;\n                        break;\n                    case SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT:\n                    case SPELL_AURA_MOD_POWER_COST_SCHOOL:\n                        // Skip melee hits and spells ws wrong school or zero cost\n                        if (procSpell &&\n                            (procSpell->ManaCost != 0 || procSpell->ManaCostPercentage != 0) && // Cost check\n                            (triggeredByAura->GetMiscValue() & procSpell->SchoolMask))          // School check\n                            takeCharges = true;\n                        break;\n                    case SPELL_AURA_MECHANIC_IMMUNITY:\n                        // Compare mechanic\n                        if (procSpell && procSpell->Mechanic == uint32(triggeredByAura->GetMiscValue()))\n                            takeCharges = true;\n                        break;\n                    case SPELL_AURA_MOD_MECHANIC_RESISTANCE:\n                        // Compare mechanic\n                        if (procSpell && procSpell->Mechanic == uint32(triggeredByAura->GetMiscValue()))\n                            takeCharges = true;\n                        break;\n                    case SPELL_AURA_MOD_DAMAGE_FROM_CASTER:\n                        // Compare casters\n                        if (triggeredByAura->GetCasterGUID() == target->GetGUID())\n                            takeCharges = true;\n                        break;\n                    case SPELL_AURA_MOD_SPELL_CRIT_CHANCE:\n                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"ProcDamageAndSpell: casting spell id %u (triggered by %s spell crit chance aura of spell %u)\", spellInfo->Id, (isVictim?\"a victim's\":\"an attacker's\"), triggeredByAura->GetId());\n                        if (procSpell && HandleSpellCritChanceAuraProc(target, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))\n                            takeCharges = true;\n                        break;\n                    // CC Auras which use their amount amount to drop\n                    // Are there any more auras which need this?\n                    case SPELL_AURA_MOD_CONFUSE:\n                    case SPELL_AURA_MOD_FEAR:\n                    case SPELL_AURA_MOD_STUN:\n                    case SPELL_AURA_MOD_ROOT:\n                    case SPELL_AURA_TRANSFORM:\n                    {\n                        // chargeable mods are breaking on hit\n                        if (useCharges)\n                            takeCharges = true;\n                        else\n                        {\n                            // Spell own direct damage at apply wont break the CC\n                            if (procSpell && (procSpell->Id == triggeredByAura->GetId()))\n                            {\n                                Aura* aura = triggeredByAura->GetBase();\n                                // called from spellcast, should not have ticked yet\n                                if (aura->GetDuration() == aura->GetMaxDuration())\n                                    break;\n                            }\n                            int32 damageLeft = triggeredByAura->GetAmount();\n                            // No damage left\n                            if (damageLeft < int32(damage))\n                                i->aura->Remove();\n                            else\n                                triggeredByAura->SetAmount(damageLeft - damage);\n                        }\n                        break;\n                    }\n                    //case SPELL_AURA_ADD_FLAT_MODIFIER:\n                    //case SPELL_AURA_ADD_PCT_MODIFIER:\n                        // HandleSpellModAuraProc\n                        //break;\n                    default:\n                        // nothing do, just charges counter\n                        takeCharges = true;\n                        break;\n                } // switch (triggeredByAura->GetAuraType())\n            } // for (uint8 effIndex = 0; effIndex < MAX_SPELL_EFFECTS; ++effIndex)\n        } // if (!handled)\n\n        // Remove charge (aura can be removed by triggers)\n        if (useCharges && takeCharges)\n            i->aura->DropCharge(AURA_REMOVE_BY_EXPIRE);\n\n        if (spellInfo->AttributesEx3 & SPELL_ATTR3_DISABLE_PROC)\n            SetCantProc(false);\n    }\n\n    // Cleanup proc requirements\n    if (procExtra & (PROC_EX_INTERNAL_TRIGGERED | PROC_EX_INTERNAL_CANT_PROC))\n        SetCantProc(false);\n}\n\nvoid Unit::GetProcAurasTriggeredOnEvent(std::list<AuraApplication*>& aurasTriggeringProc, std::list<AuraApplication*>* procAuras, ProcEventInfo eventInfo)\n{\n    // use provided list of auras which can proc\n    if (procAuras)\n    {\n        for (std::list<AuraApplication*>::iterator itr = procAuras->begin(); itr!= procAuras->end(); ++itr)\n        {\n            ASSERT((*itr)->GetTarget() == this);\n            if (!(*itr)->GetRemoveMode())\n                if ((*itr)->GetBase()->IsProcTriggeredOnEvent(*itr, eventInfo))\n                {\n                    (*itr)->GetBase()->PrepareProcToTrigger();\n                    aurasTriggeringProc.push_back(*itr);\n                }\n        }\n    }\n    // or generate one on our own\n    else\n    {\n        for (AuraApplicationMap::iterator itr = GetAppliedAuras().begin(); itr!= GetAppliedAuras().end(); ++itr)\n        {\n            if (itr->second->GetBase()->IsProcTriggeredOnEvent(itr->second, eventInfo))\n            {\n                itr->second->GetBase()->PrepareProcToTrigger();\n                aurasTriggeringProc.push_back(itr->second);\n            }\n        }\n    }\n}\n\nvoid Unit::TriggerAurasProcOnEvent(CalcDamageInfo& damageInfo)\n{\n    DamageInfo dmgInfo = DamageInfo(damageInfo);\n    TriggerAurasProcOnEvent(NULL, NULL, damageInfo.target, damageInfo.procAttacker, damageInfo.procVictim, 0, 0, damageInfo.procEx, NULL, &dmgInfo, NULL);\n}\n\nvoid Unit::TriggerAurasProcOnEvent(std::list<AuraApplication*>* myProcAuras, std::list<AuraApplication*>* targetProcAuras, Unit* actionTarget, uint32 typeMaskActor, uint32 typeMaskActionTarget, uint32 spellTypeMask, uint32 spellPhaseMask, uint32 hitMask, Spell* spell, DamageInfo* damageInfo, HealInfo* healInfo)\n{\n    // prepare data for self trigger\n    ProcEventInfo myProcEventInfo = ProcEventInfo(this, actionTarget, actionTarget, typeMaskActor, spellTypeMask, spellPhaseMask, hitMask, spell, damageInfo, healInfo);\n    std::list<AuraApplication*> myAurasTriggeringProc;\n    GetProcAurasTriggeredOnEvent(myAurasTriggeringProc, myProcAuras, myProcEventInfo);\n\n    // prepare data for target trigger\n    ProcEventInfo targetProcEventInfo = ProcEventInfo(this, actionTarget, this, typeMaskActionTarget, spellTypeMask, spellPhaseMask, hitMask, spell, damageInfo, healInfo);\n    std::list<AuraApplication*> targetAurasTriggeringProc;\n    if (typeMaskActionTarget)\n        GetProcAurasTriggeredOnEvent(targetAurasTriggeringProc, targetProcAuras, targetProcEventInfo);\n\n    TriggerAurasProcOnEvent(myProcEventInfo, myAurasTriggeringProc);\n\n    if (typeMaskActionTarget)\n        TriggerAurasProcOnEvent(targetProcEventInfo, targetAurasTriggeringProc);\n}\n\nvoid Unit::TriggerAurasProcOnEvent(ProcEventInfo& eventInfo, std::list<AuraApplication*>& aurasTriggeringProc)\n{\n    for (std::list<AuraApplication*>::iterator itr = aurasTriggeringProc.begin(); itr != aurasTriggeringProc.end(); ++itr)\n    {\n        if (!(*itr)->GetRemoveMode())\n            (*itr)->GetBase()->TriggerProcOnEvent(*itr, eventInfo);\n    }\n}\n\nSpellSchoolMask Unit::GetMeleeDamageSchoolMask() const\n{\n    return SPELL_SCHOOL_MASK_NORMAL;\n}\n\nPlayer* Unit::GetSpellModOwner() const\n{\n    if (GetTypeId() == TYPEID_PLAYER)\n        return (Player*)this;\n    if (ToCreature()->isPet() || ToCreature()->isTotem())\n    {\n        Unit* owner = GetOwner();\n        if (owner && owner->GetTypeId() == TYPEID_PLAYER)\n            return (Player*)owner;\n    }\n    return NULL;\n}\n\n///----------Pet responses methods-----------------\nvoid Unit::SendPetCastFail(uint32 spellid, SpellCastResult result)\n{\n    if (result == SPELL_CAST_OK)\n        return;\n\n    Unit* owner = GetCharmerOrOwner();\n    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)\n        return;\n\n    WorldPacket data(SMSG_PET_CAST_FAILED, 1 + 4 + 1);\n    data << uint8(0);                                       // cast count\n    data << uint32(spellid);\n    data << uint8(result);\n    owner->ToPlayer()->GetSession()->SendPacket(&data);\n}\n\nvoid Unit::SendPetActionFeedback(uint8 msg)\n{\n    Unit* owner = GetOwner();\n    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)\n        return;\n\n    WorldPacket data(SMSG_PET_ACTION_FEEDBACK, 1);\n    data << uint8(msg);\n    owner->ToPlayer()->GetSession()->SendPacket(&data);\n}\n\nvoid Unit::SendPetTalk(uint32 pettalk)\n{\n    Unit* owner = GetOwner();\n    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)\n        return;\n\n    WorldPacket data(SMSG_PET_ACTION_SOUND, 8 + 4);\n    data << uint64(GetGUID());\n    data << uint32(pettalk);\n    owner->ToPlayer()->GetSession()->SendPacket(&data);\n}\n\nvoid Unit::SendPetAIReaction(uint64 guid)\n{\n    Unit* owner = GetOwner();\n    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)\n        return;\n\n    WorldPacket data(SMSG_AI_REACTION, 8 + 4);\n    data << uint64(guid);\n    data << uint32(AI_REACTION_HOSTILE);\n    owner->ToPlayer()->GetSession()->SendPacket(&data);\n}\n\n///----------End of Pet responses methods----------\n\nvoid Unit::StopMoving()\n{\n    ClearUnitState(UNIT_STATE_MOVING);\n\n    // not need send any packets if not in world\n    if (!IsInWorld())\n        return;\n\n    Movement::MoveSplineInit init(*this);\n    init.MoveTo(GetPositionX(), GetPositionY(), GetPositionZMinusOffset());\n    init.SetFacing(GetOrientation());\n    init.Launch();\n}\n\nvoid Unit::SendMovementFlagUpdate(bool self /* = false */)\n{\n    WorldPacket data;\n    BuildHeartBeatMsg(&data);\n    SendMessageToSet(&data, self);\n}\n\nbool Unit::IsSitState() const\n{\n    uint8 s = getStandState();\n    return\n        s == UNIT_STAND_STATE_SIT_CHAIR        || s == UNIT_STAND_STATE_SIT_LOW_CHAIR  ||\n        s == UNIT_STAND_STATE_SIT_MEDIUM_CHAIR || s == UNIT_STAND_STATE_SIT_HIGH_CHAIR ||\n        s == UNIT_STAND_STATE_SIT;\n}\n\nbool Unit::IsStandState() const\n{\n    uint8 s = getStandState();\n    return !IsSitState() && s != UNIT_STAND_STATE_SLEEP && s != UNIT_STAND_STATE_KNEEL;\n}\n\nvoid Unit::SetStandState(uint8 state)\n{\n    SetByteValue(UNIT_FIELD_BYTES_1, 0, state);\n\n    if (IsStandState())\n       RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_SEATED);\n\n    if (GetTypeId() == TYPEID_PLAYER)\n    {\n        WorldPacket data(SMSG_STANDSTATE_UPDATE, 1);\n        data << (uint8)state;\n        ToPlayer()->GetSession()->SendPacket(&data);\n    }\n}\n\nbool Unit::IsPolymorphed() const\n{\n    uint32 transformId = getTransForm();\n    if (!transformId)\n        return false;\n\n    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(transformId);\n    if (!spellInfo)\n        return false;\n\n    return spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_MAGE_POLYMORPH;\n}\n\nvoid Unit::SetDisplayId(uint32 modelId)\n{\n    SetUInt32Value(UNIT_FIELD_DISPLAYID, modelId);\n\n    if (GetTypeId() == TYPEID_UNIT && ToCreature()->isPet())\n    {\n        Pet* pet = ToPet();\n        if (!pet->isControlled())\n            return;\n        Unit* owner = GetOwner();\n        if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())\n            owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MODEL_ID);\n    }\n}\n\nvoid Unit::RestoreDisplayId()\n{\n    AuraEffect* handledAura = NULL;\n    // try to receive model from transform auras\n    Unit::AuraEffectList const& transforms = GetAuraEffectsByType(SPELL_AURA_TRANSFORM);\n    if (!transforms.empty())\n    {\n        // iterate over already applied transform auras - from newest to oldest\n        for (Unit::AuraEffectList::const_reverse_iterator i = transforms.rbegin(); i != transforms.rend(); ++i)\n        {\n            if (AuraApplication const* aurApp = (*i)->GetBase()->GetApplicationOfTarget(GetGUID()))\n            {\n                if (!handledAura)\n                    handledAura = (*i);\n                // prefer negative auras\n                if (!aurApp->IsPositive())\n                {\n                    handledAura = (*i);\n                    break;\n                }\n            }\n        }\n    }\n    // transform aura was found\n    if (handledAura)\n        handledAura->HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true);\n    // we've found shapeshift\n    else if (uint32 modelId = GetModelForForm(GetShapeshiftForm()))\n        SetDisplayId(modelId);\n    // no auras found - set modelid to default\n    else\n        SetDisplayId(GetNativeDisplayId());\n}\n\nvoid Unit::ClearComboPointHolders()\n{\n    while (!m_ComboPointHolders.empty())\n    {\n        uint32 lowguid = *m_ComboPointHolders.begin();\n\n        Player* player = ObjectAccessor::FindPlayer(MAKE_NEW_GUID(lowguid, 0, HIGHGUID_PLAYER));\n        if (player && player->GetComboTarget() == GetGUID())         // recheck for safe\n            player->ClearComboPoints();                        // remove also guid from m_ComboPointHolders;\n        else\n            m_ComboPointHolders.erase(lowguid);             // or remove manually\n    }\n}\n\nvoid Unit::ClearAllReactives()\n{\n    for (uint8 i = 0; i < MAX_REACTIVE; ++i)\n        m_reactiveTimer[i] = 0;\n\n    if (HasAuraState(AURA_STATE_DEFENSE))\n        ModifyAuraState(AURA_STATE_DEFENSE, false);\n    if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))\n        ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);\n    if (getClass() == CLASS_WARRIOR && GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->ClearComboPoints();\n}\n\nvoid Unit::UpdateReactives(uint32 p_time)\n{\n    for (uint8 i = 0; i < MAX_REACTIVE; ++i)\n    {\n        ReactiveType reactive = ReactiveType(i);\n\n        if (!m_reactiveTimer[reactive])\n            continue;\n\n        if (m_reactiveTimer[reactive] <= p_time)\n        {\n            m_reactiveTimer[reactive] = 0;\n\n            switch (reactive)\n            {\n                case REACTIVE_DEFENSE:\n                    if (HasAuraState(AURA_STATE_DEFENSE))\n                        ModifyAuraState(AURA_STATE_DEFENSE, false);\n                    break;\n                case REACTIVE_HUNTER_PARRY:\n                    if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))\n                        ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);\n                    break;\n                case REACTIVE_OVERPOWER:\n                    if (getClass() == CLASS_WARRIOR && GetTypeId() == TYPEID_PLAYER)\n                        ToPlayer()->ClearComboPoints();\n                    break;\n                default:\n                    break;\n            }\n        }\n        else\n        {\n            m_reactiveTimer[reactive] -= p_time;\n        }\n    }\n}\n\nUnit* Unit::SelectNearbyTarget(Unit* exclude, float dist) const\n{\n    std::list<Unit*> targets;\n    Trinity::AnyUnfriendlyUnitInObjectRangeCheck u_check(this, this, dist);\n    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(this, targets, u_check);\n    VisitNearbyObject(dist, searcher);\n\n    // remove current target\n    if (getVictim())\n        targets.remove(getVictim());\n\n    if (exclude)\n        targets.remove(exclude);\n\n    // remove not LoS targets\n    for (std::list<Unit*>::iterator tIter = targets.begin(); tIter != targets.end();)\n    {\n        if (!IsWithinLOSInMap(*tIter) || (*tIter)->isTotem() || (*tIter)->isSpiritService() || (*tIter)->GetCreatureType() == CREATURE_TYPE_CRITTER)\n            targets.erase(tIter++);\n        else\n            ++tIter;\n    }\n\n    // no appropriate targets\n    if (targets.empty())\n        return NULL;\n\n    // select random\n    return Trinity::Containers::SelectRandomContainerElement(targets);\n}\n\nvoid Unit::ApplyAttackTimePercentMod(WeaponAttackType att, float val, bool apply)\n{\n    float remainingTimePct = (float)m_attackTimer[att] / (GetAttackTime(att) * m_modAttackSpeedPct[att]);\n    if (val > 0)\n    {\n        ApplyPercentModFloatVar(m_modAttackSpeedPct[att], val, !apply);\n        ApplyPercentModFloatValue(UNIT_FIELD_BASEATTACKTIME+att, val, !apply);\n    }\n    else\n    {\n        ApplyPercentModFloatVar(m_modAttackSpeedPct[att], -val, apply);\n        ApplyPercentModFloatValue(UNIT_FIELD_BASEATTACKTIME+att, -val, apply);\n    }\n    m_attackTimer[att] = uint32(GetAttackTime(att) * m_modAttackSpeedPct[att] * remainingTimePct);\n}\n\nvoid Unit::ApplyCastTimePercentMod(float val, bool apply)\n{\n    if (val > 0)\n        ApplyPercentModFloatValue(UNIT_MOD_CAST_SPEED, val, !apply);\n    else\n        ApplyPercentModFloatValue(UNIT_MOD_CAST_SPEED, -val, apply);\n}\n\nuint32 Unit::GetCastingTimeForBonus(SpellInfo const* spellProto, DamageEffectType damagetype, uint32 CastingTime) const\n{\n    // Not apply this to creature casted spells with casttime == 0\n    if (CastingTime == 0 && GetTypeId() == TYPEID_UNIT && !ToCreature()->isPet())\n        return 3500;\n\n    if (CastingTime > 7000) CastingTime = 7000;\n    if (CastingTime < 1500) CastingTime = 1500;\n\n    if (damagetype == DOT && !spellProto->IsChanneled())\n        CastingTime = 3500;\n\n    int32 overTime    = 0;\n    uint8 effects     = 0;\n    bool DirectDamage = false;\n    bool AreaEffect   = false;\n\n    for (uint32 i = 0; i < MAX_SPELL_EFFECTS; i++)\n    {\n        switch (spellProto->Effects[i].Effect)\n        {\n            case SPELL_EFFECT_SCHOOL_DAMAGE:\n            case SPELL_EFFECT_POWER_DRAIN:\n            case SPELL_EFFECT_HEALTH_LEECH:\n            case SPELL_EFFECT_ENVIRONMENTAL_DAMAGE:\n            case SPELL_EFFECT_POWER_BURN:\n            case SPELL_EFFECT_HEAL:\n                DirectDamage = true;\n                break;\n            case SPELL_EFFECT_APPLY_AURA:\n                switch (spellProto->Effects[i].ApplyAuraName)\n                {\n                    case SPELL_AURA_PERIODIC_DAMAGE:\n                    case SPELL_AURA_PERIODIC_HEAL:\n                    case SPELL_AURA_PERIODIC_LEECH:\n                        if (spellProto->GetDuration())\n                            overTime = spellProto->GetDuration();\n                        break;\n                    default:\n                        // -5% per additional effect\n                        ++effects;\n                        break;\n                }\n            default:\n                break;\n        }\n\n        if (spellProto->Effects[i].IsTargetingArea())\n            AreaEffect = true;\n    }\n\n    // Combined Spells with Both Over Time and Direct Damage\n    if (overTime > 0 && CastingTime > 0 && DirectDamage)\n    {\n        // mainly for DoTs which are 3500 here otherwise\n        uint32 OriginalCastTime = spellProto->CalcCastTime();\n        if (OriginalCastTime > 7000) OriginalCastTime = 7000;\n        if (OriginalCastTime < 1500) OriginalCastTime = 1500;\n        // Portion to Over Time\n        float PtOT = (overTime / 15000.0f) / ((overTime / 15000.0f) + (OriginalCastTime / 3500.0f));\n\n        if (damagetype == DOT)\n            CastingTime = uint32(CastingTime * PtOT);\n        else if (PtOT < 1.0f)\n            CastingTime  = uint32(CastingTime * (1 - PtOT));\n        else\n            CastingTime = 0;\n    }\n\n    // Area Effect Spells receive only half of bonus\n    if (AreaEffect)\n        CastingTime /= 2;\n\n    // 50% for damage and healing spells for leech spells from damage bonus and 0% from healing\n    for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)\n    {\n        if (spellProto->Effects[j].Effect == SPELL_EFFECT_HEALTH_LEECH ||\n            (spellProto->Effects[j].Effect == SPELL_EFFECT_APPLY_AURA && spellProto->Effects[j].ApplyAuraName == SPELL_AURA_PERIODIC_LEECH))\n        {\n            CastingTime /= 2;\n            break;\n        }\n    }\n\n    // -5% of total per any additional effect\n    for (uint8 i = 0; i < effects; ++i)\n        CastingTime *= 0.95f;\n\n    return CastingTime;\n}\n\nvoid Unit::UpdateAuraForGroup(uint8 slot)\n{\n    if (slot >= MAX_AURAS)                        // slot not found, return\n        return;\n    if (Player* player = ToPlayer())\n    {\n        if (player->GetGroup())\n        {\n            player->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_AURAS);\n            player->SetAuraUpdateMaskForRaid(slot);\n        }\n    }\n    else if (GetTypeId() == TYPEID_UNIT && ToCreature()->isPet())\n    {\n        Pet* pet = ((Pet*)this);\n        if (pet->isControlled())\n        {\n            Unit* owner = GetOwner();\n            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())\n            {\n                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_AURAS);\n                pet->SetAuraUpdateMaskForRaid(slot);\n            }\n        }\n    }\n}\n\nfloat Unit::CalculateDefaultCoefficient(SpellInfo const *spellInfo, DamageEffectType damagetype) const\n{\n    // Damage over Time spells bonus calculation\n    float DotFactor = 1.0f;\n    if (damagetype == DOT)\n    {\n\n        int32 DotDuration = spellInfo->GetDuration();\n        if (!spellInfo->IsChanneled() && DotDuration > 0)\n            DotFactor = DotDuration / 15000.0f;\n\n        if (uint32 DotTicks = spellInfo->GetMaxTicks())\n            DotFactor /= DotTicks;\n    }\n\n    int32 CastingTime = spellInfo->IsChanneled() ? spellInfo->GetDuration() : spellInfo->CalcCastTime();\n    // Distribute Damage over multiple effects, reduce by AoE\n    CastingTime = GetCastingTimeForBonus(spellInfo, damagetype, CastingTime);\n\n    // As wowwiki says: C = (Cast Time / 3.5)\n    return (CastingTime / 3500.0f) * DotFactor;\n}\n\nfloat Unit::GetAPMultiplier(WeaponAttackType attType, bool normalized)\n{\n    if (!normalized || GetTypeId() != TYPEID_PLAYER)\n        return float(GetAttackTime(attType)) / 1000.0f;\n\n    Item* Weapon = ToPlayer()->GetWeaponForAttack(attType, true);\n    if (!Weapon)\n        return 2.4f;                                         // fist attack\n\n    switch (Weapon->GetTemplate()->InventoryType)\n    {\n        case INVTYPE_2HWEAPON:\n            return 3.3f;\n        case INVTYPE_RANGED:\n        case INVTYPE_RANGEDRIGHT:\n        case INVTYPE_THROWN:\n            return 2.8f;\n        case INVTYPE_WEAPON:\n        case INVTYPE_WEAPONMAINHAND:\n        case INVTYPE_WEAPONOFFHAND:\n        default:\n            return Weapon->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ? 1.7f : 2.4f;\n    }\n}\n\nbool Unit::IsUnderLastManaUseEffect() const\n{\n    return  getMSTimeDiff(m_lastManaUse, getMSTime()) < 5000;\n}\n\nvoid Unit::SetContestedPvP(Player* attackedPlayer)\n{\n    Player* player = GetCharmerOrOwnerPlayerOrPlayerItself();\n\n    if (!player || (attackedPlayer && (attackedPlayer == player || (player->duel && player->duel->opponent == attackedPlayer))))\n        return;\n\n    player->SetContestedPvPTimer(30000);\n    if (!player->HasUnitState(UNIT_STATE_ATTACK_PLAYER))\n    {\n        player->AddUnitState(UNIT_STATE_ATTACK_PLAYER);\n        player->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP);\n        // call MoveInLineOfSight for nearby contested guards\n        UpdateObjectVisibility();\n    }\n    if (!HasUnitState(UNIT_STATE_ATTACK_PLAYER))\n    {\n        AddUnitState(UNIT_STATE_ATTACK_PLAYER);\n        // call MoveInLineOfSight for nearby contested guards\n        UpdateObjectVisibility();\n    }\n}\n\nvoid Unit::AddPetAura(PetAura const* petSpell)\n{\n    if (GetTypeId() != TYPEID_PLAYER)\n        return;\n\n    m_petAuras.insert(petSpell);\n    if (Pet* pet = ToPlayer()->GetPet())\n        pet->CastPetAura(petSpell);\n}\n\nvoid Unit::RemovePetAura(PetAura const* petSpell)\n{\n    if (GetTypeId() != TYPEID_PLAYER)\n        return;\n\n    m_petAuras.erase(petSpell);\n    if (Pet* pet = ToPlayer()->GetPet())\n        pet->RemoveAurasDueToSpell(petSpell->GetAura(pet->GetEntry()));\n}\n\nPet* Unit::CreateTamedPetFrom(Creature* creatureTarget, uint32 spell_id)\n{\n    if (GetTypeId() != TYPEID_PLAYER)\n        return NULL;\n\n    Pet* pet = new Pet((Player*)this, HUNTER_PET);\n\n    if (!pet->CreateBaseAtCreature(creatureTarget))\n    {\n        delete pet;\n        return NULL;\n    }\n\n    uint8 level = creatureTarget->getLevel() + 5 < getLevel() ? (getLevel() - 5) : creatureTarget->getLevel();\n\n    InitTamedPet(pet, level, spell_id);\n\n    return pet;\n}\n\nPet* Unit::CreateTamedPetFrom(uint32 creatureEntry, uint32 spell_id)\n{\n    if (GetTypeId() != TYPEID_PLAYER)\n        return NULL;\n\n    CreatureTemplate const* creatureInfo = sObjectMgr->GetCreatureTemplate(creatureEntry);\n    if (!creatureInfo)\n        return NULL;\n\n    Pet* pet = new Pet((Player*)this, HUNTER_PET);\n\n    if (!pet->CreateBaseAtCreatureInfo(creatureInfo, this) || !InitTamedPet(pet, getLevel(), spell_id))\n    {\n        delete pet;\n        return NULL;\n    }\n\n    return pet;\n}\n\nbool Unit::InitTamedPet(Pet* pet, uint8 level, uint32 spell_id)\n{\n    pet->SetCreatorGUID(GetGUID());\n    pet->setFaction(getFaction());\n    pet->SetUInt32Value(UNIT_CREATED_BY_SPELL, spell_id);\n\n    if (GetTypeId() == TYPEID_PLAYER)\n        pet->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);\n\n    if (!pet->InitStatsForLevel(level))\n    {\n        sLog->outError(LOG_FILTER_UNITS, \"Pet::InitStatsForLevel() failed for creature (Entry: %u)!\", pet->GetEntry());\n        return false;\n    }\n\n    pet->GetCharmInfo()->SetPetNumber(sObjectMgr->GeneratePetNumber(), true);\n    // this enables pet details window (Shift+P)\n    pet->InitPetCreateSpells();\n    //pet->InitLevelupSpellsForLevel();\n    pet->SetFullHealth();\n    return true;\n}\n\nbool Unit::IsTriggeredAtSpellProcEvent(Unit* victim, Aura* aura, SpellInfo const* procSpell, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, bool isVictim, bool active, SpellProcEventEntry const* & spellProcEvent)\n{\n    SpellInfo const* spellProto = aura->GetSpellInfo();\n\n    // let the aura be handled by new proc system if it has new entry\n    if (sSpellMgr->GetSpellProcEntry(spellProto->Id))\n        return false;\n\n    // Get proc Event Entry\n    spellProcEvent = sSpellMgr->GetSpellProcEvent(spellProto->Id);\n\n    // Get EventProcFlag\n    uint32 EventProcFlag;\n    if (spellProcEvent && spellProcEvent->procFlags) // if exist get custom spellProcEvent->procFlags\n        EventProcFlag = spellProcEvent->procFlags;\n    else\n        EventProcFlag = spellProto->ProcFlags;       // else get from spell proto\n    // Continue if no trigger exist\n    if (!EventProcFlag)\n        return false;\n\n    // Additional checks for triggered spells (ignore trap casts)\n    if (procExtra & PROC_EX_INTERNAL_TRIGGERED && !(procFlag & PROC_FLAG_DONE_TRAP_ACTIVATION))\n    {\n        if (!(spellProto->AttributesEx3 & SPELL_ATTR3_CAN_PROC_WITH_TRIGGERED))\n            return false;\n    }\n\n    // Check spellProcEvent data requirements\n    if (!sSpellMgr->IsSpellProcEventCanTriggeredBy(spellProcEvent, EventProcFlag, procSpell, procFlag, procExtra, active))\n        return false;\n    // In most cases req get honor or XP from kill\n    if (EventProcFlag & PROC_FLAG_KILL && GetTypeId() == TYPEID_PLAYER)\n    {\n        bool allow = false;\n\n        if (victim)\n            allow = ToPlayer()->isHonorOrXPTarget(victim);\n\n        // Shadow Word: Death - can trigger from every kill\n        if (aura->GetId() == 32409)\n            allow = true;\n        if (!allow)\n            return false;\n    }\n    // Aura added by spell can`t trigger from self (prevent drop charges/do triggers)\n    // But except periodic and kill triggers (can triggered from self)\n    if (procSpell && procSpell->Id == spellProto->Id\n        && !(spellProto->ProcFlags&(PROC_FLAG_TAKEN_PERIODIC | PROC_FLAG_KILL)))\n        return false;\n\n    // Check if current equipment allows aura to proc\n    if (!isVictim && GetTypeId() == TYPEID_PLAYER)\n    {\n        Player* player = ToPlayer();\n        if (spellProto->EquippedItemClass == ITEM_CLASS_WEAPON)\n        {\n            Item* item = NULL;\n            if (attType == BASE_ATTACK)\n                item = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);\n            else if (attType == OFF_ATTACK)\n                item = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);\n            else\n                item = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED);\n\n            if (player->IsInFeralForm())\n                return false;\n\n            if (!item || item->IsBroken() || item->GetTemplate()->Class != ITEM_CLASS_WEAPON || !((1<<item->GetTemplate()->SubClass) & spellProto->EquippedItemSubClassMask))\n                return false;\n        }\n        else if (spellProto->EquippedItemClass == ITEM_CLASS_ARMOR)\n        {\n            // Check if player is wearing shield\n            Item* item = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);\n            if (!item || item->IsBroken() || item->GetTemplate()->Class != ITEM_CLASS_ARMOR || !((1<<item->GetTemplate()->SubClass) & spellProto->EquippedItemSubClassMask))\n                return false;\n        }\n    }\n    // Get chance from spell\n    float chance = float(spellProto->ProcChance);\n    // If in spellProcEvent exist custom chance, chance = spellProcEvent->customChance;\n    if (spellProcEvent && spellProcEvent->customChance)\n        chance = spellProcEvent->customChance;\n    // If PPM exist calculate chance from PPM\n    if (spellProcEvent && spellProcEvent->ppmRate != 0)\n    {\n        if (!isVictim)\n        {\n            uint32 WeaponSpeed = GetAttackTime(attType);\n            chance = GetPPMProcChance(WeaponSpeed, spellProcEvent->ppmRate, spellProto);\n        }\n        else\n        {\n            uint32 WeaponSpeed = victim->GetAttackTime(attType);\n            chance = victim->GetPPMProcChance(WeaponSpeed, spellProcEvent->ppmRate, spellProto);\n        }\n    }\n    // Apply chance modifer aura\n    if (Player* modOwner = GetSpellModOwner())\n    {\n        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CHANCE_OF_SUCCESS, chance);\n    }\n    return roll_chance_f(chance);\n}\n\nbool Unit::HandleAuraRaidProcFromChargeWithValue(AuraEffect* triggeredByAura)\n{\n    // aura can be deleted at casts\n    SpellInfo const* spellProto = triggeredByAura->GetSpellInfo();\n    int32 heal = triggeredByAura->GetAmount();\n    uint64 caster_guid = triggeredByAura->GetCasterGUID();\n\n    // Currently only Prayer of Mending\n    if (!(spellProto->SpellFamilyName == SPELLFAMILY_PRIEST && spellProto->SpellFamilyFlags[1] & 0x20))\n    {\n        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, \"Unit::HandleAuraRaidProcFromChargeWithValue, received not handled spell: %u\", spellProto->Id);\n        return false;\n    }\n\n    // jumps\n    int32 jumps = triggeredByAura->GetBase()->GetCharges()-1;\n\n    // current aura expire\n    triggeredByAura->GetBase()->SetCharges(1);             // will removed at next charges decrease\n\n    // next target selection\n    if (jumps > 0)\n    {\n        if (Unit* caster = triggeredByAura->GetCaster())\n        {\n            float radius = triggeredByAura->GetSpellInfo()->Effects[triggeredByAura->GetEffIndex()].CalcRadius(caster);\n\n            if (Unit* target = GetNextRandomRaidMemberOrPet(radius))\n            {\n                CastCustomSpell(target, spellProto->Id, &heal, NULL, NULL, true, NULL, triggeredByAura, caster_guid);\n                if (Aura* aura = target->GetAura(spellProto->Id, caster->GetGUID()))\n                    aura->SetCharges(jumps);\n            }\n        }\n    }\n\n    // heal\n    CastCustomSpell(this, 33110, &heal, NULL, NULL, true, NULL, NULL, caster_guid);\n    return true;\n\n}\nbool Unit::HandleAuraRaidProcFromCharge(AuraEffect* triggeredByAura)\n{\n    // aura can be deleted at casts\n    SpellInfo const* spellProto = triggeredByAura->GetSpellInfo();\n\n    uint32 damageSpellId;\n    switch (spellProto->Id)\n    {\n        case 57949:            // shiver\n            damageSpellId = 57952;\n            //animationSpellId = 57951; dummy effects for jump spell have unknown use (see also 41637)\n            break;\n        case 59978:            // shiver\n            damageSpellId = 59979;\n            break;\n        case 43593:            // Cold Stare\n            damageSpellId = 43594;\n            break;\n        default:\n            sLog->outError(LOG_FILTER_UNITS, \"Unit::HandleAuraRaidProcFromCharge, received unhandled spell: %u\", spellProto->Id);\n            return false;\n    }\n\n    uint64 caster_guid = triggeredByAura->GetCasterGUID();\n\n    // jumps\n    int32 jumps = triggeredByAura->GetBase()->GetCharges()-1;\n\n    // current aura expire\n    triggeredByAura->GetBase()->SetCharges(1);             // will removed at next charges decrease\n\n    // next target selection\n    if (jumps > 0)\n    {\n        if (Unit* caster = triggeredByAura->GetCaster())\n        {\n            float radius = triggeredByAura->GetSpellInfo()->Effects[triggeredByAura->GetEffIndex()].CalcRadius(caster);\n            if (Unit* target= GetNextRandomRaidMemberOrPet(radius))\n            {\n                CastSpell(target, spellProto, true, NULL, triggeredByAura, caster_guid);\n                if (Aura* aura = target->GetAura(spellProto->Id, caster->GetGUID()))\n                    aura->SetCharges(jumps);\n            }\n        }\n    }\n\n    CastSpell(this, damageSpellId, true, NULL, triggeredByAura, caster_guid);\n\n    return true;\n}\n\nvoid Unit::Kill(Unit* victim, bool durabilityLoss)\n{\n    // Prevent killing unit twice (and giving reward from kill twice)\n    if (!victim->GetHealth())\n        return;\n\n    // find player: owner of controlled `this` or `this` itself maybe\n    Player* player = GetCharmerOrOwnerPlayerOrPlayerItself();\n    Creature* creature = victim->ToCreature();\n\n    bool isRewardAllowed = true;\n    if (creature)\n    {\n        isRewardAllowed = creature->IsDamageEnoughForLootingAndReward();\n        if (!isRewardAllowed)\n            creature->SetLootRecipient(NULL);\n    }\n\n    if (isRewardAllowed && creature && creature->GetLootRecipient())\n        player = creature->GetLootRecipient();\n\n    // Reward player, his pets, and group/raid members\n    // call kill spell proc event (before real die and combat stop to triggering auras removed at death/combat stop)\n    if (isRewardAllowed && player && player != victim)\n    {\n        WorldPacket data(SMSG_PARTYKILLLOG, (8+8)); // send event PARTY_KILL\n        data << uint64(player->GetGUID()); // player with killing blow\n        data << uint64(victim->GetGUID()); // victim\n\n        Player* looter = player;\n\n        if (Group* group = player->GetGroup())\n        {\n            group->BroadcastPacket(&data, group->GetMemberGroup(player->GetGUID()));\n\n            if (creature)\n            {\n                group->UpdateLooterGuid(creature, true);\n                if (group->GetLooterGuid())\n                {\n                    looter = ObjectAccessor::FindPlayer(group->GetLooterGuid());\n                    if (looter)\n                    {\n                        creature->SetLootRecipient(looter);   // update creature loot recipient to the allowed looter.\n                        group->SendLooter(creature, looter);\n                    }\n                    else\n                        group->SendLooter(creature, NULL);\n                }\n                else\n                    group->SendLooter(creature, NULL);\n\n                group->UpdateLooterGuid(creature);\n            }\n        }\n        else\n        {\n            player->SendDirectMessage(&data);\n\n            if (creature)\n            {\n                WorldPacket data2(SMSG_LOOT_LIST, 8 + 1 + 1);\n                data2 << uint64(creature->GetGUID());\n                data2 << uint8(0); // unk1\n                data2 << uint8(0); // no group looter\n                player->SendMessageToSet(&data2, true);\n            }\n        }\n\n        if (creature)\n        {\n            Loot* loot = &creature->loot;\n            if (creature->lootForPickPocketed)\n                creature->lootForPickPocketed = false;\n\n            loot->clear();\n            if (uint32 lootid = creature->GetCreatureTemplate()->lootid)\n                loot->FillLoot(lootid, LootTemplates_Creature, looter, false, false, creature->GetLootMode());\n\n            loot->generateMoneyLoot(creature->GetCreatureTemplate()->mingold, creature->GetCreatureTemplate()->maxgold);\n        }\n\n        player->RewardPlayerAndGroupAtKill(victim, false);\n    }\n\n    // Do KILL and KILLED procs. KILL proc is called only for the unit who landed the killing blow (and its owner - for pets and totems) regardless of who tapped the victim\n    if (isPet() || isTotem())\n        if (Unit* owner = GetOwner())\n            owner->ProcDamageAndSpell(victim, PROC_FLAG_KILL, PROC_FLAG_NONE, PROC_EX_NONE, 0);\n\n    if (victim->GetCreatureType() != CREATURE_TYPE_CRITTER)\n        ProcDamageAndSpell(victim, PROC_FLAG_KILL, PROC_FLAG_KILLED, PROC_EX_NONE, 0);\n\n    // Proc auras on death - must be before aura/combat remove\n    victim->ProcDamageAndSpell(NULL, PROC_FLAG_DEATH, PROC_FLAG_NONE, PROC_EX_NONE, 0, BASE_ATTACK, 0);\n\n    // update get killing blow achievements, must be done before setDeathState to be able to require auras on target\n    // and before Spirit of Redemption as it also removes auras\n    if (player)\n        player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GET_KILLING_BLOWS, 1, 0, victim);\n\n    // if talent known but not triggered (check priest class for speedup check)\n    bool spiritOfRedemption = false;\n    if (victim->GetTypeId() == TYPEID_PLAYER && victim->getClass() == CLASS_PRIEST)\n    {\n        AuraEffectList const& dummyAuras = victim->GetAuraEffectsByType(SPELL_AURA_DUMMY);\n        for (AuraEffectList::const_iterator itr = dummyAuras.begin(); itr != dummyAuras.end(); ++itr)\n        {\n            if ((*itr)->GetSpellInfo()->SpellIconID == 1654)\n            {\n                AuraEffect const* aurEff = *itr;\n                // save value before aura remove\n                uint32 ressSpellId = victim->GetUInt32Value(PLAYER_SELF_RES_SPELL);\n                if (!ressSpellId)\n                    ressSpellId = victim->ToPlayer()->GetResurrectionSpellId();\n                // Remove all expected to remove at death auras (most important negative case like DoT or periodic triggers)\n                victim->RemoveAllAurasOnDeath();\n                // restore for use at real death\n                victim->SetUInt32Value(PLAYER_SELF_RES_SPELL, ressSpellId);\n\n                // FORM_SPIRITOFREDEMPTION and related auras\n                victim->CastSpell(victim, 27827, true, NULL, aurEff);\n                spiritOfRedemption = true;\n                break;\n            }\n        }\n    }\n\n    if (!spiritOfRedemption)\n    {\n        sLog->outDebug(LOG_FILTER_UNITS, \"SET JUST_DIED\");\n        victim->setDeathState(JUST_DIED);\n    }\n\n    // Inform pets (if any) when player kills target)\n    // MUST come after victim->setDeathState(JUST_DIED); or pet next target\n    // selection will get stuck on same target and break pet react state\n    if (player)\n    {\n        Pet* pet = player->GetPet();\n        if (pet && pet->isAlive() && pet->isControlled())\n            pet->AI()->KilledUnit(victim);\n    }\n\n    // 10% durability loss on death\n    // clean InHateListOf\n    if (Player* plrVictim = victim->ToPlayer())\n    {\n        // remember victim PvP death for corpse type and corpse reclaim delay\n        // at original death (not at SpiritOfRedemtionTalent timeout)\n        plrVictim->SetPvPDeath(player != NULL);\n\n        // only if not player and not controlled by player pet. And not at BG\n        if ((durabilityLoss && !player && !victim->ToPlayer()->InBattleground()) || (player && sWorld->getBoolConfig(CONFIG_DURABILITY_LOSS_IN_PVP)))\n        {\n            sLog->outDebug(LOG_FILTER_UNITS, \"We are dead, losing %f percent durability\", sWorld->getRate(RATE_DURABILITY_LOSS_ON_DEATH));\n            plrVictim->DurabilityLossAll(sWorld->getRate(RATE_DURABILITY_LOSS_ON_DEATH), false);\n            // durability lost message\n            WorldPacket data(SMSG_DURABILITY_DAMAGE_DEATH, 0);\n            plrVictim->GetSession()->SendPacket(&data);\n        }\n        // Call KilledUnit for creatures\n        if (GetTypeId() == TYPEID_UNIT && IsAIEnabled)\n            ToCreature()->AI()->KilledUnit(victim);\n\n        // last damage from non duel opponent or opponent controlled creature\n        if (plrVictim->duel)\n        {\n            plrVictim->duel->opponent->CombatStopWithPets(true);\n            plrVictim->CombatStopWithPets(true);\n            plrVictim->DuelComplete(DUEL_INTERRUPTED);\n        }\n    }\n    else                                                // creature died\n    {\n        sLog->outDebug(LOG_FILTER_UNITS, \"DealDamageNotPlayer\");\n\n        if (!creature->isPet())\n        {\n            creature->DeleteThreatList();\n            CreatureTemplate const* cInfo = creature->GetCreatureTemplate();\n            if (cInfo && (cInfo->lootid || cInfo->maxgold > 0))\n                creature->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);\n        }\n\n        // Call KilledUnit for creatures, this needs to be called after the lootable flag is set\n        if (GetTypeId() == TYPEID_UNIT && IsAIEnabled)\n            ToCreature()->AI()->KilledUnit(victim);\n\n        // Call creature just died function\n        if (creature->IsAIEnabled)\n            creature->AI()->JustDied(this);\n\n        if (TempSummon* summon = creature->ToTempSummon())\n            if (Unit* summoner = summon->GetSummoner())\n                if (summoner->ToCreature() && summoner->IsAIEnabled)\n                    summoner->ToCreature()->AI()->SummonedCreatureDies(creature, this);\n\n        // Dungeon specific stuff, only applies to players killing creatures\n        if (creature->GetInstanceId())\n        {\n            Map* instanceMap = creature->GetMap();\n            Player* creditedPlayer = GetCharmerOrOwnerPlayerOrPlayerItself();\n            // TODO: do instance binding anyway if the charmer/owner is offline\n\n            if (instanceMap->IsDungeon() && creditedPlayer)\n            {\n                if (instanceMap->IsRaidOrHeroicDungeon())\n                {\n                    if (creature->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_INSTANCE_BIND)\n                        ((InstanceMap*)instanceMap)->PermBindAllPlayers(creditedPlayer);\n                }\n                else\n                {\n                    // the reset time is set but not added to the scheduler\n                    // until the players leave the instance\n                    time_t resettime = creature->GetRespawnTimeEx() + 2 * HOUR;\n                    if (InstanceSave* save = sInstanceSaveMgr->GetInstanceSave(creature->GetInstanceId()))\n                        if (save->GetResetTime() < resettime) save->SetResetTime(resettime);\n                }\n            }\n        }\n    }\n\n    // outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...\n    // handle player kill only if not suicide (spirit of redemption for example)\n    if (player && this != victim)\n    {\n        if (OutdoorPvP* pvp = player->GetOutdoorPvP())\n            pvp->HandleKill(player, victim);\n\n        if (Battlefield* bf = sBattlefieldMgr->GetBattlefieldToZoneId(player->GetZoneId()))\n            bf->HandleKill(player, victim);\n    }\n\n    //if (victim->GetTypeId() == TYPEID_PLAYER)\n    //    if (OutdoorPvP* pvp = victim->ToPlayer()->GetOutdoorPvP())\n    //        pvp->HandlePlayerActivityChangedpVictim->ToPlayer();\n\n    // battleground things (do this at the end, so the death state flag will be properly set to handle in the bg->handlekill)\n    if (player && player->InBattleground())\n    {\n        if (Battleground* bg = player->GetBattleground())\n        {\n            if (victim->GetTypeId() == TYPEID_PLAYER)\n                bg->HandleKillPlayer((Player*)victim, player);\n            else\n                bg->HandleKillUnit(victim->ToCreature(), player);\n        }\n    }\n\n    // achievement stuff\n    if (victim->GetTypeId() == TYPEID_PLAYER)\n    {\n        if (GetTypeId() == TYPEID_UNIT)\n            victim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILLED_BY_CREATURE, GetEntry());\n        else if (GetTypeId() == TYPEID_PLAYER && victim != this)\n            victim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILLED_BY_PLAYER, 1, ToPlayer()->GetTeam());\n    }\n\n    // Hook for OnPVPKill Event\n    if (Player* killerPlr = ToPlayer())\n    {\n        if (Player* killedPlr = victim->ToPlayer())\n            sScriptMgr->OnPVPKill(killerPlr, killedPlr);\n        else if (Creature* killedCre = victim->ToCreature())\n            sScriptMgr->OnCreatureKill(killerPlr, killedCre);\n    }\n    else if (Creature* killerCre = ToCreature())\n    {\n        if (Player* killed = victim->ToPlayer())\n            sScriptMgr->OnPlayerKilledByCreature(killerCre, killed);\n    }\n}\n\nvoid Unit::SetControlled(bool apply, UnitState state)\n{\n    if (apply)\n    {\n        if (HasUnitState(state))\n            return;\n\n        AddUnitState(state);\n        switch (state)\n        {\n            case UNIT_STATE_STUNNED:\n                SetStunned(true);\n                CastStop();\n                break;\n            case UNIT_STATE_ROOT:\n                if (!HasUnitState(UNIT_STATE_STUNNED))\n                    SetRooted(true);\n                break;\n            case UNIT_STATE_CONFUSED:\n                if (!HasUnitState(UNIT_STATE_STUNNED))\n                {\n                    ClearUnitState(UNIT_STATE_MELEE_ATTACKING);\n                    SendMeleeAttackStop();\n                    // SendAutoRepeatCancel ?\n                    SetConfused(true);\n                    CastStop();\n                }\n                break;\n            case UNIT_STATE_FLEEING:\n                if (!HasUnitState(UNIT_STATE_STUNNED | UNIT_STATE_CONFUSED))\n                {\n                    ClearUnitState(UNIT_STATE_MELEE_ATTACKING);\n                    SendMeleeAttackStop();\n                    // SendAutoRepeatCancel ?\n                    SetFeared(true);\n                    CastStop();\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    else\n    {\n        switch (state)\n        {\n            case UNIT_STATE_STUNNED: if (HasAuraType(SPELL_AURA_MOD_STUN))    return;\n                                    else    SetStunned(false);    break;\n            case UNIT_STATE_ROOT:    if (HasAuraType(SPELL_AURA_MOD_ROOT) || GetVehicle())    return;\n                                    else    SetRooted(false);     break;\n            case UNIT_STATE_CONFUSED:if (HasAuraType(SPELL_AURA_MOD_CONFUSE)) return;\n                                    else    SetConfused(false);   break;\n            case UNIT_STATE_FLEEING: if (HasAuraType(SPELL_AURA_MOD_FEAR))    return;\n                                    else    SetFeared(false);     break;\n            default: return;\n        }\n\n        ClearUnitState(state);\n\n        if (HasUnitState(UNIT_STATE_STUNNED))\n            SetStunned(true);\n        else\n        {\n            if (HasUnitState(UNIT_STATE_ROOT))\n                SetRooted(true);\n\n            if (HasUnitState(UNIT_STATE_CONFUSED))\n                SetConfused(true);\n            else if (HasUnitState(UNIT_STATE_FLEEING))\n                SetFeared(true);\n        }\n    }\n}\n\nvoid Unit::SetStunned(bool apply)\n{\n    if (apply)\n    {\n        SetTarget(0);\n        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);\n\n        // MOVEMENTFLAG_ROOT cannot be used in conjunction with MOVEMENTFLAG_MASK_MOVING (tested 3.3.5a)\n        // this will freeze clients. That's why we remove MOVEMENTFLAG_MASK_MOVING before\n        // setting MOVEMENTFLAG_ROOT\n        RemoveUnitMovementFlag(MOVEMENTFLAG_MASK_MOVING);\n        AddUnitMovementFlag(MOVEMENTFLAG_ROOT);\n\n        // Creature specific\n        if (GetTypeId() != TYPEID_PLAYER)\n            ToCreature()->StopMoving();\n        else\n            SetStandState(UNIT_STAND_STATE_STAND);\n\n        WorldPacket data(SMSG_FORCE_MOVE_ROOT, 8);\n        data.append(GetPackGUID());\n        data << uint32(0);\n        SendMessageToSet(&data, true);\n\n        CastStop();\n    }\n    else\n    {\n        if (isAlive() && getVictim())\n            SetTarget(getVictim()->GetGUID());\n\n        // don't remove UNIT_FLAG_STUNNED for pet when owner is mounted (disabled pet's interface)\n        Unit* owner = GetOwner();\n        if (!owner || (owner->GetTypeId() == TYPEID_PLAYER && !owner->ToPlayer()->IsMounted()))\n            RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);\n\n        if (!HasUnitState(UNIT_STATE_ROOT))         // prevent moving if it also has root effect\n        {\n            WorldPacket data(SMSG_FORCE_MOVE_UNROOT, 8+4);\n            data.append(GetPackGUID());\n            data << uint32(0);\n            SendMessageToSet(&data, true);\n\n            RemoveUnitMovementFlag(MOVEMENTFLAG_ROOT);\n        }\n    }\n}\n\nvoid Unit::SetRooted(bool apply)\n{\n    if (apply)\n    {\n        if (m_rootTimes > 0) // blizzard internal check?\n            m_rootTimes++;\n\n        // MOVEMENTFLAG_ROOT cannot be used in conjunction with MOVEMENTFLAG_MASK_MOVING (tested 3.3.5a)\n        // this will freeze clients. That's why we remove MOVEMENTFLAG_MASK_MOVING before\n        // setting MOVEMENTFLAG_ROOT\n        RemoveUnitMovementFlag(MOVEMENTFLAG_MASK_MOVING);\n        AddUnitMovementFlag(MOVEMENTFLAG_ROOT);\n\n        if (GetTypeId() == TYPEID_PLAYER)\n        {\n            WorldPacket data(SMSG_FORCE_MOVE_ROOT, 10);\n            data.append(GetPackGUID());\n            data << m_rootTimes;\n            SendMessageToSet(&data, true);\n        }\n        else\n        {\n            WorldPacket data(SMSG_SPLINE_MOVE_ROOT, 8);\n            data.append(GetPackGUID());\n            SendMessageToSet(&data, true);\n            ToCreature()->StopMoving();\n        }\n    }\n    else\n    {\n        if (!HasUnitState(UNIT_STATE_STUNNED))      // prevent moving if it also has stun effect\n        {\n            if (GetTypeId() == TYPEID_PLAYER)\n            {\n                WorldPacket data(SMSG_FORCE_MOVE_UNROOT, 10);\n                data.append(GetPackGUID());\n                data << ++m_rootTimes;\n                SendMessageToSet(&data, true);\n            }\n            else\n            {\n                WorldPacket data(SMSG_SPLINE_MOVE_UNROOT, 8);\n                data.append(GetPackGUID());\n                SendMessageToSet(&data, true);\n            }\n\n            RemoveUnitMovementFlag(MOVEMENTFLAG_ROOT);\n        }\n    }\n}\n\nvoid Unit::SetFeared(bool apply)\n{\n    if (apply)\n    {\n        SetTarget(0);\n\n        Unit* caster = NULL;\n        Unit::AuraEffectList const& fearAuras = GetAuraEffectsByType(SPELL_AURA_MOD_FEAR);\n        if (!fearAuras.empty())\n            caster = ObjectAccessor::GetUnit(*this, fearAuras.front()->GetCasterGUID());\n        if (!caster)\n            caster = getAttackerForHelper();\n        GetMotionMaster()->MoveFleeing(caster, fearAuras.empty() ? sWorld->getIntConfig(CONFIG_CREATURE_FAMILY_FLEE_DELAY) : 0);             // caster == NULL processed in MoveFleeing\n    }\n    else\n    {\n        if (isAlive())\n        {\n            if (GetMotionMaster()->GetCurrentMovementGeneratorType() == FLEEING_MOTION_TYPE)\n                GetMotionMaster()->MovementExpired();\n            if (getVictim())\n                SetTarget(getVictim()->GetGUID());\n        }\n    }\n\n    if (GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->SetClientControl(this, !apply);\n}\n\nvoid Unit::SetConfused(bool apply)\n{\n    if (apply)\n    {\n        SetTarget(0);\n        GetMotionMaster()->MoveConfused();\n    }\n    else\n    {\n        if (isAlive())\n        {\n            if (GetMotionMaster()->GetCurrentMovementGeneratorType() == CONFUSED_MOTION_TYPE)\n                GetMotionMaster()->MovementExpired();\n            if (getVictim())\n                SetTarget(getVictim()->GetGUID());\n        }\n    }\n\n    if (GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->SetClientControl(this, !apply);\n}\n\nbool Unit::SetCharmedBy(Unit* charmer, CharmType type, AuraApplication const* aurApp)\n{\n    if (!charmer)\n        return false;\n\n    // dismount players when charmed\n    if (GetTypeId() == TYPEID_PLAYER)\n        Dismount();\n\n    ASSERT(type != CHARM_TYPE_POSSESS || charmer->GetTypeId() == TYPEID_PLAYER);\n    ASSERT((type == CHARM_TYPE_VEHICLE) == IsVehicle());\n\n    sLog->outDebug(LOG_FILTER_UNITS, \"SetCharmedBy: charmer %u (GUID %u), charmed %u (GUID %u), type %u.\", charmer->GetEntry(), charmer->GetGUIDLow(), GetEntry(), GetGUIDLow(), uint32(type));\n\n    if (this == charmer)\n    {\n        sLog->outFatal(LOG_FILTER_UNITS, \"Unit::SetCharmedBy: Unit %u (GUID %u) is trying to charm itself!\", GetEntry(), GetGUIDLow());\n        return false;\n    }\n\n    //if (HasUnitState(UNIT_STATE_UNATTACKABLE))\n    //    return false;\n\n    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->GetTransport())\n    {\n        sLog->outFatal(LOG_FILTER_UNITS, \"Unit::SetCharmedBy: Player on transport is trying to charm %u (GUID %u)\", GetEntry(), GetGUIDLow());\n        return false;\n    }\n\n    // Already charmed\n    if (GetCharmerGUID())\n    {\n        sLog->outFatal(LOG_FILTER_UNITS, \"Unit::SetCharmedBy: %u (GUID %u) has already been charmed but %u (GUID %u) is trying to charm it!\", GetEntry(), GetGUIDLow(), charmer->GetEntry(), charmer->GetGUIDLow());\n        return false;\n    }\n\n    CastStop();\n    CombatStop(); // TODO: CombatStop(true) may cause crash (interrupt spells)\n    DeleteThreatList();\n\n    // Charmer stop charming\n    if (charmer->GetTypeId() == TYPEID_PLAYER)\n    {\n        charmer->ToPlayer()->StopCastingCharm();\n        charmer->ToPlayer()->StopCastingBindSight();\n    }\n\n    // Charmed stop charming\n    if (GetTypeId() == TYPEID_PLAYER)\n    {\n        ToPlayer()->StopCastingCharm();\n        ToPlayer()->StopCastingBindSight();\n    }\n\n    // StopCastingCharm may remove a possessed pet?\n    if (!IsInWorld())\n    {\n        sLog->outFatal(LOG_FILTER_UNITS, \"Unit::SetCharmedBy: %u (GUID %u) is not in world but %u (GUID %u) is trying to charm it!\", GetEntry(), GetGUIDLow(), charmer->GetEntry(), charmer->GetGUIDLow());\n        return false;\n    }\n\n    // charm is set by aura, and aura effect remove handler was called during apply handler execution\n    // prevent undefined behaviour\n    if (aurApp && aurApp->GetRemoveMode())\n        return false;\n\n    // Set charmed\n    Map* map = GetMap();\n    if (!IsVehicle() || (IsVehicle() && map && !map->IsBattleground()))\n        setFaction(charmer->getFaction());\n\n    charmer->SetCharm(this, true);\n\n    if (GetTypeId() == TYPEID_UNIT)\n    {\n        ToCreature()->AI()->OnCharmed(true);\n        GetMotionMaster()->MoveIdle();\n    }\n    else\n    {\n        Player* player = ToPlayer();\n        if (player->isAFK())\n            player->ToggleAFK();\n        player->SetClientControl(this, 0);\n    }\n\n    // charm is set by aura, and aura effect remove handler was called during apply handler execution\n    // prevent undefined behaviour\n    if (aurApp && aurApp->GetRemoveMode())\n        return false;\n\n    // Pets already have a properly initialized CharmInfo, don't overwrite it.\n    if (type != CHARM_TYPE_VEHICLE && !GetCharmInfo())\n    {\n        InitCharmInfo();\n        if (type == CHARM_TYPE_POSSESS)\n            GetCharmInfo()->InitPossessCreateSpells();\n        else\n            GetCharmInfo()->InitCharmCreateSpells();\n    }\n\n    if (charmer->GetTypeId() == TYPEID_PLAYER)\n    {\n        switch (type)\n        {\n            case CHARM_TYPE_VEHICLE:\n                SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);\n                charmer->ToPlayer()->SetClientControl(this, 1);\n                charmer->ToPlayer()->SetMover(this);\n                charmer->ToPlayer()->SetViewpoint(this, true);\n                charmer->ToPlayer()->VehicleSpellInitialize();\n                break;\n            case CHARM_TYPE_POSSESS:\n                AddUnitState(UNIT_STATE_POSSESSED);\n                SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);\n                charmer->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);\n                charmer->ToPlayer()->SetClientControl(this, 1);\n                charmer->ToPlayer()->SetMover(this);\n                charmer->ToPlayer()->SetViewpoint(this, true);\n                charmer->ToPlayer()->PossessSpellInitialize();\n                break;\n            case CHARM_TYPE_CHARM:\n                if (GetTypeId() == TYPEID_UNIT && charmer->getClass() == CLASS_WARLOCK)\n                {\n                    CreatureTemplate const* cinfo = ToCreature()->GetCreatureTemplate();\n                    if (cinfo && cinfo->type == CREATURE_TYPE_DEMON)\n                    {\n                        // to prevent client crash\n                        SetByteValue(UNIT_FIELD_BYTES_0, 1, (uint8)CLASS_MAGE);\n\n                        // just to enable stat window\n                        if (GetCharmInfo())\n                            GetCharmInfo()->SetPetNumber(sObjectMgr->GeneratePetNumber(), true);\n\n                        // if charmed two demons the same session, the 2nd gets the 1st one's name\n                        SetUInt32Value(UNIT_FIELD_PET_NAME_TIMESTAMP, uint32(time(NULL))); // cast can't be helped\n                    }\n                }\n                charmer->ToPlayer()->CharmSpellInitialize();\n                break;\n            default:\n            case CHARM_TYPE_CONVERT:\n                break;\n        }\n    }\n    return true;\n}\n\nvoid Unit::RemoveCharmedBy(Unit* charmer)\n{\n    if (!isCharmed())\n        return;\n\n    if (!charmer)\n        charmer = GetCharmer();\n    if (charmer != GetCharmer()) // one aura overrides another?\n    {\n//        sLog->outFatal(LOG_FILTER_UNITS, \"Unit::RemoveCharmedBy: this: \" UI64FMTD \" true charmer: \" UI64FMTD \" false charmer: \" UI64FMTD,\n//            GetGUID(), GetCharmerGUID(), charmer->GetGUID());\n//        ASSERT(false);\n        return;\n    }\n\n    CharmType type;\n    if (HasUnitState(UNIT_STATE_POSSESSED))\n        type = CHARM_TYPE_POSSESS;\n    else if (charmer && charmer->IsOnVehicle(this))\n        type = CHARM_TYPE_VEHICLE;\n    else\n        type = CHARM_TYPE_CHARM;\n\n    CastStop();\n    CombatStop(); // TODO: CombatStop(true) may cause crash (interrupt spells)\n    getHostileRefManager().deleteReferences();\n    DeleteThreatList();\n    Map* map = GetMap();\n    if (!IsVehicle() || (IsVehicle() && map && !map->IsBattleground()))\n        RestoreFaction();\n    GetMotionMaster()->InitDefault();\n\n    if (type == CHARM_TYPE_POSSESS)\n    {\n        ClearUnitState(UNIT_STATE_POSSESSED);\n        RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);\n    }\n\n    if (Creature* creature = ToCreature())\n    {\n        if (creature->AI())\n            creature->AI()->OnCharmed(false);\n\n        if (type != CHARM_TYPE_VEHICLE) // Vehicles' AI is never modified\n        {\n            creature->AIM_Initialize();\n\n            if (creature->AI() && charmer && charmer->isAlive())\n                creature->AI()->AttackStart(charmer);\n        }\n    }\n    else\n        ToPlayer()->SetClientControl(this, 1);\n\n    // If charmer still exists\n    if (!charmer)\n        return;\n\n    ASSERT(type != CHARM_TYPE_POSSESS || charmer->GetTypeId() == TYPEID_PLAYER);\n    ASSERT(type != CHARM_TYPE_VEHICLE || (GetTypeId() == TYPEID_UNIT && IsVehicle()));\n\n    charmer->SetCharm(this, false);\n\n    if (charmer->GetTypeId() == TYPEID_PLAYER)\n    {\n        switch (type)\n        {\n            case CHARM_TYPE_VEHICLE:\n                charmer->ToPlayer()->SetClientControl(charmer, 1);\n                charmer->ToPlayer()->SetViewpoint(this, false);\n                charmer->ToPlayer()->SetClientControl(this, 0);\n                if (GetTypeId() == TYPEID_PLAYER)\n                    ToPlayer()->SetMover(this);\n                break;\n            case CHARM_TYPE_POSSESS:\n                charmer->ToPlayer()->SetClientControl(charmer, 1);\n                charmer->ToPlayer()->SetViewpoint(this, false);\n                charmer->ToPlayer()->SetClientControl(this, 0);\n                charmer->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);\n                if (GetTypeId() == TYPEID_PLAYER)\n                    ToPlayer()->SetMover(this);\n                break;\n            case CHARM_TYPE_CHARM:\n                if (GetTypeId() == TYPEID_UNIT && charmer->getClass() == CLASS_WARLOCK)\n                {\n                    CreatureTemplate const* cinfo = ToCreature()->GetCreatureTemplate();\n                    if (cinfo && cinfo->type == CREATURE_TYPE_DEMON)\n                    {\n                        SetByteValue(UNIT_FIELD_BYTES_0, 1, uint8(cinfo->unit_class));\n                        if (GetCharmInfo())\n                            GetCharmInfo()->SetPetNumber(0, true);\n                        else\n                            sLog->outError(LOG_FILTER_UNITS, \"Aura::HandleModCharm: target=\"UI64FMTD\" with typeid=%d has a charm aura but no charm info!\", GetGUID(), GetTypeId());\n                    }\n                }\n                break;\n            default:\n            case CHARM_TYPE_CONVERT:\n                break;\n        }\n    }\n\n    // a guardian should always have charminfo\n    if (charmer->GetTypeId() == TYPEID_PLAYER && this != charmer->GetFirstControlled())\n        charmer->ToPlayer()->SendRemoveControlBar();\n    else if (GetTypeId() == TYPEID_PLAYER || (GetTypeId() == TYPEID_UNIT && !ToCreature()->isGuardian()))\n        DeleteCharmInfo();\n}\n\nvoid Unit::RestoreFaction()\n{\n    if (GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->setFactionForRace(getRace());\n    else\n    {\n        if (HasUnitTypeMask(UNIT_MASK_MINION))\n        {\n            if (Unit* owner = GetOwner())\n            {\n                setFaction(owner->getFaction());\n                return;\n            }\n        }\n\n        if (CreatureTemplate const* cinfo = ToCreature()->GetCreatureTemplate())  // normal creature\n        {\n            FactionTemplateEntry const* faction = getFactionTemplateEntry();\n            setFaction((faction && faction->friendlyMask & 0x004) ? cinfo->faction_H : cinfo->faction_A);\n        }\n    }\n}\n\nbool Unit::CreateVehicleKit(uint32 id, uint32 creatureEntry)\n{\n    VehicleEntry const* vehInfo = sVehicleStore.LookupEntry(id);\n    if (!vehInfo)\n        return false;\n\n    m_vehicleKit = new Vehicle(this, vehInfo, creatureEntry);\n    m_updateFlag |= UPDATEFLAG_VEHICLE;\n    m_unitTypeMask |= UNIT_MASK_VEHICLE;\n    return true;\n}\n\nvoid Unit::RemoveVehicleKit()\n{\n    if (!m_vehicleKit)\n        return;\n\n    m_vehicleKit->Uninstall();\n    delete m_vehicleKit;\n\n    m_vehicleKit = NULL;\n\n    m_updateFlag &= ~UPDATEFLAG_VEHICLE;\n    m_unitTypeMask &= ~UNIT_MASK_VEHICLE;\n    RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK);\n    RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_PLAYER_VEHICLE);\n}\n\nUnit* Unit::GetVehicleBase() const\n{\n    return m_vehicle ? m_vehicle->GetBase() : NULL;\n}\n\nCreature* Unit::GetVehicleCreatureBase() const\n{\n    if (Unit* veh = GetVehicleBase())\n        if (Creature* c = veh->ToCreature())\n            return c;\n\n    return NULL;\n}\n\nuint64 Unit::GetTransGUID() const\n{\n    if (GetVehicle())\n        return GetVehicleBase()->GetGUID();\n    if (GetTransport())\n        return GetTransport()->GetGUID();\n\n    return 0;\n}\n\nTransportBase* Unit::GetDirectTransport() const\n{\n    if (Vehicle* veh = GetVehicle())\n        return veh;\n    return GetTransport();\n}\n\nbool Unit::IsInPartyWith(Unit const* unit) const\n{\n    if (this == unit)\n        return true;\n\n    const Unit* u1 = GetCharmerOrOwnerOrSelf();\n    const Unit* u2 = unit->GetCharmerOrOwnerOrSelf();\n    if (u1 == u2)\n        return true;\n\n    if (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_PLAYER)\n        return u1->ToPlayer()->IsInSameGroupWith(u2->ToPlayer());\n    else if ((u2->GetTypeId() == TYPEID_PLAYER && u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER) ||\n        (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER))\n        return true;\n    else\n        return false;\n}\n\nbool Unit::IsInRaidWith(Unit const* unit) const\n{\n    if (this == unit)\n        return true;\n\n    const Unit* u1 = GetCharmerOrOwnerOrSelf();\n    const Unit* u2 = unit->GetCharmerOrOwnerOrSelf();\n    if (u1 == u2)\n        return true;\n\n    if (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_PLAYER)\n        return u1->ToPlayer()->IsInSameRaidWith(u2->ToPlayer());\n    else if ((u2->GetTypeId() == TYPEID_PLAYER && u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER) ||\n            (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER))\n        return true;\n    else\n        return false;\n}\n\nvoid Unit::GetPartyMembers(std::list<Unit*> &TagUnitMap)\n{\n    Unit* owner = GetCharmerOrOwnerOrSelf();\n    Group* group = NULL;\n    if (owner->GetTypeId() == TYPEID_PLAYER)\n        group = owner->ToPlayer()->GetGroup();\n\n    if (group)\n    {\n        uint8 subgroup = owner->ToPlayer()->GetSubGroup();\n\n        for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())\n        {\n            Player* Target = itr->getSource();\n\n            // IsHostileTo check duel and controlled by enemy\n            if (Target && Target->GetSubGroup() == subgroup && !IsHostileTo(Target))\n            {\n                if (Target->isAlive() && IsInMap(Target))\n                    TagUnitMap.push_back(Target);\n\n                if (Guardian* pet = Target->GetGuardianPet())\n                    if (pet->isAlive() && IsInMap(Target))\n                        TagUnitMap.push_back(pet);\n            }\n        }\n    }\n    else\n    {\n        if (owner->isAlive() && (owner == this || IsInMap(owner)))\n            TagUnitMap.push_back(owner);\n        if (Guardian* pet = owner->GetGuardianPet())\n            if (pet->isAlive() && (pet == this || IsInMap(pet)))\n                TagUnitMap.push_back(pet);\n    }\n}\n\nAura* Unit::AddAura(uint32 spellId, Unit* target)\n{\n    if (!target)\n        return NULL;\n\n    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);\n    if (!spellInfo)\n        return NULL;\n\n    if (!target->isAlive() && !(spellInfo->Attributes & SPELL_ATTR0_PASSIVE) && !(spellInfo->AttributesEx2 & SPELL_ATTR2_CAN_TARGET_DEAD))\n        return NULL;\n\n    return AddAura(spellInfo, MAX_EFFECT_MASK, target);\n}\n\nAura* Unit::AddAura(SpellInfo const* spellInfo, uint8 effMask, Unit* target)\n{\n    if (!spellInfo)\n        return NULL;\n\n    if (target->IsImmunedToSpell(spellInfo))\n        return NULL;\n\n    for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)\n    {\n        if (!(effMask & (1<<i)))\n            continue;\n        if (target->IsImmunedToSpellEffect(spellInfo, i))\n            effMask &= ~(1<<i);\n    }\n\n    if (Aura* aura = Aura::TryRefreshStackOrCreate(spellInfo, effMask, target, this))\n    {\n        aura->ApplyForTargets();\n        return aura;\n    }\n    return NULL;\n}\n\nvoid Unit::SetAuraStack(uint32 spellId, Unit* target, uint32 stack)\n{\n    Aura* aura = target->GetAura(spellId, GetGUID());\n    if (!aura)\n        aura = AddAura(spellId, target);\n    if (aura && stack)\n        aura->SetStackAmount(stack);\n}\n\nvoid Unit::SendPlaySpellVisual(uint32 id)\n{\n    WorldPacket data(SMSG_PLAY_SPELL_VISUAL, 8 + 4);\n    data << uint64(GetGUID());\n    data << uint32(id); // SpellVisualKit.dbc index\n    SendMessageToSet(&data, false);\n}\n\nvoid Unit::SendPlaySpellImpact(uint64 guid, uint32 id)\n{\n    WorldPacket data(SMSG_PLAY_SPELL_IMPACT, 8 + 4);\n    data << uint64(guid); // target\n    data << uint32(id); // SpellVisualKit.dbc index\n    SendMessageToSet(&data, false);\n}\n\nvoid Unit::ApplyResilience(Unit const* victim, float* crit, int32* damage, bool isCrit, CombatRating type) const\n{\n    // player mounted on multi-passenger mount is also classified as vehicle\n    if (IsVehicle() || (victim->IsVehicle() && victim->GetTypeId() != TYPEID_PLAYER))\n        return;\n\n    Unit const* source = NULL;\n    if (GetTypeId() == TYPEID_PLAYER)\n        source = this;\n    else if (GetTypeId() == TYPEID_UNIT && GetOwner() && GetOwner()->GetTypeId() == TYPEID_PLAYER)\n        source = GetOwner();\n\n    Unit const* target = NULL;\n    if (victim->GetTypeId() == TYPEID_PLAYER)\n        target = victim;\n    else if (victim->GetTypeId() == TYPEID_UNIT && victim->GetOwner() && victim->GetOwner()->GetTypeId() == TYPEID_PLAYER)\n        target = victim->GetOwner();\n\n    if (!target)\n        return;\n\n    switch (type)\n    {\n        case CR_CRIT_TAKEN_MELEE:\n            // Crit chance reduction works against nonpets\n            if (crit)\n                *crit -= target->GetMeleeCritChanceReduction();\n            if (source && damage)\n            {\n                if (isCrit)\n                    *damage -= target->GetMeleeCritDamageReduction(*damage);\n                *damage -= target->GetMeleeDamageReduction(*damage);\n            }\n            break;\n        case CR_CRIT_TAKEN_RANGED:\n            // Crit chance reduction works against nonpets\n            if (crit)\n                *crit -= target->GetRangedCritChanceReduction();\n            if (source && damage)\n            {\n                if (isCrit)\n                    *damage -= target->GetRangedCritDamageReduction(*damage);\n                *damage -= target->GetRangedDamageReduction(*damage);\n            }\n            break;\n        case CR_CRIT_TAKEN_SPELL:\n            // Crit chance reduction works against nonpets\n            if (crit)\n                *crit -= target->GetSpellCritChanceReduction();\n            if (source && damage)\n            {\n                if (isCrit)\n                    *damage -= target->GetSpellCritDamageReduction(*damage);\n                *damage -= target->GetSpellDamageReduction(*damage);\n            }\n            break;\n        default:\n            break;\n    }\n}\n\n// Melee based spells can be miss, parry or dodge on this step\n// Crit or block - determined on damage calculation phase! (and can be both in some time)\nfloat Unit::MeleeSpellMissChance(const Unit* victim, WeaponAttackType attType, int32 skillDiff, uint32 spellId) const\n{\n    //calculate miss chance\n    float missChance = victim->GetUnitMissChance(attType);\n\n    if (!spellId && haveOffhandWeapon())\n        missChance += 19;\n\n    // bonus from skills is 0.04%\n    //miss_chance -= skillDiff * 0.04f;\n    int32 diff = -skillDiff;\n    if (victim->GetTypeId() == TYPEID_PLAYER)\n        missChance += diff > 0 ? diff * 0.04f : diff * 0.02f;\n    else\n        missChance += diff > 10 ? 1 + (diff - 10) * 0.4f : diff * 0.1f;\n\n    // Calculate hit chance\n    float hitChance = 100.0f;\n\n    // Spellmod from SPELLMOD_RESIST_MISS_CHANCE\n    if (spellId)\n    {\n        if (Player* modOwner = GetSpellModOwner())\n            modOwner->ApplySpellMod(spellId, SPELLMOD_RESIST_MISS_CHANCE, hitChance);\n    }\n\n    missChance += hitChance - 100.0f;\n\n    if (attType == RANGED_ATTACK)\n        missChance -= m_modRangedHitChance;\n    else\n        missChance -= m_modMeleeHitChance;\n\n    // Limit miss chance from 0 to 60%\n    if (missChance < 0.0f)\n        return 0.0f;\n    if (missChance > 60.0f)\n        return 60.0f;\n    return missChance;\n}\n\nvoid Unit::SetPhaseMask(uint32 newPhaseMask, bool update)\n{\n    if (newPhaseMask == GetPhaseMask())\n        return;\n\n    if (IsInWorld())\n    {\n        RemoveNotOwnSingleTargetAuras(newPhaseMask);            // we can lost access to caster or target\n\n        // modify hostile references for new phasemask, some special cases deal with hostile references themselves\n        if (GetTypeId() == TYPEID_UNIT || (!ToPlayer()->isGameMaster() && !ToPlayer()->GetSession()->PlayerLogout()))\n        {\n            HostileRefManager& refManager = getHostileRefManager();\n            HostileReference* ref = refManager.getFirst();\n\n            while (ref)\n            {\n                if (Unit* unit = ref->getSource()->getOwner())\n                    if (Creature* creature = unit->ToCreature())\n                        refManager.setOnlineOfflineState(creature, creature->InSamePhase(newPhaseMask));\n\n                ref = ref->next();\n            }\n\n            // modify threat lists for new phasemask\n            if (GetTypeId() != TYPEID_PLAYER)\n            {\n                std::list<HostileReference*> threatList = getThreatManager().getThreatList();\n                std::list<HostileReference*> offlineThreatList = getThreatManager().getOfflineThreatList();\n\n                // merge expects sorted lists\n                threatList.sort();\n                offlineThreatList.sort();\n                threatList.merge(offlineThreatList);\n\n                for (std::list<HostileReference*>::const_iterator itr = threatList.begin(); itr != threatList.end(); ++itr)\n                    if (Unit* unit = (*itr)->getTarget())\n                        unit->getHostileRefManager().setOnlineOfflineState(ToCreature(), unit->InSamePhase(newPhaseMask));\n            }\n        }\n    }\n\n    WorldObject::SetPhaseMask(newPhaseMask, update);\n\n    if (!IsInWorld())\n        return;\n\n    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)\n        if ((*itr)->GetTypeId() == TYPEID_UNIT)\n            (*itr)->SetPhaseMask(newPhaseMask, true);\n\n    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)\n        if (m_SummonSlot[i])\n            if (Creature* summon = GetMap()->GetCreature(m_SummonSlot[i]))\n                summon->SetPhaseMask(newPhaseMask, true);\n}\n\nvoid Unit::UpdateObjectVisibility(bool forced)\n{\n    if (!forced)\n        AddToNotify(NOTIFY_VISIBILITY_CHANGED);\n    else\n    {\n        WorldObject::UpdateObjectVisibility(true);\n        // call MoveInLineOfSight for nearby creatures\n        Trinity::AIRelocationNotifier notifier(*this);\n        VisitNearbyObject(GetVisibilityRange(), notifier);\n    }\n}\n\nvoid Unit::KnockbackFrom(float x, float y, float speedXY, float speedZ)\n{\n    Player* player = NULL;\n    if (GetTypeId() == TYPEID_PLAYER)\n        player = (Player*)this;\n    else if (Unit* charmer = GetCharmer())\n    {\n        player = charmer->ToPlayer();\n        if (player && player->m_mover != this)\n            player = NULL;\n    }\n\n    if (!player)\n    {\n        GetMotionMaster()->MoveKnockbackFrom(x, y, speedXY, speedZ);\n    }\n    else\n    {\n        float vcos, vsin;\n        GetSinCos(x, y, vsin, vcos);\n\n        WorldPacket data(SMSG_MOVE_KNOCK_BACK, (8+4+4+4+4+4));\n        data.append(GetPackGUID());\n        data << uint32(0);                                      // counter\n        data << float(vcos);                                    // x direction\n        data << float(vsin);                                    // y direction\n        data << float(speedXY);                                 // Horizontal speed\n        data << float(-speedZ);                                 // Z Movement speed (vertical)\n\n        player->GetSession()->SendPacket(&data);\n    }\n}\n\nfloat Unit::GetCombatRatingReduction(CombatRating cr) const\n{\n    if (Player const* player = ToPlayer())\n        return player->GetRatingBonusValue(cr);\n    // Player's pet get resilience from owner\n    else if (isPet() && GetOwner())\n        if (Player* owner = GetOwner()->ToPlayer())\n            return owner->GetRatingBonusValue(cr);\n\n    return 0.0f;\n}\n\nuint32 Unit::GetCombatRatingDamageReduction(CombatRating cr, float rate, float cap, uint32 damage) const\n{\n    float percent = std::min(GetCombatRatingReduction(cr) * rate, cap);\n    return CalculatePctF(damage, percent);\n}\n\nuint32 Unit::GetModelForForm(ShapeshiftForm form)\n{\n    switch (form)\n    {\n        case FORM_CAT:\n            // Based on Hair color\n            if (getRace() == RACE_NIGHTELF)\n            {\n                uint8 hairColor = GetByteValue(PLAYER_BYTES, 3);\n                switch (hairColor)\n                {\n                    case 7: // Violet\n                    case 8:\n                        return 29405;\n                    case 3: // Light Blue\n                        return 29406;\n                    case 0: // Green\n                    case 1: // Light Green\n                    case 2: // Dark Green\n                        return 29407;\n                    case 4: // White\n                        return 29408;\n                    default: // original - Dark Blue\n                        return 892;\n                }\n            }\n            // Based on Skin color\n            else if (getRace() == RACE_TAUREN)\n            {\n                uint8 skinColor = GetByteValue(PLAYER_BYTES, 0);\n                // Male\n                if (getGender() == GENDER_MALE)\n                {\n                    switch (skinColor)\n                    {\n                        case 12: // White\n                        case 13:\n                        case 14:\n                        case 18: // Completly White\n                            return 29409;\n                        case 9: // Light Brown\n                        case 10:\n                        case 11:\n                            return 29410;\n                        case 6: // Brown\n                        case 7:\n                        case 8:\n                            return 29411;\n                        case 0: // Dark\n                        case 1:\n                        case 2:\n                        case 3: // Dark Grey\n                        case 4:\n                        case 5:\n                            return 29412;\n                        default: // original - Grey\n                            return 8571;\n                    }\n                }\n                // Female\n                else switch (skinColor)\n                {\n                    case 10: // White\n                        return 29409;\n                    case 6: // Light Brown\n                    case 7:\n                        return 29410;\n                    case 4: // Brown\n                    case 5:\n                        return 29411;\n                    case 0: // Dark\n                    case 1:\n                    case 2:\n                    case 3:\n                        return 29412;\n                    default: // original - Grey\n                        return 8571;\n                }\n            }\n            else if (Player::TeamForRace(getRace()) == ALLIANCE)\n                return 892;\n            else\n                return 8571;\n        case FORM_DIREBEAR:\n        case FORM_BEAR:\n            // Based on Hair color\n            if (getRace() == RACE_NIGHTELF)\n            {\n                uint8 hairColor = GetByteValue(PLAYER_BYTES, 3);\n                switch (hairColor)\n                {\n                    case 0: // Green\n                    case 1: // Light Green\n                    case 2: // Dark Green\n                        return 29413; // 29415?\n                    case 6: // Dark Blue\n                        return 29414;\n                    case 4: // White\n                        return 29416;\n                    case 3: // Light Blue\n                        return 29417;\n                    default: // original - Violet\n                        return 2281;\n                }\n            }\n            // Based on Skin color\n            else if (getRace() == RACE_TAUREN)\n            {\n                uint8 skinColor = GetByteValue(PLAYER_BYTES, 0);\n                // Male\n                if (getGender() == GENDER_MALE)\n                {\n                    switch (skinColor)\n                    {\n                        case 0: // Dark (Black)\n                        case 1:\n                        case 2:\n                            return 29418;\n                        case 3: // White\n                        case 4:\n                        case 5:\n                        case 12:\n                        case 13:\n                        case 14:\n                            return 29419;\n                        case 9: // Light Brown/Grey\n                        case 10:\n                        case 11:\n                        case 15:\n                        case 16:\n                        case 17:\n                            return 29420;\n                        case 18: // Completly White\n                            return 29421;\n                        default: // original - Brown\n                            return 2289;\n                    }\n                }\n                // Female\n                else switch (skinColor)\n                {\n                    case 0: // Dark (Black)\n                    case 1:\n                        return 29418;\n                    case 2: // White\n                    case 3:\n                        return 29419;\n                    case 6: // Light Brown/Grey\n                    case 7:\n                    case 8:\n                    case 9:\n                        return 29420;\n                    case 10: // Completly White\n                        return 29421;\n                    default: // original - Brown\n                        return 2289;\n                }\n            }\n            else if (Player::TeamForRace(getRace()) == ALLIANCE)\n                return 2281;\n            else\n                return 2289;\n        case FORM_FLIGHT:\n            if (Player::TeamForRace(getRace()) == ALLIANCE)\n                return 20857;\n            return 20872;\n        case FORM_FLIGHT_EPIC:\n            if (Player::TeamForRace(getRace()) == ALLIANCE)\n                return 21243;\n            return 21244;\n        default:\n            break;\n    }\n\n    uint32 modelid = 0;\n    SpellShapeshiftEntry const* formEntry = sSpellShapeshiftStore.LookupEntry(form);\n    if (formEntry && formEntry->modelID_A)\n    {\n        // Take the alliance modelid as default\n        if (GetTypeId() != TYPEID_PLAYER)\n            return formEntry->modelID_A;\n        else\n        {\n            if (Player::TeamForRace(getRace()) == ALLIANCE)\n                modelid = formEntry->modelID_A;\n            else\n                modelid = formEntry->modelID_H;\n\n            // If the player is horde but there are no values for the horde modelid - take the alliance modelid\n            if (!modelid && Player::TeamForRace(getRace()) == HORDE)\n                modelid = formEntry->modelID_A;\n        }\n    }\n\n    return modelid;\n}\n\nuint32 Unit::GetModelForTotem(PlayerTotemType totemType)\n{\n    switch (getRace())\n    {\n        case RACE_ORC:\n        {\n            switch (totemType)\n            {\n                case SUMMON_TYPE_TOTEM_FIRE:    // fire\n                    return 30758;\n                case SUMMON_TYPE_TOTEM_EARTH:   // earth\n                    return 30757;\n                case SUMMON_TYPE_TOTEM_WATER:   // water\n                    return 30759;\n                case SUMMON_TYPE_TOTEM_AIR:     // air\n                    return 30756;\n            }\n            break;\n        }\n        case RACE_DWARF:\n        {\n            switch (totemType)\n            {\n                case SUMMON_TYPE_TOTEM_FIRE:    // fire\n                    return 30754;\n                case SUMMON_TYPE_TOTEM_EARTH:   // earth\n                    return 30753;\n                case SUMMON_TYPE_TOTEM_WATER:   // water\n                    return 30755;\n                case SUMMON_TYPE_TOTEM_AIR:     // air\n                    return 30736;\n            }\n            break;\n        }\n        case RACE_TROLL:\n        {\n            switch (totemType)\n            {\n                case SUMMON_TYPE_TOTEM_FIRE:    // fire\n                    return 30762;\n                case SUMMON_TYPE_TOTEM_EARTH:   // earth\n                    return 30761;\n                case SUMMON_TYPE_TOTEM_WATER:   // water\n                    return 30763;\n                case SUMMON_TYPE_TOTEM_AIR:     // air\n                    return 30760;\n            }\n            break;\n        }\n        case RACE_TAUREN:\n        {\n            switch (totemType)\n            {\n                case SUMMON_TYPE_TOTEM_FIRE:    // fire\n                    return 4589;\n                case SUMMON_TYPE_TOTEM_EARTH:   // earth\n                    return 4588;\n                case SUMMON_TYPE_TOTEM_WATER:   // water\n                    return 4587;\n                case SUMMON_TYPE_TOTEM_AIR:     // air\n                    return 4590;\n            }\n            break;\n        }\n        case RACE_DRAENEI:\n        {\n            switch (totemType)\n            {\n                case SUMMON_TYPE_TOTEM_FIRE:    // fire\n                    return 19074;\n                case SUMMON_TYPE_TOTEM_EARTH:   // earth\n                    return 19073;\n                case SUMMON_TYPE_TOTEM_WATER:   // water\n                    return 19075;\n                case SUMMON_TYPE_TOTEM_AIR:     // air\n                    return 19071;\n            }\n            break;\n        }\n    }\n    return 0;\n}\n\nvoid Unit::JumpTo(float speedXY, float speedZ, bool forward)\n{\n    float angle = forward ? 0 : M_PI;\n    if (GetTypeId() == TYPEID_UNIT)\n        GetMotionMaster()->MoveJumpTo(angle, speedXY, speedZ);\n    else\n    {\n        float vcos = cos(angle+GetOrientation());\n        float vsin = sin(angle+GetOrientation());\n\n        WorldPacket data(SMSG_MOVE_KNOCK_BACK, (8+4+4+4+4+4));\n        data.append(GetPackGUID());\n        data << uint32(0);                                      // Sequence\n        data << float(vcos);                                    // x direction\n        data << float(vsin);                                    // y direction\n        data << float(speedXY);                                 // Horizontal speed\n        data << float(-speedZ);                                 // Z Movement speed (vertical)\n\n        ToPlayer()->GetSession()->SendPacket(&data);\n    }\n}\n\nvoid Unit::JumpTo(WorldObject* obj, float speedZ)\n{\n    float x, y, z;\n    obj->GetContactPoint(this, x, y, z);\n    float speedXY = GetExactDist2d(x, y) * 10.0f / speedZ;\n    GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);\n}\n\nbool Unit::HandleSpellClick(Unit* clicker, int8 seatId)\n{\n    bool result = false;\n    uint32 spellClickEntry = GetVehicleKit() ? GetVehicleKit()->GetCreatureEntry() : GetEntry();\n    SpellClickInfoMapBounds clickPair = sObjectMgr->GetSpellClickInfoMapBounds(spellClickEntry);\n    for (SpellClickInfoContainer::const_iterator itr = clickPair.first; itr != clickPair.second; ++itr)\n    {\n        //! First check simple relations from clicker to clickee\n        if (!itr->second.IsFitToRequirements(clicker, this))\n            continue;\n\n        //! Check database conditions\n        ConditionList conds = sConditionMgr->GetConditionsForSpellClickEvent(spellClickEntry, itr->second.spellId);\n        ConditionSourceInfo info = ConditionSourceInfo(clicker, this);\n        if (!sConditionMgr->IsObjectMeetToConditions(info, conds))\n            continue;\n\n        Unit* caster = (itr->second.castFlags & NPC_CLICK_CAST_CASTER_CLICKER) ? clicker : this;\n        Unit* target = (itr->second.castFlags & NPC_CLICK_CAST_TARGET_CLICKER) ? clicker : this;\n        uint64 origCasterGUID = (itr->second.castFlags & NPC_CLICK_CAST_ORIG_CASTER_OWNER) ? GetOwnerGUID() : clicker->GetGUID();\n\n        SpellInfo const* spellEntry = sSpellMgr->GetSpellInfo(itr->second.spellId);\n        // if (!spellEntry) should be checked at npc_spellclick load\n\n        if (seatId > -1)\n        {\n            uint8 i = 0;\n            bool valid = false;\n            while (i < MAX_SPELL_EFFECTS && !valid)\n            {\n                if (spellEntry->Effects[i].ApplyAuraName == SPELL_AURA_CONTROL_VEHICLE)\n                {\n                    valid = true;\n                    break;\n                }\n                ++i;\n            }\n\n            if (!valid)\n            {\n                sLog->outError(LOG_FILTER_SQL, \"Spell %u specified in npc_spellclick_spells is not a valid vehicle enter aura!\", itr->second.spellId);\n                continue;\n            }\n\n            if (IsInMap(caster))\n                caster->CastCustomSpell(itr->second.spellId, SpellValueMod(SPELLVALUE_BASE_POINT0+i), seatId+1, target, GetVehicleKit() ? TRIGGERED_IGNORE_CASTER_MOUNTED_OR_ON_VEHICLE : TRIGGERED_NONE, NULL, NULL, origCasterGUID);\n            else    // This can happen during Player::_LoadAuras\n            {\n                int32 bp0 = seatId;\n                Aura::TryRefreshStackOrCreate(spellEntry, MAX_EFFECT_MASK, this, clicker, &bp0, NULL, origCasterGUID);\n            }\n        }\n        else\n        {\n            if (IsInMap(caster))\n                caster->CastSpell(target, spellEntry, GetVehicleKit() ? TRIGGERED_IGNORE_CASTER_MOUNTED_OR_ON_VEHICLE : TRIGGERED_NONE, NULL, NULL, origCasterGUID);\n            else\n                Aura::TryRefreshStackOrCreate(spellEntry, MAX_EFFECT_MASK, this, clicker, NULL, NULL, origCasterGUID);\n        }\n\n        result = true;\n    }\n\n    if (result)\n    {\n        Creature* creature = ToCreature();\n        if (creature && creature->IsAIEnabled)\n            creature->AI()->OnSpellClick(clicker);\n    }\n\n    return result;\n}\n\nvoid Unit::EnterVehicle(Unit* base, int8 seatId)\n{\n    CastCustomSpell(VEHICLE_SPELL_RIDE_HARDCODED, SPELLVALUE_BASE_POINT0, seatId+1, base, TRIGGERED_IGNORE_CASTER_MOUNTED_OR_ON_VEHICLE);\n}\n\nvoid Unit::_EnterVehicle(Vehicle* vehicle, int8 seatId, AuraApplication const* aurApp)\n{\n    // Must be called only from aura handler\n    if (!isAlive() || GetVehicleKit() == vehicle || vehicle->GetBase()->IsOnVehicle(this))\n        return;\n\n    if (m_vehicle)\n    {\n        if (m_vehicle == vehicle)\n        {\n            if (seatId >= 0 && seatId != GetTransSeat())\n            {\n                sLog->outDebug(LOG_FILTER_VEHICLES, \"EnterVehicle: %u leave vehicle %u seat %d and enter %d.\", GetEntry(), m_vehicle->GetBase()->GetEntry(), GetTransSeat(), seatId);\n                ChangeSeat(seatId);\n            }\n\n            return;\n        }\n        else\n        {\n            sLog->outDebug(LOG_FILTER_VEHICLES, \"EnterVehicle: %u exit %u and enter %u.\", GetEntry(), m_vehicle->GetBase()->GetEntry(), vehicle->GetBase()->GetEntry());\n            ExitVehicle();\n        }\n    }\n\n    if (aurApp && aurApp->GetRemoveMode())\n        return;\n\n    if (Player* player = ToPlayer())\n    {\n        if (vehicle->GetBase()->GetTypeId() == TYPEID_PLAYER && player->isInCombat())\n            return;\n\n        InterruptNonMeleeSpells(false);\n        player->StopCastingCharm();\n        player->StopCastingBindSight();\n        Dismount();\n        RemoveAurasByType(SPELL_AURA_MOUNTED);\n\n        // drop flag at invisible in bg\n        if (Battleground* bg = player->GetBattleground())\n            bg->EventPlayerDroppedFlag(player);\n\n        WorldPacket data(SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA, 0);\n        player->GetSession()->SendPacket(&data);\n\n        player->UnsummonPetTemporaryIfAny();\n    }\n\n    ASSERT(!m_vehicle);\n    m_vehicle = vehicle;\n\n    if (!m_vehicle->AddPassenger(this, seatId))\n    {\n        m_vehicle = NULL;\n        return;\n    }\n}\n\nvoid Unit::ChangeSeat(int8 seatId, bool next)\n{\n    if (!m_vehicle)\n        return;\n\n    if (seatId < 0)\n    {\n        seatId = m_vehicle->GetNextEmptySeat(GetTransSeat(), next);\n        if (seatId < 0)\n            return;\n    }\n    else if (seatId == GetTransSeat() || !m_vehicle->HasEmptySeat(seatId))\n        return;\n\n    m_vehicle->RemovePassenger(this);\n    if (!m_vehicle->AddPassenger(this, seatId))\n        ASSERT(false);\n}\n\nvoid Unit::ExitVehicle(Position const* /*exitPosition*/)\n{\n    //! This function can be called at upper level code to initialize an exit from the passenger's side.\n    if (!m_vehicle)\n        return;\n\n    GetVehicleBase()->RemoveAurasByType(SPELL_AURA_CONTROL_VEHICLE, GetGUID());\n    //! The following call would not even be executed successfully as the\n    //! SPELL_AURA_CONTROL_VEHICLE unapply handler already calls _ExitVehicle without\n    //! specifying an exitposition. The subsequent call below would return on if (!m_vehicle).\n    /*_ExitVehicle(exitPosition);*/\n    //! To do:\n    //! We need to allow SPELL_AURA_CONTROL_VEHICLE unapply handlers in spellscripts\n    //! to specify exit coordinates and either store those per passenger, or we need to\n    //! init spline movement based on those coordinates in unapply handlers, and\n    //! relocate exiting passengers based on Unit::moveSpline data. Either way,\n    //! Coming Soon(TM)\n}\n\nvoid Unit::_ExitVehicle(Position const* exitPosition)\n{\n    if (!m_vehicle)\n        return;\n\n    m_vehicle->RemovePassenger(this);\n\n    Player* player = ToPlayer();\n\n    // If player is on mouted duel and exits the mount should immediatly lose the duel\n    if (player && player->duel && player->duel->isMounted)\n        player->DuelComplete(DUEL_FLED);\n\n    // This should be done before dismiss, because there may be some aura removal\n    Vehicle* vehicle = m_vehicle;\n    m_vehicle = NULL;\n\n    SetControlled(false, UNIT_STATE_ROOT);      // SMSG_MOVE_FORCE_UNROOT, ~MOVEMENTFLAG_ROOT\n\n    Position pos;\n    if (!exitPosition)                          // Exit position not specified\n        vehicle->GetBase()->GetPosition(&pos);  // This should use passenger's current position, leaving it as it is now\n                                                // because we calculate positions incorrect (sometimes under map)\n    else\n        pos = *exitPosition;\n\n    AddUnitState(UNIT_STATE_MOVE);\n\n    if (player)\n        player->SetFallInformation(0, GetPositionZ());\n    else if (HasUnitMovementFlag(MOVEMENTFLAG_ROOT))\n    {\n        WorldPacket data(SMSG_SPLINE_MOVE_UNROOT, 8);\n        data.append(GetPackGUID());\n        SendMessageToSet(&data, false);\n    }\n\n    Movement::MoveSplineInit init(*this);\n    init.MoveTo(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ());\n    init.SetFacing(GetOrientation());\n    init.SetTransportExit();\n    init.Launch();\n\n    //GetMotionMaster()->MoveFall();            // Enable this once passenger positions are calculater properly (see above)\n\n    if (player)\n        player->ResummonPetTemporaryUnSummonedIfAny();\n\n    if (vehicle->GetBase()->HasUnitTypeMask(UNIT_MASK_MINION))\n        if (((Minion*)vehicle->GetBase())->GetOwner() == this)\n            vehicle->Dismiss();\n\n    if (HasUnitTypeMask(UNIT_MASK_ACCESSORY))\n    {\n        // Vehicle just died, we die too\n        if (vehicle->GetBase()->getDeathState() == JUST_DIED)\n            setDeathState(JUST_DIED);\n        // If for other reason we as minion are exiting the vehicle (ejected, master dismounted) - unsummon\n        else\n            ToTempSummon()->UnSummon(2000); // Approximation\n    }\n}\n\nvoid Unit::BuildMovementPacket(ByteBuffer *data) const\n{\n    *data << uint32(GetUnitMovementFlags());            // movement flags\n    *data << uint16(GetExtraUnitMovementFlags());       // 2.3.0\n    *data << uint32(getMSTime());                       // time / counter\n    *data << GetPositionX();\n    *data << GetPositionY();\n    *data << GetPositionZMinusOffset();\n    *data << GetOrientation();\n\n    // 0x00000200\n    if (GetUnitMovementFlags() & MOVEMENTFLAG_ONTRANSPORT)\n    {\n        if (m_vehicle)\n            data->append(m_vehicle->GetBase()->GetPackGUID());\n        else if (GetTransport())\n            data->append(GetTransport()->GetPackGUID());\n        else\n            *data << (uint8)0;\n\n        *data << float (GetTransOffsetX());\n        *data << float (GetTransOffsetY());\n        *data << float (GetTransOffsetZ());\n        *data << float (GetTransOffsetO());\n        *data << uint32(GetTransTime());\n        *data << uint8 (GetTransSeat());\n\n        if (GetExtraUnitMovementFlags() & MOVEMENTFLAG2_INTERPOLATED_MOVEMENT)\n            *data << uint32(m_movementInfo.t_time2);\n    }\n\n    // 0x02200000\n    if ((GetUnitMovementFlags() & (MOVEMENTFLAG_SWIMMING | MOVEMENTFLAG_FLYING))\n        || (m_movementInfo.flags2 & MOVEMENTFLAG2_ALWAYS_ALLOW_PITCHING))\n        *data << (float)m_movementInfo.pitch;\n\n    *data << (uint32)m_movementInfo.fallTime;\n\n    // 0x00001000\n    if (GetUnitMovementFlags() & MOVEMENTFLAG_FALLING)\n    {\n        *data << (float)m_movementInfo.j_zspeed;\n        *data << (float)m_movementInfo.j_sinAngle;\n        *data << (float)m_movementInfo.j_cosAngle;\n        *data << (float)m_movementInfo.j_xyspeed;\n    }\n\n    // 0x04000000\n    if (GetUnitMovementFlags() & MOVEMENTFLAG_SPLINE_ELEVATION)\n        *data << (float)m_movementInfo.splineElevation;\n}\n\nvoid Unit::SetCanFly(bool apply)\n{\n    if (apply)\n        AddUnitMovementFlag(MOVEMENTFLAG_CAN_FLY);\n    else\n        RemoveUnitMovementFlag(MOVEMENTFLAG_CAN_FLY);\n}\n\nvoid Unit::NearTeleportTo(float x, float y, float z, float orientation, bool casting /*= false*/)\n{\n    DisableSpline();\n    if (GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->TeleportTo(GetMapId(), x, y, z, orientation, TELE_TO_NOT_LEAVE_TRANSPORT | TELE_TO_NOT_LEAVE_COMBAT | TELE_TO_NOT_UNSUMMON_PET | (casting ? TELE_TO_SPELL : 0));\n    else\n    {\n        UpdatePosition(x, y, z, orientation, true);\n        SendMovementFlagUpdate();\n    }\n}\n\nbool Unit::UpdatePosition(float x, float y, float z, float orientation, bool teleport)\n{\n    // prevent crash when a bad coord is sent by the client\n    if (!Trinity::IsValidMapCoord(x, y, z, orientation))\n    {\n        sLog->outDebug(LOG_FILTER_UNITS, \"Unit::UpdatePosition(%f, %f, %f) .. bad coordinates!\", x, y, z);\n        return false;\n    }\n\n    bool turn = (GetOrientation() != orientation);\n    bool relocated = (teleport || GetPositionX() != x || GetPositionY() != y || GetPositionZ() != z);\n\n    if (turn)\n        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TURNING);\n\n    if (relocated)\n    {\n        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOVE);\n\n        // move and update visible state if need\n        if (GetTypeId() == TYPEID_PLAYER)\n            GetMap()->PlayerRelocation(ToPlayer(), x, y, z, orientation);\n        else\n            GetMap()->CreatureRelocation(ToCreature(), x, y, z, orientation);\n    }\n    else if (turn)\n        UpdateOrientation(orientation);\n\n    // code block for underwater state update\n    UpdateUnderwaterState(GetMap(), x, y, z);\n\n    return (relocated || turn);\n}\n\n//! Only server-side orientation update, does not broadcast to client\nvoid Unit::UpdateOrientation(float orientation)\n{\n    SetOrientation(orientation);\n    if (IsVehicle())\n        GetVehicleKit()->RelocatePassengers();\n}\n\n//! Only server-side height update, does not broadcast to client\nvoid Unit::UpdateHeight(float newZ)\n{\n    Relocate(GetPositionX(), GetPositionY(), newZ);\n    if (IsVehicle())\n        GetVehicleKit()->RelocatePassengers();\n}\n\nvoid Unit::SendThreatListUpdate()\n{\n    if (!getThreatManager().isThreatListEmpty())\n    {\n        uint32 count = getThreatManager().getThreatList().size();\n\n        //sLog->outDebug(LOG_FILTER_UNITS, \"WORLD: Send SMSG_THREAT_UPDATE Message\");\n        WorldPacket data(SMSG_THREAT_UPDATE, 8 + count * 8);\n        data.append(GetPackGUID());\n        data << uint32(count);\n        std::list<HostileReference*>& tlist = getThreatManager().getThreatList();\n        for (std::list<HostileReference*>::const_iterator itr = tlist.begin(); itr != tlist.end(); ++itr)\n        {\n            data.appendPackGUID((*itr)->getUnitGuid());\n            data << uint32((*itr)->getThreat() * 100);\n        }\n        SendMessageToSet(&data, false);\n    }\n}\n\nvoid Unit::SendChangeCurrentVictimOpcode(HostileReference* pHostileReference)\n{\n    if (!getThreatManager().isThreatListEmpty())\n    {\n        uint32 count = getThreatManager().getThreatList().size();\n\n        sLog->outDebug(LOG_FILTER_UNITS, \"WORLD: Send SMSG_HIGHEST_THREAT_UPDATE Message\");\n        WorldPacket data(SMSG_HIGHEST_THREAT_UPDATE, 8 + 8 + count * 8);\n        data.append(GetPackGUID());\n        data.appendPackGUID(pHostileReference->getUnitGuid());\n        data << uint32(count);\n        std::list<HostileReference*>& tlist = getThreatManager().getThreatList();\n        for (std::list<HostileReference*>::const_iterator itr = tlist.begin(); itr != tlist.end(); ++itr)\n        {\n            data.appendPackGUID((*itr)->getUnitGuid());\n            data << uint32((*itr)->getThreat());\n        }\n        SendMessageToSet(&data, false);\n    }\n}\n\nvoid Unit::SendClearThreatListOpcode()\n{\n    sLog->outDebug(LOG_FILTER_UNITS, \"WORLD: Send SMSG_THREAT_CLEAR Message\");\n    WorldPacket data(SMSG_THREAT_CLEAR, 8);\n    data.append(GetPackGUID());\n    SendMessageToSet(&data, false);\n}\n\nvoid Unit::SendRemoveFromThreatListOpcode(HostileReference* pHostileReference)\n{\n    sLog->outDebug(LOG_FILTER_UNITS, \"WORLD: Send SMSG_THREAT_REMOVE Message\");\n    WorldPacket data(SMSG_THREAT_REMOVE, 8 + 8);\n    data.append(GetPackGUID());\n    data.appendPackGUID(pHostileReference->getUnitGuid());\n    SendMessageToSet(&data, false);\n}\n\nvoid Unit::RewardRage(uint32 damage, uint32 weaponSpeedHitFactor, bool attacker)\n{\n    float addRage;\n\n    float rageconversion = ((0.0091107836f * getLevel() * getLevel()) + 3.225598133f * getLevel()) + 4.2652911f;\n\n    // Unknown if correct, but lineary adjust rage conversion above level 70\n    if (getLevel() > 70)\n        rageconversion += 13.27f * (getLevel() - 70);\n\n    if (attacker)\n    {\n        addRage = (damage / rageconversion * 7.5f + weaponSpeedHitFactor) / 2;\n\n        // talent who gave more rage on attack\n        AddPctN(addRage, GetTotalAuraModifier(SPELL_AURA_MOD_RAGE_FROM_DAMAGE_DEALT));\n    }\n    else\n    {\n        addRage = damage / rageconversion * 2.5f;\n\n        // Berserker Rage effect\n        if (HasAura(18499))\n            addRage *= 2.0f;\n    }\n\n    addRage *= sWorld->getRate(RATE_POWER_RAGE_INCOME);\n\n    ModifyPower(POWER_RAGE, uint32(addRage * 10));\n}\n\nvoid Unit::StopAttackFaction(uint32 faction_id)\n{\n    if (Unit* victim = getVictim())\n    {\n        if (victim->getFactionTemplateEntry()->faction == faction_id)\n        {\n            AttackStop();\n            if (IsNonMeleeSpellCasted(false))\n                InterruptNonMeleeSpells(false);\n\n            // melee and ranged forced attack cancel\n            if (GetTypeId() == TYPEID_PLAYER)\n                ToPlayer()->SendAttackSwingCancelAttack();\n        }\n    }\n\n    AttackerSet const& attackers = getAttackers();\n    for (AttackerSet::const_iterator itr = attackers.begin(); itr != attackers.end();)\n    {\n        if ((*itr)->getFactionTemplateEntry()->faction == faction_id)\n        {\n            (*itr)->AttackStop();\n            itr = attackers.begin();\n        }\n        else\n            ++itr;\n    }\n\n    getHostileRefManager().deleteReferencesForFaction(faction_id);\n\n    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)\n            (*itr)->StopAttackFaction(faction_id);\n}\n\nvoid Unit::OutDebugInfo() const\n{\n    sLog->outError(LOG_FILTER_UNITS, \"Unit::OutDebugInfo\");\n    sLog->outInfo(LOG_FILTER_UNITS, \"GUID \"UI64FMTD\", entry %u, type %u, name %s\", GetGUID(), GetEntry(), (uint32)GetTypeId(), GetName());\n    sLog->outInfo(LOG_FILTER_UNITS, \"OwnerGUID \"UI64FMTD\", MinionGUID \"UI64FMTD\", CharmerGUID \"UI64FMTD\", CharmedGUID \"UI64FMTD, GetOwnerGUID(), GetMinionGUID(), GetCharmerGUID(), GetCharmGUID());\n    sLog->outInfo(LOG_FILTER_UNITS, \"In world %u, unit type mask %u\", (uint32)(IsInWorld() ? 1 : 0), m_unitTypeMask);\n    if (IsInWorld())\n        sLog->outInfo(LOG_FILTER_UNITS, \"Mapid %u\", GetMapId());\n\n    std::ostringstream o;\n    o << \"Summon Slot: \";\n    for (uint32 i = 0; i < MAX_SUMMON_SLOT; ++i)\n        o << m_SummonSlot[i] << \", \";\n\n    sLog->outInfo(LOG_FILTER_UNITS, \"%s\", o.str().c_str());\n    o.str(\"\");\n\n    o << \"Controlled List: \";\n    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)\n        o << (*itr)->GetGUID() << \", \";\n    sLog->outInfo(LOG_FILTER_UNITS, \"%s\", o.str().c_str());\n    o.str(\"\");\n\n    o << \"Aura List: \";\n    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.begin(); itr != m_appliedAuras.end(); ++itr)\n        o << itr->first << \", \";\n    sLog->outInfo(LOG_FILTER_UNITS, \"%s\", o.str().c_str());\n    o.str(\"\");\n\n    if (IsVehicle())\n    {\n        o << \"Passenger List: \";\n        for (SeatMap::iterator itr = GetVehicleKit()->Seats.begin(); itr != GetVehicleKit()->Seats.end(); ++itr)\n            if (Unit* passenger = ObjectAccessor::GetUnit(*GetVehicleBase(), itr->second.Passenger))\n                o << passenger->GetGUID() << \", \";\n        sLog->outInfo(LOG_FILTER_UNITS, \"%s\", o.str().c_str());\n    }\n\n    if (GetVehicle())\n        sLog->outInfo(LOG_FILTER_UNITS, \"On vehicle %u.\", GetVehicleBase()->GetEntry());\n}\n\nuint32 Unit::GetRemainingPeriodicAmount(uint64 caster, uint32 spellId, AuraType auraType, uint8 effectIndex) const\n{\n    uint32 amount = 0;\n    AuraEffectList const& periodicAuras = GetAuraEffectsByType(auraType);\n    for (AuraEffectList::const_iterator i = periodicAuras.begin(); i != periodicAuras.end(); ++i)\n    {\n        if ((*i)->GetCasterGUID() != caster || (*i)->GetId() != spellId || (*i)->GetEffIndex() != effectIndex || !(*i)->GetTotalTicks())\n            continue;\n        amount += uint32(((*i)->GetAmount() * std::max<int32>((*i)->GetTotalTicks() - int32((*i)->GetTickNumber()), 0)) / (*i)->GetTotalTicks());\n        break;\n    }\n\n    return amount;\n}\n\nvoid Unit::SendClearTarget()\n{\n    WorldPacket data(SMSG_BREAK_TARGET, GetPackGUID().size());\n    data.append(GetPackGUID());\n    SendMessageToSet(&data, false);\n}\n\nuint32 Unit::GetResistance(SpellSchoolMask mask) const\n{\n    int32 resist = -1;\n    for (int i = SPELL_SCHOOL_NORMAL; i < MAX_SPELL_SCHOOL; ++i)\n        if (mask & (1 << i) && (resist < 0 || resist > int32(GetResistance(SpellSchools(i)))))\n            resist = int32(GetResistance(SpellSchools(i)));\n\n    // resist value will never be negative here\n    return uint32(resist);\n}\n\nvoid CharmInfo::SetIsCommandAttack(bool val)\n{\n    m_isCommandAttack = val;\n}\n\nbool CharmInfo::IsCommandAttack()\n{\n    return m_isCommandAttack;\n}\n\nvoid CharmInfo::SaveStayPosition()\n{\n    //! At this point a new spline destination is enabled because of Unit::StopMoving()\n    G3D::Vector3 const stayPos = m_unit->movespline->FinalDestination();\n    m_stayX = stayPos.x;\n    m_stayY = stayPos.y;\n    m_stayZ = stayPos.z;\n}\n\nvoid CharmInfo::GetStayPosition(float &x, float &y, float &z)\n{\n    x = m_stayX;\n    y = m_stayY;\n    z = m_stayZ;\n}\n\nvoid CharmInfo::SetIsAtStay(bool val)\n{\n    m_isAtStay = val;\n}\n\nbool CharmInfo::IsAtStay()\n{\n    return m_isAtStay;\n}\n\nvoid CharmInfo::SetIsFollowing(bool val)\n{\n    m_isFollowing = val;\n}\n\nbool CharmInfo::IsFollowing()\n{\n    return m_isFollowing;\n}\n\nvoid CharmInfo::SetIsReturning(bool val)\n{\n    m_isReturning = val;\n}\n\nbool CharmInfo::IsReturning()\n{\n    return m_isReturning;\n}\n\nvoid Unit::SetInFront(Unit const* target)\n{\n    if (!HasUnitState(UNIT_STATE_CANNOT_TURN))\n        SetOrientation(GetAngle(target));\n}\n\nvoid Unit::SetFacingTo(float ori)\n{\n    Movement::MoveSplineInit init(*this);\n    init.MoveTo(GetPositionX(), GetPositionY(), GetPositionZMinusOffset());\n    init.SetFacing(ori);\n    init.Launch();\n}\n\nvoid Unit::SetFacingToObject(WorldObject* object)\n{\n    // never face when already moving\n    if (!IsStopped())\n        return;\n\n    // TODO: figure out under what conditions creature will move towards object instead of facing it where it currently is.\n    SetFacingTo(GetAngle(object));\n}\n\nbool Unit::SetWalk(bool enable)\n{\n    if (enable == IsWalking())\n        return false;\n\n    if (enable)\n        AddUnitMovementFlag(MOVEMENTFLAG_WALKING);\n    else\n        RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);\n\n    return true;\n}\n\nbool Unit::SetDisableGravity(bool disable, bool /*packetOnly = false*/)\n{\n    if (disable == IsLevitating())\n        return false;\n\n    if (disable)\n        AddUnitMovementFlag(MOVEMENTFLAG_DISABLE_GRAVITY);\n    else\n        RemoveUnitMovementFlag(MOVEMENTFLAG_DISABLE_GRAVITY);\n\n    return true;\n}\n\nbool Unit::SetHover(bool enable)\n{\n    if (enable == HasUnitMovementFlag(MOVEMENTFLAG_HOVER))\n        return false;\n\n    if (enable)\n    {\n        //! No need to check height on ascent\n        AddUnitMovementFlag(MOVEMENTFLAG_HOVER);\n        if (float hh = GetFloatValue(UNIT_FIELD_HOVERHEIGHT))\n            UpdateHeight(GetPositionZ() + hh);\n    }\n    else\n    {\n        RemoveUnitMovementFlag(MOVEMENTFLAG_HOVER);\n        if (float hh = GetFloatValue(UNIT_FIELD_HOVERHEIGHT))\n        {\n            float newZ = GetPositionZ() - hh;\n            UpdateAllowedPositionZ(GetPositionX(), GetPositionY(), newZ);\n            UpdateHeight(newZ);\n        }\n    }\n\n    return true;\n}\n\nvoid Unit::SendMovementHover()\n{\n    if (GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->SendMovementSetHover(HasUnitMovementFlag(MOVEMENTFLAG_HOVER));\n\n    WorldPacket data(MSG_MOVE_HOVER, 64);\n    data.append(GetPackGUID());\n    BuildMovementPacket(&data);\n    SendMessageToSet(&data, false);\n}\n\nvoid Unit::SendMovementWaterWalking()\n{\n    if (GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->SendMovementSetWaterWalking(HasUnitMovementFlag(MOVEMENTFLAG_WATERWALKING));\n\n    WorldPacket data(MSG_MOVE_WATER_WALK, 64);\n    data.append(GetPackGUID());\n    BuildMovementPacket(&data);\n    SendMessageToSet(&data, false);\n}\n\nvoid Unit::SendMovementFeatherFall()\n{\n    if (GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->SendMovementSetFeatherFall(HasUnitMovementFlag(MOVEMENTFLAG_FALLING_SLOW));\n\n    WorldPacket data(MSG_MOVE_FEATHER_FALL, 64);\n    data.append(GetPackGUID());\n    BuildMovementPacket(&data);\n    SendMessageToSet(&data, false);\n}\n\nvoid Unit::SendMovementGravityChange()\n{\n    WorldPacket data(MSG_MOVE_GRAVITY_CHNG, 64);\n    data.append(GetPackGUID());\n    BuildMovementPacket(&data);\n    SendMessageToSet(&data, false);\n}\n\nvoid Unit::SendMovementCanFlyChange()\n{\n    /*!\n        if ( a3->MoveFlags & MOVEMENTFLAG_CAN_FLY )\n        {\n            v4->MoveFlags |= 0x1000000u;\n            result = 1;\n        }\n        else\n        {\n            if ( v4->MoveFlags & MOVEMENTFLAG_FLYING )\n                CMovement::DisableFlying(v4);\n            v4->MoveFlags &= 0xFEFFFFFFu;\n            result = 1;\n        }\n    */\n    if (GetTypeId() == TYPEID_PLAYER)\n        ToPlayer()->SendMovementSetCanFly(CanFly());\n\n    WorldPacket data(MSG_MOVE_UPDATE_CAN_FLY, 64);\n    data.append(GetPackGUID());\n    BuildMovementPacket(&data);\n    SendMessageToSet(&data, false);\n}\n\nvoid Unit::FocusTarget(Spell const* focusSpell, uint64 target)\n{\n    // already focused\n    if (_focusSpell)\n        return;\n\n    _focusSpell = focusSpell;\n    SetUInt64Value(UNIT_FIELD_TARGET, target);\n    if (focusSpell->GetSpellInfo()->AttributesEx5 & SPELL_ATTR5_DONT_TURN_DURING_CAST)\n        AddUnitState(UNIT_STATE_ROTATING);\n}\n\nvoid Unit::ReleaseFocus(Spell const* focusSpell)\n{\n    // focused to something else\n    if (focusSpell != _focusSpell)\n        return;\n\n    _focusSpell = NULL;\n    if (Unit* victim = getVictim())\n        SetUInt64Value(UNIT_FIELD_TARGET, victim->GetGUID());\n    else\n        SetUInt64Value(UNIT_FIELD_TARGET, 0);\n\n    if (focusSpell->GetSpellInfo()->AttributesEx5 & SPELL_ATTR5_DONT_TURN_DURING_CAST)\n        ClearUnitState(UNIT_STATE_ROTATING);\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":683057}]],"length":683057}
