{"ts":1348522020482,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>\n * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __UNIT_H\n#define __UNIT_H\n\n#include \"Common.h\"\n#include \"Object.h\"\n#include \"Opcodes.h\"\n#include \"SpellAuraDefines.h\"\n#include \"UpdateFields.h\"\n#include \"SharedDefines.h\"\n#include \"ThreatManager.h\"\n#include \"HostileRefManager.h\"\n#include \"FollowerReference.h\"\n#include \"FollowerRefManager.h\"\n#include \"EventProcessor.h\"\n#include \"MotionMaster.h\"\n#include \"DBCStructure.h\"\n#include \"SpellInfo.h\"\n#include \"Path.h\"\n#include \"WorldPacket.h\"\n#include \"Timer.h\"\n#include <list>\n\n#define WORLD_TRIGGER   12999\n\nenum SpellInterruptFlags\n{\n    SPELL_INTERRUPT_FLAG_MOVEMENT     = 0x01, // why need this for instant?\n    SPELL_INTERRUPT_FLAG_PUSH_BACK    = 0x02, // push back\n    SPELL_INTERRUPT_FLAG_UNK3         = 0x04, // any info?\n    SPELL_INTERRUPT_FLAG_INTERRUPT    = 0x08, // interrupt\n    SPELL_INTERRUPT_FLAG_ABORT_ON_DMG = 0x10  // _complete_ interrupt on direct damage\n    //SPELL_INTERRUPT_UNK             = 0x20                // unk, 564 of 727 spells having this spell start with \"Glyph\"\n};\n\n// See SpellAuraInterruptFlags for other values definitions\nenum SpellChannelInterruptFlags\n{\n    CHANNEL_INTERRUPT_FLAG_INTERRUPT    = 0x08,  // interrupt\n    CHANNEL_FLAG_DELAY                  = 0x4000\n};\n\nenum SpellAuraInterruptFlags\n{\n    AURA_INTERRUPT_FLAG_HITBYSPELL          = 0x00000001,   // 0    removed when getting hit by a negative spell?\n    AURA_INTERRUPT_FLAG_TAKE_DAMAGE         = 0x00000002,   // 1    removed by any damage\n    AURA_INTERRUPT_FLAG_CAST                = 0x00000004,   // 2    cast any spells\n    AURA_INTERRUPT_FLAG_MOVE                = 0x00000008,   // 3    removed by any movement\n    AURA_INTERRUPT_FLAG_TURNING             = 0x00000010,   // 4    removed by any turning\n    AURA_INTERRUPT_FLAG_JUMP                = 0x00000020,   // 5    removed by entering combat\n    AURA_INTERRUPT_FLAG_NOT_MOUNTED         = 0x00000040,   // 6    removed by dismounting\n    AURA_INTERRUPT_FLAG_NOT_ABOVEWATER      = 0x00000080,   // 7    removed by entering water\n    AURA_INTERRUPT_FLAG_NOT_UNDERWATER      = 0x00000100,   // 8    removed by leaving water\n    AURA_INTERRUPT_FLAG_NOT_SHEATHED        = 0x00000200,   // 9    removed by unsheathing\n    AURA_INTERRUPT_FLAG_TALK                = 0x00000400,   // 10   talk to npc / loot? action on creature\n    AURA_INTERRUPT_FLAG_USE                 = 0x00000800,   // 11   mine/use/open action on gameobject\n    AURA_INTERRUPT_FLAG_MELEE_ATTACK        = 0x00001000,   // 12   removed by attacking\n    AURA_INTERRUPT_FLAG_SPELL_ATTACK        = 0x00002000,   // 13   ???\n    AURA_INTERRUPT_FLAG_UNK14               = 0x00004000,   // 14\n    AURA_INTERRUPT_FLAG_TRANSFORM           = 0x00008000,   // 15   removed by transform?\n    AURA_INTERRUPT_FLAG_UNK16               = 0x00010000,   // 16\n    AURA_INTERRUPT_FLAG_MOUNT               = 0x00020000,   // 17   misdirect, aspect, swim speed\n    AURA_INTERRUPT_FLAG_NOT_SEATED          = 0x00040000,   // 18   removed by standing up (used by food and drink mostly and sleep/Fake Death like)\n    AURA_INTERRUPT_FLAG_CHANGE_MAP          = 0x00080000,   // 19   leaving map/getting teleported\n    AURA_INTERRUPT_FLAG_IMMUNE_OR_LOST_SELECTION    = 0x00100000,   // 20   removed by auras that make you invulnerable, or make other to lose selection on you\n    AURA_INTERRUPT_FLAG_UNK21               = 0x00200000,   // 21\n    AURA_INTERRUPT_FLAG_TELEPORTED          = 0x00400000,   // 22\n    AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT    = 0x00800000,   // 23   removed by entering pvp combat\n    AURA_INTERRUPT_FLAG_DIRECT_DAMAGE       = 0x01000000,   // 24   removed by any direct damage\n    AURA_INTERRUPT_FLAG_LANDING             = 0x02000000,   // 25   removed by hitting the ground\n\n    AURA_INTERRUPT_FLAG_NOT_VICTIM = (AURA_INTERRUPT_FLAG_HITBYSPELL | AURA_INTERRUPT_FLAG_TAKE_DAMAGE | AURA_INTERRUPT_FLAG_DIRECT_DAMAGE)\n};\n\nenum SpellModOp\n{\n    SPELLMOD_DAMAGE                 = 0,\n    SPELLMOD_DURATION               = 1,\n    SPELLMOD_THREAT                 = 2,\n    SPELLMOD_EFFECT1                = 3,\n    SPELLMOD_CHARGES                = 4,\n    SPELLMOD_RANGE                  = 5,\n    SPELLMOD_RADIUS                 = 6,\n    SPELLMOD_CRITICAL_CHANCE        = 7,\n    SPELLMOD_ALL_EFFECTS            = 8,\n    SPELLMOD_NOT_LOSE_CASTING_TIME  = 9,\n    SPELLMOD_CASTING_TIME           = 10,\n    SPELLMOD_COOLDOWN               = 11,\n    SPELLMOD_EFFECT2                = 12,\n    SPELLMOD_IGNORE_ARMOR           = 13,\n    SPELLMOD_COST                   = 14,\n    SPELLMOD_CRIT_DAMAGE_BONUS      = 15,\n    SPELLMOD_RESIST_MISS_CHANCE     = 16,\n    SPELLMOD_JUMP_TARGETS           = 17,\n    SPELLMOD_CHANCE_OF_SUCCESS      = 18,\n    SPELLMOD_ACTIVATION_TIME        = 19,\n    SPELLMOD_DAMAGE_MULTIPLIER      = 20,\n    SPELLMOD_GLOBAL_COOLDOWN        = 21,\n    SPELLMOD_DOT                    = 22,\n    SPELLMOD_EFFECT3                = 23,\n    SPELLMOD_BONUS_MULTIPLIER       = 24,\n    // spellmod 25\n    SPELLMOD_PROC_PER_MINUTE        = 26,\n    SPELLMOD_VALUE_MULTIPLIER       = 27,\n    SPELLMOD_RESIST_DISPEL_CHANCE   = 28,\n    SPELLMOD_CRIT_DAMAGE_BONUS_2    = 29, //one not used spell\n    SPELLMOD_SPELL_COST_REFUND_ON_FAIL = 30\n};\n\n#define MAX_SPELLMOD 32\n\nenum SpellValueMod\n{\n    SPELLVALUE_BASE_POINT0,\n    SPELLVALUE_BASE_POINT1,\n    SPELLVALUE_BASE_POINT2,\n    SPELLVALUE_RADIUS_MOD,\n    SPELLVALUE_MAX_TARGETS,\n    SPELLVALUE_AURA_STACK\n};\n\ntypedef std::pair<SpellValueMod, int32>     CustomSpellValueMod;\nclass CustomSpellValues : public std::vector<CustomSpellValueMod>\n{\n    public:\n        void AddSpellMod(SpellValueMod mod, int32 value)\n        {\n            push_back(std::make_pair(mod, value));\n        }\n};\n\nenum SpellFacingFlags\n{\n    SPELL_FACING_FLAG_INFRONT = 0x0001\n};\n\n#define BASE_MINDAMAGE 1.0f\n#define BASE_MAXDAMAGE 2.0f\n#define BASE_ATTACK_TIME 2000\n\n// byte value (UNIT_FIELD_BYTES_1, 0)\nenum UnitStandStateType\n{\n    UNIT_STAND_STATE_STAND             = 0,\n    UNIT_STAND_STATE_SIT               = 1,\n    UNIT_STAND_STATE_SIT_CHAIR         = 2,\n    UNIT_STAND_STATE_SLEEP             = 3,\n    UNIT_STAND_STATE_SIT_LOW_CHAIR     = 4,\n    UNIT_STAND_STATE_SIT_MEDIUM_CHAIR  = 5,\n    UNIT_STAND_STATE_SIT_HIGH_CHAIR    = 6,\n    UNIT_STAND_STATE_DEAD              = 7,\n    UNIT_STAND_STATE_KNEEL             = 8,\n    UNIT_STAND_STATE_SUBMERGED         = 9\n};\n\n// byte flag value (UNIT_FIELD_BYTES_1, 2)\nenum UnitStandFlags\n{\n    UNIT_STAND_FLAGS_UNK1         = 0x01,\n    UNIT_STAND_FLAGS_CREEP        = 0x02,\n    UNIT_STAND_FLAGS_UNTRACKABLE  = 0x04,\n    UNIT_STAND_FLAGS_UNK4         = 0x08,\n    UNIT_STAND_FLAGS_UNK5         = 0x10,\n    UNIT_STAND_FLAGS_ALL          = 0xFF\n};\n\n// byte flags value (UNIT_FIELD_BYTES_1, 3)\nenum UnitBytes1_Flags\n{\n    UNIT_BYTE1_FLAG_ALWAYS_STAND    = 0x01,\n    UNIT_BYTE1_FLAG_HOVER           = 0x02,\n    UNIT_BYTE1_FLAG_UNK_3           = 0x04,\n    UNIT_BYTE1_FLAG_ALL             = 0xFF\n};\n\n// high byte (3 from 0..3) of UNIT_FIELD_BYTES_2\nenum ShapeshiftForm\n{\n    FORM_NONE               = 0x00,\n    FORM_CAT                = 0x01,\n    FORM_TREE               = 0x02,\n    FORM_TRAVEL             = 0x03,\n    FORM_AQUA               = 0x04,\n    FORM_BEAR               = 0x05,\n    FORM_AMBIENT            = 0x06,\n    FORM_GHOUL              = 0x07,\n    FORM_DIREBEAR           = 0x08,\n    FORM_STEVES_GHOUL       = 0x09,\n    FORM_THARONJA_SKELETON  = 0x0A,\n    FORM_TEST_OF_STRENGTH   = 0x0B,\n    FORM_BLB_PLAYER         = 0x0C,\n    FORM_SHADOW_DANCE       = 0x0D,\n    FORM_CREATUREBEAR       = 0x0E,\n    FORM_CREATURECAT        = 0x0F,\n    FORM_GHOSTWOLF          = 0x10,\n    FORM_BATTLESTANCE       = 0x11,\n    FORM_DEFENSIVESTANCE    = 0x12,\n    FORM_BERSERKERSTANCE    = 0x13,\n    FORM_TEST               = 0x14,\n    FORM_ZOMBIE             = 0x15,\n    FORM_METAMORPHOSIS      = 0x16,\n    FORM_UNDEAD             = 0x19,\n    FORM_MASTER_ANGLER      = 0x1A,\n    FORM_FLIGHT_EPIC        = 0x1B,\n    FORM_SHADOW             = 0x1C,\n    FORM_FLIGHT             = 0x1D,\n    FORM_STEALTH            = 0x1E,\n    FORM_MOONKIN            = 0x1F,\n    FORM_SPIRITOFREDEMPTION = 0x20\n};\n\n// low byte (0 from 0..3) of UNIT_FIELD_BYTES_2\nenum SheathState\n{\n    SHEATH_STATE_UNARMED  = 0,                              // non prepared weapon\n    SHEATH_STATE_MELEE    = 1,                              // prepared melee weapon\n    SHEATH_STATE_RANGED   = 2                               // prepared ranged weapon\n};\n\n#define MAX_SHEATH_STATE    3\n\n// byte (1 from 0..3) of UNIT_FIELD_BYTES_2\nenum UnitPVPStateFlags\n{\n    UNIT_BYTE2_FLAG_PVP         = 0x01,\n    UNIT_BYTE2_FLAG_UNK1        = 0x02,\n    UNIT_BYTE2_FLAG_FFA_PVP     = 0x04,\n    UNIT_BYTE2_FLAG_SANCTUARY   = 0x08,\n    UNIT_BYTE2_FLAG_UNK4        = 0x10,\n    UNIT_BYTE2_FLAG_UNK5        = 0x20,\n    UNIT_BYTE2_FLAG_UNK6        = 0x40,\n    UNIT_BYTE2_FLAG_UNK7        = 0x80\n};\n\n// byte (2 from 0..3) of UNIT_FIELD_BYTES_2\nenum UnitRename\n{\n    UNIT_CAN_BE_RENAMED     = 0x01,\n    UNIT_CAN_BE_ABANDONED   = 0x02\n};\n\n#define CREATURE_MAX_SPELLS     8\n#define MAX_SPELL_CHARM         4\n#define MAX_SPELL_VEHICLE       6\n#define MAX_SPELL_POSSESS       8\n#define MAX_SPELL_CONTROL_BAR   10\n\n#define MAX_AGGRO_RESET_TIME 10 // in seconds\n\nenum Swing\n{\n    NOSWING                    = 0,\n    SINGLEHANDEDSWING          = 1,\n    TWOHANDEDSWING             = 2\n};\n\nenum VictimState\n{\n    VICTIMSTATE_INTACT         = 0, // set when attacker misses\n    VICTIMSTATE_HIT            = 1, // victim got clear/blocked hit\n    VICTIMSTATE_DODGE          = 2,\n    VICTIMSTATE_PARRY          = 3,\n    VICTIMSTATE_INTERRUPT      = 4,\n    VICTIMSTATE_BLOCKS         = 5, // unused? not set when blocked, even on full block\n    VICTIMSTATE_EVADES         = 6,\n    VICTIMSTATE_IS_IMMUNE      = 7,\n    VICTIMSTATE_DEFLECTS       = 8\n};\n\nenum HitInfo\n{\n    HITINFO_NORMALSWING         = 0x00000000,\n    HITINFO_UNK1                = 0x00000001,               // req correct packet structure\n    HITINFO_AFFECTS_VICTIM      = 0x00000002,\n    HITINFO_OFFHAND             = 0x00000004,\n    HITINFO_UNK2                = 0x00000008,\n    HITINFO_MISS                = 0x00000010,\n    HITINFO_FULL_ABSORB         = 0x00000020,\n    HITINFO_PARTIAL_ABSORB      = 0x00000040,\n    HITINFO_FULL_RESIST         = 0x00000080,\n    HITINFO_PARTIAL_RESIST      = 0x00000100,\n    HITINFO_CRITICALHIT         = 0x00000200,               // critical hit\n    // 0x00000400\n    // 0x00000800\n    // 0x00001000\n    HITINFO_BLOCK               = 0x00002000,               // blocked damage\n    // 0x00004000                                           // Hides worldtext for 0 damage\n    // 0x00008000                                           // Related to blood visual\n    HITINFO_GLANCING            = 0x00010000,\n    HITINFO_CRUSHING            = 0x00020000,\n    HITINFO_NO_ANIMATION        = 0x00040000,\n    // 0x00080000\n    // 0x00100000\n    HITINFO_SWINGNOHITSOUND     = 0x00200000,               // unused?\n    // 0x00400000\n    HITINFO_RAGE_GAIN           = 0x00800000\n};\n\n//i would like to remove this: (it is defined in item.h\nenum InventorySlot\n{\n    NULL_BAG                   = 0,\n    NULL_SLOT                  = 255\n};\n\nstruct FactionTemplateEntry;\nstruct SpellValue;\n\nclass AuraApplication;\nclass Aura;\nclass UnitAura;\nclass AuraEffect;\nclass Creature;\nclass Spell;\nclass SpellInfo;\nclass DynamicObject;\nclass GameObject;\nclass Item;\nclass Pet;\nclass PetAura;\nclass Minion;\nclass Guardian;\nclass UnitAI;\nclass Totem;\nclass Transport;\nclass Vehicle;\nclass TransportBase;\n\ntypedef std::list<Unit*> UnitList;\ntypedef std::list< std::pair<Aura*, uint8> > DispelChargesList;\n\nstruct SpellImmune\n{\n    uint32 type;\n    uint32 spellId;\n};\n\ntypedef std::list<SpellImmune> SpellImmuneList;\n\nenum UnitModifierType\n{\n    BASE_VALUE = 0,\n    BASE_PCT = 1,\n    TOTAL_VALUE = 2,\n    TOTAL_PCT = 3,\n    MODIFIER_TYPE_END = 4\n};\n\nenum WeaponDamageRange\n{\n    MINDAMAGE,\n    MAXDAMAGE\n};\n\nenum DamageTypeToSchool\n{\n    RESISTANCE,\n    DAMAGE_DEALT,\n    DAMAGE_TAKEN\n};\n\nenum AuraRemoveMode\n{\n    AURA_REMOVE_NONE = 0,\n    AURA_REMOVE_BY_DEFAULT = 1,       // scripted remove, remove by stack with aura with different ids and sc aura remove\n    AURA_REMOVE_BY_CANCEL,\n    AURA_REMOVE_BY_ENEMY_SPELL,       // dispel and absorb aura destroy\n    AURA_REMOVE_BY_EXPIRE,            // aura duration has ended\n    AURA_REMOVE_BY_DEATH\n};\n\nenum TriggerCastFlags\n{\n    TRIGGERED_NONE                                  = 0x00000000,   //! Not triggered\n    TRIGGERED_IGNORE_GCD                            = 0x00000001,   //! Will ignore GCD\n    TRIGGERED_IGNORE_SPELL_AND_CATEGORY_CD          = 0x00000002,   //! Will ignore Spell and Category cooldowns\n    TRIGGERED_IGNORE_POWER_AND_REAGENT_COST         = 0x00000004,   //! Will ignore power and reagent cost\n    TRIGGERED_IGNORE_CAST_ITEM                      = 0x00000008,   //! Will not take away cast item or update related achievement criteria\n    TRIGGERED_IGNORE_AURA_SCALING                   = 0x00000010,   //! Will ignore aura scaling\n    TRIGGERED_IGNORE_CAST_IN_PROGRESS               = 0x00000020,   //! Will not check if a current cast is in progress\n    TRIGGERED_IGNORE_COMBO_POINTS                   = 0x00000040,   //! Will ignore combo point requirement\n    TRIGGERED_CAST_DIRECTLY                         = 0x00000080,   //! In Spell::prepare, will be cast directly without setting containers for executed spell\n    TRIGGERED_IGNORE_AURA_INTERRUPT_FLAGS           = 0x00000100,   //! Will ignore interruptible aura's at cast\n    TRIGGERED_IGNORE_SET_FACING                     = 0x00000200,   //! Will not adjust facing to target (if any)\n    TRIGGERED_IGNORE_SHAPESHIFT                     = 0x00000400,   //! Will ignore shapeshift checks\n    TRIGGERED_IGNORE_CASTER_AURASTATE               = 0x00000800,   //! Will ignore caster aura states including combat requirements and death state\n    TRIGGERED_IGNORE_CASTER_MOUNTED_OR_ON_VEHICLE   = 0x00002000,   //! Will ignore mounted/on vehicle restrictions\n    TRIGGERED_IGNORE_CASTER_AURAS                   = 0x00010000,   //! Will ignore caster aura restrictions or requirements\n    TRIGGERED_DISALLOW_PROC_EVENTS                  = 0x00020000,   //! Disallows proc events from triggered spell (default)\n    TRIGGERED_DONT_REPORT_CAST_ERROR                = 0x00040000,   //! Will return SPELL_FAILED_DONT_REPORT in CheckCast functions\n    TRIGGERED_FULL_MASK                             = 0xFFFFFFFF\n};\n\nenum UnitMods\n{\n    UNIT_MOD_STAT_STRENGTH,                                 // UNIT_MOD_STAT_STRENGTH..UNIT_MOD_STAT_SPIRIT must be in existed order, it's accessed by index values of Stats enum.\n    UNIT_MOD_STAT_AGILITY,\n    UNIT_MOD_STAT_STAMINA,\n    UNIT_MOD_STAT_INTELLECT,\n    UNIT_MOD_STAT_SPIRIT,\n    UNIT_MOD_HEALTH,\n    UNIT_MOD_MANA,                                          // UNIT_MOD_MANA..UNIT_MOD_RUNIC_POWER must be in existed order, it's accessed by index values of Powers enum.\n    UNIT_MOD_RAGE,\n    UNIT_MOD_FOCUS,\n    UNIT_MOD_ENERGY,\n    UNIT_MOD_HAPPINESS,\n    UNIT_MOD_RUNE,\n    UNIT_MOD_RUNIC_POWER,\n    UNIT_MOD_ARMOR,                                         // UNIT_MOD_ARMOR..UNIT_MOD_RESISTANCE_ARCANE must be in existed order, it's accessed by index values of SpellSchools enum.\n    UNIT_MOD_RESISTANCE_HOLY,\n    UNIT_MOD_RESISTANCE_FIRE,\n    UNIT_MOD_RESISTANCE_NATURE,\n    UNIT_MOD_RESISTANCE_FROST,\n    UNIT_MOD_RESISTANCE_SHADOW,\n    UNIT_MOD_RESISTANCE_ARCANE,\n    UNIT_MOD_ATTACK_POWER,\n    UNIT_MOD_ATTACK_POWER_RANGED,\n    UNIT_MOD_DAMAGE_MAINHAND,\n    UNIT_MOD_DAMAGE_OFFHAND,\n    UNIT_MOD_DAMAGE_RANGED,\n    UNIT_MOD_END,\n    // synonyms\n    UNIT_MOD_STAT_START = UNIT_MOD_STAT_STRENGTH,\n    UNIT_MOD_STAT_END = UNIT_MOD_STAT_SPIRIT + 1,\n    UNIT_MOD_RESISTANCE_START = UNIT_MOD_ARMOR,\n    UNIT_MOD_RESISTANCE_END = UNIT_MOD_RESISTANCE_ARCANE + 1,\n    UNIT_MOD_POWER_START = UNIT_MOD_MANA,\n    UNIT_MOD_POWER_END = UNIT_MOD_RUNIC_POWER + 1\n};\n\nenum BaseModGroup\n{\n    CRIT_PERCENTAGE,\n    RANGED_CRIT_PERCENTAGE,\n    OFFHAND_CRIT_PERCENTAGE,\n    SHIELD_BLOCK_VALUE,\n    BASEMOD_END\n};\n\nenum BaseModType\n{\n    FLAT_MOD,\n    PCT_MOD\n};\n\n#define MOD_END (PCT_MOD+1)\n\nenum DeathState\n{\n    ALIVE          = 0,\n    JUST_DIED      = 1,\n    CORPSE         = 2,\n    DEAD           = 3,\n    JUST_RESPAWNED = 4\n};\n\nenum UnitState\n{\n    UNIT_STATE_DIED            = 0x00000001,                     // player has fake death aura\n    UNIT_STATE_MELEE_ATTACKING = 0x00000002,                     // player is melee attacking someone\n    //UNIT_STATE_MELEE_ATTACK_BY = 0x00000004,                     // player is melee attack by someone\n    UNIT_STATE_STUNNED         = 0x00000008,\n    UNIT_STATE_ROAMING         = 0x00000010,\n    UNIT_STATE_CHASE           = 0x00000020,\n    //UNIT_STATE_SEARCHING       = 0x00000040,\n    UNIT_STATE_FLEEING         = 0x00000080,\n    UNIT_STATE_IN_FLIGHT       = 0x00000100,                     // player is in flight mode\n    UNIT_STATE_FOLLOW          = 0x00000200,\n    UNIT_STATE_ROOT            = 0x00000400,\n    UNIT_STATE_CONFUSED        = 0x00000800,\n    UNIT_STATE_DISTRACTED      = 0x00001000,\n    UNIT_STATE_ISOLATED        = 0x00002000,                     // area auras do not affect other players\n    UNIT_STATE_ATTACK_PLAYER   = 0x00004000,\n    UNIT_STATE_CASTING         = 0x00008000,\n    UNIT_STATE_POSSESSED       = 0x00010000,\n    UNIT_STATE_CHARGING        = 0x00020000,\n    UNIT_STATE_JUMPING         = 0x00040000,\n    UNIT_STATE_ONVEHICLE       = 0x00080000,\n    UNIT_STATE_MOVE            = 0x00100000,\n    UNIT_STATE_ROTATING        = 0x00200000,\n    UNIT_STATE_EVADE           = 0x00400000,\n    UNIT_STATE_ROAMING_MOVE    = 0x00800000,\n    UNIT_STATE_CONFUSED_MOVE   = 0x01000000,\n    UNIT_STATE_FLEEING_MOVE    = 0x02000000,\n    UNIT_STATE_CHASE_MOVE      = 0x04000000,\n    UNIT_STATE_FOLLOW_MOVE     = 0x08000000,\n    UNIT_STATE_UNATTACKABLE    = (UNIT_STATE_IN_FLIGHT | UNIT_STATE_ONVEHICLE),\n    // for real move using movegen check and stop (except unstoppable flight)\n    UNIT_STATE_MOVING          = UNIT_STATE_ROAMING_MOVE | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE | UNIT_STATE_CHASE_MOVE | UNIT_STATE_FOLLOW_MOVE ,\n    UNIT_STATE_CONTROLLED      = (UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING),\n    UNIT_STATE_LOST_CONTROL    = (UNIT_STATE_CONTROLLED | UNIT_STATE_JUMPING | UNIT_STATE_CHARGING),\n    UNIT_STATE_SIGHTLESS       = (UNIT_STATE_LOST_CONTROL | UNIT_STATE_EVADE),\n    UNIT_STATE_CANNOT_AUTOATTACK     = (UNIT_STATE_LOST_CONTROL | UNIT_STATE_CASTING),\n    UNIT_STATE_CANNOT_TURN     = (UNIT_STATE_LOST_CONTROL | UNIT_STATE_ROTATING),\n    // stay by different reasons\n    UNIT_STATE_NOT_MOVE        = UNIT_STATE_ROOT | UNIT_STATE_STUNNED | UNIT_STATE_DIED | UNIT_STATE_DISTRACTED,\n    UNIT_STATE_ALL_STATE       = 0xffffffff                      //(UNIT_STATE_STOPPED | UNIT_STATE_MOVING | UNIT_STATE_IN_COMBAT | UNIT_STATE_IN_FLIGHT)\n};\n\nenum UnitMoveType\n{\n    MOVE_WALK           = 0,\n    MOVE_RUN            = 1,\n    MOVE_RUN_BACK       = 2,\n    MOVE_SWIM           = 3,\n    MOVE_SWIM_BACK      = 4,\n    MOVE_TURN_RATE      = 5,\n    MOVE_FLIGHT         = 6,\n    MOVE_FLIGHT_BACK    = 7,\n    MOVE_PITCH_RATE     = 8\n};\n\n#define MAX_MOVE_TYPE     9\n\nextern float baseMoveSpeed[MAX_MOVE_TYPE];\nextern float playerBaseMoveSpeed[MAX_MOVE_TYPE];\n\nenum WeaponAttackType\n{\n    BASE_ATTACK   = 0,\n    OFF_ATTACK    = 1,\n    RANGED_ATTACK = 2,\n    MAX_ATTACK\n};\n\nenum CombatRating\n{\n    CR_WEAPON_SKILL             = 0,\n    CR_DEFENSE_SKILL            = 1,\n    CR_DODGE                    = 2,\n    CR_PARRY                    = 3,\n    CR_BLOCK                    = 4,\n    CR_HIT_MELEE                = 5,\n    CR_HIT_RANGED               = 6,\n    CR_HIT_SPELL                = 7,\n    CR_CRIT_MELEE               = 8,\n    CR_CRIT_RANGED              = 9,\n    CR_CRIT_SPELL               = 10,\n    CR_HIT_TAKEN_MELEE          = 11,\n    CR_HIT_TAKEN_RANGED         = 12,\n    CR_HIT_TAKEN_SPELL          = 13,\n    CR_CRIT_TAKEN_MELEE         = 14,\n    CR_CRIT_TAKEN_RANGED        = 15,\n    CR_CRIT_TAKEN_SPELL         = 16,\n    CR_HASTE_MELEE              = 17,\n    CR_HASTE_RANGED             = 18,\n    CR_HASTE_SPELL              = 19,\n    CR_WEAPON_SKILL_MAINHAND    = 20,\n    CR_WEAPON_SKILL_OFFHAND     = 21,\n    CR_WEAPON_SKILL_RANGED      = 22,\n    CR_EXPERTISE                = 23,\n    CR_ARMOR_PENETRATION        = 24\n};\n\n#define MAX_COMBAT_RATING         25\n\nenum DamageEffectType\n{\n    DIRECT_DAMAGE           = 0,                            // used for normal weapon damage (not for class abilities or spells)\n    SPELL_DIRECT_DAMAGE     = 1,                            // spell/class abilities damage\n    DOT                     = 2,\n    HEAL                    = 3,\n    NODAMAGE                = 4,                            // used also in case when damage applied to health but not applied to spell channelInterruptFlags/etc\n    SELF_DAMAGE             = 5\n};\n\n// Value masks for UNIT_FIELD_FLAGS\nenum UnitFlags\n{\n    UNIT_FLAG_SERVER_CONTROLLED     = 0x00000001,           // set only when unit movement is controlled by server - by SPLINE/MONSTER_MOVE packets, together with UNIT_FLAG_STUNNED; only set to units controlled by client; client function CGUnit_C::IsClientControlled returns false when set for owner\n    UNIT_FLAG_NON_ATTACKABLE        = 0x00000002,           // not attackable\n    UNIT_FLAG_DISABLE_MOVE          = 0x00000004,\n    UNIT_FLAG_PVP_ATTACKABLE        = 0x00000008,           // allow apply pvp rules to attackable state in addition to faction dependent state\n    UNIT_FLAG_RENAME                = 0x00000010,\n    UNIT_FLAG_PREPARATION           = 0x00000020,           // don't take reagents for spells with SPELL_ATTR5_NO_REAGENT_WHILE_PREP\n    UNIT_FLAG_UNK_6                 = 0x00000040,\n    UNIT_FLAG_NOT_ATTACKABLE_1      = 0x00000080,           // ?? (UNIT_FLAG_PVP_ATTACKABLE | UNIT_FLAG_NOT_ATTACKABLE_1) is NON_PVP_ATTACKABLE\n    UNIT_FLAG_IMMUNE_TO_PC          = 0x00000100,           // disables combat/assistance with PlayerCharacters (PC) - see Unit::_IsValidAttackTarget, Unit::_IsValidAssistTarget\n    UNIT_FLAG_IMMUNE_TO_NPC         = 0x00000200,           // disables combat/assistance with NonPlayerCharacters (NPC) - see Unit::_IsValidAttackTarget, Unit::_IsValidAssistTarget\n    UNIT_FLAG_LOOTING               = 0x00000400,           // loot animation\n    UNIT_FLAG_PET_IN_COMBAT         = 0x00000800,           // in combat?, 2.0.8\n    UNIT_FLAG_PVP                   = 0x00001000,           // changed in 3.0.3\n    UNIT_FLAG_SILENCED              = 0x00002000,           // silenced, 2.1.1\n    UNIT_FLAG_UNK_14                = 0x00004000,           // 2.0.8\n    UNIT_FLAG_UNK_15                = 0x00008000,\n    UNIT_FLAG_UNK_16                = 0x00010000,\n    UNIT_FLAG_PACIFIED              = 0x00020000,           // 3.0.3 ok\n    UNIT_FLAG_STUNNED               = 0x00040000,           // 3.0.3 ok\n    UNIT_FLAG_IN_COMBAT             = 0x00080000,\n    UNIT_FLAG_TAXI_FLIGHT           = 0x00100000,           // disable casting at client side spell not allowed by taxi flight (mounted?), probably used with 0x4 flag\n    UNIT_FLAG_DISARMED              = 0x00200000,           // 3.0.3, disable melee spells casting..., \"Required melee weapon\" added to melee spells tooltip.\n    UNIT_FLAG_CONFUSED              = 0x00400000,\n    UNIT_FLAG_FLEEING               = 0x00800000,\n    UNIT_FLAG_PLAYER_CONTROLLED     = 0x01000000,           // used in spell Eyes of the Beast for pet... let attack by controlled creature\n    UNIT_FLAG_NOT_SELECTABLE        = 0x02000000,\n    UNIT_FLAG_SKINNABLE             = 0x04000000,\n    UNIT_FLAG_MOUNT                 = 0x08000000,\n    UNIT_FLAG_UNK_28                = 0x10000000,\n    UNIT_FLAG_UNK_29                = 0x20000000,           // used in Feing Death spell\n    UNIT_FLAG_SHEATHE               = 0x40000000,\n    UNIT_FLAG_UNK_31                = 0x80000000\n};\n\n// Value masks for UNIT_FIELD_FLAGS_2\nenum UnitFlags2\n{\n    UNIT_FLAG2_FEIGN_DEATH                  = 0x00000001,\n    UNIT_FLAG2_UNK1                         = 0x00000002,   // Hide unit model (show only player equip)\n    UNIT_FLAG2_IGNORE_REPUTATION            = 0x00000004,\n    UNIT_FLAG2_COMPREHEND_LANG              = 0x00000008,\n    UNIT_FLAG2_MIRROR_IMAGE                 = 0x00000010,\n    UNIT_FLAG2_INSTANTLY_APPEAR_MODEL       = 0x00000020,   // Unit model instantly appears when summoned (does not fade in)\n    UNIT_FLAG2_FORCE_MOVEMENT               = 0x00000040,\n    UNIT_FLAG2_DISARM_OFFHAND               = 0x00000080,\n    UNIT_FLAG2_DISABLE_PRED_STATS           = 0x00000100,   // Player has disabled predicted stats (Used by raid frames)\n    UNIT_FLAG2_DISARM_RANGED                = 0x00000400,   // this does not disable ranged weapon display (maybe additional flag needed?)\n    UNIT_FLAG2_REGENERATE_POWER             = 0x00000800,\n    UNIT_FLAG2_RESTRICT_PARTY_INTERACTION   = 0x00001000,   // Restrict interaction to party or raid\n    UNIT_FLAG2_PREVENT_SPELL_CLICK          = 0x00002000,   // Prevent spellclick\n    UNIT_FLAG2_ALLOW_ENEMY_INTERACT         = 0x00004000,\n    UNIT_FLAG2_DISABLE_TURN                 = 0x00008000,\n    UNIT_FLAG2_UNK2                         = 0x00010000,\n    UNIT_FLAG2_PLAY_DEATH_ANIM              = 0x00020000,   // Plays special death animation upon death\n    UNIT_FLAG2_ALLOW_CHEAT_SPELLS           = 0x00040000    // Allows casting spells with AttributesEx7 & SPELL_ATTR7_IS_CHEAT_SPELL\n};\n\n/// Non Player Character flags\nenum NPCFlags\n{\n    UNIT_NPC_FLAG_NONE                  = 0x00000000,\n    UNIT_NPC_FLAG_GOSSIP                = 0x00000001,       // 100%\n    UNIT_NPC_FLAG_QUESTGIVER            = 0x00000002,       // guessed, probably ok\n    UNIT_NPC_FLAG_UNK1                  = 0x00000004,\n    UNIT_NPC_FLAG_UNK2                  = 0x00000008,\n    UNIT_NPC_FLAG_TRAINER               = 0x00000010,       // 100%\n    UNIT_NPC_FLAG_TRAINER_CLASS         = 0x00000020,       // 100%\n    UNIT_NPC_FLAG_TRAINER_PROFESSION    = 0x00000040,       // 100%\n    UNIT_NPC_FLAG_VENDOR                = 0x00000080,       // 100%\n    UNIT_NPC_FLAG_VENDOR_AMMO           = 0x00000100,       // 100%, general goods vendor\n    UNIT_NPC_FLAG_VENDOR_FOOD           = 0x00000200,       // 100%\n    UNIT_NPC_FLAG_VENDOR_POISON         = 0x00000400,       // guessed\n    UNIT_NPC_FLAG_VENDOR_REAGENT        = 0x00000800,       // 100%\n    UNIT_NPC_FLAG_REPAIR                = 0x00001000,       // 100%\n    UNIT_NPC_FLAG_FLIGHTMASTER          = 0x00002000,       // 100%\n    UNIT_NPC_FLAG_SPIRITHEALER          = 0x00004000,       // guessed\n    UNIT_NPC_FLAG_SPIRITGUIDE           = 0x00008000,       // guessed\n    UNIT_NPC_FLAG_INNKEEPER             = 0x00010000,       // 100%\n    UNIT_NPC_FLAG_BANKER                = 0x00020000,       // 100%\n    UNIT_NPC_FLAG_PETITIONER            = 0x00040000,       // 100% 0xC0000 = guild petitions, 0x40000 = arena team petitions\n    UNIT_NPC_FLAG_TABARDDESIGNER        = 0x00080000,       // 100%\n    UNIT_NPC_FLAG_BATTLEMASTER          = 0x00100000,       // 100%\n    UNIT_NPC_FLAG_AUCTIONEER            = 0x00200000,       // 100%\n    UNIT_NPC_FLAG_STABLEMASTER          = 0x00400000,       // 100%\n    UNIT_NPC_FLAG_GUILD_BANKER          = 0x00800000,       // cause client to send 997 opcode\n    UNIT_NPC_FLAG_SPELLCLICK            = 0x01000000,       // cause client to send 1015 opcode (spell click)\n    UNIT_NPC_FLAG_PLAYER_VEHICLE        = 0x02000000        // players with mounts that have vehicle data should have it set\n};\n\nenum MovementFlags\n{\n    MOVEMENTFLAG_NONE                  = 0x00000000,\n    MOVEMENTFLAG_FORWARD               = 0x00000001,\n    MOVEMENTFLAG_BACKWARD              = 0x00000002,\n    MOVEMENTFLAG_STRAFE_LEFT           = 0x00000004,\n    MOVEMENTFLAG_STRAFE_RIGHT          = 0x00000008,\n    MOVEMENTFLAG_LEFT                  = 0x00000010,\n    MOVEMENTFLAG_RIGHT                 = 0x00000020,\n    MOVEMENTFLAG_PITCH_UP              = 0x00000040,\n    MOVEMENTFLAG_PITCH_DOWN            = 0x00000080,\n    MOVEMENTFLAG_WALKING               = 0x00000100,               // Walking\n    MOVEMENTFLAG_ONTRANSPORT           = 0x00000200,               // Used for flying on some creatures\n    MOVEMENTFLAG_DISABLE_GRAVITY       = 0x00000400,               // Former MOVEMENTFLAG_LEVITATING. This is used when walking is not possible.\n    MOVEMENTFLAG_ROOT                  = 0x00000800,               // Must not be set along with MOVEMENTFLAG_MASK_MOVING\n    MOVEMENTFLAG_FALLING               = 0x00001000,               // damage dealt on that type of falling\n    MOVEMENTFLAG_FALLING_FAR           = 0x00002000,\n    MOVEMENTFLAG_PENDING_STOP          = 0x00004000,\n    MOVEMENTFLAG_PENDING_STRAFE_STOP   = 0x00008000,\n    MOVEMENTFLAG_PENDING_FORWARD       = 0x00010000,\n    MOVEMENTFLAG_PENDING_BACKWARD      = 0x00020000,\n    MOVEMENTFLAG_PENDING_STRAFE_LEFT   = 0x00040000,\n    MOVEMENTFLAG_PENDING_STRAFE_RIGHT  = 0x00080000,\n    MOVEMENTFLAG_PENDING_ROOT          = 0x00100000,\n    MOVEMENTFLAG_SWIMMING              = 0x00200000,               // appears with fly flag also\n    MOVEMENTFLAG_ASCENDING             = 0x00400000,               // press \"space\" when flying\n    MOVEMENTFLAG_DESCENDING            = 0x00800000,\n    MOVEMENTFLAG_CAN_FLY               = 0x01000000,               // Appears when unit can fly AND also walk\n    MOVEMENTFLAG_FLYING                = 0x02000000,               // unit is actually flying. pretty sure this is only used for players. creatures use disable_gravity\n    MOVEMENTFLAG_SPLINE_ELEVATION      = 0x04000000,               // used for flight paths\n    MOVEMENTFLAG_SPLINE_ENABLED        = 0x08000000,               // used for flight paths\n    MOVEMENTFLAG_WATERWALKING          = 0x10000000,               // prevent unit from falling through water\n    MOVEMENTFLAG_FALLING_SLOW          = 0x20000000,               // active rogue safe fall spell (passive)\n    MOVEMENTFLAG_HOVER                 = 0x40000000,               // hover, cannot jump\n\n    // TODO: Check if PITCH_UP and PITCH_DOWN really belong here..\n    MOVEMENTFLAG_MASK_MOVING =\n        MOVEMENTFLAG_FORWARD | MOVEMENTFLAG_BACKWARD | MOVEMENTFLAG_STRAFE_LEFT | MOVEMENTFLAG_STRAFE_RIGHT |\n        MOVEMENTFLAG_PITCH_UP | MOVEMENTFLAG_PITCH_DOWN | MOVEMENTFLAG_FALLING | MOVEMENTFLAG_FALLING_FAR | MOVEMENTFLAG_ASCENDING | MOVEMENTFLAG_DESCENDING |\n        MOVEMENTFLAG_SPLINE_ELEVATION,\n\n    MOVEMENTFLAG_MASK_TURNING =\n        MOVEMENTFLAG_LEFT | MOVEMENTFLAG_RIGHT,\n\n    MOVEMENTFLAG_MASK_MOVING_FLY =\n        MOVEMENTFLAG_FLYING | MOVEMENTFLAG_ASCENDING | MOVEMENTFLAG_DESCENDING,\n\n    //! TODO if needed: add more flags to this masks that are exclusive to players\n    MOVEMENTFLAG_MASK_PLAYER_ONLY =\n        MOVEMENTFLAG_FLYING\n};\nenum MovementFlags2\n{\n    MOVEMENTFLAG2_NONE                     = 0x00000000,\n    MOVEMENTFLAG2_NO_STRAFE                = 0x00000001,\n    MOVEMENTFLAG2_NO_JUMPING               = 0x00000002,\n    MOVEMENTFLAG2_UNK3                     = 0x00000004,        // Overrides various clientside checks\n    MOVEMENTFLAG2_FULL_SPEED_TURNING       = 0x00000008,\n    MOVEMENTFLAG2_FULL_SPEED_PITCHING      = 0x00000010,\n    MOVEMENTFLAG2_ALWAYS_ALLOW_PITCHING    = 0x00000020,\n    MOVEMENTFLAG2_UNK7                     = 0x00000040,\n    MOVEMENTFLAG2_UNK8                     = 0x00000080,\n    MOVEMENTFLAG2_UNK9                     = 0x00000100,\n    MOVEMENTFLAG2_UNK10                    = 0x00000200,\n    MOVEMENTFLAG2_INTERPOLATED_MOVEMENT    = 0x00000400,\n    MOVEMENTFLAG2_INTERPOLATED_TURNING     = 0x00000800,\n    MOVEMENTFLAG2_INTERPOLATED_PITCHING    = 0x00001000,\n    MOVEMENTFLAG2_UNK14                    = 0x00002000,\n    MOVEMENTFLAG2_UNK15                    = 0x00004000,\n    MOVEMENTFLAG2_UNK16                    = 0x00008000\n};\n\nenum UnitTypeMask\n{\n    UNIT_MASK_NONE                  = 0x00000000,\n    UNIT_MASK_SUMMON                = 0x00000001,\n    UNIT_MASK_MINION                = 0x00000002,\n    UNIT_MASK_GUARDIAN              = 0x00000004,\n    UNIT_MASK_TOTEM                 = 0x00000008,\n    UNIT_MASK_PET                   = 0x00000010,\n    UNIT_MASK_VEHICLE               = 0x00000020,\n    UNIT_MASK_PUPPET                = 0x00000040,\n    UNIT_MASK_HUNTER_PET            = 0x00000080,\n    UNIT_MASK_CONTROLABLE_GUARDIAN  = 0x00000100,\n    UNIT_MASK_ACCESSORY             = 0x00000200\n};\n\nnamespace Movement{\n    class MoveSpline;\n}\n\nenum DiminishingLevels\n{\n    DIMINISHING_LEVEL_1             = 0,\n    DIMINISHING_LEVEL_2             = 1,\n    DIMINISHING_LEVEL_3             = 2,\n    DIMINISHING_LEVEL_IMMUNE        = 3,\n    DIMINISHING_LEVEL_4             = 3,\n    DIMINISHING_LEVEL_TAUNT_IMMUNE  = 4\n};\n\nstruct DiminishingReturn\n{\n    DiminishingReturn(DiminishingGroup group, uint32 t, uint32 count)\n        : DRGroup(group), stack(0), hitTime(t), hitCount(count)\n    {}\n\n    DiminishingGroup        DRGroup:16;\n    uint16                  stack:16;\n    uint32                  hitTime;\n    uint32                  hitCount;\n};\n\nenum MeleeHitOutcome\n{\n    MELEE_HIT_EVADE, MELEE_HIT_MISS, MELEE_HIT_DODGE, MELEE_HIT_BLOCK, MELEE_HIT_PARRY,\n    MELEE_HIT_GLANCING, MELEE_HIT_CRIT, MELEE_HIT_CRUSHING, MELEE_HIT_NORMAL\n};\n\nclass DispelInfo\n{\nprivate:\n    Unit* const m_dispeller;\n    uint32 const m_dispellerSpellId;\n    uint8 m_chargesRemoved;\npublic:\n    explicit DispelInfo(Unit* _dispeller, uint32 _dispellerSpellId, uint8 _chargesRemoved) :\n    m_dispeller(_dispeller), m_dispellerSpellId(_dispellerSpellId), m_chargesRemoved(_chargesRemoved) {}\n\n    Unit* GetDispeller() { return m_dispeller; }\n    uint32 GetDispellerSpellId() const { return m_dispellerSpellId; }\n    uint8 GetRemovedCharges() const { return m_chargesRemoved; }\n    void SetRemovedCharges(uint8 amount)\n    {\n        m_chargesRemoved = amount;\n    }\n};\n\nstruct CleanDamage\n{\n    CleanDamage(uint32 mitigated, uint32 absorbed, WeaponAttackType _attackType, MeleeHitOutcome _hitOutCome) :\n    absorbed_damage(absorbed), mitigated_damage(mitigated), attackType(_attackType), hitOutCome(_hitOutCome) {}\n\n    uint32 absorbed_damage;\n    uint32 mitigated_damage;\n\n    WeaponAttackType attackType;\n    MeleeHitOutcome hitOutCome;\n};\n\nstruct CalcDamageInfo;\n\nclass DamageInfo\n{\nprivate:\n    Unit* const m_attacker;\n    Unit* const m_victim;\n    uint32 m_damage;\n    SpellInfo const* const m_spellInfo;\n    SpellSchoolMask const m_schoolMask;\n    DamageEffectType const m_damageType;\n    WeaponAttackType m_attackType;\n    uint32 m_absorb;\n    uint32 m_resist;\n    uint32 m_block;\npublic:\n    explicit DamageInfo(Unit* _attacker, Unit* _victim, uint32 _damage, SpellInfo const* _spellInfo, SpellSchoolMask _schoolMask, DamageEffectType _damageType);\n    explicit DamageInfo(CalcDamageInfo& dmgInfo);\n\n    void ModifyDamage(int32 amount);\n    void AbsorbDamage(uint32 amount);\n    void ResistDamage(uint32 amount);\n    void BlockDamage(uint32 amount);\n\n    Unit* GetAttacker() const { return m_attacker; };\n    Unit* GetVictim() const { return m_victim; };\n    SpellInfo const* GetSpellInfo() const { return m_spellInfo; };\n    SpellSchoolMask GetSchoolMask() const { return m_schoolMask; };\n    DamageEffectType GetDamageType() const { return m_damageType; };\n    WeaponAttackType GetAttackType() const { return m_attackType; };\n    uint32 GetDamage() const { return m_damage; };\n    uint32 GetAbsorb() const { return m_absorb; };\n    uint32 GetResist() const { return m_resist; };\n    uint32 GetBlock() const { return m_block; };\n};\n\nclass HealInfo\n{\nprivate:\n    Unit* const m_healer;\n    Unit* const m_target;\n    uint32 m_heal;\n    uint32 m_absorb;\n    SpellInfo const* const m_spellInfo;\n    SpellSchoolMask const m_schoolMask;\npublic:\n    explicit HealInfo(Unit* _healer, Unit* _target, uint32 _heal, SpellInfo const* _spellInfo, SpellSchoolMask _schoolMask)\n        : m_healer(_healer), m_target(_target), m_heal(_heal), m_spellInfo(_spellInfo), m_schoolMask(_schoolMask)\n    {\n        m_absorb = 0;\n    }\n    void AbsorbHeal(uint32 amount)\n    {\n        amount = std::min(amount, GetHeal());\n        m_absorb += amount;\n        m_heal -= amount;\n    }\n\n    uint32 GetHeal() const { return m_heal; };\n};\n\nclass ProcEventInfo\n{\nprivate:\n    Unit* const _actor;\n    Unit* const _actionTarget;\n    Unit* const _procTarget;\n    uint32 _typeMask;\n    uint32 _spellTypeMask;\n    uint32 _spellPhaseMask;\n    uint32 _hitMask;\n    Spell* _spell;\n    DamageInfo* _damageInfo;\n    HealInfo* _healInfo;\npublic:\n    explicit ProcEventInfo(Unit* actor, Unit* actionTarget, Unit* procTarget, uint32 typeMask, uint32 spellTypeMask, uint32 spellPhaseMask, uint32 hitMask, Spell* spell, DamageInfo* damageInfo, HealInfo* healInfo);\n    Unit* GetActor() { return _actor; };\n    Unit* GetActionTarget() const { return _actionTarget; }\n    Unit* GetProcTarget() const { return _procTarget; }\n    uint32 GetTypeMask() const { return _typeMask; }\n    uint32 GetSpellTypeMask() const { return _spellTypeMask; }\n    uint32 GetSpellPhaseMask() const { return _spellPhaseMask; }\n    uint32 GetHitMask() const { return _hitMask; }\n    SpellInfo const* GetSpellInfo() const { return NULL; }\n    SpellSchoolMask GetSchoolMask() const { return SPELL_SCHOOL_MASK_NONE; }\n    DamageInfo* GetDamageInfo() const { return _damageInfo; }\n    HealInfo* GetHealInfo() const { return _healInfo; }\n};\n\n// Struct for use in Unit::CalculateMeleeDamage\n// Need create structure like in SMSG_ATTACKERSTATEUPDATE opcode\nstruct CalcDamageInfo\n{\n    Unit  *attacker;             // Attacker\n    Unit  *target;               // Target for damage\n    uint32 damageSchoolMask;\n    uint32 damage;\n    uint32 absorb;\n    uint32 resist;\n    uint32 blocked_amount;\n    uint32 HitInfo;\n    uint32 TargetState;\n// Helper\n    WeaponAttackType attackType; //\n    uint32 procAttacker;\n    uint32 procVictim;\n    uint32 procEx;\n    uint32 cleanDamage;          // Used only for rage calculation\n    MeleeHitOutcome hitOutCome;  // TODO: remove this field (need use TargetState)\n};\n\n// Spell damage info structure based on structure sending in SMSG_SPELLNONMELEEDAMAGELOG opcode\nstruct SpellNonMeleeDamage{\n    SpellNonMeleeDamage(Unit* _attacker, Unit* _target, uint32 _SpellID, uint32 _schoolMask)\n        : target(_target), attacker(_attacker), SpellID(_SpellID), damage(0), overkill(0), schoolMask(_schoolMask),\n        absorb(0), resist(0), physicalLog(false), unused(false), blocked(0), HitInfo(0), cleanDamage(0)\n    {}\n\n    Unit   *target;\n    Unit   *attacker;\n    uint32 SpellID;\n    uint32 damage;\n    uint32 overkill;\n    uint32 schoolMask;\n    uint32 absorb;\n    uint32 resist;\n    bool   physicalLog;\n    bool   unused;\n    uint32 blocked;\n    uint32 HitInfo;\n    // Used for help\n    uint32 cleanDamage;\n};\n\nstruct SpellPeriodicAuraLogInfo\n{\n    SpellPeriodicAuraLogInfo(AuraEffect const* _auraEff, uint32 _damage, uint32 _overDamage, uint32 _absorb, uint32 _resist, float _multiplier, bool _critical)\n        : auraEff(_auraEff), damage(_damage), overDamage(_overDamage), absorb(_absorb), resist(_resist), multiplier(_multiplier), critical(_critical){}\n\n    AuraEffect const* auraEff;\n    uint32 damage;\n    uint32 overDamage;                                      // overkill/overheal\n    uint32 absorb;\n    uint32 resist;\n    float  multiplier;\n    bool   critical;\n};\n\nuint32 createProcExtendMask(SpellNonMeleeDamage* damageInfo, SpellMissInfo missCondition);\n\n#define MAX_DECLINED_NAME_CASES 5\n\nstruct DeclinedName\n{\n    std::string name[MAX_DECLINED_NAME_CASES];\n};\n\nenum CurrentSpellTypes\n{\n    CURRENT_MELEE_SPELL             = 0,\n    CURRENT_GENERIC_SPELL           = 1,\n    CURRENT_CHANNELED_SPELL         = 2,\n    CURRENT_AUTOREPEAT_SPELL        = 3\n};\n\n#define CURRENT_FIRST_NON_MELEE_SPELL 1\n#define CURRENT_MAX_SPELL             4\n\nstruct GlobalCooldown\n{\n    explicit GlobalCooldown(uint32 _dur = 0, uint32 _time = 0) : duration(_dur), cast_time(_time) {}\n\n    uint32 duration;\n    uint32 cast_time;\n};\n\ntypedef UNORDERED_MAP<uint32 /*category*/, GlobalCooldown> GlobalCooldownList;\n\nclass GlobalCooldownMgr                                     // Shared by Player and CharmInfo\n{\npublic:\n    GlobalCooldownMgr() {}\n\npublic:\n    bool HasGlobalCooldown(SpellInfo const* spellInfo) const;\n    void AddGlobalCooldown(SpellInfo const* spellInfo, uint32 gcd);\n    void CancelGlobalCooldown(SpellInfo const* spellInfo);\n\nprivate:\n    GlobalCooldownList m_GlobalCooldowns;\n};\n\nenum ActiveStates\n{\n    ACT_PASSIVE  = 0x01,                                    // 0x01 - passive\n    ACT_DISABLED = 0x81,                                    // 0x80 - castable\n    ACT_ENABLED  = 0xC1,                                    // 0x40 | 0x80 - auto cast + castable\n    ACT_COMMAND  = 0x07,                                    // 0x01 | 0x02 | 0x04\n    ACT_REACTION = 0x06,                                    // 0x02 | 0x04\n    ACT_DECIDE   = 0x00                                     // custom\n};\n\nenum ReactStates\n{\n    REACT_PASSIVE    = 0,\n    REACT_DEFENSIVE  = 1,\n    REACT_AGGRESSIVE = 2\n};\n\nenum CommandStates\n{\n    COMMAND_STAY    = 0,\n    COMMAND_FOLLOW  = 1,\n    COMMAND_ATTACK  = 2,\n    COMMAND_ABANDON = 3\n};\n\n#define UNIT_ACTION_BUTTON_ACTION(X) (uint32(X) & 0x00FFFFFF)\n#define UNIT_ACTION_BUTTON_TYPE(X)   ((uint32(X) & 0xFF000000) >> 24)\n#define MAKE_UNIT_ACTION_BUTTON(A, T) (uint32(A) | (uint32(T) << 24))\n\nstruct UnitActionBarEntry\n{\n    UnitActionBarEntry() : packedData(uint32(ACT_DISABLED) << 24) {}\n\n    uint32 packedData;\n\n    // helper\n    ActiveStates GetType() const { return ActiveStates(UNIT_ACTION_BUTTON_TYPE(packedData)); }\n    uint32 GetAction() const { return UNIT_ACTION_BUTTON_ACTION(packedData); }\n    bool IsActionBarForSpell() const\n    {\n        ActiveStates Type = GetType();\n        return Type == ACT_DISABLED || Type == ACT_ENABLED || Type == ACT_PASSIVE;\n    }\n\n    void SetActionAndType(uint32 action, ActiveStates type)\n    {\n        packedData = MAKE_UNIT_ACTION_BUTTON(action, type);\n    }\n\n    void SetType(ActiveStates type)\n    {\n        packedData = MAKE_UNIT_ACTION_BUTTON(UNIT_ACTION_BUTTON_ACTION(packedData), type);\n    }\n\n    void SetAction(uint32 action)\n    {\n        packedData = (packedData & 0xFF000000) | UNIT_ACTION_BUTTON_ACTION(action);\n    }\n};\n\ntypedef std::list<Player*> SharedVisionList;\n\nenum CharmType\n{\n    CHARM_TYPE_CHARM,\n    CHARM_TYPE_POSSESS,\n    CHARM_TYPE_VEHICLE,\n    CHARM_TYPE_CONVERT\n};\n\ntypedef UnitActionBarEntry CharmSpellInfo;\n\nenum ActionBarIndex\n{\n    ACTION_BAR_INDEX_START = 0,\n    ACTION_BAR_INDEX_PET_SPELL_START = 3,\n    ACTION_BAR_INDEX_PET_SPELL_END = 7,\n    ACTION_BAR_INDEX_END = 10\n};\n\n#define MAX_UNIT_ACTION_BAR_INDEX (ACTION_BAR_INDEX_END-ACTION_BAR_INDEX_START)\n\nstruct CharmInfo\n{\n    public:\n        explicit CharmInfo(Unit* unit);\n        ~CharmInfo();\n        void RestoreState();\n        uint32 GetPetNumber() const { return m_petnumber; }\n        void SetPetNumber(uint32 petnumber, bool statwindow);\n\n        void SetCommandState(CommandStates st) { m_CommandState = st; }\n        CommandStates GetCommandState() const { return m_CommandState; }\n        bool HasCommandState(CommandStates state) const { return (m_CommandState == state); }\n\n        void InitPossessCreateSpells();\n        void InitCharmCreateSpells();\n        void InitPetActionBar();\n        void InitEmptyActionBar(bool withAttack = true);\n\n                                                            //return true if successful\n        bool AddSpellToActionBar(SpellInfo const* spellInfo, ActiveStates newstate = ACT_DECIDE);\n        bool RemoveSpellFromActionBar(uint32 spell_id);\n        void LoadPetActionBar(const std::string& data);\n        void BuildActionBar(WorldPacket* data);\n        void SetSpellAutocast(SpellInfo const* spellInfo, bool state);\n        void SetActionBar(uint8 index, uint32 spellOrAction, ActiveStates type)\n        {\n            PetActionBar[index].SetActionAndType(spellOrAction, type);\n        }\n        UnitActionBarEntry const* GetActionBarEntry(uint8 index) const { return &(PetActionBar[index]); }\n\n        void ToggleCreatureAutocast(SpellInfo const* spellInfo, bool apply);\n\n        CharmSpellInfo* GetCharmSpell(uint8 index) { return &(m_charmspells[index]); }\n\n        GlobalCooldownMgr& GetGlobalCooldownMgr() { return m_GlobalCooldownMgr; }\n\n        void SetIsCommandAttack(bool val);\n        bool IsCommandAttack();\n        void SetIsAtStay(bool val);\n        bool IsAtStay();\n        void SetIsFollowing(bool val);\n        bool IsFollowing();\n        void SetIsReturning(bool val);\n        bool IsReturning();\n        void SaveStayPosition();\n        void GetStayPosition(float &x, float &y, float &z);\n\n    private:\n\n        Unit* m_unit;\n        UnitActionBarEntry PetActionBar[MAX_UNIT_ACTION_BAR_INDEX];\n        CharmSpellInfo m_charmspells[4];\n        CommandStates   m_CommandState;\n        uint32          m_petnumber;\n        bool            m_barInit;\n\n        //for restoration after charmed\n        ReactStates     m_oldReactState;\n\n        bool m_isCommandAttack;\n        bool m_isAtStay;\n        bool m_isFollowing;\n        bool m_isReturning;\n        float m_stayX;\n        float m_stayY;\n        float m_stayZ;\n\n        GlobalCooldownMgr m_GlobalCooldownMgr;\n};\n\n// for clearing special attacks\n#define REACTIVE_TIMER_START 4000\n\nenum ReactiveType\n{\n    REACTIVE_DEFENSE      = 0,\n    REACTIVE_HUNTER_PARRY = 1,\n    REACTIVE_OVERPOWER    = 2\n};\n\n#define MAX_REACTIVE 3\n#define SUMMON_SLOT_PET     0\n#define SUMMON_SLOT_TOTEM   1\n#define MAX_TOTEM_SLOT      5\n#define SUMMON_SLOT_MINIPET 5\n#define SUMMON_SLOT_QUEST   6\n#define MAX_SUMMON_SLOT     7\n\n#define MAX_GAMEOBJECT_SLOT 4\n\nenum PlayerTotemType\n{\n    SUMMON_TYPE_TOTEM_FIRE  = 63,\n    SUMMON_TYPE_TOTEM_EARTH = 81,\n    SUMMON_TYPE_TOTEM_WATER = 82,\n    SUMMON_TYPE_TOTEM_AIR   = 83\n};\n\n// delay time next attack to prevent client attack animation problems\n#define ATTACK_DISPLAY_DELAY 200\n#define MAX_PLAYER_STEALTH_DETECT_RANGE 30.0f               // max distance for detection targets by player\n\nstruct SpellProcEventEntry;                                 // used only privately\n\nclass Unit : public WorldObject\n{\n    public:\n        typedef std::set<Unit*> AttackerSet;\n        typedef std::set<Unit*> ControlList;\n        typedef std::pair<uint32, uint8> spellEffectPair;\n        typedef std::multimap<uint32,  Aura*> AuraMap;\n        typedef std::multimap<uint32,  AuraApplication*> AuraApplicationMap;\n        typedef std::multimap<AuraStateType,  AuraApplication*> AuraStateAurasMap;\n        typedef std::list<AuraEffect*> AuraEffectList;\n        typedef std::list<Aura*> AuraList;\n        typedef std::list<AuraApplication *> AuraApplicationList;\n        typedef std::list<DiminishingReturn> Diminishing;\n        typedef std::set<uint32> ComboPointHolderSet;\n\n        typedef std::map<uint8, AuraApplication*> VisibleAuraMap;\n\n        virtual ~Unit();\n\n        UnitAI* GetAI() { return i_AI; }\n        void SetAI(UnitAI* newAI) { i_AI = newAI; }\n\n        void AddToWorld();\n        void RemoveFromWorld();\n\n        void CleanupBeforeRemoveFromMap(bool finalCleanup);\n        void CleanupsBeforeDelete(bool finalCleanup = true);                        // used in ~Creature/~Player (or before mass creature delete to remove cross-references to already deleted units)\n\n        DiminishingLevels GetDiminishing(DiminishingGroup  group);\n        void IncrDiminishing(DiminishingGroup group);\n        float ApplyDiminishingToDuration(DiminishingGroup  group, int32 &duration, Unit* caster, DiminishingLevels Level, int32 limitduration);\n        void ApplyDiminishingAura(DiminishingGroup  group, bool apply);\n        void ClearDiminishings() { m_Diminishing.clear(); }\n\n        // target dependent range checks\n        float GetSpellMaxRangeForTarget(Unit const* target, SpellInfo const* spellInfo) const;\n        float GetSpellMinRangeForTarget(Unit const* target, SpellInfo const* spellInfo) const;\n\n        virtual void Update(uint32 time);\n\n        void setAttackTimer(WeaponAttackType type, uint32 time) { m_attackTimer[type] = time; }\n        void resetAttackTimer(WeaponAttackType type = BASE_ATTACK);\n        uint32 getAttackTimer(WeaponAttackType type) const { return m_attackTimer[type]; }\n        bool isAttackReady(WeaponAttackType type = BASE_ATTACK) const { return m_attackTimer[type] == 0; }\n        bool haveOffhandWeapon() const;\n        bool CanDualWield() const { return m_canDualWield; }\n        void SetCanDualWield(bool value) { m_canDualWield = value; }\n        float GetCombatReach() const { return m_floatValues[UNIT_FIELD_COMBATREACH]; }\n        float GetMeleeReach() const { float reach = m_floatValues[UNIT_FIELD_COMBATREACH]; return reach > MIN_MELEE_REACH ? reach : MIN_MELEE_REACH; }\n        bool IsWithinCombatRange(const Unit* obj, float dist2compare) const;\n        bool IsWithinMeleeRange(const Unit* obj, float dist = MELEE_RANGE) const;\n        void GetRandomContactPoint(const Unit* target, float &x, float &y, float &z, float distance2dMin, float distance2dMax) const;\n        uint32 m_extraAttacks;\n        bool m_canDualWield;\n\n        void _addAttacker(Unit* pAttacker)                  // must be called only from Unit::Attack(Unit*)\n        {\n            m_attackers.insert(pAttacker);\n        }\n        void _removeAttacker(Unit* pAttacker)               // must be called only from Unit::AttackStop()\n        {\n            m_attackers.erase(pAttacker);\n        }\n        Unit* getAttackerForHelper() const                 // If someone wants to help, who to give them\n        {\n            if (getVictim() != NULL)\n                return getVictim();\n\n            if (!m_attackers.empty())\n                return *(m_attackers.begin());\n\n            return NULL;\n        }\n        bool Attack(Unit* victim, bool meleeAttack);\n        void CastStop(uint32 except_spellid = 0);\n        bool AttackStop();\n        void RemoveAllAttackers();\n        AttackerSet const& getAttackers() const { return m_attackers; }\n        bool isAttackingPlayer() const;\n        Unit* getVictim() const { return m_attacking; }\n\n        void CombatStop(bool includingCast = false);\n        void CombatStopWithPets(bool includingCast = false);\n        void StopAttackFaction(uint32 faction_id);\n        Unit* SelectNearbyTarget(Unit* exclude = NULL, float dist = NOMINAL_MELEE_RANGE) const;\n        void SendMeleeAttackStop(Unit* victim = NULL);\n        void SendMeleeAttackStart(Unit* victim);\n\n        void AddUnitState(uint32 f) { m_state |= f; }\n        bool HasUnitState(const uint32 f) const { return (m_state & f); }\n        void ClearUnitState(uint32 f) { m_state &= ~f; }\n        bool CanFreeMove() const\n        {\n            return !HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_FLEEING | UNIT_STATE_IN_FLIGHT |\n                UNIT_STATE_ROOT | UNIT_STATE_STUNNED | UNIT_STATE_DISTRACTED) && GetOwnerGUID() == 0;\n        }\n\n        uint32 HasUnitTypeMask(uint32 mask) const { return mask & m_unitTypeMask; }\n        void AddUnitTypeMask(uint32 mask) { m_unitTypeMask |= mask; }\n        bool isSummon() const   { return m_unitTypeMask & UNIT_MASK_SUMMON; }\n        bool isGuardian() const { return m_unitTypeMask & UNIT_MASK_GUARDIAN; }\n        bool isPet() const      { return m_unitTypeMask & UNIT_MASK_PET; }\n        bool isHunterPet() const{ return m_unitTypeMask & UNIT_MASK_HUNTER_PET; }\n        bool isTotem() const    { return m_unitTypeMask & UNIT_MASK_TOTEM; }\n        bool IsVehicle() const  { return m_unitTypeMask & UNIT_MASK_VEHICLE; }\n\n        uint8 getLevel() const { return uint8(GetUInt32Value(UNIT_FIELD_LEVEL)); }\n        uint8 getLevelForTarget(WorldObject const* /*target*/) const { return getLevel(); }\n        void SetLevel(uint8 lvl);\n        uint8 getRace() const { return GetByteValue(UNIT_FIELD_BYTES_0, 0); }\n        uint32 getRaceMask() const { return 1 << (getRace()-1); }\n        uint8 getClass() const { return GetByteValue(UNIT_FIELD_BYTES_0, 1); }\n        uint32 getClassMask() const { return 1 << (getClass()-1); }\n        uint8 getGender() const { return GetByteValue(UNIT_FIELD_BYTES_0, 2); }\n\n        float GetStat(Stats stat) const { return float(GetUInt32Value(UNIT_FIELD_STAT0+stat)); }\n        void SetStat(Stats stat, int32 val) { SetStatInt32Value(UNIT_FIELD_STAT0+stat, val); }\n        uint32 GetArmor() const { return GetResistance(SPELL_SCHOOL_NORMAL); }\n        void SetArmor(int32 val) { SetResistance(SPELL_SCHOOL_NORMAL, val); }\n\n        uint32 GetResistance(SpellSchools school) const { return GetUInt32Value(UNIT_FIELD_RESISTANCES+school); }\n        uint32 GetResistance(SpellSchoolMask mask) const;\n        void SetResistance(SpellSchools school, int32 val) { SetStatInt32Value(UNIT_FIELD_RESISTANCES+school, val); }\n\n        uint32 GetHealth()    const { return GetUInt32Value(UNIT_FIELD_HEALTH); }\n        uint32 GetMaxHealth() const { return GetUInt32Value(UNIT_FIELD_MAXHEALTH); }\n\n        bool IsFullHealth() const { return GetHealth() == GetMaxHealth(); }\n        bool HealthBelowPct(int32 pct) const { return GetHealth() < CountPctFromMaxHealth(pct); }\n        bool HealthBelowPctDamaged(int32 pct, uint32 damage) const { return int64(GetHealth()) - int64(damage) < int64(CountPctFromMaxHealth(pct)); }\n        bool HealthAbovePct(int32 pct) const { return GetHealth() > CountPctFromMaxHealth(pct); }\n        bool HealthAbovePctHealed(int32 pct, uint32 heal) const { return uint64(GetHealth()) + uint64(heal) > CountPctFromMaxHealth(pct); }\n        float GetHealthPct() const { return GetMaxHealth() ? 100.f * GetHealth() / GetMaxHealth() : 0.0f; }\n        uint32 CountPctFromMaxHealth(int32 pct) const { return CalculatePctN(GetMaxHealth(), pct); }\n        uint32 CountPctFromCurHealth(int32 pct) const { return CalculatePctN(GetHealth(), pct); }\n\n        void SetHealth(uint32 val);\n        void SetMaxHealth(uint32 val);\n        inline void SetFullHealth() { SetHealth(GetMaxHealth()); }\n        int32 ModifyHealth(int32 val);\n        int32 GetHealthGain(int32 dVal);\n\n        Powers getPowerType() const { return Powers(GetByteValue(UNIT_FIELD_BYTES_0, 3)); }\n        void setPowerType(Powers power);\n        uint32 GetPower(Powers power) const { return GetUInt32Value(UNIT_FIELD_POWER1   +power); }\n        uint32 GetMaxPower(Powers power) const { return GetUInt32Value(UNIT_FIELD_MAXPOWER1+power); }\n        void SetPower(Powers power, uint32 val);\n        void SetMaxPower(Powers power, uint32 val);\n        // returns the change in power\n        int32 ModifyPower(Powers power, int32 val);\n        int32 ModifyPowerPct(Powers power, float pct, bool apply = true);\n\n        uint32 GetAttackTime(WeaponAttackType att) const\n        {\n           float f_BaseAttackTime = GetFloatValue(UNIT_FIELD_BASEATTACKTIME+att) / m_modAttackSpeedPct[att];\n           return (uint32)f_BaseAttackTime;\n        }\n\n        void SetAttackTime(WeaponAttackType att, uint32 val) { SetFloatValue(UNIT_FIELD_BASEATTACKTIME+att, val*m_modAttackSpeedPct[att]); }\n        void ApplyAttackTimePercentMod(WeaponAttackType att, float val, bool apply);\n        void ApplyCastTimePercentMod(float val, bool apply);\n\n        SheathState GetSheath() const { return SheathState(GetByteValue(UNIT_FIELD_BYTES_2, 0)); }\n        virtual void SetSheath(SheathState sheathed) { SetByteValue(UNIT_FIELD_BYTES_2, 0, sheathed); }\n\n        // faction template id\n        uint32 getFaction() const { return GetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE); }\n        void setFaction(uint32 faction) { SetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE, faction); }\n        FactionTemplateEntry const* getFactionTemplateEntry() const;\n\n        ReputationRank GetReactionTo(Unit const* target) const;\n        ReputationRank static GetFactionReactionTo(FactionTemplateEntry const* factionTemplateEntry, Unit const* target);\n\n        bool IsHostileTo(Unit const* unit) const;\n        bool IsHostileToPlayers() const;\n        bool IsFriendlyTo(Unit const* unit) const;\n        bool IsNeutralToAll() const;\n        bool IsInPartyWith(Unit const* unit) const;\n        bool IsInRaidWith(Unit const* unit) const;\n        void GetPartyMembers(std::list<Unit*> &units);\n        bool IsContestedGuard() const\n        {\n            if (FactionTemplateEntry const* entry = getFactionTemplateEntry())\n                return entry->IsContestedGuardFaction();\n\n            return false;\n        }\n        bool IsPvP() const { return HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_PVP); }\n        void SetPvP(bool state)\n        {\n            if (state)\n                SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_PVP);\n            else\n                RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_PVP);\n        }\n        uint32 GetCreatureType() const;\n        uint32 GetCreatureTypeMask() const\n        {\n            uint32 creatureType = GetCreatureType();\n            return (creatureType >= 1) ? (1 << (creatureType - 1)) : 0;\n        }\n\n        uint8 getStandState() const { return GetByteValue(UNIT_FIELD_BYTES_1, 0); }\n        bool IsSitState() const;\n        bool IsStandState() const;\n        void SetStandState(uint8 state);\n\n        void  SetStandFlags(uint8 flags) { SetByteFlag(UNIT_FIELD_BYTES_1, 2, flags); }\n        void  RemoveStandFlags(uint8 flags) { RemoveByteFlag(UNIT_FIELD_BYTES_1, 2, flags); }\n\n        bool IsMounted() const { return HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_MOUNT); }\n        uint32 GetMountID() const { return GetUInt32Value(UNIT_FIELD_MOUNTDISPLAYID); }\n        void Mount(uint32 mount, uint32 vehicleId = 0, uint32 creatureEntry = 0);\n        void Dismount();\n\n        uint16 GetMaxSkillValueForLevel(Unit const* target = NULL) const { return (target ? getLevelForTarget(target) : getLevel()) * 5; }\n        void DealDamageMods(Unit* victim, uint32 &damage, uint32* absorb);\n        uint32 DealDamage(Unit* victim, uint32 damage, CleanDamage const* cleanDamage = NULL, DamageEffectType damagetype = DIRECT_DAMAGE, SpellSchoolMask damageSchoolMask = SPELL_SCHOOL_MASK_NORMAL, SpellInfo const* spellProto = NULL, bool durabilityLoss = true);\n        void Kill(Unit* victim, bool durabilityLoss = true);\n        int32 DealHeal(Unit* victim, uint32 addhealth);\n\n        void ProcDamageAndSpell(Unit* victim, uint32 procAttacker, uint32 procVictim, uint32 procEx, uint32 amount, WeaponAttackType attType = BASE_ATTACK, SpellInfo const* procSpell = NULL, SpellInfo const* procAura = NULL);\n        void ProcDamageAndSpellFor(bool isVictim, Unit* target, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, SpellInfo const* procSpell, uint32 damage, SpellInfo const* procAura = NULL);\n\n        void GetProcAurasTriggeredOnEvent(std::list<AuraApplication*>& aurasTriggeringProc, std::list<AuraApplication*>* procAuras, ProcEventInfo eventInfo);\n        void TriggerAurasProcOnEvent(CalcDamageInfo& damageInfo);\n        void TriggerAurasProcOnEvent(std::list<AuraApplication*>* myProcAuras, std::list<AuraApplication*>* targetProcAuras, Unit* actionTarget, uint32 typeMaskActor, uint32 typeMaskActionTarget, uint32 spellTypeMask, uint32 spellPhaseMask, uint32 hitMask, Spell* spell, DamageInfo* damageInfo, HealInfo* healInfo);\n        void TriggerAurasProcOnEvent(ProcEventInfo& eventInfo, std::list<AuraApplication*>& procAuras);\n\n        void HandleEmoteCommand(uint32 anim_id);\n        void AttackerStateUpdate (Unit* victim, WeaponAttackType attType = BASE_ATTACK, bool extra = false);\n\n        void CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* damageInfo, WeaponAttackType attackType = BASE_ATTACK);\n        void DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss);\n        void HandleProcExtraAttackFor(Unit* victim);\n\n        void CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 damage, SpellInfo const* spellInfo, WeaponAttackType attackType = BASE_ATTACK, bool crit = false);\n        void DealSpellDamage(SpellNonMeleeDamage* damageInfo, bool durabilityLoss);\n\n        // player or player's pet resilience (-1%)\n        float GetMeleeCritChanceReduction() const { return GetCombatRatingReduction(CR_CRIT_TAKEN_MELEE); }\n        float GetRangedCritChanceReduction() const { return GetCombatRatingReduction(CR_CRIT_TAKEN_RANGED); }\n        float GetSpellCritChanceReduction() const { return GetCombatRatingReduction(CR_CRIT_TAKEN_SPELL); }\n\n        // player or player's pet resilience (-1%)\n        uint32 GetMeleeCritDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_CRIT_TAKEN_MELEE, 2.2f, 33.0f, damage); }\n        uint32 GetRangedCritDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_CRIT_TAKEN_RANGED, 2.2f, 33.0f, damage); }\n        uint32 GetSpellCritDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_CRIT_TAKEN_SPELL, 2.2f, 33.0f, damage); }\n\n        // player or player's pet resilience (-1%), cap 100%\n        uint32 GetMeleeDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_CRIT_TAKEN_MELEE, 2.0f, 100.0f, damage); }\n        uint32 GetRangedDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_CRIT_TAKEN_RANGED, 2.0f, 100.0f, damage); }\n        uint32 GetSpellDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_CRIT_TAKEN_SPELL, 2.0f, 100.0f, damage); }\n\n        void ApplyResilience(const Unit* victim, float * crit, int32 * damage, bool isCrit, CombatRating type) const;\n\n        float MeleeSpellMissChance(const Unit* victim, WeaponAttackType attType, int32 skillDiff, uint32 spellId) const;\n        SpellMissInfo MeleeSpellHitResult(Unit* victim, SpellInfo const* spell);\n        SpellMissInfo MagicSpellHitResult(Unit* victim, SpellInfo const* spell);\n        SpellMissInfo SpellHitResult(Unit* victim, SpellInfo const* spell, bool canReflect = false);\n\n        float GetUnitDodgeChance()    const;\n        float GetUnitParryChance()    const;\n        float GetUnitBlockChance()    const;\n        float GetUnitMissChance(WeaponAttackType attType)     const;\n        float GetUnitCriticalChance(WeaponAttackType attackType, const Unit* victim) const;\n        int32 GetMechanicResistChance(const SpellInfo* spell);\n        bool CanUseAttackType(uint8 attacktype) const\n        {\n            switch (attacktype)\n            {\n                case BASE_ATTACK: return !HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED);\n                case OFF_ATTACK: return !HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_DISARM_OFFHAND);\n                case RANGED_ATTACK: return !HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_DISARM_RANGED);\n            }\n            return true;\n        }\n\n        virtual uint32 GetShieldBlockValue() const =0;\n        uint32 GetShieldBlockValue(uint32 soft_cap, uint32 hard_cap) const\n        {\n            uint32 value = GetShieldBlockValue();\n            if (value >= hard_cap)\n            {\n                value = (soft_cap + hard_cap) / 2;\n            }\n            else if (value > soft_cap)\n            {\n                value = soft_cap + ((value - soft_cap) / 2);\n            }\n\n            return value;\n        }\n        uint32 GetUnitMeleeSkill(Unit const* target = NULL) const { return (target ? getLevelForTarget(target) : getLevel()) * 5; }\n        uint32 GetDefenseSkillValue(Unit const* target = NULL) const;\n        uint32 GetWeaponSkillValue(WeaponAttackType attType, Unit const* target = NULL) const;\n        float GetWeaponProcChance() const;\n        float GetPPMProcChance(uint32 WeaponSpeed, float PPM,  const SpellInfo* spellProto) const;\n\n        MeleeHitOutcome RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackType attType) const;\n        MeleeHitOutcome RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackType attType, int32 crit_chance, int32 miss_chance, int32 dodge_chance, int32 parry_chance, int32 block_chance) const;\n\n        bool isVendor()       const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_VENDOR); }\n        bool isTrainer()      const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_TRAINER); }\n        bool isQuestGiver()   const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_QUESTGIVER); }\n        bool isGossip()       const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP); }\n        bool isTaxi()         const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_FLIGHTMASTER); }\n        bool isGuildMaster()  const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_PETITIONER); }\n        bool isBattleMaster() const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_BATTLEMASTER); }\n        bool isBanker()       const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_BANKER); }\n        bool isInnkeeper()    const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_INNKEEPER); }\n        bool isSpiritHealer() const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPIRITHEALER); }\n        bool isSpiritGuide()  const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPIRITGUIDE); }\n        bool isTabardDesigner()const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_TABARDDESIGNER); }\n        bool isAuctioner()    const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_AUCTIONEER); }\n        bool isArmorer()      const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_REPAIR); }\n        bool isServiceProvider() const\n        {\n            return HasFlag(UNIT_NPC_FLAGS,\n                UNIT_NPC_FLAG_VENDOR | UNIT_NPC_FLAG_TRAINER | UNIT_NPC_FLAG_FLIGHTMASTER |\n                UNIT_NPC_FLAG_PETITIONER | UNIT_NPC_FLAG_BATTLEMASTER | UNIT_NPC_FLAG_BANKER |\n                UNIT_NPC_FLAG_INNKEEPER | UNIT_NPC_FLAG_SPIRITHEALER |\n                UNIT_NPC_FLAG_SPIRITGUIDE | UNIT_NPC_FLAG_TABARDDESIGNER | UNIT_NPC_FLAG_AUCTIONEER);\n        }\n        bool isSpiritService() const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPIRITHEALER | UNIT_NPC_FLAG_SPIRITGUIDE); }\n\n        bool isInFlight()  const { return HasUnitState(UNIT_STATE_IN_FLIGHT); }\n\n        bool isInCombat()  const { return HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT); }\n        void CombatStart(Unit* target, bool initialAggro = true);\n        void SetInCombatState(bool PvP, Unit* enemy = NULL);\n        void SetInCombatWith(Unit* enemy);\n        void ClearInCombat();\n        uint32 GetCombatTimer() const { return m_CombatTimer; }\n\n        bool HasAuraTypeWithFamilyFlags(AuraType auraType, uint32 familyName, uint32 familyFlags) const;\n        bool virtual HasSpell(uint32 /*spellID*/) const { return false; }\n        bool HasBreakableByDamageAuraType(AuraType type, uint32 excludeAura = 0) const;\n        bool HasBreakableByDamageCrowdControlAura(Unit* excludeCasterChannel = NULL) const;\n\n        bool HasStealthAura()      const { return HasAuraType(SPELL_AURA_MOD_STEALTH); }\n        bool HasInvisibilityAura() const { return HasAuraType(SPELL_AURA_MOD_INVISIBILITY); }\n        bool isFeared()  const { return HasAuraType(SPELL_AURA_MOD_FEAR); }\n        bool isInRoots() const { return HasAuraType(SPELL_AURA_MOD_ROOT); }\n        bool IsPolymorphed() const;\n\n        bool isFrozen() const;\n\n        bool isTargetableForAttack(bool checkFakeDeath = true) const;\n\n        bool IsValidAttackTarget(Unit const* target) const;\n        bool _IsValidAttackTarget(Unit const* target, SpellInfo const* bySpell, WorldObject const* obj = NULL) const;\n\n        bool IsValidAssistTarget(Unit const* target) const;\n        bool _IsValidAssistTarget(Unit const* target, SpellInfo const* bySpell) const;\n\n        virtual bool IsInWater() const;\n        virtual bool IsUnderWater() const;\n        virtual void UpdateUnderwaterState(Map* m, float x, float y, float z);\n        bool isInAccessiblePlaceFor(Creature const* c) const;\n\n        void SendHealSpellLog(Unit* victim, uint32 SpellID, uint32 Damage, uint32 OverHeal, uint32 Absorb, bool critical = false);\n        int32 HealBySpell(Unit* victim, SpellInfo const* spellInfo, uint32 addHealth, bool critical = false);\n        void SendEnergizeSpellLog(Unit* victim, uint32 SpellID, uint32 Damage, Powers powertype);\n        void EnergizeBySpell(Unit* victim, uint32 SpellID, uint32 Damage, Powers powertype);\n        uint32 SpellNonMeleeDamageLog(Unit* victim, uint32 spellID, uint32 damage);\n\n        void CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo, CustomSpellValues const* value, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);\n        void CastSpell(Unit* victim, uint32 spellId, bool triggered, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);\n        void CastSpell(Unit* victim, uint32 spellId, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);\n        void CastSpell(Unit* victim, SpellInfo const* spellInfo, bool triggered, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);\n        void CastSpell(Unit* victim, SpellInfo const* spellInfo, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);\n        void CastSpell(float x, float y, float z, uint32 spellId, bool triggered, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);\n        void CastSpell(GameObject* go, uint32 spellId, bool triggered, Item* castItem = NULL, AuraEffect* triggeredByAura = NULL, uint64 originalCaster = 0);\n        void CastCustomSpell(Unit* victim, uint32 spellId, int32 const* bp0, int32 const* bp1, int32 const* bp2, bool triggered, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);\n        void CastCustomSpell(uint32 spellId, SpellValueMod mod, int32 value, Unit* victim, bool triggered, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);\n        void CastCustomSpell(uint32 spellId, SpellValueMod mod, int32 value, Unit* victim = NULL, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);\n        void CastCustomSpell(uint32 spellId, CustomSpellValues const &value, Unit* victim = NULL, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);\n        Aura* AddAura(uint32 spellId, Unit* target);\n        Aura* AddAura(SpellInfo const* spellInfo, uint8 effMask, Unit* target);\n        void SetAuraStack(uint32 spellId, Unit* target, uint32 stack);\n        void SendPlaySpellVisual(uint32 id);\n        void SendPlaySpellImpact(uint64 guid, uint32 id);\n\n        void DeMorph();\n\n        void SendAttackStateUpdate(CalcDamageInfo* damageInfo);\n        void SendAttackStateUpdate(uint32 HitInfo, Unit* target, uint8 SwingType, SpellSchoolMask damageSchoolMask, uint32 Damage, uint32 AbsorbDamage, uint32 Resist, VictimState TargetState, uint32 BlockedAmount);\n        void SendSpellNonMeleeDamageLog(SpellNonMeleeDamage* log);\n        void SendSpellNonMeleeDamageLog(Unit* target, uint32 SpellID, uint32 Damage, SpellSchoolMask damageSchoolMask, uint32 AbsorbedDamage, uint32 Resist, bool PhysicalDamage, uint32 Blocked, bool CriticalHit = false);\n        void SendPeriodicAuraLog(SpellPeriodicAuraLogInfo* pInfo);\n        void SendSpellMiss(Unit* target, uint32 spellID, SpellMissInfo missInfo);\n        void SendSpellDamageResist(Unit* target, uint32 spellId);\n        void SendSpellDamageImmune(Unit* target, uint32 spellId);\n\n        void NearTeleportTo(float x, float y, float z, float orientation, bool casting = false);\n        virtual bool UpdatePosition(float x, float y, float z, float ang, bool teleport = false);\n        // returns true if unit's position really changed\n        bool UpdatePosition(const Position &pos, bool teleport = false) { return UpdatePosition(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation(), teleport); }\n        void UpdateOrientation(float orientation);\n        void UpdateHeight(float newZ);\n\n        void KnockbackFrom(float x, float y, float speedXY, float speedZ);\n        void JumpTo(float speedXY, float speedZ, bool forward = true);\n        void JumpTo(WorldObject* obj, float speedZ);\n\n        void MonsterMoveWithSpeed(float x, float y, float z, float speed);\n        //void SetFacing(float ori, WorldObject* obj = NULL);\n        //void SendMonsterMove(float NewPosX, float NewPosY, float NewPosZ, uint8 type, uint32 MovementFlags, uint32 Time, Player* player = NULL);\n        void SendMovementFlagUpdate(bool self = false);\n\n        /*! These methods send the same packet to the client in apply and unapply case.\n            The client-side interpretation of this packet depends on the presence of relevant movementflags\n            which are sent with movementinfo. Furthermore, these packets are broadcast to nearby players as well\n            as the current unit.\n        */\n        void SendMovementHover();\n        void SendMovementFeatherFall();\n        void SendMovementWaterWalking();\n        void SendMovementGravityChange();\n        void SendMovementCanFlyChange();\n\n        bool IsLevitating() const { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_DISABLE_GRAVITY);}\n        bool IsWalking() const { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_WALKING);}\n        virtual bool SetWalk(bool enable);\n        virtual bool SetDisableGravity(bool disable, bool packetOnly = false);\n        bool SetHover(bool enable);\n\n        void SetInFront(Unit const* target);\n        void SetFacingTo(float ori);\n        void SetFacingToObject(WorldObject* object);\n\n        void SendChangeCurrentVictimOpcode(HostileReference* pHostileReference);\n        void SendClearThreatListOpcode();\n        void SendRemoveFromThreatListOpcode(HostileReference* pHostileReference);\n        void SendThreatListUpdate();\n\n        void SendClearTarget();\n\n        void BuildHeartBeatMsg(WorldPacket* data) const;\n\n        bool isAlive() const { return (m_deathState == ALIVE); };\n        bool isDying() const { return (m_deathState == JUST_DIED); };\n        bool isDead() const { return (m_deathState == DEAD || m_deathState == CORPSE); };\n        DeathState getDeathState() { return m_deathState; };\n        virtual void setDeathState(DeathState s);           // overwrited in Creature/Player/Pet\n\n        uint64 GetOwnerGUID() const { return  GetUInt64Value(UNIT_FIELD_SUMMONEDBY); }\n        void SetOwnerGUID(uint64 owner);\n        uint64 GetCreatorGUID() const { return GetUInt64Value(UNIT_FIELD_CREATEDBY); }\n        void SetCreatorGUID(uint64 creator) { SetUInt64Value(UNIT_FIELD_CREATEDBY, creator); }\n        uint64 GetMinionGUID() const { return GetUInt64Value(UNIT_FIELD_SUMMON); }\n        void SetMinionGUID(uint64 guid) { SetUInt64Value(UNIT_FIELD_SUMMON, guid); }\n        uint64 GetCharmerGUID() const { return GetUInt64Value(UNIT_FIELD_CHARMEDBY); }\n        void SetCharmerGUID(uint64 owner) { SetUInt64Value(UNIT_FIELD_CHARMEDBY, owner); }\n        uint64 GetCharmGUID() const { return  GetUInt64Value(UNIT_FIELD_CHARM); }\n        void SetPetGUID(uint64 guid) { m_SummonSlot[SUMMON_SLOT_PET] = guid; }\n        uint64 GetPetGUID() const { return m_SummonSlot[SUMMON_SLOT_PET]; }\n        void SetCritterGUID(uint64 guid) { SetUInt64Value(UNIT_FIELD_CRITTER, guid); }\n        uint64 GetCritterGUID() const { return GetUInt64Value(UNIT_FIELD_CRITTER); }\n\n        bool IsControlledByPlayer() const { return m_ControlledByPlayer; }\n        uint64 GetCharmerOrOwnerGUID() const { return GetCharmerGUID() ? GetCharmerGUID() : GetOwnerGUID(); }\n        uint64 GetCharmerOrOwnerOrOwnGUID() const\n        {\n            if (uint64 guid = GetCharmerOrOwnerGUID())\n                return guid;\n            return GetGUID();\n        }\n        bool isCharmedOwnedByPlayerOrPlayer() const { return IS_PLAYER_GUID(GetCharmerOrOwnerOrOwnGUID()); }\n\n        Player* GetSpellModOwner() const;\n\n        Unit* GetOwner() const;\n        Guardian *GetGuardianPet() const;\n        Minion *GetFirstMinion() const;\n        Unit* GetCharmer() const;\n        Unit* GetCharm() const;\n        Unit* GetCharmerOrOwner() const { return GetCharmerGUID() ? GetCharmer() : GetOwner(); }\n        Unit* GetCharmerOrOwnerOrSelf() const\n        {\n            if (Unit* u = GetCharmerOrOwner())\n                return u;\n\n            return (Unit*)this;\n        }\n        Player* GetCharmerOrOwnerPlayerOrPlayerItself() const;\n        Player* GetAffectingPlayer() const;\n\n        void SetMinion(Minion *minion, bool apply);\n        void GetAllMinionsByEntry(std::list<Creature*>& Minions, uint32 entry);\n        void RemoveAllMinionsByEntry(uint32 entry);\n        void SetCharm(Unit* target, bool apply);\n        Unit* GetNextRandomRaidMemberOrPet(float radius);\n        bool SetCharmedBy(Unit* charmer, CharmType type, AuraApplication const* aurApp = NULL);\n        void RemoveCharmedBy(Unit* charmer);\n        void RestoreFaction();\n\n        ControlList m_Controlled;\n        Unit* GetFirstControlled() const;\n        void RemoveAllControlled();\n\n        bool isCharmed() const { return GetCharmerGUID() != 0; }\n        bool isPossessed() const { return HasUnitState(UNIT_STATE_POSSESSED); }\n        bool isPossessedByPlayer() const { return HasUnitState(UNIT_STATE_POSSESSED) && IS_PLAYER_GUID(GetCharmerGUID()); }\n        bool isPossessing() const\n        {\n            if (Unit* u = GetCharm())\n                return u->isPossessed();\n            else\n                return false;\n        }\n        bool isPossessing(Unit* u) const { return u->isPossessed() && GetCharmGUID() == u->GetGUID(); }\n\n        CharmInfo* GetCharmInfo() { return m_charmInfo; }\n        CharmInfo* InitCharmInfo();\n        void DeleteCharmInfo();\n        void UpdateCharmAI();\n        //Player* GetMoverSource() const;\n        Player* m_movedPlayer;\n        SharedVisionList const& GetSharedVisionList() { return m_sharedVision; }\n        void AddPlayerToVision(Player* player);\n        void RemovePlayerFromVision(Player* player);\n        bool HasSharedVision() const { return !m_sharedVision.empty(); }\n        void RemoveBindSightAuras();\n        void RemoveCharmAuras();\n\n        Pet* CreateTamedPetFrom(Creature* creatureTarget, uint32 spell_id = 0);\n        Pet* CreateTamedPetFrom(uint32 creatureEntry, uint32 spell_id = 0);\n        bool InitTamedPet(Pet* pet, uint8 level, uint32 spell_id);\n\n        // aura apply/remove helpers - you should better not use these\n        Aura* _TryStackingOrRefreshingExistingAura(SpellInfo const* newAura, uint8 effMask, Unit* caster, int32* baseAmount = NULL, Item* castItem = NULL, uint64 casterGUID = 0);\n        void _AddAura(UnitAura* aura, Unit* caster);\n        AuraApplication * _CreateAuraApplication(Aura* aura, uint8 effMask);\n        void _ApplyAuraEffect(Aura* aura, uint8 effIndex);\n        void _ApplyAura(AuraApplication * aurApp, uint8 effMask);\n        void _UnapplyAura(AuraApplicationMap::iterator &i, AuraRemoveMode removeMode);\n        void _UnapplyAura(AuraApplication * aurApp, AuraRemoveMode removeMode);\n        void _RemoveNoStackAuraApplicationsDueToAura(Aura* aura);\n        void _RemoveNoStackAurasDueToAura(Aura* aura);\n        bool _IsNoStackAuraDueToAura(Aura* appliedAura, Aura* existingAura) const;\n        void _RegisterAuraEffect(AuraEffect* aurEff, bool apply);\n\n        // m_ownedAuras container management\n        AuraMap      & GetOwnedAuras()       { return m_ownedAuras; }\n        AuraMap const& GetOwnedAuras() const { return m_ownedAuras; }\n\n        void RemoveOwnedAura(AuraMap::iterator &i, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);\n        void RemoveOwnedAura(uint32 spellId, uint64 casterGUID = 0, uint8 reqEffMask = 0, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);\n        void RemoveOwnedAura(Aura* aura, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);\n\n        Aura* GetOwnedAura(uint32 spellId, uint64 casterGUID = 0, uint64 itemCasterGUID = 0, uint8 reqEffMask = 0, Aura* except = NULL) const;\n\n        // m_appliedAuras container management\n        AuraApplicationMap      & GetAppliedAuras()       { return m_appliedAuras; }\n        AuraApplicationMap const& GetAppliedAuras() const { return m_appliedAuras; }\n\n        void RemoveAura(AuraApplicationMap::iterator &i, AuraRemoveMode mode = AURA_REMOVE_BY_DEFAULT);\n        void RemoveAura(uint32 spellId, uint64 casterGUID = 0, uint8 reqEffMask = 0, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);\n        void RemoveAura(AuraApplication * aurApp, AuraRemoveMode mode = AURA_REMOVE_BY_DEFAULT);\n        void RemoveAura(Aura* aur, AuraRemoveMode mode = AURA_REMOVE_BY_DEFAULT);\n\n        void RemoveAurasDueToSpell(uint32 spellId, uint64 casterGUID = 0, uint8 reqEffMask = 0, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);\n        void RemoveAuraFromStack(uint32 spellId, uint64 casterGUID = 0, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);\n        void RemoveAurasDueToSpellByDispel(uint32 spellId, uint32 dispellerSpellId, uint64 casterGUID, Unit* dispeller, uint8 chargesRemoved = 1);\n        void RemoveAurasDueToSpellBySteal(uint32 spellId, uint64 casterGUID, Unit* stealer);\n        void RemoveAurasDueToItemSpell(Item* castItem, uint32 spellId);\n        void RemoveAurasByType(AuraType auraType, uint64 casterGUID = 0, Aura* except = NULL, bool negative = true, bool positive = true);\n        void RemoveNotOwnSingleTargetAuras(uint32 newPhase = 0x0);\n        void RemoveAurasWithInterruptFlags(uint32 flag, uint32 except = 0);\n        void RemoveAurasWithAttribute(uint32 flags);\n        void RemoveAurasWithFamily(SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID);\n        void RemoveAurasWithMechanic(uint32 mechanic_mask, AuraRemoveMode removemode = AURA_REMOVE_BY_DEFAULT, uint32 except=0);\n        void RemoveMovementImpairingAuras();\n\n        void RemoveAreaAurasDueToLeaveWorld();\n        void RemoveAllAuras();\n        void RemoveArenaAuras();\n        void RemoveAllAurasOnDeath();\n        void RemoveAllAurasRequiringDeadTarget();\n        void RemoveAllAurasExceptType(AuraType type);\n        void DelayOwnedAuras(uint32 spellId, uint64 caster, int32 delaytime);\n\n        void _RemoveAllAuraStatMods();\n        void _ApplyAllAuraStatMods();\n\n        AuraEffectList const& GetAuraEffectsByType(AuraType type) const { return m_modAuras[type]; }\n        AuraList      & GetSingleCastAuras()       { return m_scAuras; }\n        AuraList const& GetSingleCastAuras() const { return m_scAuras; }\n\n        AuraEffect* GetAuraEffect(uint32 spellId, uint8 effIndex, uint64 casterGUID = 0) const;\n        AuraEffect* GetAuraEffectOfRankedSpell(uint32 spellId, uint8 effIndex, uint64 casterGUID = 0) const;\n        AuraEffect* GetAuraEffect(AuraType type, SpellFamilyNames name, uint32 iconId, uint8 effIndex) const; // spell mustn't have familyflags\n        AuraEffect* GetAuraEffect(AuraType type, SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID =0);\n        inline AuraEffect* GetDummyAuraEffect(SpellFamilyNames name, uint32 iconId, uint8 effIndex) const { return GetAuraEffect(SPELL_AURA_DUMMY, name, iconId, effIndex);}\n\n        AuraApplication * GetAuraApplication(uint32 spellId, uint64 casterGUID = 0, uint64 itemCasterGUID = 0, uint8 reqEffMask = 0, AuraApplication * except = NULL) const;\n        Aura* GetAura(uint32 spellId, uint64 casterGUID = 0, uint64 itemCasterGUID = 0, uint8 reqEffMask = 0) const;\n\n        AuraApplication * GetAuraApplicationOfRankedSpell(uint32 spellId, uint64 casterGUID = 0, uint64 itemCasterGUID = 0, uint8 reqEffMask = 0, AuraApplication * except = NULL) const;\n        Aura* GetAuraOfRankedSpell(uint32 spellId, uint64 casterGUID = 0, uint64 itemCasterGUID = 0, uint8 reqEffMask = 0) const;\n\n        void GetDispellableAuraList(Unit* caster, uint32 dispelMask, DispelChargesList& dispelList);\n\n        bool HasAuraEffect(uint32 spellId, uint8 effIndex, uint64 caster = 0) const;\n        uint32 GetAuraCount(uint32 spellId) const;\n        bool HasAura(uint32 spellId, uint64 casterGUID = 0, uint64 itemCasterGUID = 0, uint8 reqEffMask = 0) const;\n        bool HasAuraType(AuraType auraType) const;\n        bool HasAuraTypeWithCaster(AuraType auratype, uint64 caster) const;\n        bool HasAuraTypeWithMiscvalue(AuraType auratype, int32 miscvalue) const;\n        bool HasAuraTypeWithAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const;\n        bool HasAuraTypeWithValue(AuraType auratype, int32 value) const;\n        bool HasNegativeAuraWithInterruptFlag(uint32 flag, uint64 guid = 0);\n        bool HasNegativeAuraWithAttribute(uint32 flag, uint64 guid = 0);\n        bool HasAuraWithMechanic(uint32 mechanicMask);\n\n        AuraEffect* IsScriptOverriden(SpellInfo const* spell, int32 script) const;\n        uint32 GetDiseasesByCaster(uint64 casterGUID, bool remove = false);\n        uint32 GetDoTsByCaster(uint64 casterGUID) const;\n\n        int32 GetTotalAuraModifier(AuraType auratype) const;\n        float GetTotalAuraMultiplier(AuraType auratype) const;\n        int32 GetMaxPositiveAuraModifier(AuraType auratype);\n        int32 GetMaxNegativeAuraModifier(AuraType auratype) const;\n\n        int32 GetTotalAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const;\n        float GetTotalAuraMultiplierByMiscMask(AuraType auratype, uint32 misc_mask) const;\n        int32 GetMaxPositiveAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask, const AuraEffect* except = NULL) const;\n        int32 GetMaxNegativeAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const;\n\n        int32 GetTotalAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const;\n        float GetTotalAuraMultiplierByMiscValue(AuraType auratype, int32 misc_value) const;\n        int32 GetMaxPositiveAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const;\n        int32 GetMaxNegativeAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const;\n\n        int32 GetTotalAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const;\n        float GetTotalAuraMultiplierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const;\n        int32 GetMaxPositiveAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const;\n        int32 GetMaxNegativeAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const;\n\n        float GetResistanceBuffMods(SpellSchools school, bool positive) const { return GetFloatValue(positive ? UNIT_FIELD_RESISTANCEBUFFMODSPOSITIVE+school : UNIT_FIELD_RESISTANCEBUFFMODSNEGATIVE+school); }\n        void SetResistanceBuffMods(SpellSchools school, bool positive, float val) { SetFloatValue(positive ? UNIT_FIELD_RESISTANCEBUFFMODSPOSITIVE+school : UNIT_FIELD_RESISTANCEBUFFMODSNEGATIVE+school, val); }\n        void ApplyResistanceBuffModsMod(SpellSchools school, bool positive, float val, bool apply) { ApplyModSignedFloatValue(positive ? UNIT_FIELD_RESISTANCEBUFFMODSPOSITIVE+school : UNIT_FIELD_RESISTANCEBUFFMODSNEGATIVE+school, val, apply); }\n        void ApplyResistanceBuffModsPercentMod(SpellSchools school, bool positive, float val, bool apply) { ApplyPercentModFloatValue(positive ? UNIT_FIELD_RESISTANCEBUFFMODSPOSITIVE+school : UNIT_FIELD_RESISTANCEBUFFMODSNEGATIVE+school, val, apply); }\n        void InitStatBuffMods()\n        {\n            for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i) SetFloatValue(UNIT_FIELD_POSSTAT0+i, 0);\n            for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i) SetFloatValue(UNIT_FIELD_NEGSTAT0+i, 0);\n        }\n        void ApplyStatBuffMod(Stats stat, float val, bool apply) { ApplyModSignedFloatValue((val > 0 ? UNIT_FIELD_POSSTAT0+stat : UNIT_FIELD_NEGSTAT0+stat), val, apply); }\n        void ApplyStatPercentBuffMod(Stats stat, float val, bool apply)\n        {\n            ApplyPercentModFloatValue(UNIT_FIELD_POSSTAT0+stat, val, apply);\n            ApplyPercentModFloatValue(UNIT_FIELD_NEGSTAT0+stat, val, apply);\n        }\n        void SetCreateStat(Stats stat, float val) { m_createStats[stat] = val; }\n        void SetCreateHealth(uint32 val) { SetUInt32Value(UNIT_FIELD_BASE_HEALTH, val); }\n        uint32 GetCreateHealth() const { return GetUInt32Value(UNIT_FIELD_BASE_HEALTH); }\n        void SetCreateMana(uint32 val) { SetUInt32Value(UNIT_FIELD_BASE_MANA, val); }\n        uint32 GetCreateMana() const { return GetUInt32Value(UNIT_FIELD_BASE_MANA); }\n        uint32 GetCreatePowers(Powers power) const;\n        float GetPosStat(Stats stat) const { return GetFloatValue(UNIT_FIELD_POSSTAT0+stat); }\n        float GetNegStat(Stats stat) const { return GetFloatValue(UNIT_FIELD_NEGSTAT0+stat); }\n        float GetCreateStat(Stats stat) const { return m_createStats[stat]; }\n\n        void SetCurrentCastedSpell(Spell* pSpell);\n        virtual void ProhibitSpellSchool(SpellSchoolMask /*idSchoolMask*/, uint32 /*unTimeMs*/) { }\n        void InterruptSpell(CurrentSpellTypes spellType, bool withDelayed = true, bool withInstant = true);\n        void FinishSpell(CurrentSpellTypes spellType, bool ok = true);\n\n        // set withDelayed to true to account delayed spells as casted\n        // delayed+channeled spells are always accounted as casted\n        // we can skip channeled or delayed checks using flags\n        bool IsNonMeleeSpellCasted(bool withDelayed, bool skipChanneled = false, bool skipAutorepeat = false, bool isAutoshoot = false, bool skipInstant = true) const;\n\n        // set withDelayed to true to interrupt delayed spells too\n        // delayed+channeled spells are always interrupted\n        void InterruptNonMeleeSpells(bool withDelayed, uint32 spellid = 0, bool withInstant = true);\n\n        Spell* GetCurrentSpell(CurrentSpellTypes spellType) const { return m_currentSpells[spellType]; }\n        Spell* GetCurrentSpell(uint32 spellType) const { return m_currentSpells[spellType]; }\n        Spell* FindCurrentSpellBySpellId(uint32 spell_id) const;\n        int32 GetCurrentSpellCastTime(uint32 spell_id) const;\n\n        uint32 m_addDmgOnce;\n        uint64 m_SummonSlot[MAX_SUMMON_SLOT];\n        uint64 m_ObjectSlot[MAX_GAMEOBJECT_SLOT];\n\n        ShapeshiftForm GetShapeshiftForm() const { return ShapeshiftForm(GetByteValue(UNIT_FIELD_BYTES_2, 3)); }\n        void SetShapeshiftForm(ShapeshiftForm form)\n        {\n            SetByteValue(UNIT_FIELD_BYTES_2, 3, form);\n        }\n\n        inline bool IsInFeralForm() const\n        {\n            ShapeshiftForm form = GetShapeshiftForm();\n            return form == FORM_CAT || form == FORM_BEAR || form == FORM_DIREBEAR;\n        }\n\n        inline bool IsInDisallowedMountForm() const\n        {\n            ShapeshiftForm form = GetShapeshiftForm();\n            return form != FORM_NONE && form != FORM_BATTLESTANCE && form != FORM_BERSERKERSTANCE && form != FORM_DEFENSIVESTANCE &&\n                form != FORM_SHADOW && form != FORM_STEALTH && form != FORM_UNDEAD;\n        }\n\n        float m_modMeleeHitChance;\n        float m_modRangedHitChance;\n        float m_modSpellHitChance;\n        int32 m_baseSpellCritChance;\n\n        float m_threatModifier[MAX_SPELL_SCHOOL];\n        float m_modAttackSpeedPct[3];\n\n        // Event handler\n        EventProcessor m_Events;\n\n        // stat system\n        bool HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, float amount, bool apply);\n        void SetModifierValue(UnitMods unitMod, UnitModifierType modifierType, float value) { m_auraModifiersGroup[unitMod][modifierType] = value; }\n        float GetModifierValue(UnitMods unitMod, UnitModifierType modifierType) const;\n        float GetTotalStatValue(Stats stat) const;\n        float GetTotalAuraModValue(UnitMods unitMod) const;\n        SpellSchools GetSpellSchoolByAuraGroup(UnitMods unitMod) const;\n        Stats GetStatByAuraGroup(UnitMods unitMod) const;\n        Powers GetPowerTypeByAuraGroup(UnitMods unitMod) const;\n        bool CanModifyStats() const { return m_canModifyStats; }\n        void SetCanModifyStats(bool modifyStats) { m_canModifyStats = modifyStats; }\n        virtual bool UpdateStats(Stats stat) = 0;\n        virtual bool UpdateAllStats() = 0;\n        virtual void UpdateResistances(uint32 school) = 0;\n        virtual void UpdateArmor() = 0;\n        virtual void UpdateMaxHealth() = 0;\n        virtual void UpdateMaxPower(Powers power) = 0;\n        virtual void UpdateAttackPowerAndDamage(bool ranged = false) = 0;\n        virtual void UpdateDamagePhysical(WeaponAttackType attType) = 0;\n        float GetTotalAttackPowerValue(WeaponAttackType attType) const;\n        float GetWeaponDamageRange(WeaponAttackType attType, WeaponDamageRange type) const;\n        void SetBaseWeaponDamage(WeaponAttackType attType, WeaponDamageRange damageRange, float value) { m_weaponDamage[attType][damageRange] = value; }\n\n        bool isInFrontInMap(Unit const* target, float distance, float arc = M_PI) const;\n        bool isInBackInMap(Unit const* target, float distance, float arc = M_PI) const;\n\n        // Visibility system\n        bool IsVisible() const { return (m_serverSideVisibility.GetValue(SERVERSIDE_VISIBILITY_GM) > SEC_PLAYER) ? false : true; }\n        void SetVisible(bool x);\n\n        // common function for visibility checks for player/creatures with detection code\n        void SetPhaseMask(uint32 newPhaseMask, bool update);// overwrite WorldObject::SetPhaseMask\n        void UpdateObjectVisibility(bool forced = true);\n\n        SpellImmuneList m_spellImmune[MAX_SPELL_IMMUNITY];\n        uint32 m_lastSanctuaryTime;\n\n        // Threat related methods\n        bool CanHaveThreatList() const;\n        void AddThreat(Unit* victim, float fThreat, SpellSchoolMask schoolMask = SPELL_SCHOOL_MASK_NORMAL, SpellInfo const* threatSpell = NULL);\n        float ApplyTotalThreatModifier(float fThreat, SpellSchoolMask schoolMask = SPELL_SCHOOL_MASK_NORMAL);\n        void DeleteThreatList();\n        void TauntApply(Unit* victim);\n        void TauntFadeOut(Unit* taunter);\n        ThreatManager& getThreatManager() { return m_ThreatManager; }\n        void addHatedBy(HostileReference* pHostileReference) { m_HostileRefManager.insertFirst(pHostileReference); };\n        void removeHatedBy(HostileReference* /*pHostileReference*/) { /* nothing to do yet */ }\n        HostileRefManager& getHostileRefManager() { return m_HostileRefManager; }\n\n        VisibleAuraMap const* GetVisibleAuras() { return &m_visibleAuras; }\n        AuraApplication * GetVisibleAura(uint8 slot)\n        {\n            VisibleAuraMap::iterator itr = m_visibleAuras.find(slot);\n            if (itr != m_visibleAuras.end())\n                return itr->second;\n            return 0;\n        }\n        void SetVisibleAura(uint8 slot, AuraApplication * aur){ m_visibleAuras[slot]=aur; UpdateAuraForGroup(slot);}\n        void RemoveVisibleAura(uint8 slot){ m_visibleAuras.erase(slot); UpdateAuraForGroup(slot);}\n\n        uint32 GetInterruptMask() const { return m_interruptMask; }\n        void AddInterruptMask(uint32 mask) { m_interruptMask |= mask; }\n        void UpdateInterruptMask();\n\n        uint32 GetDisplayId() { return GetUInt32Value(UNIT_FIELD_DISPLAYID); }\n        void SetDisplayId(uint32 modelId);\n        uint32 GetNativeDisplayId() { return GetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID); }\n        void RestoreDisplayId();\n        void SetNativeDisplayId(uint32 modelId) { SetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID, modelId); }\n        void setTransForm(uint32 spellid) { m_transform = spellid;}\n        uint32 getTransForm() const { return m_transform;}\n\n        // DynamicObject management\n        void _RegisterDynObject(DynamicObject* dynObj);\n        void _UnregisterDynObject(DynamicObject* dynObj);\n        DynamicObject* GetDynObject(uint32 spellId);\n        void RemoveDynObject(uint32 spellId);\n        void RemoveAllDynObjects();\n\n        GameObject* GetGameObject(uint32 spellId) const;\n        void AddGameObject(GameObject* gameObj);\n        void RemoveGameObject(GameObject* gameObj, bool del);\n        void RemoveGameObject(uint32 spellid, bool del);\n        void RemoveAllGameObjects();\n\n        uint32 CalculateDamage(WeaponAttackType attType, bool normalized, bool addTotalPct);\n        float GetAPMultiplier(WeaponAttackType attType, bool normalized);\n        void ModifyAuraState(AuraStateType flag, bool apply);\n        uint32 BuildAuraStateUpdateForTarget(Unit* target) const;\n        bool HasAuraState(AuraStateType flag, SpellInfo const* spellProto = NULL, Unit const* Caster = NULL) const;\n        void UnsummonAllTotems();\n        Unit* GetMagicHitRedirectTarget(Unit* victim, SpellInfo const* spellInfo);\n        Unit* GetMeleeHitRedirectTarget(Unit* victim, SpellInfo const* spellInfo = NULL);\n\n        int32 SpellBaseDamageBonusDone(SpellSchoolMask schoolMask);\n        int32 SpellBaseDamageBonusTaken(SpellSchoolMask schoolMask);\n        uint32 SpellDamageBonusDone(Unit* victim, SpellInfo const *spellProto, uint32 pdamage, DamageEffectType damagetype, uint32 stack = 1);\n        uint32 SpellDamageBonusTaken(Unit* caster, SpellInfo const *spellProto, uint32 pdamage, DamageEffectType damagetype, uint32 stack = 1);\n        int32 SpellBaseHealingBonusDone(SpellSchoolMask schoolMask);\n        int32 SpellBaseHealingBonusTaken(SpellSchoolMask schoolMask);\n        uint32 SpellHealingBonusDone(Unit* victim, SpellInfo const *spellProto, uint32 healamount, DamageEffectType damagetype, uint32 stack = 1);\n        uint32 SpellHealingBonusTaken(Unit* caster, SpellInfo const *spellProto, uint32 healamount, DamageEffectType damagetype, uint32 stack = 1);\n\n        uint32 MeleeDamageBonusDone(Unit *pVictim, uint32 damage, WeaponAttackType attType, SpellInfo const *spellProto = NULL);\n        uint32 MeleeDamageBonusTaken(Unit* attacker, uint32 pdamage,WeaponAttackType attType, SpellInfo const *spellProto = NULL);\n\n\n        bool   isSpellBlocked(Unit* victim, SpellInfo const* spellProto, WeaponAttackType attackType = BASE_ATTACK);\n        bool   isBlockCritical();\n        bool   isSpellCrit(Unit* victim, SpellInfo const* spellProto, SpellSchoolMask schoolMask, WeaponAttackType attackType = BASE_ATTACK) const;\n        uint32 SpellCriticalDamageBonus(SpellInfo const* spellProto, uint32 damage, Unit* victim);\n        uint32 SpellCriticalHealingBonus(SpellInfo const* spellProto, uint32 damage, Unit* victim);\n\n        void SetLastManaUse(uint32 spellCastTime) { m_lastManaUse = spellCastTime; }\n        bool IsUnderLastManaUseEffect() const;\n\n        void SetContestedPvP(Player* attackedPlayer = NULL);\n\n        uint32 GetCastingTimeForBonus(SpellInfo const* spellProto, DamageEffectType damagetype, uint32 CastingTime) const;\n        float CalculateDefaultCoefficient(SpellInfo const *spellInfo, DamageEffectType damagetype) const;\n\n        uint32 GetRemainingPeriodicAmount(uint64 caster, uint32 spellId, AuraType auraType, uint8 effectIndex = 0) const;\n\n        void ApplySpellImmune(uint32 spellId, uint32 op, uint32 type, bool apply);\n        void ApplySpellDispelImmunity(const SpellInfo* spellProto, DispelType type, bool apply);\n        virtual bool IsImmunedToSpell(SpellInfo const* spellInfo);\n                                                            // redefined in Creature\n        bool IsImmunedToDamage(SpellSchoolMask meleeSchoolMask);\n        bool IsImmunedToDamage(SpellInfo const* spellInfo);\n        virtual bool IsImmunedToSpellEffect(SpellInfo const* spellInfo, uint32 index) const;\n                                                            // redefined in Creature\n        static bool IsDamageReducedByArmor(SpellSchoolMask damageSchoolMask, SpellInfo const* spellInfo = NULL, uint8 effIndex = MAX_SPELL_EFFECTS);\n        uint32 CalcArmorReducedDamage(Unit* victim, const uint32 damage, SpellInfo const* spellInfo, WeaponAttackType attackType=MAX_ATTACK);\n        void CalcAbsorbResist(Unit* victim, SpellSchoolMask schoolMask, DamageEffectType damagetype, const uint32 damage, uint32 *absorb, uint32 *resist, SpellInfo const* spellInfo = NULL);\n        void CalcHealAbsorb(Unit* victim, const SpellInfo* spellProto, uint32 &healAmount, uint32 &absorb);\n\n        void  UpdateSpeed(UnitMoveType mtype, bool forced);\n        float GetSpeed(UnitMoveType mtype) const;\n        float GetSpeedRate(UnitMoveType mtype) const { return m_speed_rate[mtype]; }\n        void SetSpeed(UnitMoveType mtype, float rate, bool forced = false);\n        float m_TempSpeed;\n\n        bool isHover() const { return HasAuraType(SPELL_AURA_HOVER); }\n\n        float ApplyEffectModifiers(SpellInfo const* spellProto, uint8 effect_index, float value) const;\n        int32 CalculateSpellDamage(Unit const* target, SpellInfo const* spellProto, uint8 effect_index, int32 const* basePoints = NULL) const;\n        int32 CalcSpellDuration(SpellInfo const* spellProto);\n        int32 ModSpellDuration(SpellInfo const* spellProto, Unit const* target, int32 duration, bool positive, uint32 effectMask);\n        void  ModSpellCastTime(SpellInfo const* spellProto, int32 & castTime, Spell* spell=NULL);\n        float CalculateLevelPenalty(SpellInfo const* spellProto) const;\n\n        void addFollower(FollowerReference* pRef) { m_FollowingRefManager.insertFirst(pRef); }\n        void removeFollower(FollowerReference* /*pRef*/) { /* nothing to do yet */ }\n        static Unit* GetUnit(WorldObject& object, uint64 guid);\n        static Player* GetPlayer(WorldObject& object, uint64 guid);\n        static Creature* GetCreature(WorldObject& object, uint64 guid);\n\n        MotionMaster* GetMotionMaster() { return &i_motionMaster; }\n        const MotionMaster* GetMotionMaster() const { return &i_motionMaster; }\n\n        bool IsStopped() const { return !(HasUnitState(UNIT_STATE_MOVING)); }\n        void StopMoving();\n\n        void AddUnitMovementFlag(uint32 f) { m_movementInfo.flags |= f; }\n        void RemoveUnitMovementFlag(uint32 f) { m_movementInfo.flags &= ~f; }\n        bool HasUnitMovementFlag(uint32 f) const { return (m_movementInfo.flags & f) == f; }\n        uint32 GetUnitMovementFlags() const { return m_movementInfo.flags; }\n        void SetUnitMovementFlags(uint32 f) { m_movementInfo.flags = f; }\n\n        void AddExtraUnitMovementFlag(uint16 f) { m_movementInfo.flags2 |= f; }\n        void RemoveExtraUnitMovementFlag(uint16 f) { m_movementInfo.flags2 &= ~f; }\n        uint16 HasExtraUnitMovementFlag(uint16 f) const { return m_movementInfo.flags2 & f; }\n        uint16 GetExtraUnitMovementFlags() const { return m_movementInfo.flags2; }\n        void SetExtraUnitMovementFlags(uint16 f) { m_movementInfo.flags2 = f; }\n\n        float GetPositionZMinusOffset() const\n        {\n            float offset = 0.0f;\n            if (HasUnitMovementFlag(MOVEMENTFLAG_HOVER))\n                offset = GetFloatValue(UNIT_FIELD_HOVERHEIGHT);\n\n            return GetPositionZ() - offset;\n        }\n\n        void SetControlled(bool apply, UnitState state);\n\n        void AddComboPointHolder(uint32 lowguid) { m_ComboPointHolders.insert(lowguid); }\n        void RemoveComboPointHolder(uint32 lowguid) { m_ComboPointHolders.erase(lowguid); }\n        void ClearComboPointHolders();\n\n        ///----------Pet responses methods-----------------\n        void SendPetCastFail(uint32 spellid, SpellCastResult msg);\n        void SendPetActionFeedback (uint8 msg);\n        void SendPetTalk (uint32 pettalk);\n        void SendPetAIReaction(uint64 guid);\n        ///----------End of Pet responses methods----------\n\n        void propagateSpeedChange() { GetMotionMaster()->propagateSpeedChange(); }\n\n        // reactive attacks\n        void ClearAllReactives();\n        void StartReactiveTimer(ReactiveType reactive) { m_reactiveTimer[reactive] = REACTIVE_TIMER_START;}\n        void UpdateReactives(uint32 p_time);\n\n        // group updates\n        void UpdateAuraForGroup(uint8 slot);\n\n        // proc trigger system\n        bool CanProc(){return !m_procDeep;}\n        void SetCantProc(bool apply)\n        {\n            if (apply)\n                ++m_procDeep;\n            else\n            {\n                ASSERT(m_procDeep);\n                --m_procDeep;\n            }\n        }\n\n        // pet auras\n        typedef std::set<PetAura const*> PetAuraSet;\n        PetAuraSet m_petAuras;\n        void AddPetAura(PetAura const* petSpell);\n        void RemovePetAura(PetAura const* petSpell);\n\n        uint32 GetModelForForm(ShapeshiftForm form);\n        uint32 GetModelForTotem(PlayerTotemType totemType);\n\n        void SetReducedThreatPercent(uint32 pct, uint64 guid)\n        {\n            m_reducedThreatPercent = pct;\n            m_misdirectionTargetGUID = guid;\n        }\n        uint32 GetReducedThreatPercent() { return m_reducedThreatPercent; }\n        Unit* GetMisdirectionTarget() { return m_misdirectionTargetGUID ? GetUnit(*this, m_misdirectionTargetGUID) : NULL; }\n\n        bool IsAIEnabled, NeedChangeAI;\n        bool CreateVehicleKit(uint32 id, uint32 creatureEntry);\n        void RemoveVehicleKit();\n        Vehicle* GetVehicleKit()const { return m_vehicleKit; }\n        Vehicle* GetVehicle()   const { return m_vehicle; }\n        bool IsOnVehicle(const Unit* vehicle) const { return m_vehicle && m_vehicle == vehicle->GetVehicleKit(); }\n        Unit* GetVehicleBase()  const;\n        Creature* GetVehicleCreatureBase() const;\n        float GetTransOffsetX() const { return m_movementInfo.t_pos.GetPositionX(); }\n        float GetTransOffsetY() const { return m_movementInfo.t_pos.GetPositionY(); }\n        float GetTransOffsetZ() const { return m_movementInfo.t_pos.GetPositionZ(); }\n        float GetTransOffsetO() const { return m_movementInfo.t_pos.GetOrientation(); }\n        uint32 GetTransTime()   const { return m_movementInfo.t_time; }\n        int8 GetTransSeat()     const { return m_movementInfo.t_seat; }\n        uint64 GetTransGUID()   const;\n        /// Returns the transport this unit is on directly (if on vehicle and transport, return vehicle)\n        TransportBase* GetDirectTransport() const;\n\n        bool m_ControlledByPlayer;\n\n        bool HandleSpellClick(Unit* clicker, int8 seatId = -1);\n        void EnterVehicle(Unit* base, int8 seatId = -1);\n        void ExitVehicle(Position const* exitPosition = NULL);\n        void ChangeSeat(int8 seatId, bool next = true);\n\n        // Should only be called by AuraEffect::HandleAuraControlVehicle(AuraApplication const* auraApp, uint8 mode, bool apply) const;\n        void _ExitVehicle(Position const* exitPosition = NULL);\n        void _EnterVehicle(Vehicle* vehicle, int8 seatId, AuraApplication const* aurApp = NULL);\n\n        void BuildMovementPacket(ByteBuffer *data) const;\n\n        bool isMoving() const   { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_MASK_MOVING); }\n        bool isTurning() const  { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_MASK_TURNING); }\n        virtual bool CanFly() const = 0;\n        bool IsFlying() const   { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_FLYING | MOVEMENTFLAG_DISABLE_GRAVITY); }\n        void SetCanFly(bool apply);\n\n        void RewardRage(uint32 damage, uint32 weaponSpeedHitFactor, bool attacker);\n\n        virtual float GetFollowAngle() const { return static_cast<float>(M_PI/2); }\n\n        void OutDebugInfo() const;\n        virtual bool isBeingLoaded() const { return false;}\n        bool IsDuringRemoveFromWorld() const {return m_duringRemoveFromWorld;}\n\n        Pet* ToPet(){ if (isPet()) return reinterpret_cast<Pet*>(this); else return NULL; }\n        Totem* ToTotem(){ if (isTotem()) return reinterpret_cast<Totem*>(this); else return NULL; }\n        TempSummon* ToTempSummon() { if (isSummon()) return reinterpret_cast<TempSummon*>(this); else return NULL; }\n        const TempSummon* ToTempSummon() const { if (isSummon()) return reinterpret_cast<const TempSummon*>(this); else return NULL; }\n\n        void SetTarget(uint64 guid)\n        {\n            if (!_focusSpell)\n                SetUInt64Value(UNIT_FIELD_TARGET, guid);\n        }\n\n        // Handling caster facing during spellcast\n        void FocusTarget(Spell const* focusSpell, uint64 target);\n        void ReleaseFocus(Spell const* focusSpell);\n\n        // Movement info\n        Movement::MoveSpline * movespline;\n\n        // Part of Evade mechanics\n        time_t GetLastDamagedTime() const { return _lastDamagedTime; }\n        void SetLastDamagedTime(time_t val) { _lastDamagedTime = val; }\n\n    protected:\n        explicit Unit (bool isWorldObject);\n\n        UnitAI* i_AI, *i_disabledAI;\n\n        void _UpdateSpells(uint32 time);\n        void _DeleteRemovedAuras();\n\n        void _UpdateAutoRepeatSpell();\n\n        bool m_AutoRepeatFirstCast;\n\n        uint32 m_attackTimer[MAX_ATTACK];\n\n        float m_createStats[MAX_STATS];\n\n        AttackerSet m_attackers;\n        Unit* m_attacking;\n\n        DeathState m_deathState;\n\n        int32 m_procDeep;\n\n        typedef std::list<DynamicObject*> DynObjectList;\n        DynObjectList m_dynObj;\n\n        typedef std::list<GameObject*> GameObjectList;\n        GameObjectList m_gameObj;\n        bool m_isSorted;\n        uint32 m_transform;\n\n        Spell* m_currentSpells[CURRENT_MAX_SPELL];\n\n        AuraMap m_ownedAuras;\n        AuraApplicationMap m_appliedAuras;\n        AuraList m_removedAuras;\n        AuraMap::iterator m_auraUpdateIterator;\n        uint32 m_removedAurasCount;\n\n        AuraEffectList m_modAuras[TOTAL_AURAS];\n        AuraList m_scAuras;                        // casted singlecast auras\n        AuraApplicationList m_interruptableAuras;             // auras which have interrupt mask applied on unit\n        AuraStateAurasMap m_auraStateAuras;        // Used for improve performance of aura state checks on aura apply/remove\n        uint32 m_interruptMask;\n\n        float m_auraModifiersGroup[UNIT_MOD_END][MODIFIER_TYPE_END];\n        float m_weaponDamage[MAX_ATTACK][2];\n        bool m_canModifyStats;\n        VisibleAuraMap m_visibleAuras;\n\n        float m_speed_rate[MAX_MOVE_TYPE];\n\n        CharmInfo* m_charmInfo;\n        SharedVisionList m_sharedVision;\n\n        virtual SpellSchoolMask GetMeleeDamageSchoolMask() const;\n\n        MotionMaster i_motionMaster;\n\n        uint32 m_reactiveTimer[MAX_REACTIVE];\n        uint32 m_regenTimer;\n\n        ThreatManager m_ThreatManager;\n\n        Vehicle* m_vehicle;\n        Vehicle* m_vehicleKit;\n\n        uint32 m_unitTypeMask;\n        LiquidTypeEntry const* _lastLiquid;\n\n        bool IsAlwaysVisibleFor(WorldObject const* seer) const;\n        bool IsAlwaysDetectableFor(WorldObject const* seer) const;\n\n        void DisableSpline();\n    private:\n        bool IsTriggeredAtSpellProcEvent(Unit* victim, Aura* aura, SpellInfo const* procSpell, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, bool isVictim, bool active, SpellProcEventEntry const* & spellProcEvent);\n        bool HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown);\n        bool HandleHasteAuraProc(Unit* victim, uint32 damage, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown);\n        bool HandleSpellCritChanceAuraProc(Unit* victim, uint32 damage, AuraEffect* triggredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown);\n        bool HandleObsModEnergyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown);\n        bool HandleModDamagePctTakenAuraProc(Unit* victim, uint32 damage, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown);\n        bool HandleAuraProc(Unit* victim, uint32 damage, Aura* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown, bool * handled);\n        bool HandleProcTriggerSpell(Unit* victim, uint32 damage, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown);\n        bool HandleOverrideClassScriptAuraProc(Unit* victim, uint32 damage, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 cooldown);\n        bool HandleAuraRaidProcFromChargeWithValue(AuraEffect* triggeredByAura);\n        bool HandleAuraRaidProcFromCharge(AuraEffect* triggeredByAura);\n\n        void UpdateSplineMovement(uint32 t_diff);\n\n        // player or player's pet\n        float GetCombatRatingReduction(CombatRating cr) const;\n        uint32 GetCombatRatingDamageReduction(CombatRating cr, float rate, float cap, uint32 damage) const;\n\n        void SetFeared(bool apply);\n        void SetConfused(bool apply);\n        void SetStunned(bool apply);\n        void SetRooted(bool apply);\n\n        uint32 m_rootTimes;\n\n        uint32 m_state;                                     // Even derived shouldn't modify\n        uint32 m_CombatTimer;\n        uint32 m_lastManaUse;                               // msecs\n        TimeTrackerSmall m_movesplineTimer;\n\n        Diminishing m_Diminishing;\n        // Manage all Units that are threatened by us\n        HostileRefManager m_HostileRefManager;\n\n        FollowerRefManager m_FollowingRefManager;\n\n        ComboPointHolderSet m_ComboPointHolders;\n\n        uint32 m_reducedThreatPercent;\n        uint64 m_misdirectionTargetGUID;\n\n        bool m_cleanupDone; // lock made to not add stuff after cleanup before delete\n        bool m_duringRemoveFromWorld; // lock made to not add stuff after begining removing from world\n\n        Spell const* _focusSpell;   ///> Locks the target during spell cast for proper facing\n        bool _isWalkingBeforeCharm; // Are we walking before we were charmed?\n\n        time_t _lastDamagedTime; // Part of Evade mechanics\n};\n\nnamespace Trinity\n{\n    // Binary predicate for sorting Units based on percent value of a power\n    class PowerPctOrderPred\n    {\n        public:\n            PowerPctOrderPred(Powers power, bool ascending = true) : m_power(power), m_ascending(ascending) {}\n            bool operator() (const Unit* a, const Unit* b) const\n            {\n                float rA = a->GetMaxPower(m_power) ? float(a->GetPower(m_power)) / float(a->GetMaxPower(m_power)) : 0.0f;\n                float rB = b->GetMaxPower(m_power) ? float(b->GetPower(m_power)) / float(b->GetMaxPower(m_power)) : 0.0f;\n                return m_ascending ? rA < rB : rA > rB;\n            }\n        private:\n            const Powers m_power;\n            const bool m_ascending;\n    };\n\n    // Binary predicate for sorting Units based on percent value of health\n    class HealthPctOrderPred\n    {\n        public:\n            HealthPctOrderPred(bool ascending = true) : m_ascending(ascending) {}\n            bool operator() (const Unit* a, const Unit* b) const\n            {\n                float rA = a->GetMaxHealth() ? float(a->GetHealth()) / float(a->GetMaxHealth()) : 0.0f;\n                float rB = b->GetMaxHealth() ? float(b->GetHealth()) / float(b->GetMaxHealth()) : 0.0f;\n                return m_ascending ? rA < rB : rA > rB;\n            }\n        private:\n            const bool m_ascending;\n    };\n}\n#endif\n"]],"start1":0,"start2":0,"length1":0,"length2":115891}]],"length":115891}
