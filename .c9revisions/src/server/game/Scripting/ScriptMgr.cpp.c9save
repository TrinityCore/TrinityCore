{"ts":1348522039448,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>\n * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"ScriptMgr.h\"\n#include \"Config.h\"\n#include \"DatabaseEnv.h\"\n#include \"DBCStores.h\"\n#include \"ObjectMgr.h\"\n#include \"OutdoorPvPMgr.h\"\n#include \"ScriptLoader.h\"\n#include \"ScriptSystem.h\"\n#include \"Transport.h\"\n#include \"Vehicle.h\"\n#include \"SpellInfo.h\"\n#include \"SpellScript.h\"\n#include \"GossipDef.h\"\n#include \"CreatureAI.h\"\n\n// This is the global static registry of scripts.\ntemplate<class TScript>\nclass ScriptRegistry\n{\n    public:\n\n        typedef std::map<uint32, TScript*> ScriptMap;\n        typedef typename ScriptMap::iterator ScriptMapIterator;\n\n        // The actual list of scripts. This will be accessed concurrently, so it must not be modified\n        // after server startup.\n        static ScriptMap ScriptPointerList;\n\n        static void AddScript(TScript* const script)\n        {\n            ASSERT(script);\n\n            // See if the script is using the same memory as another script. If this happens, it means that\n            // someone forgot to allocate new memory for a script.\n            for (ScriptMapIterator it = ScriptPointerList.begin(); it != ScriptPointerList.end(); ++it)\n            {\n                if (it->second == script)\n                {\n                    sLog->outError(LOG_FILTER_TSCR, \"Script '%s' has same memory pointer as '%s'.\",\n                        script->GetName().c_str(), it->second->GetName().c_str());\n\n                    return;\n                }\n            }\n\n            if (script->IsDatabaseBound())\n            {\n                // Get an ID for the script. An ID only exists if it's a script that is assigned in the database\n                // through a script name (or similar).\n                uint32 id = sObjectMgr->GetScriptId(script->GetName().c_str());\n                if (id)\n                {\n                    // Try to find an existing script.\n                    bool existing = false;\n                    for (ScriptMapIterator it = ScriptPointerList.begin(); it != ScriptPointerList.end(); ++it)\n                    {\n                        // If the script names match...\n                        if (it->second->GetName() == script->GetName())\n                        {\n                            // ... It exists.\n                            existing = true;\n                            break;\n                        }\n                    }\n\n                    // If the script isn't assigned -> assign it!\n                    if (!existing)\n                    {\n                        ScriptPointerList[id] = script;\n                        sScriptMgr->IncrementScriptCount();\n                    }\n                    else\n                    {\n                        // If the script is already assigned -> delete it!\n                        sLog->outError(LOG_FILTER_TSCR, \"Script '%s' already assigned with the same script name, so the script can't work.\",\n                            script->GetName().c_str());\n\n                        ASSERT(false); // Error that should be fixed ASAP.\n                    }\n                }\n                else\n                {\n                    // The script uses a script name from database, but isn't assigned to anything.\n                    if (script->GetName().find(\"example\") == std::string::npos && script->GetName().find(\"Smart\") == std::string::npos)\n                        sLog->outError(LOG_FILTER_SQL, \"Script named '%s' does not have a script name assigned in database.\",\n                            script->GetName().c_str());\n                }\n            }\n            else\n            {\n                // We're dealing with a code-only script; just add it.\n                ScriptPointerList[_scriptIdCounter++] = script;\n                sScriptMgr->IncrementScriptCount();\n            }\n        }\n\n        // Gets a script by its ID (assigned by ObjectMgr).\n        static TScript* GetScriptById(uint32 id)\n        {\n            ScriptMapIterator it = ScriptPointerList.find(id);\n            if (it != ScriptPointerList.end())\n                return it->second;\n\n            return NULL;\n        }\n\n    private:\n\n        // Counter used for code-only scripts.\n        static uint32 _scriptIdCounter;\n};\n\n// Utility macros to refer to the script registry.\n#define SCR_REG_MAP(T) ScriptRegistry<T>::ScriptMap\n#define SCR_REG_ITR(T) ScriptRegistry<T>::ScriptMapIterator\n#define SCR_REG_LST(T) ScriptRegistry<T>::ScriptPointerList\n\n// Utility macros for looping over scripts.\n#define FOR_SCRIPTS(T, C, E) \\\n    if (SCR_REG_LST(T).empty()) \\\n        return; \\\n    for (SCR_REG_ITR(T) C = SCR_REG_LST(T).begin(); \\\n        C != SCR_REG_LST(T).end(); ++C)\n#define FOR_SCRIPTS_RET(T, C, E, R) \\\n    if (SCR_REG_LST(T).empty()) \\\n        return R; \\\n    for (SCR_REG_ITR(T) C = SCR_REG_LST(T).begin(); \\\n        C != SCR_REG_LST(T).end(); ++C)\n#define FOREACH_SCRIPT(T) \\\n    FOR_SCRIPTS(T, itr, end) \\\n    itr->second\n\n// Utility macros for finding specific scripts.\n#define GET_SCRIPT(T, I, V) \\\n    T* V = ScriptRegistry<T>::GetScriptById(I); \\\n    if (!V) \\\n        return;\n#define GET_SCRIPT_RET(T, I, V, R) \\\n    T* V = ScriptRegistry<T>::GetScriptById(I); \\\n    if (!V) \\\n        return R;\n\nvoid DoScriptText(int32 iTextEntry, WorldObject* pSource, Unit* target)\n{\n    if (!pSource)\n    {\n        sLog->outError(LOG_FILTER_TSCR, \"DoScriptText entry %i, invalid Source pointer.\", iTextEntry);\n        return;\n    }\n\n    if (iTextEntry >= 0)\n    {\n        sLog->outError(LOG_FILTER_TSCR, \"DoScriptText with source entry %u (TypeId=%u, guid=%u) attempts to process text entry %i, but text entry must be negative.\", pSource->GetEntry(), pSource->GetTypeId(), pSource->GetGUIDLow(), iTextEntry);\n        return;\n    }\n\n    const StringTextData* pData = sScriptSystemMgr->GetTextData(iTextEntry);\n\n    if (!pData)\n    {\n        sLog->outError(LOG_FILTER_TSCR, \"DoScriptText with source entry %u (TypeId=%u, guid=%u) could not find text entry %i.\", pSource->GetEntry(), pSource->GetTypeId(), pSource->GetGUIDLow(), iTextEntry);\n        return;\n    }\n\n    sLog->outDebug(LOG_FILTER_TSCR, \"DoScriptText: text entry=%i, Sound=%u, Type=%u, Language=%u, Emote=%u\", iTextEntry, pData->uiSoundId, pData->uiType, pData->uiLanguage, pData->uiEmote);\n\n    if (pData->uiSoundId)\n    {\n        if (sSoundEntriesStore.LookupEntry(pData->uiSoundId))\n            pSource->SendPlaySound(pData->uiSoundId, false);\n        else\n            sLog->outError(LOG_FILTER_TSCR, \"DoScriptText entry %i tried to process invalid sound id %u.\", iTextEntry, pData->uiSoundId);\n    }\n\n    if (pData->uiEmote)\n    {\n        if (pSource->GetTypeId() == TYPEID_UNIT || pSource->GetTypeId() == TYPEID_PLAYER)\n            ((Unit*)pSource)->HandleEmoteCommand(pData->uiEmote);\n        else\n            sLog->outError(LOG_FILTER_TSCR, \"DoScriptText entry %i tried to process emote for invalid TypeId (%u).\", iTextEntry, pSource->GetTypeId());\n    }\n\n    switch (pData->uiType)\n    {\n        case CHAT_TYPE_SAY:\n            pSource->MonsterSay(iTextEntry, pData->uiLanguage, target ? target->GetGUID() : 0);\n            break;\n        case CHAT_TYPE_YELL:\n            pSource->MonsterYell(iTextEntry, pData->uiLanguage, target ? target->GetGUID() : 0);\n            break;\n        case CHAT_TYPE_TEXT_EMOTE:\n            pSource->MonsterTextEmote(iTextEntry, target ? target->GetGUID() : 0);\n            break;\n        case CHAT_TYPE_BOSS_EMOTE:\n            pSource->MonsterTextEmote(iTextEntry, target ? target->GetGUID() : 0, true);\n            break;\n        case CHAT_TYPE_WHISPER:\n        {\n            if (target && target->GetTypeId() == TYPEID_PLAYER)\n                pSource->MonsterWhisper(iTextEntry, target->GetGUID());\n            else\n                sLog->outError(LOG_FILTER_TSCR, \"DoScriptText entry %i cannot whisper without target unit (TYPEID_PLAYER).\", iTextEntry);\n\n            break;\n        }\n        case CHAT_TYPE_BOSS_WHISPER:\n        {\n            if (target && target->GetTypeId() == TYPEID_PLAYER)\n                pSource->MonsterWhisper(iTextEntry, target->GetGUID(), true);\n            else\n                sLog->outError(LOG_FILTER_TSCR, \"DoScriptText entry %i cannot whisper without target unit (TYPEID_PLAYER).\", iTextEntry);\n\n            break;\n        }\n        case CHAT_TYPE_ZONE_YELL:\n            pSource->MonsterYellToZone(iTextEntry, pData->uiLanguage, target ? target->GetGUID() : 0);\n            break;\n    }\n}\n\nScriptMgr::ScriptMgr()\n    : _scriptCount(0), _scheduledScripts(0)\n{\n}\n\nScriptMgr::~ScriptMgr()\n{\n}\n\nvoid ScriptMgr::Initialize()\n{\n    uint32 oldMSTime = getMSTime();\n\n    LoadDatabase();\n\n    sLog->outInfo(LOG_FILTER_SERVER_LOADING, \"Loading C++ scripts\");\n\n    FillSpellSummary();\n    AddScripts();\n\n    sLog->outInfo(LOG_FILTER_SERVER_LOADING, \">> Loaded %u C++ scripts in %u ms\", GetScriptCount(), GetMSTimeDiffToNow(oldMSTime));\n}\n\nvoid ScriptMgr::Unload()\n{\n    #define SCR_CLEAR(T) \\\n        for (SCR_REG_ITR(T) itr = SCR_REG_LST(T).begin(); itr != SCR_REG_LST(T).end(); ++itr) \\\n            delete itr->second; \\\n        SCR_REG_LST(T).clear();\n\n    // Clear scripts for every script type.\n    SCR_CLEAR(SpellScriptLoader);\n    SCR_CLEAR(ServerScript);\n    SCR_CLEAR(WorldScript);\n    SCR_CLEAR(FormulaScript);\n    SCR_CLEAR(WorldMapScript);\n    SCR_CLEAR(InstanceMapScript);\n    SCR_CLEAR(BattlegroundMapScript);\n    SCR_CLEAR(ItemScript);\n    SCR_CLEAR(CreatureScript);\n    SCR_CLEAR(GameObjectScript);\n    SCR_CLEAR(AreaTriggerScript);\n    SCR_CLEAR(BattlegroundScript);\n    SCR_CLEAR(OutdoorPvPScript);\n    SCR_CLEAR(CommandScript);\n    SCR_CLEAR(WeatherScript);\n    SCR_CLEAR(AuctionHouseScript);\n    SCR_CLEAR(ConditionScript);\n    SCR_CLEAR(VehicleScript);\n    SCR_CLEAR(DynamicObjectScript);\n    SCR_CLEAR(TransportScript);\n    SCR_CLEAR(AchievementCriteriaScript);\n    SCR_CLEAR(PlayerScript);\n    SCR_CLEAR(GuildScript);\n    SCR_CLEAR(GroupScript);\n\n    #undef SCR_CLEAR\n}\n\nvoid ScriptMgr::LoadDatabase()\n{\n    sScriptSystemMgr->LoadScriptTexts();\n    sScriptSystemMgr->LoadScriptTextsCustom();\n    sScriptSystemMgr->LoadScriptWaypoints();\n}\n\nstruct TSpellSummary\n{\n    uint8 Targets;                                          // set of enum SelectTarget\n    uint8 Effects;                                          // set of enum SelectEffect\n} *SpellSummary;\n\nvoid ScriptMgr::FillSpellSummary()\n{\n    SpellSummary = new TSpellSummary[sSpellMgr->GetSpellInfoStoreSize()];\n\n    SpellInfo const* pTempSpell;\n\n    for (uint32 i = 0; i < sSpellMgr->GetSpellInfoStoreSize(); ++i)\n    {\n        SpellSummary[i].Effects = 0;\n        SpellSummary[i].Targets = 0;\n\n        pTempSpell = sSpellMgr->GetSpellInfo(i);\n        // This spell doesn't exist.\n        if (!pTempSpell)\n            continue;\n\n        for (uint32 j = 0; j < MAX_SPELL_EFFECTS; ++j)\n        {\n            // Spell targets self.\n            if (pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_CASTER)\n                SpellSummary[i].Targets |= 1 << (SELECT_TARGET_SELF-1);\n\n            // Spell targets a single enemy.\n            if (pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_TARGET_ENEMY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_DEST_TARGET_ENEMY)\n                SpellSummary[i].Targets |= 1 << (SELECT_TARGET_SINGLE_ENEMY-1);\n\n            // Spell targets AoE at enemy.\n            if (pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_SRC_AREA_ENEMY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_DEST_AREA_ENEMY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_SRC_CASTER ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_DEST_DYNOBJ_ENEMY)\n                SpellSummary[i].Targets |= 1 << (SELECT_TARGET_AOE_ENEMY-1);\n\n            // Spell targets an enemy.\n            if (pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_TARGET_ENEMY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_DEST_TARGET_ENEMY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_SRC_AREA_ENEMY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_DEST_AREA_ENEMY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_SRC_CASTER ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_DEST_DYNOBJ_ENEMY)\n                SpellSummary[i].Targets |= 1 << (SELECT_TARGET_ANY_ENEMY-1);\n\n            // Spell targets a single friend (or self).\n            if (pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_CASTER ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_TARGET_ALLY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_TARGET_PARTY)\n                SpellSummary[i].Targets |= 1 << (SELECT_TARGET_SINGLE_FRIEND-1);\n\n            // Spell targets AoE friends.\n            if (pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_CASTER_AREA_PARTY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_LASTTARGET_AREA_PARTY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_SRC_CASTER)\n                SpellSummary[i].Targets |= 1 << (SELECT_TARGET_AOE_FRIEND-1);\n\n            // Spell targets any friend (or self).\n            if (pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_CASTER ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_TARGET_ALLY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_TARGET_PARTY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_CASTER_AREA_PARTY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_UNIT_LASTTARGET_AREA_PARTY ||\n                pTempSpell->Effects[j].TargetA.GetTarget() == TARGET_SRC_CASTER)\n                SpellSummary[i].Targets |= 1 << (SELECT_TARGET_ANY_FRIEND-1);\n\n            // Make sure that this spell includes a damage effect.\n            if (pTempSpell->Effects[j].Effect == SPELL_EFFECT_SCHOOL_DAMAGE ||\n                pTempSpell->Effects[j].Effect == SPELL_EFFECT_INSTAKILL ||\n                pTempSpell->Effects[j].Effect == SPELL_EFFECT_ENVIRONMENTAL_DAMAGE ||\n                pTempSpell->Effects[j].Effect == SPELL_EFFECT_HEALTH_LEECH)\n                SpellSummary[i].Effects |= 1 << (SELECT_EFFECT_DAMAGE-1);\n\n            // Make sure that this spell includes a healing effect (or an apply aura with a periodic heal).\n            if (pTempSpell->Effects[j].Effect == SPELL_EFFECT_HEAL ||\n                pTempSpell->Effects[j].Effect == SPELL_EFFECT_HEAL_MAX_HEALTH ||\n                pTempSpell->Effects[j].Effect == SPELL_EFFECT_HEAL_MECHANICAL ||\n                (pTempSpell->Effects[j].Effect == SPELL_EFFECT_APPLY_AURA  && pTempSpell->Effects[j].ApplyAuraName == 8))\n                SpellSummary[i].Effects |= 1 << (SELECT_EFFECT_HEALING-1);\n\n            // Make sure that this spell applies an aura.\n            if (pTempSpell->Effects[j].Effect == SPELL_EFFECT_APPLY_AURA)\n                SpellSummary[i].Effects |= 1 << (SELECT_EFFECT_AURA-1);\n        }\n    }\n}\n\nvoid ScriptMgr::CreateSpellScripts(uint32 spellId, std::list<SpellScript*>& scriptVector)\n{\n    SpellScriptsBounds bounds = sObjectMgr->GetSpellScriptsBounds(spellId);\n\n    for (SpellScriptsContainer::iterator itr = bounds.first; itr != bounds.second; ++itr)\n    {\n        SpellScriptLoader* tmpscript = ScriptRegistry<SpellScriptLoader>::GetScriptById(itr->second);\n        if (!tmpscript)\n            continue;\n\n        SpellScript* script = tmpscript->GetSpellScript();\n\n        if (!script)\n            continue;\n\n        script->_Init(&tmpscript->GetName(), spellId);\n\n        scriptVector.push_back(script);\n    }\n}\n\nvoid ScriptMgr::CreateAuraScripts(uint32 spellId, std::list<AuraScript*>& scriptVector)\n{\n    SpellScriptsBounds bounds = sObjectMgr->GetSpellScriptsBounds(spellId);\n\n    for (SpellScriptsContainer::iterator itr = bounds.first; itr != bounds.second; ++itr)\n    {\n        SpellScriptLoader* tmpscript = ScriptRegistry<SpellScriptLoader>::GetScriptById(itr->second);\n        if (!tmpscript)\n            continue;\n\n        AuraScript* script = tmpscript->GetAuraScript();\n\n        if (!script)\n            continue;\n\n        script->_Init(&tmpscript->GetName(), spellId);\n\n        scriptVector.push_back(script);\n    }\n}\n\nvoid ScriptMgr::CreateSpellScriptLoaders(uint32 spellId, std::vector<std::pair<SpellScriptLoader*, SpellScriptsContainer::iterator> >& scriptVector)\n{\n    SpellScriptsBounds bounds = sObjectMgr->GetSpellScriptsBounds(spellId);\n    scriptVector.reserve(std::distance(bounds.first, bounds.second));\n\n    for (SpellScriptsContainer::iterator itr = bounds.first; itr != bounds.second; ++itr)\n    {\n        SpellScriptLoader* tmpscript = ScriptRegistry<SpellScriptLoader>::GetScriptById(itr->second);\n        if (!tmpscript)\n            continue;\n\n        scriptVector.push_back(std::make_pair(tmpscript, itr));\n    }\n}\n\nvoid ScriptMgr::OnNetworkStart()\n{\n    FOREACH_SCRIPT(ServerScript)->OnNetworkStart();\n}\n\nvoid ScriptMgr::OnNetworkStop()\n{\n    FOREACH_SCRIPT(ServerScript)->OnNetworkStop();\n}\n\nvoid ScriptMgr::OnSocketOpen(WorldSocket* socket)\n{\n    ASSERT(socket);\n\n    FOREACH_SCRIPT(ServerScript)->OnSocketOpen(socket);\n}\n\nvoid ScriptMgr::OnSocketClose(WorldSocket* socket, bool wasNew)\n{\n    ASSERT(socket);\n\n    FOREACH_SCRIPT(ServerScript)->OnSocketClose(socket, wasNew);\n}\n\nvoid ScriptMgr::OnPacketReceive(WorldSocket* socket, WorldPacket packet)\n{\n    ASSERT(socket);\n\n    FOREACH_SCRIPT(ServerScript)->OnPacketReceive(socket, packet);\n}\n\nvoid ScriptMgr::OnPacketSend(WorldSocket* socket, WorldPacket packet)\n{\n    ASSERT(socket);\n\n    FOREACH_SCRIPT(ServerScript)->OnPacketSend(socket, packet);\n}\n\nvoid ScriptMgr::OnUnknownPacketReceive(WorldSocket* socket, WorldPacket packet)\n{\n    ASSERT(socket);\n\n    FOREACH_SCRIPT(ServerScript)->OnUnknownPacketReceive(socket, packet);\n}\n\nvoid ScriptMgr::OnOpenStateChange(bool open)\n{\n    FOREACH_SCRIPT(WorldScript)->OnOpenStateChange(open);\n}\n\nvoid ScriptMgr::OnConfigLoad(bool reload)\n{\n    FOREACH_SCRIPT(WorldScript)->OnConfigLoad(reload);\n}\n\nvoid ScriptMgr::OnMotdChange(std::string& newMotd)\n{\n    FOREACH_SCRIPT(WorldScript)->OnMotdChange(newMotd);\n}\n\nvoid ScriptMgr::OnShutdownInitiate(ShutdownExitCode code, ShutdownMask mask)\n{\n    FOREACH_SCRIPT(WorldScript)->OnShutdownInitiate(code, mask);\n}\n\nvoid ScriptMgr::OnShutdownCancel()\n{\n    FOREACH_SCRIPT(WorldScript)->OnShutdownCancel();\n}\n\nvoid ScriptMgr::OnWorldUpdate(uint32 diff)\n{\n    FOREACH_SCRIPT(WorldScript)->OnUpdate(diff);\n}\n\nvoid ScriptMgr::OnHonorCalculation(float& honor, uint8 level, float multiplier)\n{\n    FOREACH_SCRIPT(FormulaScript)->OnHonorCalculation(honor, level, multiplier);\n}\n\nvoid ScriptMgr::OnGrayLevelCalculation(uint8& grayLevel, uint8 playerLevel)\n{\n    FOREACH_SCRIPT(FormulaScript)->OnGrayLevelCalculation(grayLevel, playerLevel);\n}\n\nvoid ScriptMgr::OnColorCodeCalculation(XPColorChar& color, uint8 playerLevel, uint8 mobLevel)\n{\n    FOREACH_SCRIPT(FormulaScript)->OnColorCodeCalculation(color, playerLevel, mobLevel);\n}\n\nvoid ScriptMgr::OnZeroDifferenceCalculation(uint8& diff, uint8 playerLevel)\n{\n    FOREACH_SCRIPT(FormulaScript)->OnZeroDifferenceCalculation(diff, playerLevel);\n}\n\nvoid ScriptMgr::OnBaseGainCalculation(uint32& gain, uint8 playerLevel, uint8 mobLevel, ContentLevels content)\n{\n    FOREACH_SCRIPT(FormulaScript)->OnBaseGainCalculation(gain, playerLevel, mobLevel, content);\n}\n\nvoid ScriptMgr::OnGainCalculation(uint32& gain, Player* player, Unit* unit)\n{\n    ASSERT(player);\n    ASSERT(unit);\n\n    FOREACH_SCRIPT(FormulaScript)->OnGainCalculation(gain, player, unit);\n}\n\nvoid ScriptMgr::OnGroupRateCalculation(float& rate, uint32 count, bool isRaid)\n{\n    FOREACH_SCRIPT(FormulaScript)->OnGroupRateCalculation(rate, count, isRaid);\n}\n\n#define SCR_MAP_BGN(M, V, I, E, C, T) \\\n    if (V->GetEntry()->T()) \\\n    { \\\n        FOR_SCRIPTS(M, I, E) \\\n        { \\\n            MapEntry const* C = I->second->GetEntry(); \\\n            if (!C) \\\n                continue; \\\n            if (entry->MapID == V->GetId()) \\\n            {\n\n#define SCR_MAP_END \\\n                return; \\\n            } \\\n        } \\\n    }\n\nvoid ScriptMgr::OnCreateMap(Map* map)\n{\n    ASSERT(map);\n\n    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);\n        itr->second->OnCreate(map);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(InstanceMapScript, map, itr, end, entry, IsDungeon);\n        itr->second->OnCreate((InstanceMap*)map);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(BattlegroundMapScript, map, itr, end, entry, IsBattleground);\n        itr->second->OnCreate((BattlegroundMap*)map);\n    SCR_MAP_END;\n}\n\nvoid ScriptMgr::OnDestroyMap(Map* map)\n{\n    ASSERT(map);\n\n    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);\n        itr->second->OnDestroy(map);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(InstanceMapScript, map, itr, end, entry, IsDungeon);\n        itr->second->OnDestroy((InstanceMap*)map);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(BattlegroundMapScript, map, itr, end, entry, IsBattleground);\n        itr->second->OnDestroy((BattlegroundMap*)map);\n    SCR_MAP_END;\n}\n\nvoid ScriptMgr::OnLoadGridMap(Map* map, GridMap* gmap, uint32 gx, uint32 gy)\n{\n    ASSERT(map);\n    ASSERT(gmap);\n\n    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);\n        itr->second->OnLoadGridMap(map, gmap, gx, gy);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(InstanceMapScript, map, itr, end, entry, IsDungeon);\n        itr->second->OnLoadGridMap((InstanceMap*)map, gmap, gx, gy);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(BattlegroundMapScript, map, itr, end, entry, IsBattleground);\n        itr->second->OnLoadGridMap((BattlegroundMap*)map, gmap, gx, gy);\n    SCR_MAP_END;\n}\n\nvoid ScriptMgr::OnUnloadGridMap(Map* map, GridMap* gmap, uint32 gx, uint32 gy)\n{\n    ASSERT(map);\n    ASSERT(gmap);\n\n    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);\n        itr->second->OnUnloadGridMap(map, gmap, gx, gy);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(InstanceMapScript, map, itr, end, entry, IsDungeon);\n        itr->second->OnUnloadGridMap((InstanceMap*)map, gmap, gx, gy);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(BattlegroundMapScript, map, itr, end, entry, IsBattleground);\n        itr->second->OnUnloadGridMap((BattlegroundMap*)map, gmap, gx, gy);\n    SCR_MAP_END;\n}\n\nvoid ScriptMgr::OnPlayerEnterMap(Map* map, Player* player)\n{\n    ASSERT(map);\n    ASSERT(player);\n\n    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);\n        itr->second->OnPlayerEnter(map, player);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(InstanceMapScript, map, itr, end, entry, IsDungeon);\n        itr->second->OnPlayerEnter((InstanceMap*)map, player);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(BattlegroundMapScript, map, itr, end, entry, IsBattleground);\n        itr->second->OnPlayerEnter((BattlegroundMap*)map, player);\n    SCR_MAP_END;\n}\n\nvoid ScriptMgr::OnPlayerLeaveMap(Map* map, Player* player)\n{\n    ASSERT(map);\n    ASSERT(player);\n\n    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);\n        itr->second->OnPlayerLeave(map, player);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(InstanceMapScript, map, itr, end, entry, IsDungeon);\n        itr->second->OnPlayerLeave((InstanceMap*)map, player);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(BattlegroundMapScript, map, itr, end, entry, IsBattleground);\n        itr->second->OnPlayerLeave((BattlegroundMap*)map, player);\n    SCR_MAP_END;\n}\n\nvoid ScriptMgr::OnMapUpdate(Map* map, uint32 diff)\n{\n    ASSERT(map);\n\n    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);\n        itr->second->OnUpdate(map, diff);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(InstanceMapScript, map, itr, end, entry, IsDungeon);\n        itr->second->OnUpdate((InstanceMap*)map, diff);\n    SCR_MAP_END;\n\n    SCR_MAP_BGN(BattlegroundMapScript, map, itr, end, entry, IsBattleground);\n        itr->second->OnUpdate((BattlegroundMap*)map, diff);\n    SCR_MAP_END;\n}\n\n#undef SCR_MAP_BGN\n#undef SCR_MAP_END\n\nInstanceScript* ScriptMgr::CreateInstanceData(InstanceMap* map)\n{\n    ASSERT(map);\n\n    GET_SCRIPT_RET(InstanceMapScript, map->GetScriptId(), tmpscript, NULL);\n    return tmpscript->GetInstanceScript(map);\n}\n\nbool ScriptMgr::OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, Item* target)\n{\n    ASSERT(caster);\n    ASSERT(target);\n\n    GET_SCRIPT_RET(ItemScript, target->GetScriptId(), tmpscript, false);\n    return tmpscript->OnDummyEffect(caster, spellId, effIndex, target);\n}\n\nbool ScriptMgr::OnQuestAccept(Player* player, Item* item, Quest const* quest)\n{\n    ASSERT(player);\n    ASSERT(item);\n    ASSERT(quest);\n\n    GET_SCRIPT_RET(ItemScript, item->GetScriptId(), tmpscript, false);\n    player->PlayerTalkClass->ClearMenus();\n    return tmpscript->OnQuestAccept(player, item, quest);\n}\n\nbool ScriptMgr::OnItemUse(Player* player, Item* item, SpellCastTargets const& targets)\n{\n    ASSERT(player);\n    ASSERT(item);\n\n    GET_SCRIPT_RET(ItemScript, item->GetScriptId(), tmpscript, false);\n    return tmpscript->OnUse(player, item, targets);\n}\n\nbool ScriptMgr::OnItemExpire(Player* player, ItemTemplate const* proto)\n{\n    ASSERT(player);\n    ASSERT(proto);\n\n    GET_SCRIPT_RET(ItemScript, proto->ScriptId, tmpscript, false);\n    return tmpscript->OnExpire(player, proto);\n}\n\nbool ScriptMgr::OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, Creature* target)\n{\n    ASSERT(caster);\n    ASSERT(target);\n\n    GET_SCRIPT_RET(CreatureScript, target->GetScriptId(), tmpscript, false);\n    return tmpscript->OnDummyEffect(caster, spellId, effIndex, target);\n}\n\nbool ScriptMgr::OnGossipHello(Player* player, Creature* creature)\n{\n    ASSERT(player);\n    ASSERT(creature);\n\n    GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);\n    player->PlayerTalkClass->ClearMenus();\n    return tmpscript->OnGossipHello(player, creature);\n}\n\nbool ScriptMgr::OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)\n{\n    ASSERT(player);\n    ASSERT(creature);\n\n    GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);\n    return tmpscript->OnGossipSelect(player, creature, sender, action);\n}\n\nbool ScriptMgr::OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code)\n{\n    ASSERT(player);\n    ASSERT(creature);\n    ASSERT(code);\n\n    GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);\n    return tmpscript->OnGossipSelectCode(player, creature, sender, action, code);\n}\n\nbool ScriptMgr::OnQuestAccept(Player* player, Creature* creature, Quest const* quest)\n{\n    ASSERT(player);\n    ASSERT(creature);\n    ASSERT(quest);\n\n    GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);\n    player->PlayerTalkClass->ClearMenus();\n    return tmpscript->OnQuestAccept(player, creature, quest);\n}\n\nbool ScriptMgr::OnQuestSelect(Player* player, Creature* creature, Quest const* quest)\n{\n    ASSERT(player);\n    ASSERT(creature);\n    ASSERT(quest);\n\n    GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);\n    player->PlayerTalkClass->ClearMenus();\n    return tmpscript->OnQuestSelect(player, creature, quest);\n}\n\nbool ScriptMgr::OnQuestComplete(Player* player, Creature* creature, Quest const* quest)\n{\n    ASSERT(player);\n    ASSERT(creature);\n    ASSERT(quest);\n\n    GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);\n    player->PlayerTalkClass->ClearMenus();\n    return tmpscript->OnQuestComplete(player, creature, quest);\n}\n\nbool ScriptMgr::OnQuestReward(Player* player, Creature* creature, Quest const* quest, uint32 opt)\n{\n    ASSERT(player);\n    ASSERT(creature);\n    ASSERT(quest);\n\n    GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);\n    player->PlayerTalkClass->ClearMenus();\n    return tmpscript->OnQuestReward(player, creature, quest, opt);\n}\n\nuint32 ScriptMgr::GetDialogStatus(Player* player, Creature* creature)\n{\n    ASSERT(player);\n    ASSERT(creature);\n\n    // TODO: 100 is a funny magic number to have hanging around here...\n    GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, 100);\n    player->PlayerTalkClass->ClearMenus();\n    return tmpscript->GetDialogStatus(player, creature);\n}\n\nCreatureAI* ScriptMgr::GetCreatureAI(Creature* creature)\n{\n    ASSERT(creature);\n\n    GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, NULL);\n    return tmpscript->GetAI(creature);\n}\n\nGameObjectAI* ScriptMgr::GetGameObjectAI(GameObject* gameobject)\n{\n    ASSERT(gameobject);\n\n    GET_SCRIPT_RET(GameObjectScript, gameobject->GetScriptId(), tmpscript, NULL);\n    return tmpscript->GetAI(gameobject);\n}\n\nvoid ScriptMgr::OnCreatureUpdate(Creature* creature, uint32 diff)\n{\n    ASSERT(creature);\n\n    GET_SCRIPT(CreatureScript, creature->GetScriptId(), tmpscript);\n    tmpscript->OnUpdate(creature, diff);\n}\n\nbool ScriptMgr::OnGossipHello(Player* player, GameObject* go)\n{\n    ASSERT(player);\n    ASSERT(go);\n\n    GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);\n    player->PlayerTalkClass->ClearMenus();\n    return tmpscript->OnGossipHello(player, go);\n}\n\nbool ScriptMgr::OnGossipSelect(Player* player, GameObject* go, uint32 sender, uint32 action)\n{\n    ASSERT(player);\n    ASSERT(go);\n\n    GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);\n    return tmpscript->OnGossipSelect(player, go, sender, action);\n}\n\nbool ScriptMgr::OnGossipSelectCode(Player* player, GameObject* go, uint32 sender, uint32 action, const char* code)\n{\n    ASSERT(player);\n    ASSERT(go);\n    ASSERT(code);\n\n    GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);\n    return tmpscript->OnGossipSelectCode(player, go, sender, action, code);\n}\n\nbool ScriptMgr::OnQuestAccept(Player* player, GameObject* go, Quest const* quest)\n{\n    ASSERT(player);\n    ASSERT(go);\n    ASSERT(quest);\n\n    GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);\n    player->PlayerTalkClass->ClearMenus();\n    return tmpscript->OnQuestAccept(player, go, quest);\n}\n\nbool ScriptMgr::OnQuestReward(Player* player, GameObject* go, Quest const* quest, uint32 opt)\n{\n    ASSERT(player);\n    ASSERT(go);\n    ASSERT(quest);\n\n    GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);\n    player->PlayerTalkClass->ClearMenus();\n    return tmpscript->OnQuestReward(player, go, quest, opt);\n}\n\nuint32 ScriptMgr::GetDialogStatus(Player* player, GameObject* go)\n{\n    ASSERT(player);\n    ASSERT(go);\n\n    // TODO: 100 is a funny magic number to have hanging around here...\n    GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, 100);\n    player->PlayerTalkClass->ClearMenus();\n    return tmpscript->GetDialogStatus(player, go);\n}\n\nvoid ScriptMgr::OnGameObjectDestroyed(GameObject* go, Player* player)\n{\n    ASSERT(go);\n\n    GET_SCRIPT(GameObjectScript, go->GetScriptId(), tmpscript);\n    tmpscript->OnDestroyed(go, player);\n}\n\nvoid ScriptMgr::OnGameObjectDamaged(GameObject* go, Player* player)\n{\n    ASSERT(go);\n\n    GET_SCRIPT(GameObjectScript, go->GetScriptId(), tmpscript);\n    tmpscript->OnDamaged(go, player);\n}\n\nvoid ScriptMgr::OnGameObjectLootStateChanged(GameObject* go, uint32 state, Unit* unit)\n{\n    ASSERT(go);\n\n    GET_SCRIPT(GameObjectScript, go->GetScriptId(), tmpscript);\n    tmpscript->OnLootStateChanged(go, state, unit);\n}\n\nvoid ScriptMgr::OnGameObjectStateChanged(GameObject* go, uint32 state)\n{\n    ASSERT(go);\n\n    GET_SCRIPT(GameObjectScript, go->GetScriptId(), tmpscript);\n    tmpscript->OnGameObjectStateChanged(go, state);\n}\n\nvoid ScriptMgr::OnGameObjectUpdate(GameObject* go, uint32 diff)\n{\n    ASSERT(go);\n\n    GET_SCRIPT(GameObjectScript, go->GetScriptId(), tmpscript);\n    tmpscript->OnUpdate(go, diff);\n}\n\nbool ScriptMgr::OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, GameObject* target)\n{\n    ASSERT(caster);\n    ASSERT(target);\n\n    GET_SCRIPT_RET(GameObjectScript, target->GetScriptId(), tmpscript, false);\n    return tmpscript->OnDummyEffect(caster, spellId, effIndex, target);\n}\n\nbool ScriptMgr::OnAreaTrigger(Player* player, AreaTriggerEntry const* trigger)\n{\n    ASSERT(player);\n    ASSERT(trigger);\n\n    GET_SCRIPT_RET(AreaTriggerScript, sObjectMgr->GetAreaTriggerScriptId(trigger->id), tmpscript, false);\n    return tmpscript->OnTrigger(player, trigger);\n}\n\nBattleground* ScriptMgr::CreateBattleground(BattlegroundTypeId /*typeId*/)\n{\n    // TODO: Implement script-side battlegrounds.\n    ASSERT(false);\n    return NULL;\n}\n\nOutdoorPvP* ScriptMgr::CreateOutdoorPvP(OutdoorPvPData const* data)\n{\n    ASSERT(data);\n\n    GET_SCRIPT_RET(OutdoorPvPScript, data->ScriptId, tmpscript, NULL);\n    return tmpscript->GetOutdoorPvP();\n}\n\nstd::vector<ChatCommand*> ScriptMgr::GetChatCommands()\n{\n    std::vector<ChatCommand*> table;\n\n    FOR_SCRIPTS_RET(CommandScript, itr, end, table)\n        table.push_back(itr->second->GetCommands());\n\n    return table;\n}\n\nvoid ScriptMgr::OnWeatherChange(Weather* weather, WeatherState state, float grade)\n{\n    ASSERT(weather);\n\n    GET_SCRIPT(WeatherScript, weather->GetScriptId(), tmpscript);\n    tmpscript->OnChange(weather, state, grade);\n}\n\nvoid ScriptMgr::OnWeatherUpdate(Weather* weather, uint32 diff)\n{\n    ASSERT(weather);\n\n    GET_SCRIPT(WeatherScript, weather->GetScriptId(), tmpscript);\n    tmpscript->OnUpdate(weather, diff);\n}\n\nvoid ScriptMgr::OnAuctionAdd(AuctionHouseObject* ah, AuctionEntry* entry)\n{\n    ASSERT(ah);\n    ASSERT(entry);\n\n    FOREACH_SCRIPT(AuctionHouseScript)->OnAuctionAdd(ah, entry);\n}\n\nvoid ScriptMgr::OnAuctionRemove(AuctionHouseObject* ah, AuctionEntry* entry)\n{\n    ASSERT(ah);\n    ASSERT(entry);\n\n    FOREACH_SCRIPT(AuctionHouseScript)->OnAuctionRemove(ah, entry);\n}\n\nvoid ScriptMgr::OnAuctionSuccessful(AuctionHouseObject* ah, AuctionEntry* entry)\n{\n    ASSERT(ah);\n    ASSERT(entry);\n\n    FOREACH_SCRIPT(AuctionHouseScript)->OnAuctionSuccessful(ah, entry);\n}\n\nvoid ScriptMgr::OnAuctionExpire(AuctionHouseObject* ah, AuctionEntry* entry)\n{\n    ASSERT(ah);\n    ASSERT(entry);\n\n    FOREACH_SCRIPT(AuctionHouseScript)->OnAuctionExpire(ah, entry);\n}\n\nbool ScriptMgr::OnConditionCheck(Condition* condition, ConditionSourceInfo& sourceInfo)\n{\n    ASSERT(condition);\n\n    GET_SCRIPT_RET(ConditionScript, condition->ScriptId, tmpscript, true);\n    return tmpscript->OnConditionCheck(condition, sourceInfo);\n}\n\nvoid ScriptMgr::OnInstall(Vehicle* veh)\n{\n    ASSERT(veh);\n    ASSERT(veh->GetBase()->GetTypeId() == TYPEID_UNIT);\n\n    GET_SCRIPT(VehicleScript, veh->GetBase()->ToCreature()->GetScriptId(), tmpscript);\n    tmpscript->OnInstall(veh);\n}\n\nvoid ScriptMgr::OnUninstall(Vehicle* veh)\n{\n    ASSERT(veh);\n    ASSERT(veh->GetBase()->GetTypeId() == TYPEID_UNIT);\n\n    GET_SCRIPT(VehicleScript, veh->GetBase()->ToCreature()->GetScriptId(), tmpscript);\n    tmpscript->OnUninstall(veh);\n}\n\nvoid ScriptMgr::OnReset(Vehicle* veh)\n{\n    ASSERT(veh);\n    ASSERT(veh->GetBase()->GetTypeId() == TYPEID_UNIT);\n\n    GET_SCRIPT(VehicleScript, veh->GetBase()->ToCreature()->GetScriptId(), tmpscript);\n    tmpscript->OnReset(veh);\n}\n\nvoid ScriptMgr::OnInstallAccessory(Vehicle* veh, Creature* accessory)\n{\n    ASSERT(veh);\n    ASSERT(veh->GetBase()->GetTypeId() == TYPEID_UNIT);\n    ASSERT(accessory);\n\n    GET_SCRIPT(VehicleScript, veh->GetBase()->ToCreature()->GetScriptId(), tmpscript);\n    tmpscript->OnInstallAccessory(veh, accessory);\n}\n\nvoid ScriptMgr::OnAddPassenger(Vehicle* veh, Unit* passenger, int8 seatId)\n{\n    ASSERT(veh);\n    ASSERT(veh->GetBase()->GetTypeId() == TYPEID_UNIT);\n    ASSERT(passenger);\n\n    GET_SCRIPT(VehicleScript, veh->GetBase()->ToCreature()->GetScriptId(), tmpscript);\n    tmpscript->OnAddPassenger(veh, passenger, seatId);\n}\n\nvoid ScriptMgr::OnRemovePassenger(Vehicle* veh, Unit* passenger)\n{\n    ASSERT(veh);\n    ASSERT(veh->GetBase()->GetTypeId() == TYPEID_UNIT);\n    ASSERT(passenger);\n\n    GET_SCRIPT(VehicleScript, veh->GetBase()->ToCreature()->GetScriptId(), tmpscript);\n    tmpscript->OnRemovePassenger(veh, passenger);\n}\n\nvoid ScriptMgr::OnDynamicObjectUpdate(DynamicObject* dynobj, uint32 diff)\n{\n    ASSERT(dynobj);\n\n    FOR_SCRIPTS(DynamicObjectScript, itr, end)\n        itr->second->OnUpdate(dynobj, diff);\n}\n\nvoid ScriptMgr::OnAddPassenger(Transport* transport, Player* player)\n{\n    ASSERT(transport);\n    ASSERT(player);\n\n    GET_SCRIPT(TransportScript, transport->GetScriptId(), tmpscript);\n    tmpscript->OnAddPassenger(transport, player);\n}\n\nvoid ScriptMgr::OnAddCreaturePassenger(Transport* transport, Creature* creature)\n{\n    ASSERT(transport);\n    ASSERT(creature);\n\n    GET_SCRIPT(TransportScript, transport->GetScriptId(), tmpscript);\n    tmpscript->OnAddCreaturePassenger(transport, creature);\n}\n\nvoid ScriptMgr::OnRemovePassenger(Transport* transport, Player* player)\n{\n    ASSERT(transport);\n    ASSERT(player);\n\n    GET_SCRIPT(TransportScript, transport->GetScriptId(), tmpscript);\n    tmpscript->OnRemovePassenger(transport, player);\n}\n\nvoid ScriptMgr::OnTransportUpdate(Transport* transport, uint32 diff)\n{\n    ASSERT(transport);\n\n    GET_SCRIPT(TransportScript, transport->GetScriptId(), tmpscript);\n    tmpscript->OnUpdate(transport, diff);\n}\n\nvoid ScriptMgr::OnRelocate(Transport* transport, uint32 waypointId, uint32 mapId, float x, float y, float z)\n{\n    GET_SCRIPT(TransportScript, transport->GetScriptId(), tmpscript);\n    tmpscript->OnRelocate(transport, waypointId, mapId, x, y, z);\n}\n\nvoid ScriptMgr::OnStartup()\n{\n    FOREACH_SCRIPT(WorldScript)->OnStartup();\n}\n\nvoid ScriptMgr::OnShutdown()\n{\n    FOREACH_SCRIPT(WorldScript)->OnShutdown();\n}\n\nbool ScriptMgr::OnCriteriaCheck(AchievementCriteriaData const* data, Player* source, Unit* target)\n{\n    ASSERT(source);\n    // target can be NULL.\n\n    GET_SCRIPT_RET(AchievementCriteriaScript, data->ScriptId, tmpscript, false);\n    return tmpscript->OnCheck(source, target);\n}\n\n// Player\nvoid ScriptMgr::OnPVPKill(Player* killer, Player* killed)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnPVPKill(killer, killed);\n}\n\nvoid ScriptMgr::OnCreatureKill(Player* killer, Creature* killed)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnCreatureKill(killer, killed);\n}\n\nvoid ScriptMgr::OnPlayerKilledByCreature(Creature* killer, Player* killed)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnPlayerKilledByCreature(killer, killed);\n}\n\nvoid ScriptMgr::OnPlayerLevelChanged(Player* player, uint8 oldLevel)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnLevelChanged(player, oldLevel);\n}\n\nvoid ScriptMgr::OnPlayerFreeTalentPointsChanged(Player* player, uint32 points)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnFreeTalentPointsChanged(player, points);\n}\n\nvoid ScriptMgr::OnPlayerTalentsReset(Player* player, bool noCost)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnTalentsReset(player, noCost);\n}\n\nvoid ScriptMgr::OnPlayerMoneyChanged(Player* player, int32& amount)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnMoneyChanged(player, amount);\n}\n\nvoid ScriptMgr::OnGivePlayerXP(Player* player, uint32& amount, Unit* victim)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnGiveXP(player, amount, victim);\n}\n\nvoid ScriptMgr::OnPlayerReputationChange(Player* player, uint32 factionID, int32& standing, bool incremental)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnReputationChange(player, factionID, standing, incremental);\n}\n\nvoid ScriptMgr::OnPlayerDuelRequest(Player* target, Player* challenger)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnDuelRequest(target, challenger);\n}\n\nvoid ScriptMgr::OnPlayerDuelStart(Player* player1, Player* player2)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnDuelStart(player1, player2);\n}\n\nvoid ScriptMgr::OnPlayerDuelEnd(Player* winner, Player* loser, DuelCompleteType type)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnDuelEnd(winner, loser, type);\n}\n\nvoid ScriptMgr::OnPlayerChat(Player* player, uint32 type, uint32 lang, std::string& msg)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnChat(player, type, lang, msg);\n}\n\nvoid ScriptMgr::OnPlayerChat(Player* player, uint32 type, uint32 lang, std::string& msg, Player* receiver)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnChat(player, type, lang, msg, receiver);\n}\n\nvoid ScriptMgr::OnPlayerChat(Player* player, uint32 type, uint32 lang, std::string& msg, Group* group)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnChat(player, type, lang, msg, group);\n}\n\nvoid ScriptMgr::OnPlayerChat(Player* player, uint32 type, uint32 lang, std::string& msg, Guild* guild)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnChat(player, type, lang, msg, guild);\n}\n\nvoid ScriptMgr::OnPlayerChat(Player* player, uint32 type, uint32 lang, std::string& msg, Channel* channel)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnChat(player, type, lang, msg, channel);\n}\n\nvoid ScriptMgr::OnPlayerEmote(Player* player, uint32 emote)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnEmote(player, emote);\n}\n\nvoid ScriptMgr::OnPlayerTextEmote(Player* player, uint32 textEmote, uint32 emoteNum, uint64 guid)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnTextEmote(player, textEmote, emoteNum, guid);\n}\n\nvoid ScriptMgr::OnPlayerSpellCast(Player* player, Spell* spell, bool skipCheck)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnSpellCast(player, spell, skipCheck);\n}\n\nvoid ScriptMgr::OnPlayerLogin(Player* player)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnLogin(player);\n}\n\nvoid ScriptMgr::OnPlayerLogout(Player* player)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnLogout(player);\n}\n\nvoid ScriptMgr::OnPlayerCreate(Player* player)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnCreate(player);\n}\n\nvoid ScriptMgr::OnPlayerDelete(uint64 guid)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnDelete(guid);\n}\n\nvoid ScriptMgr::OnPlayerBindToInstance(Player* player, Difficulty difficulty, uint32 mapid, bool permanent)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnBindToInstance(player, difficulty, mapid, permanent);\n}\n\nvoid ScriptMgr::OnPlayerUpdateZone(Player* player, uint32 newZone, uint32 newArea)\n{\n    FOREACH_SCRIPT(PlayerScript)->OnUpdateZone(player, newZone, newArea);\n}\n\n// Guild\nvoid ScriptMgr::OnGuildAddMember(Guild* guild, Player* player, uint8& plRank)\n{\n    FOREACH_SCRIPT(GuildScript)->OnAddMember(guild, player, plRank);\n}\n\nvoid ScriptMgr::OnGuildRemoveMember(Guild* guild, Player* player, bool isDisbanding, bool isKicked)\n{\n    FOREACH_SCRIPT(GuildScript)->OnRemoveMember(guild, player, isDisbanding, isKicked);\n}\n\nvoid ScriptMgr::OnGuildMOTDChanged(Guild* guild, const std::string& newMotd)\n{\n    FOREACH_SCRIPT(GuildScript)->OnMOTDChanged(guild, newMotd);\n}\n\nvoid ScriptMgr::OnGuildInfoChanged(Guild* guild, const std::string& newInfo)\n{\n    FOREACH_SCRIPT(GuildScript)->OnInfoChanged(guild, newInfo);\n}\n\nvoid ScriptMgr::OnGuildCreate(Guild* guild, Player* leader, const std::string& name)\n{\n    FOREACH_SCRIPT(GuildScript)->OnCreate(guild, leader, name);\n}\n\nvoid ScriptMgr::OnGuildDisband(Guild* guild)\n{\n    FOREACH_SCRIPT(GuildScript)->OnDisband(guild);\n}\n\nvoid ScriptMgr::OnGuildMemberWitdrawMoney(Guild* guild, Player* player, uint32 &amount, bool isRepair)\n{\n    FOREACH_SCRIPT(GuildScript)->OnMemberWitdrawMoney(guild, player, amount, isRepair);\n}\n\nvoid ScriptMgr::OnGuildMemberDepositMoney(Guild* guild, Player* player, uint32 &amount)\n{\n    FOREACH_SCRIPT(GuildScript)->OnMemberDepositMoney(guild, player, amount);\n}\n\nvoid ScriptMgr::OnGuildItemMove(Guild* guild, Player* player, Item* pItem, bool isSrcBank, uint8 srcContainer, uint8 srcSlotId,\n            bool isDestBank, uint8 destContainer, uint8 destSlotId)\n{\n    FOREACH_SCRIPT(GuildScript)->OnItemMove(guild, player, pItem, isSrcBank, srcContainer, srcSlotId, isDestBank, destContainer, destSlotId);\n}\n\nvoid ScriptMgr::OnGuildEvent(Guild* guild, uint8 eventType, uint32 playerGuid1, uint32 playerGuid2, uint8 newRank)\n{\n    FOREACH_SCRIPT(GuildScript)->OnEvent(guild, eventType, playerGuid1, playerGuid2, newRank);\n}\n\nvoid ScriptMgr::OnGuildBankEvent(Guild* guild, uint8 eventType, uint8 tabId, uint32 playerGuid, uint32 itemOrMoney, uint16 itemStackCount, uint8 destTabId)\n{\n    FOREACH_SCRIPT(GuildScript)->OnBankEvent(guild, eventType, tabId, playerGuid, itemOrMoney, itemStackCount, destTabId);\n}\n\n// Group\nvoid ScriptMgr::OnGroupAddMember(Group* group, uint64 guid)\n{\n    ASSERT(group);\n    FOREACH_SCRIPT(GroupScript)->OnAddMember(group, guid);\n}\n\nvoid ScriptMgr::OnGroupInviteMember(Group* group, uint64 guid)\n{\n    ASSERT(group);\n    FOREACH_SCRIPT(GroupScript)->OnInviteMember(group, guid);\n}\n\nvoid ScriptMgr::OnGroupRemoveMember(Group* group, uint64 guid, RemoveMethod method, uint64 kicker, const char* reason)\n{\n    ASSERT(group);\n    FOREACH_SCRIPT(GroupScript)->OnRemoveMember(group, guid, method, kicker, reason);\n}\n\nvoid ScriptMgr::OnGroupChangeLeader(Group* group, uint64 newLeaderGuid, uint64 oldLeaderGuid)\n{\n    ASSERT(group);\n    FOREACH_SCRIPT(GroupScript)->OnChangeLeader(group, newLeaderGuid, oldLeaderGuid);\n}\n\nvoid ScriptMgr::OnGroupDisband(Group* group)\n{\n    ASSERT(group);\n    FOREACH_SCRIPT(GroupScript)->OnDisband(group);\n}\n\nSpellScriptLoader::SpellScriptLoader(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<SpellScriptLoader>::AddScript(this);\n}\n\nServerScript::ServerScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<ServerScript>::AddScript(this);\n}\n\nWorldScript::WorldScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<WorldScript>::AddScript(this);\n}\n\nFormulaScript::FormulaScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<FormulaScript>::AddScript(this);\n}\n\nWorldMapScript::WorldMapScript(const char* name, uint32 mapId)\n    : ScriptObject(name), MapScript<Map>(mapId)\n{\n    if (GetEntry() && !GetEntry()->IsWorldMap())\n        sLog->outError(LOG_FILTER_TSCR, \"WorldMapScript for map %u is invalid.\", mapId);\n\n    ScriptRegistry<WorldMapScript>::AddScript(this);\n}\n\nInstanceMapScript::InstanceMapScript(const char* name, uint32 mapId)\n    : ScriptObject(name), MapScript<InstanceMap>(mapId)\n{\n    if (GetEntry() && !GetEntry()->IsDungeon())\n        sLog->outError(LOG_FILTER_TSCR, \"InstanceMapScript for map %u is invalid.\", mapId);\n\n    ScriptRegistry<InstanceMapScript>::AddScript(this);\n}\n\nBattlegroundMapScript::BattlegroundMapScript(const char* name, uint32 mapId)\n    : ScriptObject(name), MapScript<BattlegroundMap>(mapId)\n{\n    if (GetEntry() && !GetEntry()->IsBattleground())\n        sLog->outError(LOG_FILTER_TSCR, \"BattlegroundMapScript for map %u is invalid.\", mapId);\n\n    ScriptRegistry<BattlegroundMapScript>::AddScript(this);\n}\n\nItemScript::ItemScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<ItemScript>::AddScript(this);\n}\n\nCreatureScript::CreatureScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<CreatureScript>::AddScript(this);\n}\n\nGameObjectScript::GameObjectScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<GameObjectScript>::AddScript(this);\n}\n\nAreaTriggerScript::AreaTriggerScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<AreaTriggerScript>::AddScript(this);\n}\n\nBattlegroundScript::BattlegroundScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<BattlegroundScript>::AddScript(this);\n}\n\nOutdoorPvPScript::OutdoorPvPScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<OutdoorPvPScript>::AddScript(this);\n}\n\nCommandScript::CommandScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<CommandScript>::AddScript(this);\n}\n\nWeatherScript::WeatherScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<WeatherScript>::AddScript(this);\n}\n\nAuctionHouseScript::AuctionHouseScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<AuctionHouseScript>::AddScript(this);\n}\n\nConditionScript::ConditionScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<ConditionScript>::AddScript(this);\n}\n\nVehicleScript::VehicleScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<VehicleScript>::AddScript(this);\n}\n\nDynamicObjectScript::DynamicObjectScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<DynamicObjectScript>::AddScript(this);\n}\n\nTransportScript::TransportScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<TransportScript>::AddScript(this);\n}\n\nAchievementCriteriaScript::AchievementCriteriaScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<AchievementCriteriaScript>::AddScript(this);\n}\n\nPlayerScript::PlayerScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<PlayerScript>::AddScript(this);\n}\n\nGuildScript::GuildScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<GuildScript>::AddScript(this);\n}\n\nGroupScript::GroupScript(const char* name)\n    : ScriptObject(name)\n{\n    ScriptRegistry<GroupScript>::AddScript(this);\n}\n\n// Instantiate static members of ScriptRegistry.\ntemplate<class TScript> std::map<uint32, TScript*> ScriptRegistry<TScript>::ScriptPointerList;\ntemplate<class TScript> uint32 ScriptRegistry<TScript>::_scriptIdCounter = 0;\n\n// Specialize for each script type class like so:\ntemplate class ScriptRegistry<SpellScriptLoader>;\ntemplate class ScriptRegistry<ServerScript>;\ntemplate class ScriptRegistry<WorldScript>;\ntemplate class ScriptRegistry<FormulaScript>;\ntemplate class ScriptRegistry<WorldMapScript>;\ntemplate class ScriptRegistry<InstanceMapScript>;\ntemplate class ScriptRegistry<BattlegroundMapScript>;\ntemplate class ScriptRegistry<ItemScript>;\ntemplate class ScriptRegistry<CreatureScript>;\ntemplate class ScriptRegistry<GameObjectScript>;\ntemplate class ScriptRegistry<AreaTriggerScript>;\ntemplate class ScriptRegistry<BattlegroundScript>;\ntemplate class ScriptRegistry<OutdoorPvPScript>;\ntemplate class ScriptRegistry<CommandScript>;\ntemplate class ScriptRegistry<WeatherScript>;\ntemplate class ScriptRegistry<AuctionHouseScript>;\ntemplate class ScriptRegistry<ConditionScript>;\ntemplate class ScriptRegistry<VehicleScript>;\ntemplate class ScriptRegistry<DynamicObjectScript>;\ntemplate class ScriptRegistry<TransportScript>;\ntemplate class ScriptRegistry<AchievementCriteriaScript>;\ntemplate class ScriptRegistry<PlayerScript>;\ntemplate class ScriptRegistry<GuildScript>;\ntemplate class ScriptRegistry<GroupScript>;\n\n// Undefine utility macros.\n#undef GET_SCRIPT_RET\n#undef GET_SCRIPT\n#undef FOREACH_SCRIPT\n#undef FOR_SCRIPTS_RET\n#undef FOR_SCRIPTS\n#undef SCR_REG_LST\n#undef SCR_REG_ITR\n#undef SCR_REG_MAP\n"]],"start1":0,"start2":0,"length1":0,"length2":50865}]],"length":50865}
